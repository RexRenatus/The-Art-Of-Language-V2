{
  "subdomain_title": "Advanced Programming Paradigms",
  "domain_title": "Programming Fundamentals",
  "category_title": "Software Engineering",
  "curriculum_type": "software-engineering",
  "cleaned_at": "2025-12-30T09:08:34.369407",
  "model_used": "google/gemini-2.5-flash",
  "entries": [
    {
      "domain": "Imperative Programming Paradigm",
      "subdomain": "Procedural Programming",
      "topic": "Procedure Definition and Declaration"
    },
    {
      "domain": "Imperative Programming Paradigm",
      "subdomain": "Procedural Programming",
      "topic": "Parameter Passing Mechanisms (Call-by-Value, Call-by-Reference)"
    },
    {
      "domain": "Imperative Programming Paradigm",
      "subdomain": "Procedural Programming",
      "topic": "Stack Frame Management and Activation Records"
    },
    {
      "domain": "Imperative Programming Paradigm",
      "subdomain": "Procedural Programming",
      "topic": "Scope and Binding Rules"
    },
    {
      "domain": "Imperative Programming Paradigm",
      "subdomain": "Procedural Programming",
      "topic": "Control Flow Abstractions"
    },
    {
      "domain": "Imperative Programming Paradigm",
      "subdomain": "Procedural Programming",
      "topic": "Sequential Execution Model"
    },
    {
      "domain": "Imperative Programming Paradigm",
      "subdomain": "Procedural Programming",
      "topic": "Statement-Oriented Computation"
    },
    {
      "domain": "Imperative Programming Paradigm",
      "subdomain": "Procedural Programming",
      "topic": "Side Effects and State Mutation"
    },
    {
      "domain": "Imperative Programming Paradigm",
      "subdomain": "Object-Oriented Programming",
      "topic": "Class-Based Inheritance"
    },
    {
      "domain": "Imperative Programming Paradigm",
      "subdomain": "Object-Oriented Programming",
      "topic": "Prototype-Based Inheritance"
    },
    {
      "domain": "Imperative Programming Paradigm",
      "subdomain": "Object-Oriented Programming",
      "topic": "Encapsulation and Information Hiding"
    },
    {
      "domain": "Imperative Programming Paradigm",
      "subdomain": "Object-Oriented Programming",
      "topic": "Polymorphism (Static and Dynamic)"
    },
    {
      "domain": "Imperative Programming Paradigm",
      "subdomain": "Object-Oriented Programming",
      "topic": "Method Dispatch and Virtual Tables"
    },
    {
      "domain": "Imperative Programming Paradigm",
      "subdomain": "Object-Oriented Programming",
      "topic": "Object Runtime and 'This' Pointer Mechanics"
    },
    {
      "domain": "Imperative Programming Paradigm",
      "subdomain": "Object-Oriented Programming",
      "topic": "Multiple Inheritance and Interface Implementation"
    },
    {
      "domain": "Imperative Programming Paradigm",
      "subdomain": "Object-Oriented Programming",
      "topic": "Abstract Classes and Interfaces"
    },
    {
      "domain": "Imperative Programming Paradigm",
      "subdomain": "Low-Level Systems Programming",
      "topic": "Memory Layout and Address Spaces"
    },
    {
      "domain": "Imperative Programming Paradigm",
      "subdomain": "Low-Level Systems Programming",
      "topic": "Pointer Arithmetic and Type Casting"
    },
    {
      "domain": "Imperative Programming Paradigm",
      "subdomain": "Low-Level Systems Programming",
      "topic": "Manual Memory Management (malloc/free)"
    },
    {
      "domain": "Imperative Programming Paradigm",
      "subdomain": "Low-Level Systems Programming",
      "topic": "Stack vs Heap Allocation"
    },
    {
      "domain": "Imperative Programming Paradigm",
      "subdomain": "Low-Level Systems Programming",
      "topic": "Memory Alignment and Padding"
    },
    {
      "domain": "Imperative Programming Paradigm",
      "subdomain": "Low-Level Systems Programming",
      "topic": "Endianness (Little-Endian vs Big-Endian)"
    },
    {
      "domain": "Imperative Programming Paradigm",
      "subdomain": "Low-Level Systems Programming",
      "topic": "Generic Programming with Void Pointers"
    },
    {
      "domain": "Imperative Programming Paradigm",
      "subdomain": "Low-Level Systems Programming",
      "topic": "Function Pointers and Callbacks"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Core Functional Concepts",
      "topic": "Pure Functions and Referential Transparency"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Core Functional Concepts",
      "topic": "Immutability and Persistent Data Structures"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Core Functional Concepts",
      "topic": "First-Class and Higher-Order Functions"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Core Functional Concepts",
      "topic": "Function Composition and Pipelining"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Core Functional Concepts",
      "topic": "Currying and Partial Application"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Core Functional Concepts",
      "topic": "Lazy Evaluation and Strictness"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Core Functional Concepts",
      "topic": "Recursion and Tail-Call Optimization"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Core Functional Concepts",
      "topic": "Pattern Matching and Destructuring"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Lambda Calculus and Foundations",
      "topic": "Lambda Abstraction and Application"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Lambda Calculus and Foundations",
      "topic": "Alpha Conversion and Beta Reduction"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Lambda Calculus and Foundations",
      "topic": "Church Encodings"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Lambda Calculus and Foundations",
      "topic": "Combinators (SKI Combinators)"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Lambda Calculus and Foundations",
      "topic": "Fixed-Point Combinators (Y Combinator)"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Lambda Calculus and Foundations",
      "topic": "Substitution Model of Evaluation"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Lambda Calculus and Foundations",
      "topic": "Normal Order vs Applicative Order"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Lambda Calculus and Foundations",
      "topic": "Lambda Calculus as Computation Model"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Advanced Functional Techniques",
      "topic": "Functors and Mappable Structures"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Advanced Functional Techniques",
      "topic": "Applicative Functors"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Advanced Functional Techniques",
      "topic": "Monads and Monad Laws"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Advanced Functional Techniques",
      "topic": "Monad Transformers"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Advanced Functional Techniques",
      "topic": "Algebraic Data Types (Sum and Product Types)"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Advanced Functional Techniques",
      "topic": "Type Classes and Polymorphism"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Advanced Functional Techniques",
      "topic": "Lenses and Optics"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Advanced Functional Techniques",
      "topic": "Free Monads and Interpreters"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Functional Data Processing",
      "topic": "Map-Reduce Programming Model"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Functional Data Processing",
      "topic": "Stream Processing and Pipelines"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Functional Data Processing",
      "topic": "Folding and Catamorphisms"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Functional Data Processing",
      "topic": "List Comprehensions"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Functional Data Processing",
      "topic": "Parallel Map and Parallel Reduce"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Functional Data Processing",
      "topic": "Transducers"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Functional Data Processing",
      "topic": "Functional Reactive Streams"
    },
    {
      "domain": "Functional Programming Paradigm",
      "subdomain": "Functional Data Processing",
      "topic": "Event-Driven Functional Programming"
    },
    {
      "domain": "Logic Programming Paradigm",
      "subdomain": "Declarative Logic Foundations",
      "topic": "First-Order Predicate Logic"
    },
    {
      "domain": "Logic Programming Paradigm",
      "subdomain": "Declarative Logic Foundations",
      "topic": "Horn Clauses and Resolution"
    },
    {
      "domain": "Logic Programming Paradigm",
      "subdomain": "Declarative Logic Foundations",
      "topic": "Unification Algorithm"
    },
    {
      "domain": "Logic Programming Paradigm",
      "subdomain": "Declarative Logic Foundations",
      "topic": "Facts, Rules, and Queries"
    },
    {
      "domain": "Logic Programming Paradigm",
      "subdomain": "Declarative Logic Foundations",
      "topic": "Backward Chaining (Goal-Directed Search)"
    },
    {
      "domain": "Logic Programming Paradigm",
      "subdomain": "Declarative Logic Foundations",
      "topic": "Forward Chaining (Data-Driven)"
    },
    {
      "domain": "Logic Programming Paradigm",
      "subdomain": "Declarative Logic Foundations",
      "topic": "Logical Inference and Theorem Proving"
    },
    {
      "domain": "Logic Programming Paradigm",
      "subdomain": "Declarative Logic Foundations",
      "topic": "Herbrand Universe and Models"
    },
    {
      "domain": "Logic Programming Paradigm",
      "subdomain": "Constraint Logic Programming (CLP)",
      "topic": "Constraint Satisfaction Problems (CSP)"
    },
    {
      "domain": "Logic Programming Paradigm",
      "subdomain": "Constraint Logic Programming (CLP)",
      "topic": "Finite Domain Constraints"
    },
    {
      "domain": "Logic Programming Paradigm",
      "subdomain": "Constraint Logic Programming (CLP)",
      "topic": "Constraint Propagation and Arc Consistency"
    },
    {
      "domain": "Logic Programming Paradigm",
      "subdomain": "Constraint Logic Programming (CLP)",
      "topic": "Backtracking with Constraint Checking"
    },
    {
      "domain": "Logic Programming Paradigm",
      "subdomain": "Constraint Logic Programming (CLP)",
      "topic": "CLP over Finite Domains (CLP(FD))"
    },
    {
      "domain": "Logic Programming Paradigm",
      "subdomain": "Constraint Logic Programming (CLP)",
      "topic": "CLP over Reals (CLP(R))"
    },
    {
      "domain": "Logic Programming Paradigm",
      "subdomain": "Constraint Logic Programming (CLP)",
      "topic": "Global Constraints"
    },
    {
      "domain": "Logic Programming Paradigm",
      "subdomain": "Constraint Logic Programming (CLP)",
      "topic": "Optimization in CLP"
    },
    {
      "domain": "Logic Programming Paradigm",
      "subdomain": "Logic Programming Implementation",
      "topic": "WAM (Warren Abstract Machine)"
    },
    {
      "domain": "Logic Programming Paradigm",
      "subdomain": "Logic Programming Implementation",
      "topic": "Choice Points and Backtracking"
    },
    {
      "domain": "Logic Programming Paradigm",
      "subdomain": "Logic Programming Implementation",
      "topic": "Cut Operator and Negation"
    },
    {
      "domain": "Logic Programming Paradigm",
      "subdomain": "Logic Programming Implementation",
      "topic": "Tail Recursion in Logic Programming"
    },
    {
      "domain": "Logic Programming Paradigm",
      "subdomain": "Logic Programming Implementation",
      "topic": "Dynamic Predicates"
    },
    {
      "domain": "Logic Programming Paradigm",
      "subdomain": "Logic Programming Implementation",
      "topic": "Meta-Interpreters"
    },
    {
      "domain": "Logic Programming Paradigm",
      "subdomain": "Logic Programming Implementation",
      "topic": "Definite Clause Grammars (DCG)"
    },
    {
      "domain": "Logic Programming Paradigm",
      "subdomain": "Logic Programming Implementation",
      "topic": "Tabling and Memoization"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Shared Memory Concurrency",
      "topic": "Multithreading and Thread Management"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Shared Memory Concurrency",
      "topic": "Race Conditions and Data Races"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Shared Memory Concurrency",
      "topic": "Critical Sections and Mutual Exclusion"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Shared Memory Concurrency",
      "topic": "Locks and Spinlocks"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Shared Memory Concurrency",
      "topic": "Semaphores (Binary and Counting)"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Shared Memory Concurrency",
      "topic": "Monitors and Condition Variables"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Shared Memory Concurrency",
      "topic": "Deadlock Detection and Prevention"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Shared Memory Concurrency",
      "topic": "Memory Consistency Models"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Message-Passing Concurrency",
      "topic": "Actor Model and Mailboxes"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Message-Passing Concurrency",
      "topic": "Communicating Sequential Processes (CSP)"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Message-Passing Concurrency",
      "topic": "Channels and Synchronous Communication"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Message-Passing Concurrency",
      "topic": "Asynchronous Message Passing"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Message-Passing Concurrency",
      "topic": "Process Calculi (Pi-Calculus)"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Message-Passing Concurrency",
      "topic": "Supervision Trees and Fault Tolerance"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Message-Passing Concurrency",
      "topic": "Location Transparency"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Message-Passing Concurrency",
      "topic": "Message Ordering Guarantees"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Parallel Computing Models",
      "topic": "Data Parallelism vs Task Parallelism"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Parallel Computing Models",
      "topic": "Fork-Join Parallelism"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Parallel Computing Models",
      "topic": "Work-Stealing Algorithms"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Parallel Computing Models",
      "topic": "SIMD (Single Instruction Multiple Data)"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Parallel Computing Models",
      "topic": "GPU Programming Models (CUDA/OpenCL)"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Parallel Computing Models",
      "topic": "Distributed Memory Systems"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Parallel Computing Models",
      "topic": "MapReduce and Bulk Synchronous Parallel (BSP)"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Parallel Computing Models",
      "topic": "Parallel Functional Programming"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Reactive Programming",
      "topic": "Observable Streams and Observers"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Reactive Programming",
      "topic": "Functional Reactive Programming (FRP)"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Reactive Programming",
      "topic": "Event Streams and Time-Varying Values"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Reactive Programming",
      "topic": "Operators (Map, Filter, Merge, FlatMap)"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Reactive Programming",
      "topic": "Backpressure Management"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Reactive Programming",
      "topic": "Hot vs Cold Observables"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Reactive Programming",
      "topic": "Schedulers and Concurrency Control"
    },
    {
      "domain": "Concurrent and Parallel Programming Paradigms",
      "subdomain": "Reactive Programming",
      "topic": "Reactive Extensions (Rx)"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Type Theory Foundations",
      "topic": "Simply Typed Lambda Calculus"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Type Theory Foundations",
      "topic": "System F (Polymorphic Lambda Calculus)"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Type Theory Foundations",
      "topic": "System F-omega (Higher-Kinded Types)"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Type Theory Foundations",
      "topic": "Dependent Types"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Type Theory Foundations",
      "topic": "Linear Types and Affine Types"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Type Theory Foundations",
      "topic": "Gradual Typing"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Type Theory Foundations",
      "topic": "Type Inference (Hindley-Milner)"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Type Theory Foundations",
      "topic": "Subtyping and Type Lattices"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Advanced Type System Features",
      "topic": "Parametric Polymorphism (Generics)"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Advanced Type System Features",
      "topic": "Ad-hoc Polymorphism (Overloading)"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Advanced Type System Features",
      "topic": "Variance (Covariance and Contravariance)"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Advanced Type System Features",
      "topic": "Existential Types"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Advanced Type System Features",
      "topic": "Phantom Types"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Advanced Type System Features",
      "topic": "GADTs (Generalized Algebraic Data Types)"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Advanced Type System Features",
      "topic": "Type Families and Associated Types"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Advanced Type System Features",
      "topic": "Effect Systems and Effect Handlers"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Program Verification and Correctness",
      "topic": "Hoare Logic and Pre/Post-conditions"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Program Verification and Correctness",
      "topic": "Weakest Precondition Calculus"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Program Verification and Correctness",
      "topic": "Separation Logic"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Program Verification and Correctness",
      "topic": "Structural Induction Proofs"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Program Verification and Correctness",
      "topic": "Equational Reasoning"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Program Verification and Correctness",
      "topic": "Proof Assistants (Coq, Agda, Lean, Isabelle)"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Program Verification and Correctness",
      "topic": "Curry-Howard Correspondence"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Program Verification and Correctness",
      "topic": "Automated Theorem Proving"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Ownership and Resource Management",
      "topic": "Ownership Type Systems"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Ownership and Resource Management",
      "topic": "Borrowing and Lifetimes"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Ownership and Resource Management",
      "topic": "Affine and Linear Type Systems"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Ownership and Resource Management",
      "topic": "Region-Based Memory Management"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Ownership and Resource Management",
      "topic": "Capability-Based Security"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Ownership and Resource Management",
      "topic": "Uniqueness Types"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Ownership and Resource Management",
      "topic": "Session Types"
    },
    {
      "domain": "Type Systems and Formal Methods",
      "subdomain": "Ownership and Resource Management",
      "topic": "Resource-Aware Type Systems"
    },
    {
      "domain": "Metaprogramming Paradigms",
      "subdomain": "Compile-Time Metaprogramming",
      "topic": "Template Metaprogramming (C++)"
    },
    {
      "domain": "Metaprogramming Paradigms",
      "subdomain": "Compile-Time Metaprogramming",
      "topic": "Macro Systems (Lisp, Scheme)"
    },
    {
      "domain": "Metaprogramming Paradigms",
      "subdomain": "Compile-Time Metaprogramming",
      "topic": "Hygienic Macros"
    },
    {
      "domain": "Metaprogramming Paradigms",
      "subdomain": "Compile-Time Metaprogramming",
      "topic": "Syntax Extension and DSL Embedding"
    },
    {
      "domain": "Metaprogramming Paradigms",
      "subdomain": "Compile-Time Metaprogramming",
      "topic": "Code Generation at Compile Time"
    },
    {
      "domain": "Metaprogramming Paradigms",
      "subdomain": "Compile-Time Metaprogramming",
      "topic": "Constexpr and Constant Evaluation"
    },
    {
      "domain": "Metaprogramming Paradigms",
      "subdomain": "Compile-Time Metaprogramming",
      "topic": "Type-Level Programming"
    },
    {
      "domain": "Metaprogramming Paradigms",
      "subdomain": "Compile-Time Metaprogramming",
      "topic": "Static Reflection"
    },
    {
      "domain": "Metaprogramming Paradigms",
      "subdomain": "Runtime Metaprogramming",
      "topic": "Reflection and Introspection"
    },
    {
      "domain": "Metaprogramming Paradigms",
      "subdomain": "Runtime Metaprogramming",
      "topic": "Dynamic Code Generation"
    },
    {
      "domain": "Metaprogramming Paradigms",
      "subdomain": "Runtime Metaprogramming",
      "topic": "Eval and Dynamic Execution"
    },
    {
      "domain": "Metaprogramming Paradigms",
      "subdomain": "Runtime Metaprogramming",
      "topic": "Monkey Patching and Open Classes"
    },
    {
      "domain": "Metaprogramming Paradigms",
      "subdomain": "Runtime Metaprogramming",
      "topic": "Prototype Modification"
    },
    {
      "domain": "Metaprogramming Paradigms",
      "subdomain": "Runtime Metaprogramming",
      "topic": "Method Intercession and Proxies"
    },
    {
      "domain": "Metaprogramming Paradigms",
      "subdomain": "Runtime Metaprogramming",
      "topic": "Metaclasses and Metaobject Protocols"
    },
    {
      "domain": "Metaprogramming Paradigms",
      "subdomain": "Runtime Metaprogramming",
      "topic": "Bytecode Manipulation"
    },
    {
      "domain": "Metaprogramming Paradigms",
      "subdomain": "Program Transformation",
      "topic": "Abstract Syntax Trees (AST) Manipulation"
    },
    {
      "domain": "Metaprogramming Paradigms",
      "subdomain": "Program Transformation",
      "topic": "Source-to-Source Translation"
    },
    {
      "domain": "Metaprogramming Paradigms",
      "subdomain": "Program Transformation",
      "topic": "Partial Evaluation and Staging"
    },
    {
      "domain": "Metaprogramming Paradigms",
      "subdomain": "Program Transformation",
      "topic": "Program Synthesis"
    },
    {
      "domain": "Metaprogramming Paradigms",
      "subdomain": "Program Transformation",
      "topic": "Aspect Weaving"
    },
    {
      "domain": "Metaprogramming Paradigms",
      "subdomain": "Program Transformation",
      "topic": "Deforestation and Fusion"
    },
    {
      "domain": "Metaprogramming Paradigms",
      "subdomain": "Program Transformation",
      "topic": "Quasiquotation"
    },
    {
      "domain": "Metaprogramming Paradigms",
      "subdomain": "Program Transformation",
      "topic": "Multi-Stage Programming"
    },
    {
      "domain": "Aspect-Oriented and Advanced Paradigms",
      "subdomain": "Aspect-Oriented Programming (AOP)",
      "topic": "Cross-Cutting Concerns"
    },
    {
      "domain": "Aspect-Oriented and Advanced Paradigms",
      "subdomain": "Aspect-Oriented Programming (AOP)",
      "topic": "Join Points and Pointcuts"
    },
    {
      "domain": "Aspect-Oriented and Advanced Paradigms",
      "subdomain": "Aspect-Oriented Programming (AOP)",
      "topic": "Advice (Before, After, Around)"
    },
    {
      "domain": "Aspect-Oriented and Advanced Paradigms",
      "subdomain": "Aspect-Oriented Programming (AOP)",
      "topic": "Aspect Weaving (Compile-Time, Load-Time, Runtime)"
    },
    {
      "domain": "Aspect-Oriented and Advanced Paradigms",
      "subdomain": "Aspect-Oriented Programming (AOP)",
      "topic": "AspectJ and AOP Frameworks"
    },
    {
      "domain": "Aspect-Oriented and Advanced Paradigms",
      "subdomain": "Aspect-Oriented Programming (AOP)",
      "topic": "Concern Separation and Modularity"
    },
    {
      "domain": "Aspect-Oriented and Advanced Paradigms",
      "subdomain": "Aspect-Oriented Programming (AOP)",
      "topic": "Policy Injection"
    },
    {
      "domain": "Aspect-Oriented and Advanced Paradigms",
      "subdomain": "Aspect-Oriented Programming (AOP)",
      "topic": "Quantification and Obliviousness"
    },
    {
      "domain": "Aspect-Oriented and Advanced Paradigms",
      "subdomain": "Dataflow Programming",
      "topic": "Dataflow Graphs and Networks"
    },
    {
      "domain": "Aspect-Oriented and Advanced Paradigms",
      "subdomain": "Dataflow Programming",
      "topic": "Static Dataflow Analysis"
    },
    {
      "domain": "Aspect-Oriented and Advanced Paradigms",
      "subdomain": "Dataflow Programming",
      "topic": "Reactive Dataflow (Spreadsheet Model)"
    },
    {
      "domain": "Aspect-Oriented and Advanced Paradigms",
      "subdomain": "Dataflow Programming",
      "topic": "Stream Processing Frameworks"
    },
    {
      "domain": "Aspect-Oriented and Advanced Paradigms",
      "subdomain": "Dataflow Programming",
      "topic": "Dataflow Variables and Single Assignment"
    },
    {
      "domain": "Aspect-Oriented and Advanced Paradigms",
      "subdomain": "Dataflow Programming",
      "topic": "Flow-Based Programming"
    },
    {
      "domain": "Aspect-Oriented and Advanced Paradigms",
      "subdomain": "Dataflow Programming",
      "topic": "Kahn Process Networks"
    },
    {
      "domain": "Aspect-Oriented and Advanced Paradigms",
      "subdomain": "Dataflow Programming",
      "topic": "Synchronous Dataflow"
    },
    {
      "domain": "Aspect-Oriented and Advanced Paradigms",
      "subdomain": "Domain-Specific and Specialized Paradigms",
      "topic": "Domain-Specific Languages (DSL) Design"
    },
    {
      "domain": "Aspect-Oriented and Advanced Paradigms",
      "subdomain": "Domain-Specific and Specialized Paradigms",
      "topic": "Embedded DSLs vs External DSLs"
    },
    {
      "domain": "Aspect-Oriented and Advanced Paradigms",
      "subdomain": "Domain-Specific and Specialized Paradigms",
      "topic": "Differentiable Programming"
    },
    {
      "domain": "Aspect-Oriented and Advanced Paradigms",
      "subdomain": "Domain-Specific and Specialized Paradigms",
      "topic": "Probabilistic Programming"
    },
    {
      "domain": "Aspect-Oriented and Advanced Paradigms",
      "subdomain": "Domain-Specific and Specialized Paradigms",
      "topic": "Array Programming"
    },
    {
      "domain": "Aspect-Oriented and Advanced Paradigms",
      "subdomain": "Domain-Specific and Specialized Paradigms",
      "topic": "Literate Programming"
    },
    {
      "domain": "Aspect-Oriented and Advanced Paradigms",
      "subdomain": "Domain-Specific and Specialized Paradigms",
      "topic": "Visual and Graph-Based Programming"
    },
    {
      "domain": "Aspect-Oriented and Advanced Paradigms",
      "subdomain": "Domain-Specific and Specialized Paradigms",
      "topic": "Quantum Programming Paradigms"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Formal Language Description",
      "topic": "Context-Free Grammars (CFG)"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Formal Language Description",
      "topic": "Backus-Naur Form (BNF) and EBNF"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Formal Language Description",
      "topic": "Abstract Syntax vs Concrete Syntax"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Formal Language Description",
      "topic": "Lexical Analysis and Tokenization"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Formal Language Description",
      "topic": "Parsing (Recursive Descent, LR, LALR)"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Formal Language Description",
      "topic": "Operator Precedence and Associativity"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Formal Language Description",
      "topic": "Ambiguity Resolution"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Formal Language Description",
      "topic": "Parser Generators and Combinator Libraries"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Semantic Models",
      "topic": "Operational Semantics (Small-Step, Big-Step)"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Semantic Models",
      "topic": "Denotational Semantics"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Semantic Models",
      "topic": "Axiomatic Semantics"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Semantic Models",
      "topic": "Environment Model of Evaluation"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Semantic Models",
      "topic": "Substitution Model of Evaluation"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Semantic Models",
      "topic": "Continuation Semantics"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Semantic Models",
      "topic": "Abstract Interpretation"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Semantic Models",
      "topic": "Formal Semantics of Concurrency"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Runtime Systems and Virtual Machines",
      "topic": "Bytecode Interpretation"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Runtime Systems and Virtual Machines",
      "topic": "Just-In-Time (JIT) Compilation"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Runtime Systems and Virtual Machines",
      "topic": "Garbage 003_003_Collection (Mark-Sweep, Generational)"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Runtime Systems and Virtual Machines",
      "topic": "Reference Counting"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Runtime Systems and Virtual Machines",
      "topic": "Dynamic Type Checking"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Runtime Systems and Virtual Machines",
      "topic": "Virtual Machine Design"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Runtime Systems and Virtual Machines",
      "topic": "Instruction Set Architecture for VMs"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Runtime Systems and Virtual Machines",
      "topic": "Stack-Based vs Register-Based VMs"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Compilation and Code Generation",
      "topic": "Static Single Assignment (SSA) Form"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Compilation and Code Generation",
      "topic": "Control Flow Graphs (CFG)"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Compilation and Code Generation",
      "topic": "Register Allocation"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Compilation and Code Generation",
      "topic": "Instruction Selection"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Compilation and Code Generation",
      "topic": "Code Optimization (Constant Folding, Dead Code Elimination)"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Compilation and Code Generation",
      "topic": "Intermediate Representations (IR)"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Compilation and Code Generation",
      "topic": "Linking and Symbol Resolution"
    },
    {
      "domain": "Language Implementation and Semantics",
      "subdomain": "Compilation and Code Generation",
      "topic": "Ahead-of-Time (AOT) Compilation"
    }
  ],
  "stats": {
    "entry_count": 224,
    "input_tokens": 3644,
    "output_tokens": 7314,
    "cost_usd": 0.019378199999999998,
    "latency_ms": 41591.13836288452,
    "duration_seconds": 2.226595
  }
}