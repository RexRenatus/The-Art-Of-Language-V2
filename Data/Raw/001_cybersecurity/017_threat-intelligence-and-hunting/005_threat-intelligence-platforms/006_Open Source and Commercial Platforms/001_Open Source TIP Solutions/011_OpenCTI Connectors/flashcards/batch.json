{
  "topic_title": "OpenCTI Connectors",
  "category": "Cybersecurity - Threat Intelligence And Hunting - Threat Intelligence Platforms - Open Source TIP Solutions",
  "flashcards": [
    {
      "question_text": "What is the primary role of connectors in the OpenCTI platform?",
      "correct_answer": "To ingest, enrich, and export data by integrating with external sources and services.",
      "distractors": [
        {
          "text": "To manage user authentication and authorization within OpenCTI.",
          "misconception": "Targets [functional scope confusion]: Confuses connector roles with user management functions."
        },
        {
          "text": "To provide a graphical user interface for data visualization.",
          "misconception": "Targets [UI vs. integration confusion]: Misunderstands connectors as a front-end component."
        },
        {
          "text": "To perform real-time security monitoring and alerting.",
          "misconception": "Targets [operational vs. integration confusion]: Overlaps connector function with SIEM/SOAR capabilities."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Connectors are essential for OpenCTI's data ecosystem, enabling automated data flow. They work by fetching data from external sources (import), enhancing existing data (enrichment), and sending data out (export), thus connecting OpenCTI to the broader threat intelligence landscape.",
        "distractor_analysis": "The distractors incorrectly assign roles related to user management, UI presentation, and real-time monitoring, which are separate functions from the data integration capabilities of connectors.",
        "analogy": "Think of OpenCTI connectors as the delivery trucks and pipelines that bring raw materials (threat data) into a factory (OpenCTI) and take finished goods (analyzed intelligence) out to other destinations."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "OPENCTI_BASICS"
      ]
    },
    {
      "question_text": "Which category of OpenCTI connectors is designed to automatically retrieve information from external sources and convert it into STIX 2.1 bundles for import?",
      "correct_answer": "Import connectors",
      "distractors": [
        {
          "text": "Enrichment connectors",
          "misconception": "Targets [functional overlap]: Confuses data retrieval with data enhancement."
        },
        {
          "text": "Stream connectors",
          "misconception": "Targets [data flow confusion]: Misunderstands stream connectors as data ingestion tools rather than event consumers."
        },
        {
          "text": "Export connectors",
          "misconception": "Targets [directionality error]: Reverses the data flow direction from import."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Import connectors are specifically built to fetch data from external organizations, applications, or services. They function by converting this data into STIX 2.1 bundles, which are then imported into OpenCTI, thereby populating the platform with external threat intelligence.",
        "distractor_analysis": "Enrichment connectors enhance existing data, stream connectors process live events, and export connectors send data out, none of which are primarily for initial data retrieval and conversion into STIX bundles.",
        "analogy": "Import connectors are like librarians who go to different publishers (external sources) to collect new books (threat data) and catalog them (convert to STIX) for the library (OpenCTI)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "OPENCTI_CONNECTORS_TYPES"
      ]
    },
    {
      "question_text": "What is the purpose of 'Stream' connectors in OpenCTI?",
      "correct_answer": "To consume events from a live stream and perform actions, such as sending data to SIEMs or XDRs.",
      "distractors": [
        {
          "text": "To periodically poll external APIs for new threat intelligence.",
          "misconception": "Targets [polling vs. streaming confusion]: Confuses continuous data streams with periodic polling."
        },
        {
          "text": "To generate STIX 2.1 bundles from uploaded files.",
          "misconception": "Targets [file import vs. stream processing]: Misattributes file-based ingestion to stream connectors."
        },
        {
          "text": "To perform automated data enrichment on newly created objects.",
          "misconception": "Targets [enrichment vs. stream processing]: Confuses enrichment tasks with real-time event consumption."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Stream connectors connect to a platform's live stream to continuously process events. They function by consuming these events and acting upon them, often by pushing data to other security platforms like SIEMs or XDRs, thereby enabling real-time threat intelligence dissemination.",
        "distractor_analysis": "The distractors describe functions of import connectors (polling, file processing) or enrichment connectors, not the core purpose of consuming and acting on live data streams.",
        "analogy": "Stream connectors are like a news ticker; they continuously display incoming information (events) and can trigger actions based on that information, such as alerting a news editor (SIEM/XDR)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "OPENCTI_CONNECTORS_TYPES",
        "THREAT_INTEL_DATA_FLOW"
      ]
    },
    {
      "question_text": "When configuring OpenCTI connectors, what are the two mandatory parameters required for them to access the platform's API?",
      "correct_answer": "OPENCTI_URL and OPENCTI_TOKEN",
      "distractors": [
        {
          "text": "OPENCTI_HOST and OPENCTI_PORT",
          "misconception": "Targets [configuration detail confusion]: Mixes network parameters with authentication credentials."
        },
        {
          "text": "API_KEY and SECRET_KEY",
          "misconception": "Targets [generic API vs. specific parameter confusion]: Uses generic terms instead of OpenCTI's specific parameter names."
        },
        {
          "text": "USERNAME and PASSWORD",
          "misconception": "Targets [authentication method confusion]: Assumes traditional username/password instead of token-based authentication."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Connectors require specific credentials to authenticate with the OpenCTI API. The mandatory parameters OPENCTI_URL and OPENCTI_TOKEN enable them to establish a secure connection, allowing them to ingest, enrich, or export data as configured.",
        "distractor_analysis": "The distractors suggest incorrect or incomplete authentication mechanisms, such as network details, generic API keys, or traditional user credentials, rather than the specific URL and token required by OpenCTI.",
        "analogy": "To access a secure building (OpenCTI API), you need both the building's address (OPENCTI_URL) and a valid access card (OPENCTI_TOKEN)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "OPENCTI_CONNECTORS_CONFIG"
      ]
    },
    {
      "question_text": "Why is it strongly recommended to use a dedicated token for each OpenCTI connector?",
      "correct_answer": "To enhance security by limiting the blast radius if a single connector's token is compromised.",
      "distractors": [
        {
          "text": "To simplify log analysis by associating logs with specific connectors.",
          "misconception": "Targets [unknown]: Not specified"
        },
        {
          "text": "To enable different connectors to use different API versions.",
          "misconception": "Targets [versioning vs. security confusion]: Misunderstands token purpose as version control."
        },
        {
          "text": "To allow connectors to run with different network access privileges.",
          "misconception": "Targets [token vs. role/permission confusion]: Confuses token function with user role assignments."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Using dedicated tokens for each connector is a security best practice. Because each token is unique, if one is compromised, only that specific connector's access is affected, thereby minimizing the potential damage and simplifying revocation.",
        "distractor_analysis": "The distractors focus on secondary benefits like logging or incorrect assumptions about API versioning and network privileges, rather than the core security principle of least privilege and blast radius reduction.",
        "analogy": "Giving each employee a unique key card to their specific office area is better than giving everyone a master key to the entire building; if one card is lost, only that area is compromised."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "OPENCTI_CONNECTORS_SECURITY",
        "PRINCIPLES_OF_LEAST_PRIVILEGE"
      ]
    },
    {
      "question_text": "Which type of OpenCTI connector requires an 'Administrator' role for its associated user, rather than the standard 'Connector' role?",
      "correct_answer": "Internal Export File connectors",
      "distractors": [
        {
          "text": "External Import connectors",
          "misconception": "Targets [role confusion]: Assumes all connectors use the same role."
        },
        {
          "text": "Enrichment connectors",
          "misconception": "Targets [role confusion]: Assumes all connectors use the same role."
        },
        {
          "text": "Stream connectors",
          "misconception": "Targets [role confusion]: Assumes all connectors use the same role."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Internal Export File connectors need Administrator privileges because they impersonate the user requesting the export. This is necessary to avoid data leaks by ensuring the export respects the requesting user's permissions, unlike other connectors that operate with their own 'Connector' role.",
        "distractor_analysis": "External Import, Enrichment, and Stream connectors typically operate with a 'Connector' role, which grants necessary permissions for their specific tasks without requiring elevated administrative privileges.",
        "analogy": "Imagine a librarian (Connector role) fetching books for patrons. An 'Internal Export File' connector is like a library manager (Administrator role) who can access any book to fulfill a specific patron's request, ensuring privacy."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "OPENCTI_CONNECTORS_ROLES",
        "RBAC_PRINCIPLES"
      ]
    },
    {
      "question_text": "In OpenCTI connector configuration, what does setting <code>CONNECTOR_QUEUE_PROTOCOL=api</code> achieve?",
      "correct_answer": "It directs the connector to send data directly via HTTP to the OpenCTI API instead of using RabbitMQ.",
      "distractors": [
        {
          "text": "It enables the connector to listen for jobs via HTTP instead of RabbitMQ.",
          "misconception": "Targets [protocol direction confusion]: Confuses sending data with receiving jobs."
        },
        {
          "text": "It configures the connector to use an alternative message queue protocol.",
          "misconception": "Targets [protocol specificity confusion]: Generalizes 'api' to any alternative protocol."
        },
        {
          "text": "It increases the payload size limit for data sent to OpenCTI.",
          "misconception": "Targets [parameter scope confusion]: Misassociates queue protocol with payload size limits."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Setting <code>CONNECTOR_QUEUE_PROTOCOL=api</code> changes the communication method for sending data. Instead of relying on RabbitMQ (AMQP), the connector functions by sending STIX bundles directly through HTTP requests to the OpenCTI API, which is useful in environments where RabbitMQ access is restricted.",
        "distractor_analysis": "The distractors incorrectly describe the function as listening for jobs, using a generic alternative protocol, or affecting payload limits, none of which are the direct outcome of setting the queue protocol to 'api'.",
        "analogy": "Instead of sending mail through the central post office (RabbitMQ), setting <code>CONNECTOR_QUEUE_PROTOCOL=api</code> is like using a direct courier service (HTTP API) to deliver packages (data) immediately."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "OPENCTI_CONNECTORS_CONFIG",
        "MESSAGE_QUEUE_PROTOCOLS"
      ]
    },
    {
      "question_text": "What is the purpose of the <code>CONNECTOR_LISTEN_PROTOCOL=api</code> setting for certain OpenCTI connectors?",
      "correct_answer": "To allow the connector to run an HTTP server and receive jobs/bundles directly from OpenCTI workers.",
      "distractors": [
        {
          "text": "To enable the connector to send data directly to external threat intelligence feeds.",
          "misconception": "Targets [data flow direction]: Reverses the direction of communication."
        },
        {
          "text": "To configure the connector to poll OpenCTI for new data periodically.",
          "misconception": "Targets [polling vs. listening confusion]: Confuses active listening with passive polling."
        },
        {
          "text": "To establish a secure TLS connection for all connector communications.",
          "misconception": "Targets [protocol vs. security feature confusion]: Equates listening protocol with TLS encryption."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When <code>CONNECTOR_LISTEN_PROTOCOL=api</code> is set, the connector starts its own HTTP server. This allows OpenCTI workers to send jobs (like enrichment or export tasks) directly to the connector via HTTP, bypassing RabbitMQ and enabling bi-directional communication over HTTP.",
        "distractor_analysis": "The distractors misrepresent the function as sending data externally, polling for data, or enabling TLS, which are not the primary outcomes of this specific configuration parameter.",
        "analogy": "Instead of the connector constantly checking a mailbox (RabbitMQ) for instructions, setting <code>CONNECTOR_LISTEN_PROTOCOL=api</code> is like the connector setting up a reception desk where instructions (jobs) are delivered directly to it."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "OPENCTI_CONNECTORS_CONFIG",
        "NETWORK_PROTOCOLS"
      ]
    },
    {
      "question_text": "Which STIX 2.1 object type is primarily used to represent a threat actor or group?",
      "correct_answer": "Intrusion Set",
      "distractors": [
        {
          "text": "Malware",
          "misconception": "Targets [object type confusion]: Confuses the actor with their tools."
        },
        {
          "text": "Attack Pattern",
          "misconception": "Targets [object type confusion]: Confuses the actor with their methods."
        },
        {
          "text": "Threat Actor",
          "misconception": "Targets [naming convention confusion]: Uses a more general term that might be confused with STIX's specific 'Intrusion Set'."
        }
      ],
      "detailed_explanation": {
        "core_logic": "In STIX 2.1, the 'Intrusion Set' object type is specifically designed to represent a managed threat actor or group, including their motivations, capabilities, and TTPs. It functions as a container for intelligence related to a specific threat entity.",
        "distractor_analysis": "Malware and Attack Patterns represent tools and methods, respectively. While 'Threat Actor' is a common term, 'Intrusion Set' is the precise STIX 2.1 object for this concept, making the other options plausible but incorrect.",
        "analogy": "If STIX is a library catalog, 'Intrusion Set' is the specific subject heading for 'Organized Criminal Groups' or 'Nation-State Actors', distinct from 'Tools Used' (Malware) or 'Methods Employed' (Attack Pattern)."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "STIX_DATA_MODEL",
        "THREAT_ACTOR_CONCEPTS"
      ]
    },
    {
      "question_text": "What is the relationship between OpenCTI's data model and the STIX standard?",
      "correct_answer": "OpenCTI's core design is based on the STIX 2.1 standard for representing threat intelligence.",
      "distractors": [
        {
          "text": "OpenCTI uses a proprietary data model that is incompatible with STIX.",
          "misconception": "Targets [compatibility confusion]: Assumes vendor lock-in or lack of standardization."
        },
        {
          "text": "STIX is an extension of OpenCTI's data model.",
          "misconception": "Targets [dependency confusion]: Reverses the relationship between the platform and the standard."
        },
        {
          "text": "OpenCTI only supports older versions of STIX, not STIX 2.1.",
          "misconception": "Targets [versioning confusion]: Assumes outdated technology support."
        }
      ],
      "detailed_explanation": {
        "core_logic": "OpenCTI is built upon the STIX 2.1 standard to ensure interoperability and a unified approach to threat intelligence. This means it uses STIX Domain Objects (SDOs), Cyber Observables (SCOs), and Relationship Objects (SROs) as its foundational data structures, enabling seamless data exchange.",
        "distractor_analysis": "The distractors incorrectly claim incompatibility, reverse the standard's role, or suggest outdated version support, all of which contradict OpenCTI's design principles centered around STIX 2.1.",
        "analogy": "OpenCTI is like a house built using standard construction blueprints (STIX 2.1). This ensures that anyone familiar with standard construction can understand and work with the house, and that standard building materials (threat intel) fit perfectly."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "STIX_DATA_MODEL",
        "OPENCTI_BASICS"
      ]
    },
    {
      "question_text": "In the context of OpenCTI and STIX 2.1, what is the difference between a STIX Domain Object (SDO) and a STIX Cyber Observable (SCO)?",
      "correct_answer": "SDOs represent threat intelligence concepts like actors and malware, while SCOs represent concrete technical indicators like IP addresses and file hashes.",
      "distractors": [
        {
          "text": "SDOs are used for internal analysis, while SCOs are for external sharing.",
          "misconception": "Targets [usage context confusion]: Misapplies objects based on sharing context rather than type."
        },
        {
          "text": "SDOs are always relationships, while SCOs are always individual entities.",
          "misconception": "Targets [object type confusion]: Incorrectly categorizes SDOs and SCOs based on relationship status."
        },
        {
          "text": "SDOs are generated by connectors, while SCOs are manually entered.",
          "misconception": "Targets [creation method confusion]: Assumes a fixed creation method for each object type."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SDOs (like Intrusion-Set, Malware) describe the 'who, what, why' of threats, functioning as the core intelligence entities. SCOs (like IPv4-Addr, File) describe the 'where and how' at a technical level, representing observable technical details. This distinction allows for structured representation of threat intelligence.",
        "distractor_analysis": "The distractors incorrectly assign usage contexts, confuse object types with relationships, or impose rigid creation methods, failing to grasp the fundamental difference between conceptual threat entities (SDO) and technical indicators (SCO).",
        "analogy": "In a detective's case file: SDOs are the 'Suspects', 'Motives', and 'Modus Operandi' sections. SCOs are the 'Evidence' section, listing fingerprints, DNA, and weapon details."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "STIX_DATA_MODEL",
        "THREAT_OBSERVABLES"
      ]
    },
    {
      "question_text": "Consider a scenario where an OpenCTI connector needs to ingest threat intelligence from a MISP instance. Which type of connector would be most appropriate?",
      "correct_answer": "External Import connector",
      "distractors": [
        {
          "text": "Enrichment connector",
          "misconception": "Targets [functional scope confusion]: Assumes data retrieval is an enrichment task."
        },
        {
          "text": "Stream connector",
          "misconception": "Targets [data flow type confusion]: Mistakenly applies real-time streaming to batch import."
        },
        {
          "text": "Internal Export File connector",
          "misconception": "Targets [data direction confusion]: Reverses the data flow from import to export."
        }
      ],
      "detailed_explanation": {
        "core_logic": "An External Import connector is designed precisely for this purpose: to retrieve data from external sources like MISP and convert it into STIX 2.1 bundles for ingestion into OpenCTI. It functions by connecting to the external source's API or data feed and processing the information.",
        "distractor_analysis": "Enrichment connectors add information to existing data, Stream connectors process live events, and Export connectors send data out. None of these are primarily for initial bulk ingestion from an external platform like MISP.",
        "analogy": "If OpenCTI is your central intelligence hub, an External Import connector is like a dedicated agent sent to gather intel from allied agencies (MISP) and bring it back to the hub."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "OPENCTI_CONNECTORS_TYPES",
        "MISP_INTEGRATION"
      ]
    },
    {
      "question_text": "A security analyst is using OpenCTI and wants to automatically enrich newly discovered IP addresses with geolocation data from an external threat intelligence service. Which type of connector should be configured?",
      "correct_answer": "Enrichment connector",
      "distractors": [
        {
          "text": "Import connector",
          "misconception": "Targets [functional scope confusion]: Assumes enrichment is a form of initial import."
        },
        {
          "text": "Stream connector",
          "misconception": "Targets [triggering mechanism confusion]: Believes enrichment is triggered by data streams rather than object creation."
        },
        {
          "text": "Export connector",
          "misconception": "Targets [data flow direction]: Reverses the data flow from enrichment to export."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Enrichment connectors are designed to enhance existing objects within OpenCTI. They function by looking up newly created or user-requested objects (like IP addresses) in external services and adding relevant information (like geolocation) back into OpenCTI as STIX bundles.",
        "distractor_analysis": "Import connectors bring in new data, Stream connectors process live events, and Export connectors send data out. Enrichment connectors specifically perform the task of adding value to existing data.",
        "analogy": "An Enrichment connector is like a research assistant who, when given a name (IP address), goes to the library (external service) to find more details (geolocation) and adds them to the subject's file (OpenCTI object)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "OPENCTI_CONNECTORS_TYPES",
        "THREAT_INTEL_ENRICHMENT"
      ]
    },
    {
      "question_text": "When deploying OpenCTI connectors, what is the significance of the <code>CONNECTOR_ID</code> parameter?",
      "correct_answer": "It provides a unique identifier for the connector instance, allowing OpenCTI to manage and track it.",
      "distractors": [
        {
          "text": "It specifies the network port the connector will listen on.",
          "misconception": "Targets [parameter function confusion]: Confuses identification with network configuration."
        },
        {
          "text": "It determines the type of data the connector is allowed to process.",
          "misconception": "Targets [scope vs. identifier confusion]: Misunderstands the parameter's role in defining data scope."
        },
        {
          "text": "It sets the security level for the connector's API token.",
          "misconception": "Targets [security feature confusion]: Equates a unique ID with security settings."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>CONNECTOR_ID</code> serves as a unique identifier for each connector instance within OpenCTI. This allows the platform to uniquely register, manage, and monitor the connector's status and operations, ensuring proper integration and communication.",
        "distractor_analysis": "The distractors incorrectly assign roles related to network ports, data processing scope, or security levels, none of which are the primary function of the <code>CONNECTOR_ID</code> parameter.",
        "analogy": "The <code>CONNECTOR_ID</code> is like a serial number on a piece of equipment; it uniquely identifies that specific device (connector) for inventory, maintenance, and operational tracking within the larger system (OpenCTI)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "OPENCTI_CONNECTORS_CONFIG",
        "UNIQUE_IDENTIFIERS"
      ]
    },
    {
      "question_text": "What is the primary benefit of using OpenCTI connectors in a threat intelligence program?",
      "correct_answer": "Automation of data ingestion and dissemination, leading to more timely and comprehensive intelligence.",
      "distractors": [
        {
          "text": "Elimination of the need for human analysts.",
          "misconception": "Targets [automation vs. human role confusion]: Overstates automation's impact on human roles."
        },
        {
          "text": "Guaranteed accuracy of all ingested threat intelligence.",
          "misconception": "Targets [accuracy vs. automation confusion]: Assumes automation inherently guarantees data quality."
        },
        {
          "text": "Complete independence from external threat intelligence sources.",
          "misconception": "Targets [integration vs. independence confusion]: Misunderstands connectors as a replacement for external feeds."
        }
      ],
      "detailed_explanation": {
        "core_logic": "OpenCTI connectors automate the flow of threat intelligence data, enabling faster ingestion from diverse sources and quicker dissemination to relevant systems (like SIEMs or EDRs). This automation significantly enhances the timeliness and comprehensiveness of the intelligence available to analysts.",
        "distractor_analysis": "The distractors present unrealistic benefits such as eliminating human analysts, guaranteeing accuracy, or achieving complete independence, which are not direct outcomes of using connectors.",
        "analogy": "Connectors act like automated postal sorters and delivery systems for your intelligence; they speed up getting information from various senders (sources) to the right recipients (analysts, tools) much faster than manual sorting."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "THREAT_INTEL_PROGRAM_MANAGEMENT",
        "AUTOMATION_IN_CYBERSECURITY"
      ]
    },
    {
      "question_text": "A security operations center (SOC) wants to feed detected Indicators of Compromise (IoCs) from their SIEM into OpenCTI for correlation with other threat intelligence. Which connector type is best suited for this task?",
      "correct_answer": "Stream connector",
      "distractors": [
        {
          "text": "External Import connector",
          "misconception": "Targets [source type confusion]: Assumes SIEM is an external feed rather than an internal system generating events."
        },
        {
          "text": "Internal Import File connector",
          "misconception": "Targets [data format confusion]: Assumes IoCs are always in files, not live events."
        },
        {
          "text": "Enrichment connector",
          "misconception": "Targets [data flow direction]: Reverses the process; IoCs are being sent *to* OpenCTI, not used to enrich existing data *within* OpenCTI."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Stream connectors are designed to consume events from live data streams, such as those generated by a SIEM. By configuring a Stream connector, detected IoCs can be continuously fed into OpenCTI, allowing for real-time correlation with other intelligence and enabling faster threat hunting.",
        "distractor_analysis": "External Import connectors are for external feeds, Internal Import File connectors handle file-based data, and Enrichment connectors add data to existing objects. Stream connectors are the appropriate choice for processing live event feeds from internal systems like SIEMs.",
        "analogy": "The SIEM is like a security camera feed, and the Stream connector is the security guard watching the feed in real-time, immediately flagging any suspicious activity (IoCs) and sending an alert to the central command (OpenCTI)."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "OPENCTI_CONNECTORS_TYPES",
        "SIEM_INTEGRATION",
        "INDICATORS_OF_COMPROMISE"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 16,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "OpenCTI Connectors Threat Intelligence And Hunting best practices",
    "latency_ms": 25660.02
  },
  "timestamp": "2026-01-04T03:04:07.930490"
}