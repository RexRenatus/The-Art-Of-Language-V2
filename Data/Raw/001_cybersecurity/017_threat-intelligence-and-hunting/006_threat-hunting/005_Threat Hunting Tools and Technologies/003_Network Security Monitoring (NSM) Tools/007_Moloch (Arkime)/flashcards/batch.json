{
  "topic_title": "Moloch (Arkime)",
  "category": "Threat Intelligence And Hunting - 011_Threat Hunting",
  "flashcards": [
    {
      "question_text": "According to MITRE's TTP-based hunting methodology, what is the primary benefit of focusing on adversary Tactics, Techniques, and Procedures (TTPs) over Indicators of Compromise (IOCs)?",
      "correct_answer": "TTPs are more stable and harder for adversaries to change, providing more robust detection capabilities.",
      "distractors": [
        {
          "text": "IOCs are easier to automate for detection.",
          "misconception": "Targets [automation misconception]: While IOCs can be automated, TTPs offer more enduring detection logic."
        },
        {
          "text": "TTPs are specific to individual malware families.",
          "misconception": "Targets [specificity confusion]: TTPs are generalized behaviors, not tied to specific malware instances."
        },
        {
          "text": "IOCs provide better context for understanding adversary motives.",
          "misconception": "Targets [contextualization error]: TTPs provide better context by describing the adversary's actions and goals."
        }
      ],
      "detailed_explanation": {
        "core_logic": "TTPs describe adversary behaviors that are constrained by technology and harder to change than IOCs like IP addresses or file hashes. Focusing on TTPs allows for more resilient detection because adversaries must use these fundamental techniques.",
        "distractor_analysis": "The first distractor incorrectly prioritizes automation over robust detection logic. The second wrongly limits TTPs to specific malware. The third incorrectly assigns better contextualization to IOCs.",
        "analogy": "Hunting with TTPs is like understanding a burglar's methods (e.g., picking locks, disabling alarms), which remain consistent even if they change their tools (IOCs)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "THREAT_HUNTING_BASICS",
        "MITRE_ATTACK_FRAMEWORK"
      ]
    },
    {
      "question_text": "In the context of threat hunting with tools like Arkime, what is the primary advantage of using a Network Security Monitoring (NSM) approach focused on network traffic analysis?",
      "correct_answer": "It provides visibility into lateral movement and data exfiltration stages that perimeter monitoring might miss.",
      "distractors": [
        {
          "text": "It offers deep insights into host-based malware execution.",
          "misconception": "Targets [domain focus]: NSM primarily analyzes network traffic, not host-specific process execution details."
        },
        {
          "text": "It is the most cost-effective method for collecting all security data.",
          "misconception": "Targets [cost misconception]: While valuable, comprehensive NSM can be resource-intensive; host data is also crucial."
        },
        {
          "text": "It directly identifies specific malware signatures.",
          "misconception": "Targets [detection method confusion]: NSM focuses on traffic patterns and behaviors, not solely on static malware signatures."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Network Security Monitoring (NSM) analyzes network traffic to detect malicious activity. Because it captures communications between systems, it's crucial for understanding lateral movement and data exfiltration, which are often missed by perimeter defenses alone.",
        "distractor_analysis": "The first distractor misattributes host-level detail to NSM. The second makes an unsubstantiated claim about cost-effectiveness. The third incorrectly states NSM's primary function is signature detection.",
        "analogy": "NSM is like monitoring all the phone calls and mail between departments in a company to see who is talking to whom, which helps spot unauthorized communication, rather than just checking if a specific known spy is making calls."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "NSM_BASICS",
        "NETWORK_TRAFFIC_ANALYSIS"
      ]
    },
    {
      "question_text": "When implementing TTP-based hunting, what is the recommended approach for determining data collection requirements?",
      "correct_answer": "Identify data needed to support specific detection hypotheses derived from adversary TTPs.",
      "distractors": [
        {
          "text": "Collect all available data to ensure no gaps exist.",
          "misconception": "Targets [data volume misconception]: Collecting all data is often infeasible; focus on data relevant to specific TTPs."
        },
        {
          "text": "Prioritize data sources based on their cost and availability.",
          "misconception": "Targets [prioritization error]: While cost is a factor, data relevance to TTPs should be the primary driver."
        },
        {
          "text": "Wait for specific malware signatures to emerge before collecting data.",
          "misconception": "Targets [reactive approach]: TTP-based hunting is proactive, focusing on behaviors, not just known malware signatures."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Data collection requirements for TTP-based hunting are driven by the need to support specific detection hypotheses. These hypotheses are developed from understanding adversary Tactics, Techniques, and Procedures (TTPs), ensuring that collected data directly aids in identifying those behaviors.",
        "distractor_analysis": "The first distractor suggests an impractical 'collect-all' approach. The second prioritizes cost over relevance. The third promotes a reactive, signature-based strategy, contrary to TTP hunting.",
        "analogy": "Instead of collecting every single piece of paper in an office, you collect only the documents relevant to investigating a specific suspected fraud scheme."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "TTP_BASED_HUNTING",
        "DATA_COLLECTION_STRATEGIES"
      ]
    },
    {
      "question_text": "Arkime's architecture is designed for scalability. Which component is primarily responsible for capturing, parsing, and indexing network traffic?",
      "correct_answer": "The Capture Layer",
      "distractors": [
        {
          "text": "The Processing Layer",
          "misconception": "Targets [component function confusion]: The Processing Layer handles data enrichment (WISE) and database communication, not initial capture."
        },
        {
          "text": "The Visualization Layer",
          "misconception": "Targets [component function confusion]: The Visualization Layer (Viewer) provides interfaces for analysis and management, not capture."
        },
        {
          "text": "The WISE Service",
          "misconception": "Targets [component function confusion]: WISE enhances data with intelligence, but doesn't perform the core capture and indexing."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Arkime's Capture Layer, written in C, is responsible for ingesting network traffic via libpcap, parsing protocols, and sending session metadata to Elasticsearch/OpenSearch for indexing, forming the foundation of its scalable architecture.",
        "distractor_analysis": "Distractors misattribute core capture and indexing functions to other Arkime components (Processing, Visualization, WISE) which have distinct roles.",
        "analogy": "In a factory, the Capture Layer is the assembly line that receives raw materials, processes them, and prepares them for storage."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "ARKIME_ARCHITECTURE"
      ]
    },
    {
      "question_text": "What is the primary role of the WISE (With Intelligence See Everything) service in Arkime?",
      "correct_answer": "To enrich captured network traffic with external threat intelligence data.",
      "distractors": [
        {
          "text": "To perform the initial capture and storage of network packets.",
          "misconception": "Targets [component function confusion]: This is the role of the Capture Layer, not WISE."
        },
        {
          "text": "To provide the user interface for analyzing network sessions.",
          "misconception": "Targets [component function confusion]: This is the function of the Viewer Interface."
        },
        {
          "text": "To manage multiple Arkime clusters and monitor their health.",
          "misconception": "Targets [component function confusion]: This is the responsibility of the Parliament component."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The WISE service integrates with external threat intelligence feeds to enrich captured network traffic, adding context such as threat actor indicators or reputation scores to the data.",
        "distractor_analysis": "Each distractor assigns the function of another core Arkime component (Capture, Viewer, Parliament) to WISE.",
        "analogy": "WISE acts like an intelligence analyst who adds context and background information to raw reports, making them more meaningful."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "ARKIME_WISE_SERVICE",
        "THREAT_INTELLIGENCE_ENRICHMENT"
      ]
    },
    {
      "question_text": "When hunting for persistence mechanisms using Arkime, what is a key benefit of profiling the 'gold' image of systems?",
      "correct_answer": "It establishes a baseline of known good persistence locations, making deviations easier to identify.",
      "distractors": [
        {
          "text": "It automatically removes all identified persistence artifacts.",
          "misconception": "Targets [automation misconception]: Profiling identifies deviations; it does not automatically remove artifacts."
        },
        {
          "text": "It guarantees that all persistence techniques will be detected.",
          "misconception": "Targets [detection guarantee misconception]: Profiling aids detection by highlighting anomalies, but doesn't guarantee detection of all techniques."
        },
        {
          "text": "It replaces the need for network traffic analysis.",
          "misconception": "Targets [methodology confusion]: Profiling is a host-centric baseline activity, complementary to network analysis, not a replacement."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Profiling a system's 'gold' image establishes a baseline of its default persistence configurations. By comparing live systems against this baseline, hunt analysts can more easily identify deviations that may indicate unauthorized persistence mechanisms.",
        "distractor_analysis": "The first distractor overstates profiling's automation capabilities. The second falsely guarantees detection. The third incorrectly suggests it replaces network analysis.",
        "analogy": "Knowing what a 'clean' car looks like (baseline) makes it easier to spot unauthorized modifications (persistence) later."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "PERSISTENCE_HUNTING",
        "SYSTEM_BASELINING"
      ]
    },
    {
      "question_text": "According to the Elastic Guide to Threat Hunting, what is a critical characteristic of effective threat hunting that distinguishes it from passive security measures?",
      "correct_answer": "It is an active capability that combines human understanding with technology to seek out evidence of malicious activity.",
      "distractors": [
        {
          "text": "It relies solely on automated alerts from security tools.",
          "misconception": "Targets [automation reliance]: Threat hunting actively seeks threats, not just passively waits for alerts."
        },
        {
          "text": "It focuses exclusively on known Indicators of Compromise (IOCs).",
          "misconception": "Targets [scope limitation]: Effective hunting goes beyond IOCs to look for behaviors and anomalies."
        },
        {
          "text": "It aims to replace all existing security technologies.",
          "misconception": "Targets [replacement misconception]: Hunting complements, rather than replaces, existing security measures."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Effective threat hunting is an active, human-driven process that leverages technology to proactively search for and identify malicious activity, aiming to reduce adversary dwell time, unlike passive security measures that rely on predefined alerts.",
        "distractor_analysis": "The first distractor emphasizes passive automation, the second limits scope to IOCs, and the third suggests replacement rather than integration, all misrepresenting active threat hunting.",
        "analogy": "Passive security is like a security camera that records events; threat hunting is like a detective actively patrolling and looking for suspicious activity that the camera might miss."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "THREAT_HUNTING_CONCEPTS"
      ]
    },
    {
      "question_text": "When analyzing PsExec usage for lateral movement, what type of Windows Event ID is particularly useful for identifying requests to hidden administrative shares like \\(ADMIN or \\)IPC?",
      "correct_answer": "Event ID 5145",
      "distractors": [
        {
          "text": "Event ID 4688",
          "misconception": "Targets [event ID confusion]: EID 4688 logs process execution details, not share access attempts."
        },
        {
          "text": "Event ID 4769",
          "misconception": "Targets [event ID confusion]: EID 4769 relates to Kerberos service ticket requests, not share access."
        },
        {
          "text": "Event ID 7045",
          "misconception": "Targets [event ID confusion]: EID 7045 logs service installation, not direct share access attempts."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Windows Event ID 5145 logs metadata about requests for access to network shares, including administrative shares like \\(ADMIN and \\)IPC. This event is crucial for identifying potential unauthorized use of tools like PsExec that leverage these shares.",
        "distractor_analysis": "The distractors incorrectly associate PsExec's share access activity with unrelated Windows Event IDs (4688 for process execution, 4769 for Kerberos tickets, 7045 for service installation).",
        "analogy": "Detecting PsExec's use of hidden shares is like finding a logbook entry detailing who tried to access a restricted area, specifically noting the attempt on the '$ADMIN' door."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "LATERAL_MOVEMENT_TECHNIQUES",
        "WINDOWS_EVENT_LOGGING"
      ]
    },
    {
      "question_text": "What is the primary risk associated with using default or weak passwords for Service Principal Names (SPNs) in a Kerberos environment, as exploited by KERBEROASTING?",
      "correct_answer": "Attackers can obtain service tickets for these SPNs and crack them offline to reveal plaintext passwords.",
      "distractors": [
        {
          "text": "Domain controllers will immediately lock out accounts with weak passwords.",
          "misconception": "Targets [security control misconception]: Kerberos doesn't typically lock out accounts based on weak SPN passwords during ticket requests."
        },
        {
          "text": "It allows attackers to directly impersonate domain administrators.",
          "misconception": "Targets [privilege escalation misconception]: KERBEROASTING yields credentials, not direct impersonation without further steps."
        },
        {
          "text": "It forces the use of less secure NTLM authentication.",
          "misconception": "Targets [protocol confusion]: KERBEROASTING targets Kerberos tickets, not NTLM authentication."
        }
      ],
      "detailed_explanation": {
        "core_logic": "KERBEROASTING exploits weak passwords on SPNs by allowing attackers to request service tickets from the domain controller. These tickets can then be cracked offline to reveal the plaintext password of the service account associated with the SPN.",
        "distractor_analysis": "The first distractor misrepresents Kerberos lockout policies. The second overstates the immediate impact of KERBEROASTING. The third incorrectly links the attack to NTLM.",
        "analogy": "Weak SPN passwords are like leaving the key to a valuable service account's safe deposit box easily accessible; attackers can 'borrow' the key (ticket) and try to crack it later."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "KERBEROS_AUTHENTICATION",
        "CREDENTIAL_THEFT_TECHNIQUES"
      ]
    },
    {
      "question_text": "In Arkime, what is the purpose of the <code>db.pl</code> script, particularly concerning upgrades?",
      "correct_answer": "To manage database schemas, perform upgrades, and ensure compatibility between Arkime versions and the backend (Elasticsearch/OpenSearch).",
      "distractors": [
        {
          "text": "To directly capture and analyze network traffic.",
          "misconception": "Targets [script function confusion]: Traffic capture is handled by the 'capture' binary, not 'db.pl'."
        },
        {
          "text": "To configure the user interface and visualization settings.",
          "misconception": "Targets [script function confusion]: UI configuration is managed via config files and the Viewer interface."
        },
        {
          "text": "To manage threat intelligence feeds for the WISE service.",
          "misconception": "Targets [script function confusion]: WISE service configuration is separate from 'db.pl'."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>db.pl</code> script is essential for maintaining Arkime's backend database. During upgrades, it ensures that the database schema is updated correctly to be compatible with the new Arkime version and the chosen backend (Elasticsearch or OpenSearch).",
        "distractor_analysis": "The distractors incorrectly assign core Arkime functions (traffic capture, UI configuration, WISE management) to the <code>db.pl</code> script, which is specifically for database operations.",
        "analogy": "The <code>db.pl</code> script is like a database administrator who ensures the database structure is updated and compatible whenever new software versions are installed."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "ARKIME_INSTALLATION",
        "DATABASE_MANAGEMENT"
      ]
    },
    {
      "question_text": "When hunting for fileless attacks using 'living off the land' techniques, what is a key indicator that an administrative tool like PowerShell might be used maliciously?",
      "correct_answer": "Unusual command-line parameters, such as encoded commands or unexpected execution contexts.",
      "distractors": [
        {
          "text": "The presence of PowerShell on the system.",
          "misconception": "Targets [tool presence misconception]: PowerShell is a legitimate administrative tool; its mere presence is not malicious."
        },
        {
          "text": "PowerShell being used by a system administrator.",
          "misconception": "Targets [user context misconception]: Legitimate administrative use is expected; the context and parameters are key."
        },
        {
          "text": "PowerShell executing standard system commands.",
          "misconception": "Targets [command normalcy misconception]: While it executes standard commands, the *way* it's used (e.g., unusual parameters) is the indicator."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Fileless attacks often leverage legitimate administrative tools like PowerShell. Malicious use is typically indicated not by the tool's presence or standard commands, but by unusual parameters (like encoding or hidden execution) or unexpected parent processes.",
        "distractor_analysis": "The distractors focus on the tool's presence, legitimate user context, or normal command execution, missing the crucial indicators of malicious intent found in unusual parameters or execution patterns.",
        "analogy": "Spotting a chef using a knife is normal; seeing them use it to pry open a safe is suspicious, even though the knife itself is a standard tool."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "FILELESS_ATTACKS",
        "LIVING_OFF_THE_LAND"
      ]
    },
    {
      "question_text": "What is the purpose of the <code>arkime_packet_log</code> output in Arkime's capture logs?",
      "correct_answer": "To provide periodic progress updates on packet processing, including received, dropped, and queued packets.",
      "distractors": [
        {
          "text": "To log detailed HTTP request and response headers.",
          "misconception": "Targets [log content confusion]: HTTP details are logged elsewhere; this log focuses on packet processing statistics."
        },
        {
          "text": "To record security alerts generated by Arkime rules.",
          "misconception": "Targets [log content confusion]: Security alerts are typically handled by a separate alerting mechanism or log category."
        },
        {
          "text": "To store the full packet capture (PCAP) data.",
          "misconception": "Targets [log content confusion]: PCAP data is stored in separate files, not within these progress logs."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>arkime_packet_log</code> entries provide crucial operational statistics on packet processing, such as the number of packets received, dropped, queued for disk, and awaiting processing, offering insight into the capture system's performance.",
        "distractor_analysis": "The distractors incorrectly describe the log's content, attributing HTTP details, security alerts, or PCAP data storage to it, which are handled by different Arkime components or logs.",
        "analogy": "These logs are like the status updates on a factory production line, showing how many items have entered, how many are waiting, and if any have been dropped."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "ARKIME_LOGGING",
        "PACKET_PROCESSING"
      ]
    },
    {
      "question_text": "According to the MITRE ATT&CK framework, what is the primary goal of the 'Discovery' tactic?",
      "correct_answer": "To gather information about the internal network, systems, and user accounts to plan further actions.",
      "distractors": [
        {
          "text": "To gain initial access into the target network.",
          "misconception": "Targets [tactic scope confusion]: Initial access is a separate tactic; Discovery occurs after initial compromise."
        },
        {
          "text": "To establish persistent access to compromised systems.",
          "misconception": "Targets [tactic scope confusion]: Persistence is a distinct tactic focused on maintaining access."
        },
        {
          "text": "To exfiltrate sensitive data from the target network.",
          "misconception": "Targets [tactic scope confusion]: Exfiltration is the final stage of data theft, occurring after discovery and collection."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'Discovery' tactic in MITRE ATT&CK involves adversaries gathering intelligence about the target environment after gaining initial access. This information is used to identify valuable assets, understand network topology, and plan subsequent actions like lateral movement or data collection.",
        "distractor_analysis": "The distractors incorrectly assign the goals of other MITRE ATT&CK tactics (Initial Access, Persistence, Exfiltration) to the Discovery tactic.",
        "analogy": "Discovery is like a burglar casing a house after breaking in â€“ they look for where the valuables are kept and how to move around unseen, before actually stealing anything."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "MITRE_ATTACK_FRAMEWORK",
        "CYBER_ATTACK_LIFECYCLE"
      ]
    },
    {
      "question_text": "When Arkime encounters an 'ERROR - Dropping request' message, what is the most likely underlying cause?",
      "correct_answer": "The Elasticsearch/OpenSearch cluster cannot keep up with the rate of session data being sent by the capture nodes.",
      "distractors": [
        {
          "text": "A network connectivity issue between capture nodes and the viewer.",
          "misconception": "Targets [connectivity misconception]: The error relates to backend processing capacity, not viewer connectivity."
        },
        {
          "text": "Insufficient disk space on the capture node's local storage.",
          "misconception": "Targets [storage misconception]: While disk space is important, this error specifically points to backend indexing bottlenecks."
        },
        {
          "text": "A misconfiguration in the Arkime viewer's user interface.",
          "misconception": "Targets [component confusion]: The error originates from the capture-to-backend data flow, not the UI."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'Dropping request' error indicates that the Elasticsearch or OpenSearch backend is overwhelmed by the volume of session metadata from capture nodes. This suggests the backend cluster lacks the capacity (CPU, memory, or I/O) to index the incoming data quickly enough.",
        "distractor_analysis": "The distractors incorrectly attribute the error to viewer connectivity, capture node disk space, or UI misconfiguration, diverting focus from the actual bottleneck in the backend data ingestion process.",
        "analogy": "It's like a post office trying to process too much mail at once; the mailroom (backend) gets overwhelmed, and mail (requests) starts getting dropped because it can't be handled fast enough."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "ARKIME_TROUBLESHOOTING",
        "ELASTICSEARCH_OPENSEARCH_PERFORMANCE"
      ]
    },
    {
      "question_text": "What is the recommended approach for handling self-signed or private CA TLS certificates with Arkime components like capture and viewer?",
      "correct_answer": "Configure the <code>caTrustFile</code> option in the configuration to point to the trusted certificate file.",
      "distractors": [
        {
          "text": "Disable TLS verification entirely using the <code>--insecure</code> flag for all components.",
          "misconception": "Targets [security posture]: While possible, disabling verification is less secure; using `caTrustFile` is preferred."
        },
        {
          "text": "Replace self-signed certificates with certificates from Let's Encrypt.",
          "misconception": "Targets [certificate source]: While Let's Encrypt is good, it doesn't directly address the trust issue for private CAs or self-signed certs without proper configuration."
        },
        {
          "text": "Manually add the certificate to the operating system's trust store only.",
          "misconception": "Targets [trust store scope]: Arkime components may use separate trust stores; `caTrustFile` provides explicit Arkime-level trust."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Arkime components can be configured to trust self-signed or private CA certificates by specifying the <code>caTrustFile</code> option, which points to a file containing the necessary trusted certificates, ensuring secure communication without disabling verification.",
        "distractor_analysis": "The first distractor suggests a less secure alternative. The second offers a valid alternative but doesn't address the core configuration need for existing private certs. The third overlooks Arkime's specific trust configuration mechanism.",
        "analogy": "Instead of telling your computer to ignore all security guards (disabling verification), you provide it with a list of known, trusted guards (caTrustFile) it should recognize."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "ARKIME_CONFIGURATION",
        "TLS_CERTIFICATE_MANAGEMENT"
      ]
    },
    {
      "question_text": "According to the Elastic Guide to Threat Hunting, what is the significance of 'recency' when categorizing unknowns during a hunt?",
      "correct_answer": "More recent events or artifacts are generally considered more suspicious because intrusions often happen in the present.",
      "distractors": [
        {
          "text": "Older artifacts are more likely to be malicious because they indicate long-term compromise.",
          "misconception": "Targets [recency interpretation]: While some persistence is long-term, active intrusions are typically recent."
        },
        {
          "text": "Recency is irrelevant; only prevalence matters for identifying threats.",
          "misconception": "Targets [prevalence vs. recency]: Both prevalence and recency are important indicators; recency helps focus on active threats."
        },
        {
          "text": "Recency helps determine the exact malware family used.",
          "misconception": "Targets [artifact identification]: Recency indicates activity timing, not necessarily the specific malware type."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Recency is a key factor in threat hunting because active intrusions occur in the present. By focusing on recent events and artifacts, analysts can prioritize investigations on potentially ongoing malicious activities, rather than historical data.",
        "distractor_analysis": "The first distractor misinterprets recency as indicating long-term compromise. The second dismisses recency's importance. The third incorrectly links recency to malware family identification.",
        "analogy": "When looking for a lost item, you first check where you last saw it (recent activity), rather than searching places you haven't been in years."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "THREAT_HUNTING_METHODOLOGY",
        "EVENT_TIMING_ANALYSIS"
      ]
    },
    {
      "question_text": "What is the primary purpose of the <code>arkime_fields</code> index in Arkime?",
      "correct_answer": "To store metadata about available fields, enabling the viewer to correctly parse and display session data.",
      "distractors": [
        {
          "text": "To store the raw packet capture (PCAP) data.",
          "misconception": "Targets [data storage confusion]: PCAP data is stored separately; this index holds field definitions."
        },
        {
          "text": "To log all user authentication events within Arkime.",
          "misconception": "Targets [log storage confusion]: User authentication logs are managed differently, not primarily in the fields index."
        },
        {
          "text": "To index threat intelligence data used by the WISE service.",
          "misconception": "Targets [data indexing confusion]: WISE data is managed separately; this index is for field definitions."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>arkime_fields</code> index acts as a schema definition for Arkime's data. It stores information about available fields, their types, and how they should be interpreted, which is essential for the Viewer interface to correctly parse and display session data.",
        "distractor_analysis": "The distractors incorrectly assign the roles of PCAP storage, user log management, or threat intelligence indexing to the <code>arkime_fields</code> index.",
        "analogy": "The <code>arkime_fields</code> index is like a dictionary for Arkime's data, defining what each 'word' (field) means so the system can understand and display information correctly."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "ARKIME_DATA_MODEL",
        "METADATA_MANAGEMENT"
      ]
    },
    {
      "question_text": "When Arkime capture logs show 'pstats' values indicating dropped packets due to 'packet-drop-ips', what is the most direct action to mitigate this?",
      "correct_answer": "Review and adjust the <code>packet-drop-ips</code> configuration setting in <code>config.ini</code> to exclude unnecessary IP addresses or CIDRs.",
      "distractors": [
        {
          "text": "Increase the <code>packetThreads</code> setting to process packets faster.",
          "misconception": "Targets [mitigation strategy confusion]: `packetThreads` affects processing queue load, not packet filtering based on IP."
        },
        {
          "text": "Disable the <code>bpf</code> filter to allow more traffic through.",
          "misconception": "Targets [mitigation strategy confusion]: Disabling the BPF filter would increase traffic, potentially worsening drops; `packet-drop-ips` is for filtering specific IPs."
        },
        {
          "text": "Ensure the Elasticsearch/OpenSearch cluster has sufficient capacity.",
          "misconception": "Targets [bottleneck confusion]: Backend capacity issues cause 'Dropping request' errors, not 'packet-drop-ips' which is a pre-processing filter."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'packet-drop-ips' value in <code>pstats</code> directly corresponds to packets dropped because their source or destination IPs are listed in the <code>packet-drop-ips</code> configuration. Adjusting this setting to exclude unwanted IPs is the direct mitigation.",
        "distractor_analysis": "The distractors suggest unrelated performance tuning (<code>packetThreads</code>), filtering changes (<code>bpf</code>), or backend capacity adjustments, which do not address the specific IP-based packet filtering indicated by 'packet-drop-ips'.",
        "analogy": "If your mail sorter is discarding mail addressed to specific departments you don't care about, you adjust the sorter's rules (packet-drop-ips) to stop discarding that mail."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "ARKIME_PERFORMANCE_TUNING",
        "PACKET_FILTERING"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 18,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Moloch (Arkime) Threat Intelligence And Hunting best practices",
    "latency_ms": 27669.916
  },
  "timestamp": "2026-01-04T03:31:30.564674"
}