{
  "topic_title": "Major vs. Minor Version Changes",
  "category": "Security And Risk Management - Security Policy Development",
  "flashcards": [
    {
      "question_text": "According to Semantic Versioning (SemVer), which type of change necessitates an increment in the MAJOR version number?",
      "correct_answer": "Backward incompatible API changes",
      "distractors": [
        {
          "text": "Introduction of new features that do not affect existing functionality",
          "misconception": "Targets [minor version confusion]: This describes a minor version increment, not a major one."
        },
        {
          "text": "Backward compatible bug fixes",
          "misconception": "Targets [patch version confusion]: This is the definition of a patch version increment."
        },
        {
          "text": "Internal code refactoring that does not alter the public API",
          "misconception": "Targets [scope confusion]: Internal changes that don't impact the API typically don't require a version bump, or at most a patch."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Major version increments (X.y.z) are reserved for backward incompatible API changes because they signal to users that existing code relying on the previous API will likely break and require modification.",
        "distractor_analysis": "The distractors represent common misunderstandings of versioning schemes, confusing major changes with minor feature additions or patch-level bug fixes, which are handled by different version number components.",
        "analogy": "Think of a major version update like a complete renovation of a house where the layout changes significantly, requiring residents to adapt their furniture and routines. Minor updates are like adding a new room, and patch updates are like fixing a leaky faucet."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SEMVER_BASICS"
      ]
    },
    {
      "question_text": "In Semantic Versioning (SemVer), what does incrementing the MINOR version (X.Y.z) signify?",
      "correct_answer": "Addition of backward-compatible functionality to the public API",
      "distractors": [
        {
          "text": "A critical security vulnerability has been patched",
          "misconception": "Targets [patch version confusion]: Security fixes are typically patch versions unless they introduce breaking changes."
        },
        {
          "text": "A complete overhaul of the system's architecture",
          "misconception": "Targets [major version confusion]: This describes a major version change due to breaking incompatibilities."
        },
        {
          "text": "Deprecation of a previously supported feature",
          "misconception": "Targets [deprecation handling]: While deprecation can lead to a minor bump, it's not the sole or primary meaning."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A minor version increment (x.Y.z, where x > 0) signifies that new, backward-compatible functionality has been added to the public API, because users can adopt the new features without breaking existing integrations.",
        "distractor_analysis": "Distractors incorrectly associate minor version bumps with security patches (patch version), major architectural changes (major version), or solely with deprecation, missing the core concept of adding compatible features.",
        "analogy": "A minor version update is like adding a new, optional feature to a car, such as a better navigation system, without changing how the existing engine or controls work."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SEMVER_BASICS"
      ]
    },
    {
      "question_text": "What is the primary purpose of Semantic Versioning (SemVer) in software development?",
      "correct_answer": "To convey meaning about the underlying code and changes through version numbers, aiding dependency management.",
      "distractors": [
        {
          "text": "To enforce strict coding standards across all projects",
          "misconception": "Targets [scope confusion]: SemVer is about versioning, not direct code enforcement."
        },
        {
          "text": "To automatically generate release notes for developers",
          "misconception": "Targets [tool confusion]: SemVer provides a framework, but note generation is a separate process."
        },
        {
          "text": "To track the number of bugs fixed in each release",
          "misconception": "Targets [misinterpretation of patch]: While patch versions track bug fixes, SemVer's purpose is broader dependency communication."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SemVer's core purpose is to communicate the nature of changes (major, minor, patch) because this meaning is crucial for managing software dependencies and preventing 'dependency hell'.",
        "distractor_analysis": "The distractors misattribute SemVer's function to code enforcement, automated documentation, or solely bug tracking, rather than its primary role in clear, version-based communication for dependency management.",
        "analogy": "SemVer is like a traffic light system for software updates: red (major) means stop and be careful, yellow (minor) means proceed with caution for new features, and green (patch) means go, as it's a safe fix."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SEMVER_BASICS",
        "DEPENDENCY_MANAGEMENT"
      ]
    },
    {
      "question_text": "A software library is currently at version 1.2.3. If the developers release a new version that fixes a critical security vulnerability without altering any existing functionality or API, what should the new version number be according to SemVer?",
      "correct_answer": "1.2.4",
      "distractors": [
        {
          "text": "1.3.0",
          "misconception": "Targets [minor version confusion]: This indicates new features, not just bug fixes."
        },
        {
          "text": "2.0.0",
          "misconception": "Targets [major version confusion]: This signifies breaking changes, not simple fixes."
        },
        {
          "text": "1.2.3-security",
          "misconception": "Targets [pre-release confusion]: Pre-release tags are for unstable versions, not stable security fixes."
        }
      ],
      "detailed_explanation": {
        "core_logic": "According to Semantic Versioning, a patch version (the third number, Z in X.Y.Z) MUST be incremented for backward-compatible bug fixes, because these changes do not affect the public API and should not break dependent software.",
        "distractor_analysis": "The distractors represent common errors: assuming any fix warrants a minor or major bump, or incorrectly applying pre-release tags for stable updates.",
        "analogy": "This is like a software update that fixes a small bug in your car's infotainment system without changing how you drive or operate other features. The version number only gets a small increment."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "SEMVER_BASICS"
      ]
    },
    {
      "question_text": "NIST SP 800-126A defines version updates. A 'major version update' is described as a revision that breaks backward compatibility in numerous significant ways. What is the primary implication of such an update for dependent systems?",
      "correct_answer": "Dependent systems may require modifications to function correctly with the new version.",
      "distractors": [
        {
          "text": "Dependent systems will automatically adapt due to built-in compatibility layers.",
          "misconception": "Targets [assumption of compatibility]: Breaking changes explicitly mean automatic adaptation is unlikely."
        },
        {
          "text": "Dependent systems will continue to function without any changes.",
          "misconception": "Targets [misunderstanding of 'breaking changes']: This is the opposite of what a major version update implies."
        },
        {
          "text": "Dependent systems will be automatically updated by the new version.",
          "misconception": "Targets [scope confusion]: Version updates do not typically auto-update dependent systems; that's a deployment task."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A major version update breaks backward compatibility because it introduces incompatible API changes; therefore, dependent systems that rely on the previous API will likely need to be updated or modified to work with the new version.",
        "distractor_analysis": "The distractors suggest automatic compatibility or updates, which contradict the definition of a 'breaking change' and the reality of managing software dependencies.",
        "analogy": "Imagine a new edition of a textbook that completely rewrites chapters and changes the numbering of concepts. Students using the old edition will need to get the new one and relearn where things are."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SEMVER_BASICS",
        "NIST_SP_800_126A_DEFINITIONS"
      ]
    },
    {
      "question_text": "Consider a scenario where a software product's public API is significantly altered, rendering previous integrations non-functional. Which versioning scheme, as defined by Semantic Versioning (SemVer), should be applied?",
      "correct_answer": "Major version increment (e.g., from 2.x.x to 3.0.0)",
      "distractors": [
        {
          "text": "Minor version increment (e.g., from 2.1.x to 2.2.0)",
          "misconception": "Targets [minor vs. major confusion]: Minor versions are for backward-compatible additions, not breaking changes."
        },
        {
          "text": "Patch version increment (e.g., from 2.1.5 to 2.1.6)",
          "misconception": "Targets [patch vs. major confusion]: Patch versions are for bug fixes, not API alterations."
        },
        {
          "text": "Pre-release version tag (e.g., 3.0.0-alpha)",
          "misconception": "Targets [pre-release vs. stable release confusion]: Pre-release tags are for unstable versions, not for a finalized breaking change."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Semantic Versioning mandates that a major version increment (X.y.z, where X increases) MUST be used for backward incompatible API changes, because this clearly signals to users that their existing integrations will break and require updates.",
        "distractor_analysis": "The distractors incorrectly suggest using minor, patch, or pre-release versions for a fundamental API change, failing to recognize the distinct purpose of each version component in communicating compatibility.",
        "analogy": "This is like changing the electrical plug type on a device. You can't just plug it into the old socket; you need an adapter or a new socket, signifying a major change."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "SEMVER_BASICS"
      ]
    },
    {
      "question_text": "According to NIST SP 1800-31, 'patching' is defined as applying a change to installed software to correct problems or add capabilities. What is a common challenge organizations face with patching, as highlighted by NIST?",
      "correct_answer": "Patching can reduce system and service availability, and prioritizing/testing patches is difficult.",
      "distractors": [
        {
          "text": "Patching always requires significant hardware upgrades.",
          "misconception": "Targets [misconception of patch requirements]: Patches are software changes, not typically hardware requirements."
        },
        {
          "text": "Patching is primarily a concern for end-user devices, not servers.",
          "misconception": "Targets [scope confusion]: NIST SP 1800-31 covers enterprise patching, including servers and systems."
        },
        {
          "text": "Automated patching tools are universally unreliable.",
          "misconception": "Targets [overgeneralization]: While challenges exist, NIST SP 1800-31 focuses on *improving* patching with tools, not dismissing them."
        }
      ],
      "detailed_explanation": {
        "core_logic": "NIST SP 1800-31 highlights that patching is resource-intensive and can impact system availability, and organizations struggle with prioritization and testing, because these operational challenges often lead to delayed or inadequate patching.",
        "distractor_analysis": "The distractors present inaccurate or overly narrow views of patching challenges, such as requiring hardware, being limited to end-user devices, or universally condemning automated tools, contrary to the guidance in NIST SP 1800-31.",
        "analogy": "Imagine a restaurant needing to update its menu. While adding new dishes (new capabilities) is good, the process of testing recipes, training staff, and updating printed menus (patching) can be time-consuming and might temporarily disrupt service."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "PATCH_MANAGEMENT_BASICS",
        "NIST_SP_1800_31"
      ]
    },
    {
      "question_text": "Which of the following best describes the relationship between a 'major version update' and 'minor version update' in the context of software versioning, according to NIST SP 800-126A?",
      "correct_answer": "Major updates break backward compatibility significantly, while minor updates add functionality with minimal impact on compatibility.",
      "distractors": [
        {
          "text": "Minor updates are always security-focused, while major updates are feature-focused.",
          "misconception": "Targets [scope confusion]: Both major and minor updates can include features or fixes, but the key differentiator is compatibility."
        },
        {
          "text": "Major updates are for new products, and minor updates are for existing ones.",
          "misconception": "Targets [product lifecycle confusion]: Versioning applies to the evolution of a single product or library."
        },
        {
          "text": "Minor updates are only applied to operating systems, while major updates apply to applications.",
          "misconception": "Targets [platform confusion]: Versioning principles apply broadly across software types."
        }
      ],
      "detailed_explanation": {
        "core_logic": "NIST SP 800-126A defines major version updates as those breaking backward compatibility significantly, necessitating changes in dependent systems. Minor version updates, conversely, add or enhance functionality with minimal impact, because they maintain backward compatibility.",
        "distractor_analysis": "The distractors misrepresent the core difference by focusing on security vs. features, product lifecycle, or platform specificity, rather than the critical aspect of backward compatibility.",
        "analogy": "Think of a car model year. A major update (e.g., a completely redesigned car) might require you to buy new accessories designed for that specific model. A minor update (e.g., adding a new trim package or a slightly improved engine) usually means your existing accessories still fit."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "SEMVER_BASICS",
        "NIST_SP_800_126A_DEFINITIONS"
      ]
    },
    {
      "question_text": "A cybersecurity team is evaluating a new version of a critical security tool. The release notes state 'Version 3.0.0: Complete API overhaul, new authentication mechanism, and deprecation of several legacy functions.' What type of version change does this represent according to SemVer?",
      "correct_answer": "Major version change",
      "distractors": [
        {
          "text": "Minor version change",
          "misconception": "Targets [major vs. minor confusion]: An API overhaul and deprecation of functions are breaking changes, not backward-compatible additions."
        },
        {
          "text": "Patch version change",
          "misconception": "Targets [patch vs. major confusion]: Patch versions are for bug fixes, not significant API changes."
        },
        {
          "text": "Pre-release version",
          "misconception": "Targets [pre-release vs. stable release confusion]: While '3.0.0-alpha' might precede 3.0.0, the description itself signifies a stable major release."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A major version increment is required when backward incompatible changes are introduced to the public API, such as a complete API overhaul and deprecation of functions, because these changes will break existing integrations.",
        "distractor_analysis": "The distractors fail to recognize that an 'API overhaul' and 'deprecation of several legacy functions' are inherently breaking changes, which are the defining characteristic of a major version update in SemVer.",
        "analogy": "This is like a software company releasing a completely new version of its operating system that requires new hardware drivers and is not compatible with older applications. It's a major shift."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "SEMVER_BASICS"
      ]
    },
    {
      "question_text": "When managing software dependencies, what is the primary risk associated with a 'major version update' of a critical library?",
      "correct_answer": "It may introduce backward-incompatible changes, requiring updates to dependent applications.",
      "distractors": [
        {
          "text": "It will likely introduce performance regressions.",
          "misconception": "Targets [performance assumption]: Major updates *can* improve or degrade performance, but incompatibility is the defining risk."
        },
        {
          "text": "It will increase the software's memory footprint significantly.",
          "misconception": "Targets [resource assumption]: While possible, this is not the primary or guaranteed risk of a major version update."
        },
        {
          "text": "It will require a complete reinstallation of the operating system.",
          "misconception": "Targets [overstated impact]: While significant, it rarely necessitates an OS reinstallation unless the library is fundamental."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The primary risk of a major version update is backward incompatibility because SemVer reserves major bumps for changes that break the public API, meaning dependent software must be adapted to function correctly.",
        "distractor_analysis": "The distractors focus on potential side effects like performance or memory usage, or an exaggerated impact like OS reinstallation, rather than the core, defined risk of API incompatibility.",
        "analogy": "If a critical component in your car's engine is redesigned in a major update (e.g., a new fuel injection system), your existing mechanic might not have the tools or knowledge to service it without specific training or new equipment."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SEMVER_BASICS",
        "DEPENDENCY_MANAGEMENT"
      ]
    },
    {
      "question_text": "A software vendor releases version 1.5.2 of their product. They later announce version 1.6.0, stating it includes 'new reporting features and improved data export capabilities, all while maintaining full compatibility with existing configurations.' What type of version change is this?",
      "correct_answer": "Minor version change",
      "distractors": [
        {
          "text": "Major version change",
          "misconception": "Targets [major vs. minor confusion]: The explicit mention of 'full compatibility' contradicts the definition of a major change."
        },
        {
          "text": "Patch version change",
          "misconception": "Targets [patch vs. minor confusion]: New features and improved capabilities go beyond simple bug fixes."
        },
        {
          "text": "Build metadata update",
          "misconception": "Targets [build metadata confusion]: Build metadata (e.g., '+build123') does not affect version precedence or functionality type."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A minor version increment (x.Y.z, where Y increases) is used for backward-compatible functionality additions, because the vendor explicitly stated 'full compatibility' while introducing new features like reporting and data export.",
        "distractor_analysis": "The distractors incorrectly label the update as major (due to new features), patch (as it's more than just fixes), or build metadata (which is irrelevant to functional changes).",
        "analogy": "This is like a smartphone update that adds new apps or features to the operating system without changing how you use existing apps or the phone's core functions."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "SEMVER_BASICS"
      ]
    },
    {
      "question_text": "In the context of software versioning, what does the term 'backward compatibility' primarily refer to?",
      "correct_answer": "The ability of a new version of software to work with older versions or data created by older versions.",
      "distractors": [
        {
          "text": "The ability of older software versions to work with new data formats.",
          "misconception": "Targets [directionality confusion]: Backward compatibility is about new versions working with old systems/data, not vice-versa."
        },
        {
          "text": "The software's ability to run on older hardware.",
          "misconception": "Targets [scope confusion]: Backward compatibility typically refers to software interfaces, not hardware."
        },
        {
          "text": "The software's ability to be easily upgraded to the latest version.",
          "misconception": "Targets [upgrade vs. compatibility confusion]: While related, compatibility is about function, not ease of upgrade process."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Backward compatibility means that a newer version of software can interact with or replace an older version without causing issues, because it maintains the same interfaces or data structures that older versions relied upon.",
        "distractor_analysis": "The distractors confuse the directionality of compatibility (new with old vs. old with new), conflate it with hardware requirements, or mix it with the ease of the upgrade process itself.",
        "analogy": "If a new version of a word processor can still open and edit documents created by its previous version, it is backward compatible."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SOFTWARE_VERSIONING_CONCEPTS"
      ]
    },
    {
      "question_text": "A cybersecurity professional is managing updates for a critical infrastructure system. The vendor releases an update labeled 'v2.1.0-rc.1'. What does the '-rc.1' suffix indicate according to Semantic Versioning?",
      "correct_answer": "It is a pre-release version, indicating potential instability and not yet satisfying the final compatibility requirements.",
      "distractors": [
        {
          "text": "It is a patch release containing only bug fixes.",
          "misconception": "Targets [pre-release vs. patch confusion]: Patch releases are stable (e.g., 2.1.1), while pre-releases are explicitly unstable."
        },
        {
          "text": "It is a major release that includes breaking changes.",
          "misconception": "Targets [pre-release vs. major confusion]: Major releases are denoted by the first number change (e.g., 3.0.0), not a suffix."
        },
        {
          "text": "It is a build artifact for internal testing only.",
          "misconception": "Targets [pre-release vs. build metadata confusion]: Build metadata (e.g., '+build123') is for build specifics, not pre-release status."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Pre-release versions, indicated by a hyphen and identifiers like '-rc.1', signify that the version is unstable and may not meet the compatibility guarantees of the final release because it's intended for testing before the official stable release.",
        "distractor_analysis": "The distractors incorrectly equate pre-release versions with stable patch or major releases, or confuse them with build metadata, failing to grasp their purpose as indicators of pre-production instability.",
        "analogy": "This is like a 'beta' version of a new app on your phone. It has new features but might have bugs and isn't the final, polished version."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "SEMVER_BASICS"
      ]
    },
    {
      "question_text": "When a software component is versioned as 0.y.z (e.g., 0.1.0, 0.2.5), what does Semantic Versioning (SemVer) imply about its public API?",
      "correct_answer": "The public API should not be considered stable and can change at any time.",
      "distractors": [
        {
          "text": "The public API is stable and backward compatible.",
          "misconception": "Targets [version 0 stability confusion]: Version 0 is explicitly for initial development and unstable APIs."
        },
        {
          "text": "Only patch versions (0.y.Z) are considered unstable.",
          "misconception": "Targets [version 0 scope confusion]: The entire 0.y.z range signifies instability, not just patch increments."
        },
        {
          "text": "The public API is guaranteed to be backward compatible until version 1.0.0.",
          "misconception": "Targets [version 1.0.0 transition confusion]: Stability guarantees begin at 1.0.0; before that, changes are expected."
        }
      ],
      "detailed_explanation": {
        "core_logic": "According to SemVer, major version zero (0.y.z) is designated for initial development, meaning anything may change at any time, and the public API should not be considered stable because the software is still under active, potentially breaking, development.",
        "distractor_analysis": "The distractors incorrectly assume stability or backward compatibility during the 0.y.z phase, misunderstanding that this phase is precisely for rapid development and API evolution before a stable 1.0.0 release.",
        "analogy": "Think of version 0.y.z as a construction site. The layout can change daily, and you shouldn't rely on specific paths or structures being permanent until the building is officially opened (version 1.0.0)."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SEMVER_BASICS"
      ]
    },
    {
      "question_text": "A company is developing a new security product. They plan to release an initial version. According to Semantic Versioning (SemVer), what is the recommended starting version number for initial development?",
      "correct_answer": "0.1.0",
      "distractors": [
        {
          "text": "1.0.0",
          "misconception": "Targets [version 1.0.0 purpose confusion]: Version 1.0.0 signifies a stable public API, not initial development."
        },
        {
          "text": "0.0.1",
          "misconception": "Targets [initial development convention confusion]: While technically in the 0.y.z range, 0.1.0 is the conventional starting point for initial development."
        },
        {
          "text": "1.0.0-alpha",
          "misconception": "Targets [pre-release vs. initial development confusion]: Pre-release tags are typically used for versions *after* initial development has begun, not the very start."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SemVer recommends starting initial development at version 0.1.0 because this signifies that the public API is not yet stable and can change frequently, allowing for rapid iteration before a stable 1.0.0 release.",
        "distractor_analysis": "The distractors suggest versions that imply stability (1.0.0), a less conventional starting point (0.0.1), or a pre-release tag, missing the standard convention for initiating development under SemVer.",
        "analogy": "When starting a new project, you might begin with a rough sketch (0.1.0) rather than a finished blueprint (1.0.0) or a specific detail of the sketch (0.0.1)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "SEMVER_BASICS"
      ]
    },
    {
      "question_text": "When a software vendor deprecates a feature as part of a minor version update (x.Y.z, where x > 0), what is the best practice according to Semantic Versioning?",
      "correct_answer": "The deprecation should be announced in the minor release, and the feature should be removed in a subsequent major release.",
      "distractors": [
        {
          "text": "The feature should be removed immediately in the same minor release.",
          "misconception": "Targets [deprecation timeline confusion]: Immediate removal breaks backward compatibility, which minor versions aim to preserve."
        },
        {
          "text": "The feature should only be removed in a patch release.",
          "misconception": "Targets [patch vs. removal confusion]: Removing features is a breaking change, not a bug fix."
        },
        {
          "text": "The feature should be marked for removal but never actually removed.",
          "misconception": "Targets [deprecation finality confusion]: Deprecation implies eventual removal, not indefinite marking."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Deprecating functionality in a minor release (x.Y.z) allows users to transition smoothly because it provides a warning period before the feature is removed in a future major release (X.0.0), thus preserving backward compatibility for at least one release cycle.",
        "distractor_analysis": "The distractors suggest immediate removal (breaking compatibility), removal via patch (incorrect type of change), or indefinite marking, all of which deviate from the standard practice of phased deprecation.",
        "analogy": "If a restaurant decides to remove a popular dish from its menu, they should announce it in advance (minor version deprecation) and give customers a chance to order it one last time before it's permanently gone (major version removal)."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "SEMVER_BASICS",
        "SOFTWARE_MAINTENANCE_PRACTICES"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 16,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Major vs. Minor Version Changes Security And Risk Management best practices",
    "latency_ms": 24709.232
  },
  "timestamp": "2026-01-01T12:51:25.562891"
}