{
  "topic_title": "Browser Security Architecture Weaknesses",
  "category": "Cybersecurity - Security Architecture And Engineering - Security Architecture Vulnerabilities - 002_System Architecture Vulnerabilities - Client System Architecture Weaknesses",
  "flashcards": [
    {
      "question_text": "Which browser security feature is primarily designed to prevent Cross-Site Scripting (XSS) attacks by controlling the sources from which content can be loaded?",
      "correct_answer": "Content Security Policy (CSP)",
      "distractors": [
        {
          "text": "HTTP Strict Transport Security (HSTS)",
          "misconception": "Targets [protocol enforcement]: Confuses protocol security (HTTPS) with content source control."
        },
        {
          "text": "X-Frame-Options (XFO)",
          "misconception": "Targets [clickjacking prevention]: Misunderstands XFO's purpose as frame embedding control, not script execution."
        },
        {
          "text": "Same-Origin Policy (SOP)",
          "misconception": "Targets [origin restriction]: Understands SOP restricts cross-origin requests but not the sources of executable content within the same origin."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CSP is crucial because it allows web developers to specify which content sources (scripts, styles, images) are legitimate, thereby preventing the browser from executing malicious scripts injected by attackers. It functions by defining a policy that the browser enforces, connecting to the broader concept of defense-in-depth.",
        "distractor_analysis": "HSTS enforces HTTPS, XFO prevents clickjacking, and SOP restricts cross-origin interactions. None of these directly control the sources of executable content within a page like CSP does.",
        "analogy": "CSP is like a strict bouncer at a club, checking IDs (sources) of everyone (content) trying to get in, ensuring only approved guests (legitimate scripts) can enter and perform actions."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "XSS_BASICS",
        "CSP_FUNDAMENTALS"
      ]
    },
    {
      "question_text": "What is the primary security risk associated with a website failing to implement the 'secure' flag on its cookies?",
      "correct_answer": "Cookies can be transmitted over unencrypted HTTP connections, exposing sensitive session data.",
      "distractors": [
        {
          "text": "The website may be subject to Cross-Site Scripting (XSS) attacks.",
          "misconception": "Targets [XSS confusion]: Associates cookie transmission issues with script injection vulnerabilities."
        },
        {
          "text": "The browser may block all JavaScript execution on the site.",
          "misconception": "Targets [JavaScript restriction confusion]: Incorrectly links cookie security to general JavaScript functionality."
        },
        {
          "text": "Search engine crawlers may de-index the website.",
          "misconception": "Targets [SEO impact confusion]: Attributes security flaws to search engine ranking rather than direct user risk."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'secure' flag ensures cookies are only sent over HTTPS because it prevents transmission over unencrypted HTTP, thus protecting sensitive data like session IDs from interception. This is vital because HTTP is vulnerable to eavesdropping, unlike encrypted HTTPS.",
        "distractor_analysis": "XSS is a different vulnerability, JavaScript blocking is unrelated, and SEO impact is a consequence, not the primary security risk of unencrypted cookie transmission.",
        "analogy": "It's like sending a postcard (HTTP) instead of a sealed, tamper-evident envelope (HTTPS) for your sensitive mail (cookies); anyone can read the postcard along the way."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "attack",
      "bloom_level": "understand",
      "prerequisites": [
        "HTTP_BASICS",
        "HTTPS_BASICS",
        "COOKIE_SECURITY"
      ]
    },
    {
      "question_text": "Which HTTP header is used to instruct the browser to only connect to a website using HTTPS, thereby preventing SSL stripping attacks?",
      "correct_answer": "HTTP Strict Transport Security (HSTS)",
      "distractors": [
        {
          "text": "Content Security Policy (CSP)",
          "misconception": "Targets [policy scope confusion]: Misunderstands CSP's role in content source control, not protocol enforcement."
        },
        {
          "text": "X-Content-Type-Options",
          "misconception": "Targets [MIME type confusion]: Relates header to content type sniffing, not transport layer security."
        },
        {
          "text": "Referrer-Policy",
          "misconception": "Targets [information disclosure]: Focuses on controlling referrer header information, not enforcing HTTPS."
        }
      ],
      "detailed_explanation": {
        "core_logic": "HSTS is essential because it forces browsers to use HTTPS for all future connections to a domain, effectively preventing man-in-the-middle attackers from downgrading the connection to HTTP. This works by the server sending the HSTS header, which the browser then caches.",
        "distractor_analysis": "CSP controls content sources, X-Content-Type-Options prevents MIME type sniffing, and Referrer-Policy manages referrer header data; none of these enforce HTTPS connections like HSTS.",
        "analogy": "HSTS is like a permanent 'HTTPS only' sign on a store's door, ensuring customers always use the secure entrance, even if they initially tried the insecure one."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "defense",
      "bloom_level": "remember",
      "prerequisites": [
        "HTTPS_BASICS",
        "MITM_ATTACKS"
      ]
    },
    {
      "question_text": "What is the primary purpose of the 'httpOnly' flag on cookies?",
      "correct_answer": "To prevent client-side scripts (like JavaScript) from accessing the cookie.",
      "distractors": [
        {
          "text": "To ensure the cookie is only transmitted over HTTPS.",
          "misconception": "Targets [secure flag confusion]: Confuses 'httpOnly' with the 'secure' flag's function."
        },
        {
          "text": "To limit the cookie's lifespan on the browser.",
          "misconception": "Targets [cookie expiration confusion]: Relates flag to cookie expiration rather than script access."
        },
        {
          "text": "To prevent the cookie from being stored in the browser cache.",
          "misconception": "Targets [caching confusion]: Misunderstands the flag's impact on browser storage mechanisms."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'httpOnly' flag is critical because it mitigates XSS attacks by preventing JavaScript from accessing sensitive cookies, such as session tokens. This works by instructing the browser's JavaScript engine to ignore such cookies, thereby protecting them from being stolen by malicious scripts.",
        "distractor_analysis": "The 'secure' flag handles HTTPS transmission, cookie lifespan is managed by expiration attributes, and caching is a separate browser function; 'httpOnly' specifically targets script access.",
        "analogy": "'httpOnly' is like putting a valuable item in a locked safe that only the server can open, making it inaccessible to anyone trying to pick the lock with a paperclip (JavaScript)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "XSS_BASICS",
        "COOKIE_SECURITY"
      ]
    },
    {
      "question_text": "Which browser security mechanism restricts how a document or script loaded from one origin can interact with a resource from another origin?",
      "correct_answer": "Same-Origin Policy (SOP)",
      "distractors": [
        {
          "text": "Cross-Origin Resource Sharing (CORS)",
          "misconception": "Targets [policy reversal]: Confuses SOP's restriction with CORS's mechanism for *allowing* cross-origin requests."
        },
        {
          "text": "Content Security Policy (CSP)",
          "misconception": "Targets [content control confusion]: Misunderstands CSP as controlling origin interactions, rather than content sources."
        },
        {
          "text": "Transport Layer Security (TLS)",
          "misconception": "Targets [protocol security confusion]: Relates security to data transmission encryption, not origin-based access control."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The Same-Origin Policy (SOP) is fundamental because it prevents scripts from one origin (domain, protocol, port) from accessing data or executing actions on another origin, thus isolating potentially malicious content. It works by enforcing strict rules at the browser level for resource access.",
        "distractor_analysis": "CORS is a mechanism to *relax* SOP, CSP controls content sources, and TLS secures data in transit; SOP is the core restriction on origin interaction.",
        "analogy": "SOP is like a strict apartment building rule: residents (scripts) from one apartment (origin) cannot freely enter or take things from other apartments without explicit permission."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "ORIGIN_CONCEPT",
        "HTTP_BASICS"
      ]
    },
    {
      "question_text": "A website fails to properly sanitize user input, allowing an attacker to inject malicious JavaScript into a page. What type of attack is this?",
      "correct_answer": "Cross-Site Scripting (XSS)",
      "distractors": [
        {
          "text": "SQL Injection",
          "misconception": "Targets [injection type confusion]: Associates input sanitization failure with database-level attacks, not client-side script execution."
        },
        {
          "text": "Cross-Site Request Forgery (CSRF)",
          "misconception": "Targets [action hijacking confusion]: Confuses XSS (script execution) with CSRF (unintended user actions)."
        },
        {
          "text": "Man-in-the-Middle (MITM) Attack",
          "misconception": "Targets [network interception confusion]: Relates the vulnerability to network traffic interception, not input validation flaws."
        }
      ],
      "detailed_explanation": {
        "core_logic": "This scenario describes Cross-Site Scripting (XSS) because the vulnerability arises from the website accepting and executing untrusted input as code, which is the hallmark of XSS. Proper input sanitization is key because it neutralizes malicious code before it can be rendered by the browser.",
        "distractor_analysis": "SQL Injection targets databases, CSRF tricks users into performing actions, and MITM intercepts network traffic; XSS specifically exploits the trust a browser places in scripts served from a website.",
        "analogy": "It's like a restaurant chef (website) not checking ingredients (user input) properly, allowing a diner to sneak in poison (malicious script) that then harms other diners (users)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "attack",
      "bloom_level": "apply",
      "prerequisites": [
        "XSS_BASICS",
        "INPUT_VALIDATION"
      ]
    },
    {
      "question_text": "What is the primary security concern when sensitive data, such as API keys or personal identifiers, is included in URL query strings?",
      "correct_answer": "The data can be easily exposed through browser history, server logs, and the Referer header.",
      "distractors": [
        {
          "text": "It increases the likelihood of Cross-Site Scripting (XSS) attacks.",
          "misconception": "Targets [XSS confusion]: Associates query string exposure with script injection, which is a different vulnerability."
        },
        {
          "text": "It can lead to denial-of-service (DoS) conditions.",
          "misconception": "Targets [availability confusion]: Links data exposure to service disruption, which is not the direct consequence."
        },
        {
          "text": "It violates the Same-Origin Policy (SOP).",
          "misconception": "Targets [SOP confusion]: Misunderstands SOP as governing data in URLs, rather than origin-based resource access."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Sensitive data in URLs is a risk because query strings are often logged, cached, and transmitted via the Referer header, making them easily accessible to attackers. Therefore, using POST requests for sensitive data is preferred because it sends data in the request body, which is not typically logged or exposed.",
        "distractor_analysis": "XSS exploits script execution, DoS aims to disrupt availability, and SOP restricts cross-origin access; query string exposure is primarily an information disclosure vulnerability.",
        "analogy": "Putting sensitive information in a URL query string is like writing a secret code on the outside of an envelope – it's visible to anyone who handles the mail (browser history, logs, etc.)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "attack",
      "bloom_level": "understand",
      "prerequisites": [
        "HTTP_BASICS",
        "INFORMATION_DISCLOSURE"
      ]
    },
    {
      "question_text": "Which browser security feature helps mitigate clickjacking attacks by controlling whether a page can be embedded within an iframe on another site?",
      "correct_answer": "X-Frame-Options (XFO)",
      "distractors": [
        {
          "text": "Content Security Policy (CSP)",
          "misconception": "Targets [policy scope confusion]: While CSP has frame-related directives, XFO is specifically designed for this purpose."
        },
        {
          "text": "Subresource Integrity (SRI)",
          "misconception": "Targets [resource integrity confusion]: Relates to verifying the integrity of loaded resources, not frame embedding."
        },
        {
          "text": "HTTP Strict Transport Security (HSTS)",
          "misconception": "Targets [protocol security confusion]: Focuses on enforcing HTTPS, not controlling frame embedding."
        }
      ],
      "detailed_explanation": {
        "core_logic": "X-Frame-Options (XFO) is vital because it prevents clickjacking by instructing the browser not to render the page within a frame on a different origin. This works by the server sending the XFO header with directives like DENY or SAMEORIGIN, thereby protecting users from being tricked into interacting with malicious overlays.",
        "distractor_analysis": "CSP has frame-related directives but XFO is the dedicated header for this. SRI ensures resource integrity, and HSTS enforces HTTPS; neither directly prevents clickjacking via frame embedding.",
        "analogy": "X-Frame-Options is like a 'No Trespassing' sign on a property, specifically telling other buildings (websites) they cannot put your house (webpage) inside their structure (iframe)."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "defense",
      "bloom_level": "remember",
      "prerequisites": [
        "CLICKJACKING_BASICS",
        "HTTP_HEADERS"
      ]
    },
    {
      "question_text": "What is the primary risk of 'mixed content' on a webpage served over HTTPS?",
      "correct_answer": "Unencrypted resources loaded over HTTP can be intercepted and modified by attackers, undermining HTTPS security.",
      "distractors": [
        {
          "text": "It causes the browser to display a security warning to the user.",
          "misconception": "Targets [warning vs. risk confusion]: Focuses on the symptom (warning) rather than the underlying security compromise."
        },
        {
          "text": "It prevents the website from being indexed by search engines.",
          "misconception": "Targets [SEO impact confusion]: Attributes a security flaw to search engine visibility issues."
        },
        {
          "text": "It violates the Same-Origin Policy (SOP).",
          "misconception": "Targets [SOP confusion]: Misunderstands SOP as governing mixed content, rather than origin-based access."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Mixed content is dangerous because while the main page is HTTPS, insecure HTTP resources (like scripts or images) can be intercepted and altered by attackers, potentially injecting malicious code or stealing data. This undermines the entire security of the HTTPS connection because the browser trusts all loaded resources.",
        "distractor_analysis": "While mixed content often triggers warnings, the core risk is the security compromise. SEO is not directly affected, and SOP governs origin interactions, not the protocol of loaded resources.",
        "analogy": "It's like having a secure, armored truck (HTTPS page) carrying valuable goods, but some of the goods were loaded from an unsecured roadside stall (HTTP resource), making them vulnerable to theft during transit."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "attack",
      "bloom_level": "understand",
      "prerequisites": [
        "HTTPS_BASICS",
        "MITM_ATTACKS"
      ]
    },
    {
      "question_text": "Which browser security feature allows developers to define a policy for which origins are allowed to embed their site using frames, thereby helping to prevent clickjacking?",
      "correct_answer": "Content Security Policy (CSP) 'frame-ancestors' directive",
      "distractors": [
        {
          "text": "X-Frame-Options (XFO)",
          "misconception": "Targets [header specificity confusion]: XFO is a predecessor and less flexible than CSP's frame-ancestors."
        },
        {
          "text": "Referrer-Policy",
          "misconception": "Targets [information disclosure confusion]: Controls the Referer header, not frame embedding."
        },
        {
          "text": "Permissions Policy",
          "misconception": "Targets [feature control confusion]: Controls browser feature access (camera, mic), not frame embedding."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The CSP 'frame-ancestors' directive is powerful because it provides granular control over which external origins can embed the page, offering a more flexible alternative to X-Frame-Options for preventing clickjacking. It works by specifying a whitelist of allowed parent origins.",
        "distractor_analysis": "XFO is a related but older and less flexible header. Referrer-Policy controls referrer data, and Permissions Policy manages browser feature access; 'frame-ancestors' is specific to frame embedding.",
        "analogy": "The 'frame-ancestors' directive is like a security guard at a building entrance, explicitly listing which other buildings (origins) are allowed to place your building (webpage) within their own structure (frame)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "analyze",
      "prerequisites": [
        "CSP_FUNDAMENTALS",
        "CLICKJACKING_BASICS"
      ]
    },
    {
      "question_text": "What is the main security benefit of using the 'SameSite' cookie attribute?",
      "correct_answer": "It helps mitigate Cross-Site Request Forgery (CSRF) attacks by controlling when cookies are sent with cross-site requests.",
      "distractors": [
        {
          "text": "It prevents cookies from being accessed by JavaScript.",
          "misconception": "Targets [httpOnly confusion]: Confuses 'SameSite' with the 'httpOnly' flag's function."
        },
        {
          "text": "It ensures cookies are only sent over HTTPS.",
          "misconception": "Targets [secure flag confusion]: Confuses 'SameSite' with the 'secure' flag's function."
        },
        {
          "text": "It reduces the risk of session fixation attacks.",
          "misconception": "Targets [session fixation confusion]: While related to session security, 'SameSite' primarily targets CSRF."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'SameSite' attribute is crucial because it prevents browsers from sending cookies with cross-site requests unless explicitly allowed (e.g., 'SameSite=None' with 'Secure'), thereby mitigating CSRF attacks. This works by the browser checking the origin of the request against the cookie's SameSite attribute.",
        "distractor_analysis": "'httpOnly' prevents JS access, 'secure' enforces HTTPS, and while related to session security, 'SameSite' directly targets CSRF by controlling cross-site cookie transmission.",
        "analogy": "'SameSite' is like a bouncer at a club (website) who checks if a guest (cookie) is arriving from the same street (origin) or a different one before letting them in (sending the cookie)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "CSRF_BASICS",
        "COOKIE_SECURITY"
      ]
    },
    {
      "question_text": "Which of the following best describes the security risk of prototype pollution in JavaScript environments?",
      "correct_answer": "Attackers can modify the properties of Object.prototype, potentially leading to unexpected behavior, logic errors, or further attacks like XSS.",
      "distractors": [
        {
          "text": "It allows attackers to bypass the Same-Origin Policy (SOP).",
          "misconception": "Targets [SOP confusion]: Associates prototype pollution with origin restrictions, which is incorrect."
        },
        {
          "text": "It causes the browser to crash due to excessive memory usage.",
          "misconception": "Targets [DoS confusion]: Attributes the vulnerability to denial-of-service rather than code execution or logic manipulation."
        },
        {
          "text": "It enables attackers to intercept and decrypt TLS/SSL traffic.",
          "misconception": "Targets [encryption confusion]: Links prototype pollution to network traffic interception, which is unrelated."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Prototype pollution is dangerous because modifying Object.prototype affects all objects inheriting from it, potentially allowing attackers to inject malicious code or alter application logic. This works by exploiting how JavaScript handles prototype chains, enabling unexpected property additions or modifications.",
        "distractor_analysis": "Prototype pollution does not bypass SOP, cause crashes directly, or affect TLS/SSL encryption; its primary impact is on application logic and potential for code execution.",
        "analogy": "It's like altering the fundamental blueprint (prototype) for all building materials (objects) in a city; any new structure built using those materials could have hidden flaws or be designed to collapse."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "JAVASCRIPT_PROTOTYPES",
        "XSS_BASICS"
      ]
    },
    {
      "question_text": "What is the primary function of the 'X-Content-Type-Options: nosniff' HTTP header?",
      "correct_answer": "To prevent the browser from performing MIME type sniffing, which could lead to executing malicious scripts disguised as benign file types.",
      "distractors": [
        {
          "text": "To enforce the use of HTTPS for all connections.",
          "misconception": "Targets [protocol enforcement confusion]: Confuses content type handling with transport layer security."
        },
        {
          "text": "To restrict the origins from which scripts can be loaded.",
          "misconception": "Targets [CSP confusion]: Relates the header to content source control, not MIME type interpretation."
        },
        {
          "text": "To prevent clickjacking attacks by disallowing framing.",
          "misconception": "Targets [clickjacking confusion]: Associates the header with frame embedding controls, which is incorrect."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'X-Content-Type-Options: nosniff' header is important because it stops the browser from guessing the content type of a resource if it differs from the declared 'Content-Type' header, thus preventing attacks where a malicious script might be disguised as an image or document. It works by instructing the browser to strictly adhere to the declared Content-Type.",
        "distractor_analysis": "This header is about MIME type interpretation, not HTTPS enforcement (HSTS), script source restriction (CSP), or frame embedding prevention (XFO/CSP frame-ancestors).",
        "analogy": "It's like a strict librarian who only allows books labeled 'Fiction' to be shelved in the fiction section, preventing someone from sneaking in a 'How-To' manual disguised as a novel."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "MIME_TYPES",
        "HTTP_HEADERS"
      ]
    },
    {
      "question_text": "In the context of web security, what does 'DNS rebinding' exploit?",
      "correct_answer": "It exploits the browser's trust in DNS resolution to bypass the Same-Origin Policy (SOP) by making a malicious domain resolve to an internal IP address.",
      "distractors": [
        {
          "text": "It exploits vulnerabilities in the TLS/SSL certificate validation process.",
          "misconception": "Targets [TLS/SSL confusion]: Associates DNS rebinding with certificate trust issues, not origin bypass."
        },
        {
          "text": "It exploits weak password policies to gain unauthorized access.",
          "misconception": "Targets [authentication confusion]: Relates the attack to credential compromise, not SOP bypass."
        },
        {
          "text": "It exploits insecure handling of user input to execute arbitrary code.",
          "misconception": "Targets [input sanitization confusion]: Confuses DNS rebinding with injection attacks like XSS or SQLi."
        }
      ],
      "detailed_explanation": {
        "core_logic": "DNS rebinding is a threat because it tricks a browser into thinking a malicious external domain is actually an internal resource (like localhost), thereby bypassing the Same-Origin Policy and allowing the malicious site to interact with internal services. This works by rapidly changing the DNS resolution of a domain to point to different IP addresses.",
        "distractor_analysis": "DNS rebinding is not about TLS certificates, weak passwords, or input sanitization; its core mechanism is manipulating DNS to trick the browser's origin enforcement.",
        "analogy": "It's like a spy changing their disguise rapidly – first appearing as a trusted local resident (localhost), then quickly changing to look like a foreign agent (malicious domain), tricking security (browser SOP) into letting them access restricted areas."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "DNS_BASICS",
        "SOP_BASICS",
        "NETWORK_SECURITY"
      ]
    },
    {
      "question_text": "Which browser security feature is designed to protect against speculative side-channel attacks by controlling how resources are loaded across different origins?",
      "correct_answer": "Cross-Origin Resource Policy (CORP)",
      "distractors": [
        {
          "text": "Content Security Policy (CSP)",
          "misconception": "Targets [policy scope confusion]: CSP controls content sources, while CORP controls resource loading context."
        },
        {
          "text": "HTTP Strict Transport Security (HSTS)",
          "misconception": "Targets [protocol security confusion]: HSTS enforces HTTPS, not cross-origin resource loading policies."
        },
        {
          "text": "Same-Origin Policy (SOP)",
          "misconception": "Targets [origin restriction confusion]: SOP restricts cross-origin *requests*, CORP restricts cross-origin *loading* of resources."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CORP is essential because it prevents browsers from sending sensitive data (like cookies) to cross-origin requests when the resource is not intended to be shared, thus mitigating side-channel attacks. It works by allowing developers to specify whether a resource can be loaded by same-origin requests only, or by any origin.",
        "distractor_analysis": "CSP controls content sources, HSTS enforces HTTPS, and SOP restricts cross-origin requests; CORP specifically addresses the security implications of loading resources across origins, particularly for side-channel attack prevention.",
        "analogy": "CORP is like a secure vault for valuable documents (resources); it ensures that only authorized personnel (same-origin requests) can access them, preventing unauthorized parties (cross-origin requests) from potentially inferring sensitive information."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "SIDE_CHANNEL_ATTACKS",
        "HTTP_HEADERS"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Browser Security Architecture Weaknesses Security Architecture And Engineering best practices",
    "latency_ms": 22494.623
  },
  "timestamp": "2026-01-01T15:31:33.110017"
}