{
  "topic_title": "Type Enforcement in SELinux",
  "category": "Cybersecurity - Security Architecture And Engineering - Security Models",
  "flashcards": [
    {
      "question_text": "In SELinux, what is the primary function of 'Type Enforcement' (TE)?",
      "correct_answer": "To define access control rules between processes (domains) and system resources (types) based on their security labels.",
      "distractors": [
        {
          "text": "To manage user authentication and authorization across different systems.",
          "misconception": "Targets [domain confusion]: Confuses Type Enforcement with authentication/authorization mechanisms like Kerberos or RBAC."
        },
        {
          "text": "To encrypt data at rest and in transit using cryptographic algorithms.",
          "misconception": "Targets [cryptography confusion]: Mixes access control concepts with data encryption principles."
        },
        {
          "text": "To enforce network segmentation policies between different subnets.",
          "misconception": "Targets [network security confusion]: Equates SELinux TE with network-level access control like firewalls or VLANs."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Type Enforcement (TE) is a core component of SELinux that functions by assigning security labels (types) to processes (domains) and objects (files, ports, etc.). Access is granted only if an explicit policy rule allows the interaction between the source type and the target type, enforcing the principle of least privilege.",
        "distractor_analysis": "The distractors target common confusions: authentication systems, encryption, and network segmentation, none of which are the primary function of SELinux Type Enforcement.",
        "analogy": "Think of Type Enforcement like a strict club bouncer (SELinux policy) who checks the ID badge (type label) of everyone trying to enter different areas (domains) of a building (system resources) and only allows entry if the badge matches the area's access list."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SELINUX_BASICS",
        "SELINUX_CONTEXTS"
      ]
    },
    {
      "question_text": "What is the significance of the '_t' suffix in SELinux type names, such as 'httpd_t' or 'user_home_t'?",
      "correct_answer": "It conventionally denotes that the label represents a security type, commonly used for processes (domains) or file objects.",
      "distractors": [
        {
          "text": "It indicates that the type is automatically generated and cannot be modified.",
          "misconception": "Targets [label mutability confusion]: Assumes types are immutable, ignoring policy customization."
        },
        {
          "text": "It signifies a type that is only applicable to network-related services.",
          "misconception": "Targets [scope limitation]: Incorrectly restricts the application of types to only network services."
        },
        {
          "text": "It denotes a type that requires a specific role to be active for access.",
          "misconception": "Targets [type/role confusion]: Mixes the function of types with roles in SELinux."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The '_t' suffix is a convention in SELinux policy language to denote a security type. These types are fundamental to Type Enforcement, defining the security context for both processes (domains) and objects (files, sockets, etc.), thereby controlling interactions based on policy rules.",
        "distractor_analysis": "Distractors incorrectly suggest immutability, network-only scope, or a direct link to roles, rather than the conventional naming for security types.",
        "analogy": "The '_t' suffix is like a label on a folder or a person's badge – it tells you what category it belongs to (e.g., 'Web Server' or 'User Home Directory') so the security system knows how to handle it."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "SELINUX_TYPES"
      ]
    },
    {
      "question_text": "Consider a scenario where a web server process (httpd_t) attempts to access a file labeled as samba_share_t. If the SELinux policy has no explicit 'allow' rule for httpd_t to access samba_share_t, what will be the outcome?",
      "correct_answer": "SELinux will deny the access, and the operation will fail, even if standard Linux DAC permissions would allow it.",
      "distractors": [
        {
          "text": "SELinux will allow the access because standard Linux DAC permissions permit it.",
          "misconception": "Targets [DAC precedence confusion]: Incorrectly assumes DAC permissions override SELinux denials."
        },
        {
          "text": "SELinux will log a warning but allow the access to proceed.",
          "misconception": "Targets [permissive mode confusion]: Describes behavior of permissive mode, not enforcing mode."
        },
        {
          "text": "SELinux will automatically create a new rule to allow the access.",
          "misconception": "Targets [policy modification confusion]: Assumes SELinux dynamically modifies policy to permit access."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SELinux operates on the principle of 'default deny'. If no explicit 'allow' rule exists in the SELinux policy for a specific interaction (like httpd_t accessing samba_share_t), access is denied. This occurs after DAC checks, meaning SELinux acts as an additional, stricter layer of security.",
        "distractor_analysis": "Distractors incorrectly suggest DAC precedence, permissive mode behavior, or automatic policy modification, all of which contradict SELinux's default-deny and explicit-allow mechanism.",
        "analogy": "It's like a VIP club (SELinux) where even if you have a general entry ticket (DAC permission), you need a specific invitation (SELinux allow rule) to enter certain restricted areas (types)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "SELINUX_POLICY_RULES",
        "SELINUX_DAC_INTERACTION"
      ]
    },
    {
      "question_text": "What is the role of the 'entrypoint' permission in SELinux Type Enforcement?",
      "correct_answer": "It controls which executable types (applications) are allowed to transition a process into a specific target domain.",
      "distractors": [
        {
          "text": "It defines the network ports a process is allowed to bind to.",
          "misconception": "Targets [port access confusion]: Mixes process execution control with network port binding."
        },
        {
          "text": "It dictates the file types a process can read or write.",
          "misconception": "Targets [file access confusion]: Confuses execution permissions with file I/O permissions."
        },
        {
          "text": "It determines the user identity a process can assume.",
          "misconception": "Targets [user identity confusion]: Mixes execution control with user context management."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'entrypoint' permission is a crucial part of SELinux Type Enforcement that governs domain transitions. It specifies which executable types are permitted to initiate a transition into a target domain, ensuring that only authorized applications can launch processes in specific security contexts.",
        "distractor_analysis": "Distractors incorrectly associate 'entrypoint' with network ports, file I/O, or user identity, rather than its specific role in controlling executable transitions into domains.",
        "analogy": "Think of 'entrypoint' like a specific gatekeeper for a restricted area (domain). Only certain authorized personnel (executable types) are allowed to use that specific gate (entrypoint) to enter the area."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SELINUX_DOMAINS",
        "SELINUX_TYPES",
        "SELINUX_TRANSITIONS"
      ]
    },
    {
      "question_text": "When SELinux is running in 'enforcing' mode, what is the default behavior for access control decisions?",
      "correct_answer": "Access is denied unless an explicit 'allow' rule exists in the SELinux policy.",
      "distractors": [
        {
          "text": "Access is allowed unless an explicit 'deny' rule exists in the SELinux policy.",
          "misconception": "Targets [default behavior reversal]: Reverses the default-deny principle of SELinux."
        },
        {
          "text": "Access is allowed by default, but logged as a warning.",
          "misconception": "Targets [permissive mode confusion]: Describes the behavior of permissive mode, not enforcing mode."
        },
        {
          "text": "Access is determined solely by standard Linux DAC permissions.",
          "misconception": "Targets [SELinux bypass confusion]: Ignores SELinux's role and assumes DAC is the only control."
        }
      ],
      "detailed_explanation": {
        "core_logic": "In enforcing mode, SELinux operates under a 'default deny' policy. This means that any access attempt is blocked unless there is a specific 'allow' rule in the SELinux policy that explicitly permits the action. This principle ensures that only necessary permissions are granted, adhering to the principle of least privilege.",
        "distractor_analysis": "Distractors incorrectly suggest a default-allow policy, permissive mode behavior, or a complete bypass of SELinux in favor of DAC, all of which are fundamentally different from enforcing mode's operation.",
        "analogy": "Enforcing mode is like a strict security checkpoint where you need a specific pass (allow rule) to get through; without it, you're stopped, even if you have general access to the building (DAC permission)."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SELINUX_MODES",
        "SELINUX_POLICY_RULES"
      ]
    },
    {
      "question_text": "Which SELinux command is used to temporarily change the security context (type) of a file or directory?",
      "correct_answer": "chcon",
      "distractors": [
        {
          "text": "restorecon",
          "misconception": "Targets [temporary vs. persistent confusion]: Confuses temporary context changes with restoring default contexts."
        },
        {
          "text": "semanage fcontext",
          "misconception": "Targets [temporary vs. persistent confusion]: Confuses temporary context changes with persistent policy definitions."
        },
        {
          "text": "matchpathcon",
          "misconception": "Targets [query vs. modification confusion]: Mixes tools for checking contexts with tools for changing them."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>chcon</code> command is used for temporary, non-persistent changes to a file's SELinux context. These changes are useful for testing but are overwritten by file system relabels or <code>restorecon</code>. Persistent changes are managed using <code>semanage fcontext</code>.",
        "distractor_analysis": "Distractors represent commands for restoring default contexts (<code>restorecon</code>), defining persistent context rules (<code>semanage fcontext</code>), and querying contexts (<code>matchpathcon</code>), none of which are for temporary, immediate context modification.",
        "analogy": "<code>chcon</code> is like temporarily putting a different colored sticker on a box to see if it fits in a new shelf, but the original label is still there and will reappear if you clean the box."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "SELINUX_FILE_LABELING",
        "SELINUX_CHCON"
      ]
    },
    {
      "question_text": "What is the purpose of the 'Access Vector Cache' (AVC) in SELinux?",
      "correct_answer": "To cache SELinux access control decisions, improving performance by reducing the need to re-evaluate policy rules for repeated access attempts.",
      "distractors": [
        {
          "text": "To log all SELinux policy violations and denials.",
          "misconception": "Targets [logging confusion]: Confuses caching with the logging function of auditd."
        },
        {
          "text": "To dynamically generate SELinux policy rules based on observed behavior.",
          "misconception": "Targets [policy generation confusion]: Assumes SELinux dynamically creates rules, rather than enforcing pre-defined ones."
        },
        {
          "text": "To store and manage the SELinux policy files on the system.",
          "misconception": "Targets [storage confusion]: Mixes caching of decisions with the storage of policy definitions."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The Access Vector Cache (AVC) is a kernel-level cache that stores the results of SELinux policy checks. When a process attempts to access a resource, SELinux first checks the AVC. If a decision for that specific access is found in the cache, it's returned immediately, significantly speeding up operations by avoiding repeated policy evaluations.",
        "distractor_analysis": "Distractors incorrectly attribute logging, dynamic rule generation, or policy file storage to the AVC, which is solely focused on caching access decisions for performance.",
        "analogy": "The AVC is like a shortcut list for a librarian: instead of checking the entire catalog every time someone asks for a popular book, the librarian remembers who asked for it recently and where it is, speeding up retrieval."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SELINUX_ARCHITECTURE",
        "SELINUX_PERFORMANCE"
      ]
    },
    {
      "question_text": "Which SELinux command is used to define persistent file context rules that survive file system relabels?",
      "correct_answer": "semanage fcontext",
      "distractors": [
        {
          "text": "chcon",
          "misconception": "Targets [temporary vs. persistent confusion]: `chcon` makes temporary changes that are lost on relabel."
        },
        {
          "text": "restorecon",
          "misconception": "Targets [definition vs. application confusion]: `restorecon` applies existing rules, but doesn't define them."
        },
        {
          "text": "matchpathcon",
          "misconception": "Targets [query vs. definition confusion]: `matchpathcon` queries existing contexts, it doesn't define new persistent rules."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>semanage fcontext</code> command is used to define persistent SELinux file context rules. These rules are stored in local policy files and are applied during file system relabels or when <code>restorecon</code> is run, ensuring that files and directories maintain their intended security labels across system changes.",
        "distractor_analysis": "Distractors represent commands for temporary changes (<code>chcon</code>), applying existing rules (<code>restorecon</code>), and querying contexts (<code>matchpathcon</code>), none of which are used for defining persistent file context rules.",
        "analogy": "<code>semanage fcontext</code> is like writing a permanent instruction manual for labeling files in specific locations, ensuring that whenever the system is reorganized (relabelled), these instructions are followed."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "SELINUX_FILE_LABELING",
        "SELINUX_SEMANAGE"
      ]
    },
    {
      "question_text": "What is the primary benefit of SELinux Type Enforcement (TE) in mitigating privilege escalation attacks?",
      "correct_answer": "By confining processes to specific domains and strictly controlling inter-domain communication, TE limits the damage an attacker can do if a process is compromised.",
      "distractors": [
        {
          "text": "By encrypting all data accessed by processes, preventing unauthorized reading.",
          "misconception": "Targets [encryption confusion]: Mixes access control with data encryption."
        },
        {
          "text": "By automatically revoking all user privileges upon detecting suspicious activity.",
          "misconception": "Targets [automatic revocation confusion]: Assumes SELinux automatically revokes privileges based on detection, rather than pre-defined policy."
        },
        {
          "text": "By isolating network traffic and preventing any external communication.",
          "misconception": "Targets [network isolation confusion]: Overstates network isolation as the primary benefit, ignoring process/file confinement."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Type Enforcement (TE) is fundamental to SELinux's defense against privilege escalation. It confines processes to specific domains (types) and enforces granular rules on how these domains can interact. If a process is compromised, its limited domain and strict inter-domain communication rules prevent the attacker from accessing or compromising other parts of the system.",
        "distractor_analysis": "Distractors incorrectly attribute encryption, automatic privilege revocation, or complete network isolation as the primary benefit, rather than the targeted confinement and controlled interaction enforced by TE.",
        "analogy": "TE is like assigning each employee a specific job role and access card for only certain rooms in a building. If an employee's card is stolen, the thief can only access the rooms the card allows, not the entire building."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SELINUX_TE",
        "SELINUX_PRIVILEGE_ESCALATION",
        "SELINUX_COMPROMISE_MITIGATION"
      ]
    },
    {
      "question_text": "When SELinux is running in 'permissive' mode, what is the system's behavior regarding access denials?",
      "correct_answer": "Access denials are logged, but the system does not enforce them, allowing operations to proceed.",
      "distractors": [
        {
          "text": "Access denials are enforced, and the system logs them for later review.",
          "misconception": "Targets [enforcing mode confusion]: Describes enforcing mode, not permissive mode."
        },
        {
          "text": "Access denials are ignored, and no logs are generated.",
          "misconception": "Targets [logging omission confusion]: Assumes no logging occurs in permissive mode."
        },
        {
          "text": "Access is denied by default, but allowed if a specific rule permits it.",
          "misconception": "Targets [default behavior reversal]: Reverses the default-deny principle and permissive mode's logging behavior."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Permissive mode is a diagnostic state where SELinux logs access denials but does not enforce them. This allows administrators to identify potential policy issues without disrupting system operations, making it invaluable for policy development and troubleshooting.",
        "distractor_analysis": "Distractors incorrectly describe enforcing mode, complete denial of logging, or a default-deny policy, none of which accurately represent permissive mode's function.",
        "analogy": "Permissive mode is like a security guard who watches everyone but only writes down suspicious activity, without stopping anyone. They gather information but don't interfere with operations."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SELINUX_MODES"
      ]
    },
    {
      "question_text": "Which SELinux command is used to view the default security context that SELinux policy associates with a given file path?",
      "correct_answer": "matchpathcon",
      "distractors": [
        {
          "text": "ls -Z",
          "misconception": "Targets [query vs. current context confusion]: `ls -Z` shows the *current* context, not the *default* policy context."
        },
        {
          "text": "semanage fcontext -l",
          "misconception": "Targets [definition vs. query confusion]: `semanage fcontext -l` lists *defined* persistent rules, not the default context for arbitrary paths."
        },
        {
          "text": "restorecon",
          "misconception": "Targets [application vs. query confusion]: `restorecon` *applies* default contexts, it doesn't query them."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>matchpathcon</code> utility queries the SELinux policy to determine the default security context that should be applied to a given file path. This is crucial for verifying if files are correctly labeled according to policy, especially after operations that might affect labeling.",
        "distractor_analysis": "Distractors represent commands for viewing current contexts (<code>ls -Z</code>), listing defined persistent rules (<code>semanage fcontext -l</code>), and applying default contexts (<code>restorecon</code>), none of which directly query the default policy context for an arbitrary path.",
        "analogy": "<code>matchpathcon</code> is like asking a librarian for the standard shelf location for a specific book title, rather than asking where a particular copy of the book is currently shelved (<code>ls -Z</code>) or telling them where to put it (<code>restorecon</code>)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "SELINUX_FILE_LABELING",
        "SELINUX_MATCHPATHCON"
      ]
    },
    {
      "question_text": "What is the purpose of the 'neverallow' rules in SELinux policy?",
      "correct_answer": "To explicitly prevent certain interactions from ever being allowed, serving as a safety net during policy development and ensuring critical denials are maintained.",
      "distractors": [
        {
          "text": "To temporarily disable specific SELinux rules for debugging purposes.",
          "misconception": "Targets [temporary disablement confusion]: Confuses 'neverallow' with disabling rules for debugging (like `dontaudit` or permissive mode)."
        },
        {
          "text": "To automatically allow access for processes that frequently trigger denials.",
          "misconception": "Targets [automatic allowance confusion]: Assumes 'neverallow' rules grant access, which is the opposite of their function."
        },
        {
          "text": "To define the default security context for newly created files.",
          "misconception": "Targets [default context confusion]: Mixes explicit prohibitions with default labeling mechanisms."
        }
      ],
      "detailed_explanation": {
        "core_logic": "'Neverallow' rules are a powerful feature in SELinux policy that explicitly prohibit certain actions or interactions between security contexts. They are checked during policy compilation and ensure that specific, potentially dangerous, combinations are never permitted, acting as a critical safeguard against misconfigurations or unintended access.",
        "distractor_analysis": "Distractors incorrectly describe temporary disabling, automatic allowance, or default labeling, all of which are distinct from the absolute prohibition enforced by 'neverallow' rules.",
        "analogy": "'Neverallow' rules are like a 'Do Not Enter' sign on a door that is permanently enforced by the building's security system – no matter who you are or what your general access is, you are absolutely forbidden from entering that specific area."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "definition",
      "bloom_level": "analyze",
      "prerequisites": [
        "SELINUX_POLICY_RULES",
        "SELINUX_POLICY_COMPILATION"
      ]
    },
    {
      "question_text": "When copying a file from one directory to another using the <code>cp</code> command without any special options, what SELinux context is typically applied to the newly created file in the destination directory?",
      "correct_answer": "The context is determined by the default labeling rules for the destination directory, not inherited from the source file's context.",
      "distractors": [
        {
          "text": "The context is inherited directly from the source file.",
          "misconception": "Targets [inheritance confusion]: Assumes context is always inherited, ignoring destination rules."
        },
        {
          "text": "The context is temporarily set to 'unconfined_t' for all copied files.",
          "misconception": "Targets [universal context confusion]: Assumes a single, unconfined context for all copied files."
        },
        {
          "text": "The context is determined by the user performing the copy operation.",
          "misconception": "Targets [user context confusion]: Attributes context determination solely to the user, ignoring policy and destination rules."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When a file is copied using <code>cp</code> without preservation options, the destination file inherits the SELinux context from its parent directory based on the system's default labeling policy. This ensures that files are correctly labeled for their intended location, rather than retaining potentially inappropriate labels from their source.",
        "distractor_analysis": "Distractors incorrectly suggest direct inheritance from the source, a universal 'unconfined_t' context, or sole determination by the user, all of which overlook the policy-driven default labeling of the destination.",
        "analogy": "When you move a book to a new shelf in a library, it gets labeled according to the rules of that new shelf (destination directory's context), not by the label it had on its old shelf (source file's context)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SELINUX_FILE_LABELING",
        "SELINUX_CP_BEHAVIOR"
      ]
    },
    {
      "question_text": "What is the purpose of the <code>audit2allow</code> utility in SELinux troubleshooting?",
      "correct_answer": "To analyze SELinux denial messages and generate custom 'allow' rules for a local policy module, enabling specific access that was previously denied.",
      "distractors": [
        {
          "text": "To automatically enforce all denied SELinux operations.",
          "misconception": "Targets [automatic enforcement confusion]: Assumes `audit2allow` enforces rules, rather than generating them."
        },
        {
          "text": "To disable SELinux temporarily for debugging purposes.",
          "misconception": "Targets [temporary disablement confusion]: Confuses rule generation with disabling SELinux."
        },
        {
          "text": "To query the SELinux policy for existing 'allow' rules.",
          "misconception": "Targets [query vs. generation confusion]: Mixes querying existing rules with generating new ones."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>audit2allow</code> utility is a powerful tool for SELinux troubleshooting. It parses audit logs for denial messages and translates them into SELinux 'allow' rules. These rules can then be compiled into a custom policy module (<code>.pp</code> file) and loaded, effectively permitting the previously denied access, but only after careful review.",
        "distractor_analysis": "Distractors incorrectly suggest automatic enforcement, temporary disabling of SELinux, or simply querying existing rules, none of which reflect <code>audit2allow</code>'s function of generating new policy rules from denials.",
        "analogy": "<code>audit2allow</code> is like a translator that listens to a security guard's report of who was denied entry (denial messages) and writes a specific permission slip (allow rule) for that person, so they can get in next time."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "SELINUX_TROUBLESHOOTING",
        "SELINUX_AUDIT2ALLOW",
        "SELINUX_POLICY_MODULES"
      ]
    },
    {
      "question_text": "Which of the following BEST describes the relationship between SELinux Type Enforcement (TE) and Discretionary Access Control (DAC)?",
      "correct_answer": "SELinux TE rules are checked *after* DAC rules; if DAC denies access, SELinux rules are not evaluated for that operation.",
      "distractors": [
        {
          "text": "SELinux TE rules are checked *before* DAC rules, providing a primary layer of access control.",
          "misconception": "Targets [order of operations confusion]: Incorrectly reverses the order of DAC and SELinux checks."
        },
        {
          "text": "SELinux TE rules completely replace DAC, making standard Linux permissions irrelevant.",
          "misconception": "Targets [replacement confusion]: Assumes SELinux supersedes DAC entirely, rather than complementing it."
        },
        {
          "text": "SELinux TE and DAC operate independently and do not interact.",
          "misconception": "Targets [independence confusion]: Ignores the sequential interaction between DAC and SELinux."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SELinux Type Enforcement complements, rather than replaces, standard Linux Discretionary Access Control (DAC). DAC checks are performed first. If DAC denies access, the SELinux check is bypassed, and no SELinux denial is logged. Only if DAC permits access does SELinux evaluate its own policy rules.",
        "distractor_analysis": "Distractors incorrectly reverse the order of operations, suggest SELinux replaces DAC, or claim they operate independently, all of which misrepresent their sequential and complementary relationship.",
        "analogy": "DAC is like needing a key to open your front door (basic access). SELinux TE is like needing a specific security clearance badge to enter certain rooms *after* you've opened the front door. If you don't have the key to the front door, the badge check never happens."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "SELINUX_DAC_INTERACTION",
        "SELINUX_TE",
        "SELINUX_POLICY_RULES"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Type Enforcement in SELinux Security Architecture And Engineering best practices",
    "latency_ms": 35721.33500000001
  },
  "timestamp": "2026-01-01T15:37:51.505223"
}