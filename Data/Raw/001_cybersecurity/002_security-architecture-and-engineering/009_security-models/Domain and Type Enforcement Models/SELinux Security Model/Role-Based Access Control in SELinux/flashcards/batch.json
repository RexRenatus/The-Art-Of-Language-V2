{
  "topic_title": "Role-Based Access Control in SELinux",
  "category": "Cybersecurity - Security Architecture And Engineering - Security Models",
  "flashcards": [
    {
      "question_text": "In SELinux, what is the primary function of a 'role' within the Role-Based Access Control (RBAC) model?",
      "correct_answer": "To act as an intermediary between SELinux users and SELinux types (domains/objects), controlling which domains can be entered.",
      "distractors": [
        {
          "text": "To define the specific file permissions for a user.",
          "misconception": "Targets [DAC confusion]: Confuses SELinux roles with traditional Discretionary Access Control (DAC) permissions."
        },
        {
          "text": "To assign a unique security level for data classification.",
          "misconception": "Targets [MLS confusion]: Mixes the concept of roles with Multi-Level Security (MLS) levels."
        },
        {
          "text": "To specify the executable type for a process.",
          "misconception": "Targets [type confusion]: Equates roles with SELinux types, which define process domains and file types."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SELinux RBAC uses roles as intermediaries; SELinux users are authorized for roles, and roles are authorized for domains (types). Therefore, roles control which domains (processes or objects) can be accessed, enhancing security by limiting privilege escalation.",
        "distractor_analysis": "The first distractor confuses roles with DAC permissions. The second mixes roles with MLS levels. The third incorrectly equates roles with SELinux types.",
        "analogy": "Think of a role like a job title within a company. A 'Manager' role (SELinux role) might grant access to 'Sales' or 'HR' departments (SELinux types/domains), but not directly to 'Engineering' unless explicitly allowed."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SELINUX_RBAC_BASICS",
        "SELINUX_CONTEXT_FIELDS"
      ]
    },
    {
      "question_text": "Which SELinux context field is most critical for defining allowed interactions between processes and system resources in the Targeted Policy?",
      "correct_answer": "Type",
      "distractors": [
        {
          "text": "User",
          "misconception": "Targets [field importance confusion]: Overemphasizes the SELinux user, which primarily maps Linux users and limits roles/levels, not direct resource interaction rules."
        },
        {
          "text": "Role",
          "misconception": "Targets [field function confusion]: Misunderstands the role's function as an intermediary rather than the primary rule definer for resource access."
        },
        {
          "text": "Security Level",
          "misconception": "Targets [MLS vs. TE confusion]: Confuses the primary mechanism of Type Enforcement (TE) with Multi-Level Security (MLS) levels."
        }
      ],
      "detailed_explanation": {
        "core_logic": "In SELinux's Targeted Policy, the 'type' field is paramount because policy rules primarily define interactions between SELinux types (domains for processes, types for files). Therefore, type enforcement dictates most resource access, making it the most critical field for defining process-resource interactions.",
        "distractor_analysis": "The distractors represent other fields within an SELinux context but do not serve the primary function of defining resource interaction rules in the same way 'type' does in Targeted Policy.",
        "analogy": "Imagine a security guard (SELinux policy) checking IDs. The 'type' is like the department badge on the ID (e.g., 'IT Department' or 'Janitorial Staff'), which the guard uses to decide if the person can enter specific areas (resources)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SELINUX_CONTEXT_FIELDS",
        "SELINUX_TARGETED_POLICY"
      ]
    },
    {
      "question_text": "What is the fundamental question that SELinux's Mandatory Access Control (MAC) aims to answer?",
      "correct_answer": "May a subject perform a specific action on a specific object?",
      "distractors": [
        {
          "text": "Is the user authenticated and authorized for the requested resource?",
          "misconception": "Targets [authentication vs. authorization confusion]: Focuses on authentication (like passwords) rather than the fine-grained access control rules."
        },
        {
          "text": "Does the requested action comply with the system's overall security posture?",
          "misconception": "Targets [policy scope confusion]: Overgeneralizes SELinux's role to a broad security posture assessment rather than specific subject-object-action rules."
        },
        {
          "text": "Has the system administrator explicitly granted permission for this operation?",
          "misconception": "Targets [DAC vs. MAC confusion]: Implies explicit, user-defined grants (like DAC) rather than policy-based, system-wide mandatory rules."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SELinux's MAC model operates on the principle of 'least privilege' by answering the fundamental question: 'May a subject perform a specific action on a specific object?'. This is enforced through policy rules that explicitly define allowed interactions, denying all others by default.",
        "distractor_analysis": "The distractors represent other security concepts (authentication, posture assessment, DAC) but miss the core MAC principle of explicit, policy-driven subject-object-action permissions.",
        "analogy": "It's like a strict building security system asking: 'Can this specific person (subject) use this specific keycard (action) to open this specific door (object)?' If the rules don't allow it, access is denied, regardless of who the person is or if they have a general security clearance."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "SELINUX_MAC_BASICS",
        "SELINUX_SUBJECT_OBJECT_MODEL"
      ]
    },
    {
      "question_text": "How does SELinux's Type Enforcement (TE) differ from Discretionary Access Control (DAC) in terms of policy definition?",
      "correct_answer": "TE policy is administratively defined and enforced system-wide, whereas DAC policy is user-discretionary and based on ownership.",
      "distractors": [
        {
          "text": "TE policy is based on user roles, while DAC is based on object types.",
          "misconception": "Targets [TE vs. RBAC confusion]: Mixes Type Enforcement with Role-Based Access Control (RBAC) and misrepresents DAC's basis."
        },
        {
          "text": "DAC policy is system-wide, while TE policy is user-specific.",
          "misconception": "Targets [policy scope reversal]: Incorrectly assigns system-wide enforcement to DAC and user-specific to TE."
        },
        {
          "text": "TE policy is enforced by the kernel, while DAC is enforced by applications.",
          "misconception": "Targets [enforcement mechanism confusion]: Both DAC and TE are enforced by the kernel, though DAC is discretionary and TE is mandatory."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SELinux's Type Enforcement (TE) implements MAC by defining system-wide rules based on types, enforced by the kernel. DAC, conversely, is user-discretionary, allowing owners to set permissions, and is checked before SELinux rules.",
        "distractor_analysis": "Distractor 1 confuses TE with RBAC and DAC. Distractor 2 reverses the scope of DAC and TE. Distractor 3 misattributes enforcement mechanisms.",
        "analogy": "DAC is like a homeowner deciding who can enter their house and which rooms they can access. TE is like a government building's security system, where access is strictly controlled by your job role (type) and clearance level (policy), regardless of who owns the building."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "SELINUX_TE",
        "DAC_BASICS"
      ]
    },
    {
      "question_text": "What is the purpose of the Access Vector Cache (AVC) in SELinux?",
      "correct_answer": "To cache SELinux decisions, reducing the need to check policy rules frequently and improving performance.",
      "distractors": [
        {
          "text": "To log all denied access attempts for later analysis.",
          "misconception": "Targets [logging vs. caching confusion]: Confuses the AVC's primary function (caching decisions) with the audit log's function (recording denials)."
        },
        {
          "text": "To dynamically update SELinux policy rules based on system activity.",
          "misconception": "Targets [policy management confusion]: Misunderstands AVC as a policy modification mechanism rather than a performance optimization for existing policy."
        },
        {
          "text": "To enforce DAC rules before SELinux policy rules are checked.",
          "misconception": "Targets [rule order confusion]: Incorrectly states AVC's role in rule checking order; DAC is checked first, but AVC caches SELinux decisions."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The Access Vector Cache (AVC) stores recent SELinux access control decisions. By caching these decisions, the system avoids repeatedly consulting the full SELinux policy for every access attempt, significantly improving performance, especially for frequently accessed resources.",
        "distractor_analysis": "Distractor 1 confuses caching with logging. Distractor 2 misrepresents AVC as a dynamic policy update tool. Distractor 3 incorrectly places AVC before DAC rule checking.",
        "analogy": "Think of the AVC like a speed-pass lane at a theme park. Once you've had your ticket scanned (decision made), you get a quick pass for that ride (resource) for a while, instead of having to show your ticket to the gatekeeper every single time."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SELINUX_ARCHITECTURE",
        "SELINUX_POLICY_EVALUATION"
      ]
    },
    {
      "question_text": "When SELinux is in 'permissive' mode, what is the key difference in its behavior compared to 'enforcing' mode?",
      "correct_answer": "SELinux logs policy violations but does not deny access, whereas in enforcing mode, it denies access and logs violations.",
      "distractors": [
        {
          "text": "SELinux logs all access attempts but denies none in permissive mode.",
          "misconception": "Targets [logging scope confusion]: Permissive mode logs denials, not all access attempts."
        },
        {
          "text": "SELinux denies access but does not log violations in permissive mode.",
          "misconception": "Targets [denial vs. logging confusion]: Permissive mode logs denials; enforcing mode denies and logs."
        },
        {
          "text": "SELinux logs only critical security violations in permissive mode.",
          "misconception": "Targets [logging severity confusion]: Permissive mode logs all violations that *would* have been denied, not just critical ones."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Permissive mode is a diagnostic state where SELinux monitors and logs policy violations without enforcing them. This allows administrators to identify potential issues without disrupting system operations, unlike enforcing mode, which actively denies unauthorized access.",
        "distractor_analysis": "Distractor 1 incorrectly states all access attempts are logged. Distractor 2 reverses the logging behavior. Distractor 3 misrepresents the severity of logged events in permissive mode.",
        "analogy": "Permissive mode is like a security guard watching a building and noting down rule-breakers but not stopping them. Enforcing mode is like the guard actively stopping rule-breakers and also noting it down."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "SELINUX_MODES"
      ]
    },
    {
      "question_text": "Which SELinux command is used to view the current SELinux mode (enforcing, permissive, or disabled)?",
      "correct_answer": "getenforce",
      "distractors": [
        {
          "text": "sestatus",
          "misconception": "Targets [command confusion]: sestatus provides overall SELinux status, including loaded policy and current mode, but getenforce specifically returns only the current mode."
        },
        {
          "text": "setenforce",
          "misconception": "Targets [command function confusion]: setenforce is used to *change* the mode, not view it."
        },
        {
          "text": "semanage",
          "misconception": "Targets [command scope confusion]: semanage is used for managing policy, users, ports, etc., not for directly querying the current runtime mode."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>getenforce</code> command is specifically designed to query and return the current SELinux mode (Enforcing, Permissive, or Disabled). While <code>sestatus</code> provides more comprehensive information, <code>getenforce</code> offers a direct answer to the current operational mode.",
        "distractor_analysis": "Distractor 1 (<code>sestatus</code>) provides more info than requested. Distractor 2 (<code>setenforce</code>) changes the mode, not views it. Distractor 3 (<code>semanage</code>) is for policy management.",
        "analogy": "Asking 'What's the temperature?' and getting 'It's 72 degrees Fahrenheit' (getenforce) versus getting a full weather report including humidity, wind speed, and forecast (sestatus)."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "SELINUX_MODES",
        "SELINUX_COMMANDS"
      ]
    },
    {
      "question_text": "What is the primary purpose of the <code>semanage login -l</code> command in SELinux?",
      "correct_answer": "To list the mappings between Linux user accounts and SELinux users.",
      "distractors": [
        {
          "text": "To define new SELinux user roles and types.",
          "misconception": "Targets [command scope confusion]: Misunderstands semanage login's purpose; defining roles/types is done with `semanage user` or policy modules."
        },
        {
          "text": "To view the current SELinux mode (enforcing/permissive).",
          "misconception": "Targets [command function confusion]: This function is performed by `getenforce` or `sestatus`."
        },
        {
          "text": "To display the SELinux context of files and directories.",
          "misconception": "Targets [command scope confusion]: This is the function of `ls -Z` or `matchpathcon`."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>semanage login -l</code> command is crucial for understanding how Linux user identities are translated into SELinux user identities within the security policy. It displays the mappings, including default mappings and specific user assignments, which dictates the initial SELinux context for logged-in users.",
        "distractor_analysis": "Distractor 1 describes <code>semanage user</code> or policy creation. Distractor 2 describes <code>getenforce</code>. Distractor 3 describes <code>ls -Z</code> or <code>matchpathcon</code>.",
        "analogy": "It's like a directory that shows how different employee IDs (Linux users) are linked to specific job roles (SELinux users) within the company's security system."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "SELINUX_USER_MAPPING",
        "SELINUX_COMMANDS"
      ]
    },
    {
      "question_text": "When a Linux user logs in, which PAM module is responsible for automatically mapping the Linux user to an SELinux user and setting the resulting SELinux context?",
      "correct_answer": "pam_selinux",
      "distractors": [
        {
          "text": "pam_loginuid",
          "misconception": "Targets [PAM module confusion]: pam_loginuid is related to tracking login sessions but not SELinux context mapping."
        },
        {
          "text": "pam_access",
          "misconception": "Targets [PAM module confusion]: pam_access controls access based on user/group/host rules, not SELinux context."
        },
        {
          "text": "pam_namespace",
          "misconception": "Targets [PAM module confusion]: pam_namespace is related to managing user namespaces, not SELinux context mapping."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>pam_selinux</code> module is specifically designed to interface with SELinux during the login process. It reads the SELinux policy to determine the correct SELinux user, role, and type based on the logged-in Linux user, thereby establishing the initial security context for the user's session.",
        "distractor_analysis": "The distractors are other PAM modules with different security-related functions, none of which are directly responsible for SELinux context mapping during login.",
        "analogy": "Think of <code>pam_selinux</code> as the security desk at a building entrance that checks your employee ID (Linux user) and assigns you the correct security badge (SELinux context) based on company policy."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "SELINUX_USER_MAPPING",
        "PAM_BASICS"
      ]
    },
    {
      "question_text": "What is the primary security benefit of running processes in SELinux 'domains'?",
      "correct_answer": "Domains separate processes, limiting an attacker's access to only the normal functions of the compromised process and its configured accessible files.",
      "distractors": [
        {
          "text": "Domains encrypt all data processed by the application.",
          "misconception": "Targets [domain vs. encryption confusion]: Misunderstands the purpose of domains as encryption, rather than access control."
        },
        {
          "text": "Domains automatically update system software to patch vulnerabilities.",
          "misconception": "Targets [domain vs. patching confusion]: Confuses process isolation with software update mechanisms."
        },
        {
          "text": "Domains allow processes to access any file, preventing privilege escalation.",
          "misconception": "Targets [domain isolation reversal]: Incorrectly states domains *allow* broad access and prevent escalation, when they actually *restrict* access to prevent it."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SELinux domains provide process isolation. By confining processes to specific domains, SELinux ensures that even if a process is compromised, the attacker's actions are limited to the permissions granted to that specific domain, thereby mitigating privilege escalation and limiting damage.",
        "distractor_analysis": "Distractor 1 confuses domains with encryption. Distractor 2 conflates domains with software patching. Distractor 3 fundamentally misunderstands the purpose of domain isolation.",
        "analogy": "Domains are like separate, secure rooms in a building. If someone breaks into one room (compromised process), they can't easily access other rooms (processes or files) because the doors (SELinux policy) are locked."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SELINUX_DOMAINS",
        "SELINUX_MAC_BASICS"
      ]
    },
    {
      "question_text": "Which SELinux command is used to temporarily change the security context (label) of a file or directory?",
      "correct_answer": "chcon",
      "distractors": [
        {
          "text": "restorecon",
          "misconception": "Targets [command function confusion]: restorecon is used to restore default contexts, not temporarily change them."
        },
        {
          "text": "semanage fcontext",
          "misconception": "Targets [command persistence confusion]: semanage fcontext makes persistent changes that survive relabels, not temporary ones."
        },
        {
          "text": "matchpathcon",
          "misconception": "Targets [command purpose confusion]: matchpathcon checks the default context, it does not change it."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>chcon</code> command allows administrators to temporarily modify the SELinux context (label) of files and directories. These changes are not persistent and will be reverted if the file system is relabeled or <code>restorecon</code> is run, making it suitable for testing or temporary adjustments.",
        "distractor_analysis": "Distractor 1 (<code>restorecon</code>) reverts changes. Distractor 2 (<code>semanage fcontext</code>) makes persistent changes. Distractor 3 (<code>matchpathcon</code>) checks contexts.",
        "analogy": "<code>chcon</code> is like temporarily putting a different colored sticker on a box to indicate its contents for a specific task, knowing the original label is still there and will reappear later."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "SELINUX_FILE_LABELING",
        "SELINUX_COMMANDS"
      ]
    },
    {
      "question_text": "What is the primary purpose of the <code>semanage fcontext</code> command in SELinux?",
      "correct_answer": "To define persistent SELinux file context rules that survive file system relabels.",
      "distractors": [
        {
          "text": "To temporarily change the SELinux context of a file.",
          "misconception": "Targets [command persistence confusion]: This describes `chcon`, not `semanage fcontext`."
        },
        {
          "text": "To display the default SELinux context for a given path.",
          "misconception": "Targets [command function confusion]: This describes `matchpathcon`."
        },
        {
          "text": "To list all available SELinux booleans.",
          "misconception": "Targets [command scope confusion]: This is the function of `semanage boolean -l` or `getsebool -a`."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>semanage fcontext</code> command is used to define persistent SELinux file context rules. These rules are stored in local policy files and are applied by utilities like <code>restorecon</code> or during file system relabels, ensuring that files and directories maintain their intended SELinux context across system reboots and updates.",
        "distractor_analysis": "Distractor 1 describes <code>chcon</code>. Distractor 2 describes <code>matchpathcon</code>. Distractor 3 describes <code>semanage boolean</code>.",
        "analogy": "<code>semanage fcontext</code> is like writing a permanent rule in the building's security manual: 'All boxes entering the 'Shipping' area must be labeled 'Fragile'.' This rule is followed every time, even after the boxes are moved or the area is reorganized."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SELINUX_FILE_LABELING",
        "SELINUX_COMMANDS"
      ]
    },
    {
      "question_text": "When copying files using the <code>cp</code> command, which option is necessary to preserve the original SELinux context?",
      "correct_answer": "--preserve=context",
      "distractors": [
        {
          "text": "--context",
          "misconception": "Targets [option confusion]: `--context` is used with `cp` to *set* a specific context, not preserve the original."
        },
        {
          "text": "--attributes",
          "misconception": "Targets [option confusion]: While context is an attribute, `--attributes` is too general and doesn't specifically target SELinux context preservation."
        },
        {
          "text": "--selinux",
          "misconception": "Targets [option confusion]: `--selinux` is an option for `tar`, not `cp`, for preserving SELinux contexts during archiving."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>cp</code> command's <code>--preserve=context</code> option explicitly instructs the utility to copy the SELinux security context (label) along with the file's data and other attributes. Without this option, copied files typically inherit the context of the destination directory, potentially causing access issues.",
        "distractor_analysis": "Distractor 1 (<code>--context</code>) sets a new context. Distractor 2 (<code>--attributes</code>) is too broad. Distractor 3 (<code>--selinux</code>) is for <code>tar</code>, not <code>cp</code>.",
        "analogy": "When copying files, <code>--preserve=context</code> is like making a photocopy that includes not just the text, but also the original document's official seal and color coding, ensuring the copy is identical in all aspects, including its security classification."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "SELINUX_FILE_COPYING",
        "SELINUX_COMMANDS"
      ]
    },
    {
      "question_text": "Why is moving files with the <code>mv</code> command potentially problematic for SELinux contexts?",
      "correct_answer": "Files retain their original SELinux context when moved, which may be incorrect for the destination directory's policy.",
      "distractors": [
        {
          "text": "The <code>mv</code> command always removes SELinux contexts to prevent data leakage.",
          "misconception": "Targets [command behavior misunderstanding]: `mv` preserves context, it doesn't remove it."
        },
        {
          "text": "SELinux prevents files from being moved between directories.",
          "misconception": "Targets [SELinux capability overstatement]: SELinux does not inherently prevent file moves; it enforces access based on context."
        },
        {
          "text": "The <code>mv</code> command forces files to inherit the destination directory's context.",
          "misconception": "Targets [command behavior confusion]: This describes copying behavior (`cp` without `--preserve=context`), not moving (`mv`)."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Unlike copying, moving a file with <code>mv</code> typically preserves its existing SELinux context. If the destination directory has a different security policy (e.g., moving a file from a user's home directory into a web server's document root), the inherited context might violate the destination's policy, leading to access denials.",
        "distractor_analysis": "Distractor 1 incorrectly states <code>mv</code> removes context. Distractor 2 overstates SELinux's restrictions on file movement. Distractor 3 describes <code>cp</code> behavior, not <code>mv</code>.",
        "analogy": "Moving a file is like relocating a person. They keep their original ID badge (SELinux context). If they move to a new building with different security rules, their old badge might not grant them access to the new areas."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SELINUX_FILE_MOVING",
        "SELINUX_CONTEXT_BASICS"
      ]
    },
    {
      "question_text": "What is the purpose of the <code>audit2allow</code> utility in SELinux troubleshooting?",
      "correct_answer": "To generate SELinux policy rules (allow rules) based on logged denial messages.",
      "distractors": [
        {
          "text": "To automatically apply correct SELinux labels to files.",
          "misconception": "Targets [utility function confusion]: This describes `restorecon` or `semanage fcontext`."
        },
        {
          "text": "To display detailed explanations of SELinux denials.",
          "misconception": "Targets [utility function confusion]: This describes `sealert`."
        },
        {
          "text": "To list all available SELinux booleans and their states.",
          "misconception": "Targets [utility function confusion]: This describes `getsebool` or `semanage boolean -l`."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When SELinux denies access, <code>audit2allow</code> analyzes the corresponding denial messages in the audit log. It then generates Type Enforcement (TE) rules that, when compiled into a policy module and loaded, permit the previously denied action, aiding in the creation of custom policies.",
        "distractor_analysis": "Distractor 1 describes file labeling commands. Distractor 2 describes <code>sealert</code>. Distractor 3 describes boolean management commands.",
        "analogy": "<code>audit2allow</code> is like a translator that reads a security guard's report of a denied entry (denial message) and writes a new instruction manual (policy rule) for the guard to allow that specific entry next time."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SELINUX_TROUBLESHOOTING",
        "SELINUX_POLICY_MODULES"
      ]
    },
    {
      "question_text": "In SELinux, what is the significance of the <code>__default__</code> entry in the <code>semanage login -l</code> output?",
      "correct_answer": "It defines the default SELinux user mapping for Linux users who do not have an explicit mapping.",
      "distractors": [
        {
          "text": "It represents the SELinux user for the root Linux account.",
          "misconception": "Targets [default vs. specific mapping confusion]: The root account often has its own explicit mapping, while `__default__` applies to others."
        },
        {
          "text": "It indicates that SELinux is disabled for all users.",
          "misconception": "Targets [mode vs. mapping confusion]: `__default__` relates to user mapping, not the overall SELinux mode (enforcing/permissive/disabled)."
        },
        {
          "text": "It specifies the default SELinux role for all system processes.",
          "misconception": "Targets [user vs. role confusion]: `__default__` applies to Linux user logins, not system processes, and relates to SELinux users, not roles."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>__default__</code> entry in <code>semanage login -l</code> acts as a fallback. If a Linux user logs in and doesn't have a specific mapping defined, they are assigned the SELinux user specified by the <code>__default__</code> entry. This allows administrators to set a system-wide default SELinux user context for regular users.",
        "distractor_analysis": "Distractor 1 incorrectly identifies <code>__default__</code> as specific to root. Distractor 2 confuses user mapping with SELinux modes. Distractor 3 conflates user mappings with system process roles.",
        "analogy": "The <code>__default__</code> mapping is like a company's default email signature for all employees unless they have a specific, personalized one. It ensures everyone gets a basic, standardized signature (SELinux context) if no special one is assigned."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SELINUX_USER_MAPPING",
        "SELINUX_COMMANDS"
      ]
    },
    {
      "question_text": "What is the primary security benefit of SELinux's Type Enforcement (TE) model?",
      "correct_answer": "It enforces fine-grained access control by defining specific interactions between process types (domains) and object types.",
      "distractors": [
        {
          "text": "It encrypts data at rest and in transit.",
          "misconception": "Targets [TE vs. encryption confusion]: TE is about access control, not data encryption."
        },
        {
          "text": "It automatically patches vulnerabilities in running applications.",
          "misconception": "Targets [TE vs. patching confusion]: TE isolates processes; it does not perform software patching."
        },
        {
          "text": "It allows users to define their own access control policies.",
          "misconception": "Targets [MAC vs. DAC confusion]: TE is part of MAC, which is administratively defined, unlike user-defined DAC policies."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Type Enforcement (TE) is a core component of SELinux's MAC. It works by assigning types to processes (domains) and objects (files, ports, etc.) and then defining explicit rules in the policy that dictate precisely which types can interact with which other types and via which actions, thereby enforcing least privilege.",
        "distractor_analysis": "Distractor 1 confuses TE with encryption. Distractor 2 confuses TE with vulnerability management. Distractor 3 incorrectly attributes policy definition to users, contrary to MAC principles.",
        "analogy": "TE is like a highly secure facility where each type of worker (process type) has a specific badge (type label) that only allows them access to certain rooms (object types) for specific tasks (actions), ensuring no unauthorized access."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SELINUX_TE",
        "SELINUX_MAC_BASICS"
      ]
    },
    {
      "question_text": "In SELinux, what is the role of the <code>entrypoint</code> permission in domain transitions?",
      "correct_answer": "It controls which applications (executables with a specific type) can be used to transition a process into a new domain.",
      "distractors": [
        {
          "text": "It allows any process to transition to any domain.",
          "misconception": "Targets [entrypoint scope confusion]: `entrypoint` is restrictive, not permissive."
        },
        {
          "text": "It defines the default domain for all new processes.",
          "misconception": "Targets [entrypoint vs. default domain confusion]: Default domains are typically `unconfined_t` or `init_t`, not controlled by `entrypoint`."
        },
        {
          "text": "It grants read and write access to files within the target domain.",
          "misconception": "Targets [entrypoint vs. file access confusion]: `entrypoint` governs execution/transition, not file access permissions."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>entrypoint</code> permission in SELinux policy is crucial for controlling domain transitions. It specifies the executable type that a process must have to be allowed to transition into a particular target domain, ensuring that only authorized applications can initiate a change in process context.",
        "distractor_analysis": "Distractor 1 incorrectly states <code>entrypoint</code> allows any transition. Distractor 2 confuses it with default domain assignments. Distractor 3 misrepresents its function as file access control.",
        "analogy": "The <code>entrypoint</code> permission is like a specific gate or doorway (executable type) that you must use to enter a restricted area (new domain). You can't just walk in anywhere; you must use the designated entrance."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SELINUX_DOMAIN_TRANSITIONS",
        "SELINUX_POLICY_RULES"
      ]
    },
    {
      "question_text": "Which SELinux command is used to view the SELinux context of running processes?",
      "correct_answer": "ps -eZ",
      "distractors": [
        {
          "text": "id -Z",
          "misconception": "Targets [command scope confusion]: `id -Z` shows the context of the *current* user's session, not all running processes."
        },
        {
          "text": "ls -Z",
          "misconception": "Targets [command scope confusion]: `ls -Z` shows the context of files and directories, not processes."
        },
        {
          "text": "seinfo",
          "misconception": "Targets [command function confusion]: `seinfo` provides information about policy components (types, roles, etc.), not live process contexts."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>ps -eZ</code> command is used to list all running processes (<code>ps -e</code>) along with their SELinux security contexts (<code>-Z</code>). This provides a comprehensive view of the SELinux labels applied to every active process on the system.",
        "distractor_analysis": "Distractor 1 (<code>id -Z</code>) is user-specific. Distractor 2 (<code>ls -Z</code>) is for files. Distractor 3 (<code>seinfo</code>) is for policy information.",
        "analogy": "Using <code>ps -eZ</code> is like looking at a security roster for an entire building, showing the specific security clearance (SELinux context) for every person (process) currently inside."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "SELINUX_PROCESS_CONTEXT",
        "SELINUX_COMMANDS"
      ]
    },
    {
      "question_text": "What is the primary purpose of the <code>restorecon</code> utility in SELinux?",
      "correct_answer": "To restore the default SELinux security context for files and directories based on the system policy.",
      "distractors": [
        {
          "text": "To temporarily change the SELinux context of a file.",
          "misconception": "Targets [utility function confusion]: This describes `chcon`."
        },
        {
          "text": "To define persistent SELinux file context rules.",
          "misconception": "Targets [utility function confusion]: This describes `semanage fcontext`."
        },
        {
          "text": "To display the default SELinux context for a given path.",
          "misconception": "Targets [utility function confusion]: This describes `matchpathcon`."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>restorecon</code> utility is essential for maintaining SELinux integrity. It reads the system's SELinux policy files (e.g., in <code>/etc/selinux/targeted/contexts/files/</code>) and applies the correct default security contexts to specified files and directories, correcting any incorrect or missing labels.",
        "distractor_analysis": "Distractor 1 describes <code>chcon</code>. Distractor 2 describes <code>semanage fcontext</code>. Distractor 3 describes <code>matchpathcon</code>.",
        "analogy": "<code>restorecon</code> is like a librarian who ensures every book (file) is placed on the correct shelf (context) according to the library's catalog (SELinux policy), fixing any misplaced books."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SELINUX_FILE_LABELING",
        "SELINUX_COMMANDS"
      ]
    },
    {
      "question_text": "When using <code>semanage fcontext</code> to define persistent SELinux file contexts, why is it important to use specific regular expressions for paths?",
      "correct_answer": "Because <code>semanage fcontext</code> rules are evaluated in reverse order of definition, and local customizations override system policy, specificity prevents unintended impacts on other file system areas.",
      "distractors": [
        {
          "text": "Because SELinux policy rules are evaluated in alphabetical order.",
          "misconception": "Targets [rule evaluation order confusion]: SELinux policy evaluation order is based on specificity and definition order (local overrides), not alphabetical."
        },
        {
          "text": "Because <code>semanage fcontext</code> rules are evaluated in the order they are defined.",
          "misconception": "Targets [rule evaluation order confusion]: `semanage fcontext` rules are evaluated in reverse order of definition."
        },
        {
          "text": "Because SELinux requires all paths to be explicitly defined.",
          "misconception": "Targets [policy completeness misunderstanding]: While specificity is key, SELinux has default handling for undefined paths (`default_t`), and not *all* paths require explicit definition if defaults are acceptable."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SELinux policy evaluation prioritizes specificity and local overrides. <code>semanage fcontext</code> rules are processed in reverse order of definition, and entries in <code>file_contexts.local</code> take precedence. Therefore, using specific regular expressions is crucial to ensure that custom contexts are applied only where intended and do not inadvertently override system policy or affect unrelated files.",
        "distractor_analysis": "Distractor 1 incorrectly states alphabetical order. Distractor 2 incorrectly states forward order of definition. Distractor 3 overstates the requirement for explicit definition for all paths.",
        "analogy": "Defining file contexts with <code>semanage fcontext</code> is like setting up specific rules for different types of mail in a sorting facility. If you have a general rule for 'all packages' and a specific rule for 'urgent packages', the urgent package rule needs to be precise so it doesn't accidentally apply to regular packages, and the system needs to know which rule to check first (reverse order/local override)."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SELINUX_FILE_LABELING",
        "SELINUX_POLICY_EVALUATION"
      ]
    },
    {
      "question_text": "What is the primary security benefit of SELinux's Role-Based Access Control (RBAC) model?",
      "correct_answer": "It allows administrators to define specific sets of privileges for different job functions, limiting user actions to only what is necessary for their role.",
      "distractors": [
        {
          "text": "It encrypts all data accessed by users in specific roles.",
          "misconception": "Targets [RBAC vs. encryption confusion]: RBAC is about access control, not data encryption."
        },
        {
          "text": "It automatically assigns users to the most privileged role available.",
          "misconception": "Targets [least privilege violation]: RBAC enforces least privilege, not maximum privilege assignment."
        },
        {
          "text": "It replaces the need for traditional user authentication methods.",
          "misconception": "Targets [RBAC vs. authentication confusion]: RBAC complements, rather than replaces, authentication mechanisms like passwords or Kerberos."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SELinux RBAC enhances security by mapping users to roles, and roles to specific types (domains/objects). This ensures users operate with the minimum necessary privileges for their assigned role, significantly reducing the attack surface and mitigating the impact of compromised accounts.",
        "distractor_analysis": "Distractor 1 confuses RBAC with encryption. Distractor 2 contradicts the principle of least privilege. Distractor 3 incorrectly suggests RBAC replaces authentication.",
        "analogy": "RBAC is like assigning different security clearances in a government agency. A 'Clerk' role (SELinux role) has access to specific files (types), while a 'Department Head' role has broader access, ensuring each person only has the permissions needed for their job."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SELINUX_RBAC_BASICS",
        "LEAST_PRIVILEGE_PRINCIPLE"
      ]
    },
    {
      "question_text": "In SELinux, what is the purpose of the <code>system_u</code> SELinux user identity?",
      "correct_answer": "It is a special identity reserved for system processes and objects, and should never be associated with a Linux user.",
      "distractors": [
        {
          "text": "It is the default SELinux user for all unconfined Linux users.",
          "misconception": "Targets [user identity confusion]: The default for unconfined users is typically `unconfined_u`."
        },
        {
          "text": "It grants elevated privileges to regular Linux users.",
          "misconception": "Targets [privilege confusion]: `system_u` is for system processes, not for granting elevated privileges to regular users."
        },
        {
          "text": "It is used for mapping Linux users to the <code>guest_r</code> SELinux role.",
          "misconception": "Targets [user vs. role confusion]: `system_u` is a user identity, not directly tied to the `guest_r` role in this manner."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>system_u</code> SELinux user identity is a reserved designation for system processes and objects managed by the operating system kernel and core services. It is distinct from user-level identities and is crucial for maintaining the integrity and security of system operations by ensuring these components operate within their designated security context.",
        "distractor_analysis": "Distractor 1 incorrectly identifies <code>system_u</code> as the default for unconfined users. Distractor 2 misrepresents its purpose as granting user privileges. Distractor 3 confuses user identities with roles.",
        "analogy": "The <code>system_u</code> identity is like the official 'building management' designation for all the maintenance staff and infrastructure systems. They have specific access and responsibilities for the building's core functions, separate from regular tenants (Linux users)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SELINUX_USER_MAPPING",
        "SELINUX_CONTEXT_FIELDS"
      ]
    },
    {
      "question_text": "Which SELinux command is used to define persistent file context rules that survive file system relabels?",
      "correct_answer": "semanage fcontext",
      "distractors": [
        {
          "text": "chcon",
          "misconception": "Targets [command persistence confusion]: `chcon` makes temporary changes."
        },
        {
          "text": "restorecon",
          "misconception": "Targets [command function confusion]: `restorecon` applies existing persistent rules or default contexts, it does not define them."
        },
        {
          "text": "matchpathcon",
          "misconception": "Targets [command purpose confusion]: `matchpathcon` checks contexts, it does not define them."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>semanage fcontext</code> command is the authoritative tool for defining persistent SELinux file context rules. These rules are stored in policy files and are used by utilities like <code>restorecon</code> during system boots or manual relabeling operations, ensuring files and directories maintain their correct SELinux labels.",
        "distractor_analysis": "Distractor 1 describes <code>chcon</code>. Distractor 2 describes <code>restorecon</code>. Distractor 3 describes <code>matchpathcon</code>.",
        "analogy": "<code>semanage fcontext</code> is like writing the master blueprint for labeling items in a warehouse. It defines the permanent rules for what label each type of item should have, ensuring consistency even after inventory checks (<code>restorecon</code>)."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "SELINUX_FILE_LABELING",
        "SELINUX_COMMANDS"
      ]
    },
    {
      "question_text": "What is the primary security benefit of SELinux's Mandatory Access Control (MAC) model over Discretionary Access Control (DAC)?",
      "correct_answer": "MAC enforces system-wide, centrally managed policies that restrict access based on security contexts, whereas DAC relies on individual user-defined permissions.",
      "distractors": [
        {
          "text": "MAC automatically encrypts all data, while DAC does not.",
          "misconception": "Targets [MAC vs. encryption confusion]: MAC is about access control, not data encryption."
        },
        {
          "text": "DAC is enforced by the kernel, while MAC is enforced by applications.",
          "misconception": "Targets [enforcement mechanism confusion]: Both are enforced by the kernel, but MAC is mandatory and DAC is discretionary."
        },
        {
          "text": "MAC allows users to define their own access rules, while DAC is system-wide.",
          "misconception": "Targets [policy definition confusion]: MAC policies are centrally managed; DAC policies are user-defined."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SELinux's MAC model provides a more robust security framework than DAC. MAC policies are centrally defined and enforced by the kernel, ensuring consistent security across the system. DAC, conversely, allows individual users to control access to their files, which can lead to inconsistent or weak security configurations.",
        "distractor_analysis": "Distractor 1 confuses MAC with encryption. Distractor 2 misattributes enforcement mechanisms. Distractor 3 reverses the policy definition roles of MAC and DAC.",
        "analogy": "DAC is like each person in a building deciding who can enter their apartment. MAC is like a central security command center that dictates who can enter which floor or room based on their job role and clearance, regardless of who owns the room."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "SELINUX_MAC_BASICS",
        "DAC_BASICS"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 25,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Role-Based Access Control in SELinux Security Architecture And Engineering best practices",
    "latency_ms": 52624.57
  },
  "timestamp": "2026-01-01T15:38:25.264515"
}