{
  "topic_title": "Brute-Force Password Cracking",
  "category": "001_Cryptography - Hash Functions",
  "flashcards": [
    {
      "question_text": "What is the primary goal of a brute-force password attack?",
      "correct_answer": "To systematically try all possible combinations of characters until the correct password is found.",
      "distractors": [
        {
          "text": "To exploit known vulnerabilities in the hashing algorithm itself.",
          "misconception": "Targets [attack vector confusion]: Students confuse brute-force with vulnerability exploitation."
        },
        {
          "text": "To guess passwords based on common patterns and dictionary words.",
          "misconception": "Targets [attack type confusion]: Students confuse brute-force with dictionary attacks."
        },
        {
          "text": "To intercept password hashes during transmission over a network.",
          "misconception": "Targets [attack vector confusion]: Students confuse brute-force with man-in-the-middle attacks."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Brute-force attacks work by systematically testing every possible character combination. This exhaustive approach aims to find the password because it guarantees eventual discovery, unlike dictionary attacks which rely on pre-existing wordlists.",
        "distractor_analysis": "The first distractor describes vulnerability exploitation, not brute-force. The second describes a dictionary attack, a related but distinct method. The third describes eavesdropping or interception, not guessing.",
        "analogy": "Imagine trying to open a combination lock by starting at 000, then 001, 002, and so on, until you find the correct combination. That's brute-force."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "attack",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_HASH_FUNCTIONS",
        "CRYPTO_ATTACKS"
      ]
    },
    {
      "question_text": "Which of the following is the MOST effective defense against brute-force password cracking?",
      "correct_answer": "Implementing strong password policies and account lockout mechanisms.",
      "distractors": [
        {
          "text": "Using simple, short passwords for ease of memorization.",
          "misconception": "Targets [password policy confusion]: Students believe shorter passwords are more secure or easier to manage."
        },
        {
          "text": "Storing passwords in plain text for quick retrieval.",
          "misconception": "Targets [storage security confusion]: Students misunderstand the need for secure password storage."
        },
        {
          "text": "Disabling all account lockout features to avoid user inconvenience.",
          "misconception": "Targets [security vs. usability confusion]: Students prioritize usability over security, ignoring lockout benefits."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Strong password policies (complexity, length) increase the search space for brute-force attacks, making them infeasible. Account lockouts temporarily block attackers after a set number of failed attempts, because they disrupt the attacker's progress.",
        "distractor_analysis": "Short passwords are easily brute-forced. Plain text storage is a critical security failure. Disabling lockouts removes a key defense against repeated guessing attempts.",
        "analogy": "Think of a bank vault. Strong password policies are like making the vault door thicker and more complex. Account lockouts are like having a guard who stops anyone trying too many keys."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "CRYPTO_PASSWORD_SECURITY",
        "CRYPTO_ACCOUNT_LOCKOUT"
      ]
    },
    {
      "question_text": "How does salting a password hash mitigate brute-force attacks?",
      "correct_answer": "It adds a unique, random value to each password before hashing, making precomputed rainbow tables ineffective.",
      "distractors": [
        {
          "text": "It encrypts the password using a secret key known only to the server.",
          "misconception": "Targets [hashing vs. encryption confusion]: Students confuse hashing with symmetric encryption."
        },
        {
          "text": "It shortens the password to a fixed-length string for faster comparison.",
          "misconception": "Targets [hashing mechanism confusion]: Students misunderstand that hashing produces a fixed-size output, not that it shortens input."
        },
        {
          "text": "It requires a second factor of authentication for every login attempt.",
          "misconception": "Targets [authentication method confusion]: Students confuse salting with multi-factor authentication (MFA)."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Salting adds a unique random string (the salt) to each password before hashing. This ensures that identical passwords produce different hashes, because each hash is unique to the password and its specific salt. Therefore, precomputed rainbow tables, which rely on identical hashes for identical passwords, become useless.",
        "distractor_analysis": "The first distractor describes encryption. The second misunderstands hashing output size. The third describes MFA, a different security control.",
        "analogy": "Imagine each person having a unique, secret ingredient (the salt) they add to their recipe (the password) before making a unique spice blend (the hash). Even if two people make the same dish, the final spice blend will be different."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_PASSWORD_HASHING",
        "CRYPTO_SALTING",
        "CRYPTO_RAINBOW_TABLES"
      ]
    },
    {
      "question_text": "What is a 'rainbow table' in the context of password cracking?",
      "correct_answer": "A precomputed table of password hashes used to quickly find the original password for a given hash.",
      "distractors": [
        {
          "text": "A list of common passwords used in dictionary attacks.",
          "misconception": "Targets [attack type confusion]: Students confuse rainbow tables with dictionary attack wordlists."
        },
        {
          "text": "A secure method for storing password hashes on a server.",
          "misconception": "Targets [storage security confusion]: Students believe rainbow tables are a secure storage mechanism."
        },
        {
          "text": "A cryptographic algorithm designed to resist brute-force attacks.",
          "misconception": "Targets [algorithm confusion]: Students confuse attack tools with defensive algorithms."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Rainbow tables are optimized data structures that store precomputed hashes of potential passwords. They significantly speed up the process of cracking hashes because they allow an attacker to look up a hash and find its corresponding password, rather than computing each hash individually.",
        "distractor_analysis": "The first distractor describes a dictionary attack wordlist. The second incorrectly suggests rainbow tables are for secure storage. The third misidentifies rainbow tables as a defensive algorithm.",
        "analogy": "A rainbow table is like a cheat sheet for a math test where all the answers (passwords) are already matched with their corresponding problems (hashes). Instead of solving each problem, you just look up the answer."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_PASSWORD_HASHING",
        "CRYPTO_ATTACKS"
      ]
    },
    {
      "question_text": "Why are modern, slow hashing algorithms like bcrypt and Argon2 preferred over faster ones like MD5 for password storage?",
      "correct_answer": "Slower algorithms increase the computational cost for attackers, making brute-force attacks infeasible within a reasonable time.",
      "distractors": [
        {
          "text": "Faster algorithms are more efficient for servers to compute during authentication.",
          "misconception": "Targets [performance vs. security confusion]: Students prioritize server efficiency over attacker cost."
        },
        {
          "text": "Faster algorithms produce shorter, more manageable hash outputs.",
          "misconception": "Targets [hash output size confusion]: Students believe hash output size is the primary factor for security."
        },
        {
          "text": "Faster algorithms are less prone to collisions, ensuring unique hashes.",
          "misconception": "Targets [collision resistance confusion]: Students confuse speed with collision resistance, which is a separate property."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Slow hashing algorithms like bcrypt and Argon2 are designed to be computationally expensive, incorporating work factors (iterations, memory cost). This increases the time and resources required for an attacker to perform brute-force or dictionary attacks, because each guess takes longer to compute, thus enhancing security.",
        "distractor_analysis": "The first distractor prioritizes server performance, which is counterproductive for password security. The second is incorrect; hash output size is generally fixed. The third confuses speed with collision resistance, a different cryptographic property.",
        "analogy": "Using a slow hashing algorithm is like making attackers dig through sand to find a needle, while a fast one is like letting them sift through it quickly. The sand (computation) is the barrier."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "CRYPTO_PASSWORD_HASHING",
        "CRYPTO_SLOW_HASHES",
        "CRYPTO_ATTACKS"
      ]
    },
    {
      "question_text": "What is the role of a 'work factor' in password hashing algorithms like scrypt or PBKDF2?",
      "correct_answer": "It controls the computational cost (time and resources) required to compute a hash, deliberately slowing down attackers.",
      "distractors": [
        {
          "text": "It determines the length of the salt used with the password.",
          "misconception": "Targets [parameter confusion]: Students confuse work factor with salt length."
        },
        {
          "text": "It specifies the number of rounds for a cryptographic cipher.",
          "misconception": "Targets [algorithm confusion]: Students confuse password hashing parameters with block cipher parameters."
        },
        {
          "text": "It ensures that the hash output is unique for every input.",
          "misconception": "Targets [uniqueness vs. cost confusion]: Students confuse the goal of uniqueness with the mechanism of computational cost."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The work factor, often configured as iteration count or memory cost, dictates how much computational effort is needed to generate a password hash. By increasing this factor, the algorithm deliberately slows down hash computation, making brute-force attacks prohibitively expensive for attackers because each guess requires significant processing power.",
        "distractor_analysis": "The first distractor confuses the work factor with salt management. The second incorrectly applies concepts from symmetric ciphers. The third conflates the goal of unique hashes with the mechanism of computational cost.",
        "analogy": "A work factor is like setting a difficulty level for a game. A higher work factor means the game (hashing) is harder and takes longer to complete, thus deterring players (attackers) who want quick results."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_PASSWORD_HASHING",
        "CRYPTO_SLOW_HASHES"
      ]
    },
    {
      "question_text": "How can GPU acceleration impact brute-force password cracking?",
      "correct_answer": "GPUs can perform massively parallel computations, allowing them to hash passwords millions of times faster than traditional CPUs.",
      "distractors": [
        {
          "text": "GPUs are primarily used for encrypting data, not for cracking hashes.",
          "misconception": "Targets [hardware function confusion]: Students misunderstand GPU capabilities beyond encryption."
        },
        {
          "text": "GPUs require complex cryptographic keys that are difficult to obtain.",
          "misconception": "Targets [key management confusion]: Students confuse hardware capabilities with key management requirements."
        },
        {
          "text": "GPUs are only effective against weak, short passwords.",
          "misconception": "Targets [attack effectiveness confusion]: Students underestimate GPU power against longer passwords."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Graphics Processing Units (GPUs) contain thousands of cores designed for parallel processing. This architecture is highly effective for hashing algorithms, which involve repetitive calculations. Therefore, GPUs can compute password hashes exponentially faster than CPUs, significantly accelerating brute-force attacks.",
        "distractor_analysis": "The first distractor is incorrect; GPUs are widely used for hash cracking. The second confuses hardware capabilities with key requirements. The third underestimates GPU power; they accelerate cracking against all password types, though longer ones still take longer.",
        "analogy": "A CPU is like a single, powerful chef who can cook one complex dish at a time. A GPU is like an army of chefs, each capable of cooking a simpler dish, allowing them to prepare thousands of dishes simultaneously."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "CRYPTO_PASSWORD_HASHING",
        "CRYPTO_ATTACKS",
        "HARDWARE_ACCELERATION"
      ]
    },
    {
      "question_text": "According to NIST SP 800-63-4, what is a key recommendation for password complexity?",
      "correct_answer": "Focus on password length and prohibit common, easily guessable patterns rather than enforcing complex character sets.",
      "distractors": [
        {
          "text": "Enforce a minimum of 8 characters with at least one uppercase, one lowercase, one number, and one symbol.",
          "misconception": "Targets [outdated policy confusion]: Students adhere to older, less effective complexity rules."
        },
        {
          "text": "Require passwords to be changed every 90 days, regardless of length or complexity.",
          "misconception": "Targets [forced rotation confusion]: Students believe mandatory rotation is the primary security measure."
        },
        {
          "text": "Allow users to reuse their last 10 passwords to simplify management.",
          "misconception": "Targets [password reuse confusion]: Students misunderstand the risks of allowing password reuse."
        }
      ],
      "detailed_explanation": {
        "core_logic": "NIST SP 800-63-4 emphasizes that longer passwords and avoiding easily guessable patterns are more effective against brute-force attacks than complex character requirements. This is because length exponentially increases the search space, making attacks computationally infeasible, whereas complex rules can still allow for predictable patterns.",
        "distractor_analysis": "The first distractor describes older, less effective complexity rules. The second focuses on forced rotation, which NIST guidance has moved away from. The third promotes password reuse, a significant security risk.",
        "analogy": "Instead of making a lock require a specific sequence of different types of turns (complex characters), it's better to make the key much longer (password length) and ensure no one uses a key that looks like a common shape (avoiding patterns)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "CRYPTO_PASSWORD_SECURITY",
        "NIST_SP_800_63"
      ]
    },
    {
      "question_text": "What is the primary purpose of using a Key Derivation Function (KDF) like PBKDF2 for password hashing?",
      "correct_answer": "To derive a strong cryptographic key from a potentially weak password, often with added salt and iterations.",
      "distractors": [
        {
          "text": "To encrypt the password hash itself for added security.",
          "misconception": "Targets [hashing vs. encryption confusion]: Students confuse key derivation with encrypting existing hashes."
        },
        {
          "text": "To generate random, unique salts for each user's password.",
          "misconception": "Targets [function confusion]: Students confuse KDFs with salt generation mechanisms."
        },
        {
          "text": "To compress the password into a fixed-size string.",
          "misconception": "Targets [hashing mechanism confusion]: Students confuse KDFs with basic hash function output properties."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Key Derivation Functions (KDFs) are designed to strengthen weak secrets like passwords by adding computational work (iterations, salt). They derive a cryptographically strong key from the password, making it much harder for attackers to brute-force the original password because each guess requires significant computation.",
        "distractor_analysis": "The first distractor incorrectly suggests KDFs encrypt hashes. The second confuses KDFs with salt generation. The third misrepresents KDFs as simple compression functions.",
        "analogy": "A KDF is like a sophisticated recipe that takes a simple ingredient (password) and, using extra steps (salt, iterations), turns it into a complex, stable compound (strong key) that's hard to reverse-engineer."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_PASSWORD_HASHING",
        "CRYPTO_KDFS",
        "CRYPTO_SALTING"
      ]
    },
    {
      "question_text": "In the context of password cracking, what is a 'dictionary attack'?",
      "correct_answer": "An attack that tries passwords from a pre-compiled list of common words, phrases, and variations.",
      "distractors": [
        {
          "text": "An attack that tries every possible combination of characters.",
          "misconception": "Targets [attack type confusion]: Students confuse dictionary attacks with brute-force attacks."
        },
        {
          "text": "An attack that exploits known vulnerabilities in the authentication system.",
          "misconception": "Targets [attack vector confusion]: Students confuse password guessing with vulnerability exploitation."
        },
        {
          "text": "An attack that intercepts password hashes transmitted over a network.",
          "misconception": "Targets [attack vector confusion]: Students confuse password guessing with network interception."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A dictionary attack is a type of password attack that leverages lists of likely passwords (dictionaries). It's faster than brute-force because it tests only probable candidates, assuming users choose common or easily guessable words, thus increasing the chance of a quick success.",
        "distractor_analysis": "The first distractor describes a brute-force attack. The second describes vulnerability exploitation. The third describes a man-in-the-middle or eavesdropping attack.",
        "analogy": "A dictionary attack is like trying to guess a word by looking through a dictionary for common words. A brute-force attack is like trying every single letter combination, even nonsensical ones, until you find the right word."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "attack",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_PASSWORD_HASHING",
        "CRYPTO_ATTACKS"
      ]
    },
    {
      "question_text": "What is the significance of 'password spraying' as a brute-force variant?",
      "correct_answer": "It involves trying a few common passwords against a large number of accounts to avoid triggering account lockouts.",
      "distractors": [
        {
          "text": "It attempts to guess the password for a single account using every possible character combination.",
          "misconception": "Targets [attack scope confusion]: Students confuse password spraying with single-account brute-force."
        },
        {
          "text": "It uses a dictionary of common passwords against a single target account.",
          "misconception": "Targets [attack scope confusion]: Students confuse password spraying with single-account dictionary attacks."
        },
        {
          "text": "It exploits a vulnerability to bypass the password check entirely.",
          "misconception": "Targets [attack vector confusion]: Students confuse password guessing with vulnerability exploitation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Password spraying is a brute-force variant designed to evade account lockout policies. It works by using a small set of common passwords against a large number of accounts, because this strategy minimizes failed login attempts per account, thus avoiding detection and lockout.",
        "distractor_analysis": "The first distractor describes a standard brute-force attack on one account. The second describes a dictionary attack on one account. The third describes a different type of attack altogether.",
        "analogy": "Password spraying is like trying the same few keys (common passwords) on many different doors (accounts) to see if any fit, rather than trying every single key on one door. This avoids alerting the owner of any single door too quickly."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "CRYPTO_PASSWORD_SECURITY",
        "CRYPTO_ACCOUNT_LOCKOUT",
        "CRYPTO_ATTACKS"
      ]
    },
    {
      "question_text": "How does adaptive multi-factor authentication (MFA) help mitigate risks associated with brute-force attacks?",
      "correct_answer": "It dynamically adjusts authentication requirements based on risk factors, potentially requiring MFA more often for suspicious login attempts.",
      "distractors": [
        {
          "text": "It replaces passwords entirely with a single, highly complex password.",
          "misconception": "Targets [MFA vs. password confusion]: Students believe MFA eliminates the need for passwords."
        },
        {
          "text": "It requires all users to use a hardware security key for every login.",
          "misconception": "Targets [MFA implementation confusion]: Students assume MFA always means hardware keys."
        },
        {
          "text": "It automatically locks accounts after the first failed login attempt.",
          "misconception": "Targets [MFA vs. lockout confusion]: Students confuse MFA's adaptive nature with strict lockout policies."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Adaptive MFA assesses risk for each login. If a login attempt appears suspicious (e.g., unusual location, time), it can trigger additional authentication factors, making brute-force attacks harder because the attacker would need to compromise both the password and the second factor.",
        "distractor_analysis": "The first distractor is incorrect; MFA adds layers, not replaces passwords. The second describes a specific MFA implementation, not the adaptive concept. The third conflates adaptive MFA with a simple, strict lockout.",
        "analogy": "Adaptive MFA is like a security guard who, based on how suspicious someone looks (risk factors), might ask for more ID (additional factors) or just let them pass. It's not a one-size-fits-all rule."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "CRYPTO_MFA",
        "CRYPTO_ACCOUNT_LOCKOUT",
        "CRYPTO_RISK_BASED_AUTH"
      ]
    },
    {
      "question_text": "What is the primary security benefit of using a password manager against brute-force attacks?",
      "correct_answer": "It enables users to create and store long, complex, and unique passwords for each service, significantly increasing the attack surface.",
      "distractors": [
        {
          "text": "It automatically encrypts all user passwords stored on the device.",
          "misconception": "Targets [mechanism confusion]: Students confuse password manager function with simple encryption."
        },
        {
          "text": "It prevents brute-force attacks by blocking IP addresses that fail logins.",
          "misconception": "Targets [defense mechanism confusion]: Students confuse password manager function with network-level defenses."
        },
        {
          "text": "It forces users to choose simple passwords that are easy to remember.",
          "misconception": "Targets [usability vs. security confusion]: Students believe password managers encourage simple passwords."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Password managers facilitate the use of strong, unique passwords by generating and storing them. This increases the complexity and length of passwords, making them exponentially harder to crack via brute-force because the attacker must overcome a much larger search space for each account.",
        "distractor_analysis": "The first distractor is partially true but misses the core benefit for attack mitigation. The second describes a firewall or IPS function, not a password manager. The third is the opposite of what password managers encourage.",
        "analogy": "A password manager is like a personal vault for your keys (passwords). It helps you create very complex, unique keys for every door (service) and keeps them safe, making it impossible for someone to pick them all."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "CRYPTO_PASSWORD_SECURITY",
        "CRYPTO_PASSWORD_MANAGERS",
        "CRYPTO_ATTACKS"
      ]
    },
    {
      "question_text": "Why is it important to use a strong, unique salt for each password hash?",
      "correct_answer": "It ensures that identical passwords result in different hashes, preventing attackers from using precomputed tables (like rainbow tables) effectively.",
      "distractors": [
        {
          "text": "It allows the system to recover the original password if the salt is lost.",
          "misconception": "Targets [salt purpose confusion]: Students believe salts aid in password recovery."
        },
        {
          "text": "It encrypts the password hash to protect it from unauthorized access.",
          "misconception": "Targets [hashing vs. encryption confusion]: Students confuse salting with encryption."
        },
        {
          "text": "It reduces the overall size of the stored password hash.",
          "misconception": "Targets [salt impact confusion]: Students misunderstand that salt increases, not decreases, storage size."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A unique salt is appended to each password before hashing. This means even if two users have the same password, their resulting hashes will be different because the salts are unique. Therefore, attackers cannot use precomputed rainbow tables, which rely on identical hashes for identical passwords, because each hash is now unique to its specific password-salt combination.",
        "distractor_analysis": "The first distractor is incorrect; salts are not for recovery. The second confuses salting with encryption. The third is incorrect; salts add to the storage size.",
        "analogy": "Imagine each person adding a unique, secret spice blend (salt) to the same base ingredient (password) before making a final dish (hash). Even if the base ingredient is the same, the final dish will taste different due to the unique spice blend."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_PASSWORD_HASHING",
        "CRYPTO_SALTING",
        "CRYPTO_RAINBOW_TABLES"
      ]
    },
    {
      "question_text": "What is the primary difference between a brute-force attack and a hybrid attack on passwords?",
      "correct_answer": "A hybrid attack combines brute-force methods with dictionary attacks, often by adding numbers or symbols to dictionary words.",
      "distractors": [
        {
          "text": "A brute-force attack tries all combinations, while a hybrid attack only uses dictionary words.",
          "misconception": "Targets [attack scope confusion]: Students confuse the scope and methods of brute-force and hybrid attacks."
        },
        {
          "text": "A brute-force attack targets network protocols, while a hybrid attack targets password hashes.",
          "misconception": "Targets [attack target confusion]: Students confuse the targets of different password attack types."
        },
        {
          "text": "A brute-force attack uses GPUs, while a hybrid attack uses CPUs.",
          "misconception": "Targets [hardware usage confusion]: Students associate specific hardware with specific attack types."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Hybrid attacks are a refinement of dictionary attacks. They start with a wordlist but then systematically modify those words by appending, prepending, or substituting characters (like numbers or symbols), effectively blending dictionary and brute-force techniques. This makes them more efficient than pure brute-force because they focus on likely password patterns.",
        "distractor_analysis": "The first distractor incorrectly limits hybrid attacks to only dictionary words. The second confuses the targets of password attacks. The third incorrectly assigns hardware exclusively to one attack type.",
        "analogy": "A pure brute-force attack is like trying every single key on a keychain. A hybrid attack is like trying common keys first, then modifying them slightly (e.g., adding a keychain charm) before trying again."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "CRYPTO_PASSWORD_HASHING",
        "CRYPTO_ATTACKS"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Brute-Force Password Cracking 001_Cryptography best practices",
    "latency_ms": 25929.442000000003
  },
  "timestamp": "2026-01-18T15:45:55.628254"
}