{
  "topic_title": "PowerShell Script Signing",
  "category": "001_Cryptography - 009_Public Key Infrastructure (PKI)",
  "flashcards": [
    {
      "question_text": "What is the primary purpose of signing PowerShell scripts?",
      "correct_answer": "To ensure the authenticity and integrity of the script, verifying its origin and that it hasn't been tampered with.",
      "distractors": [
        {
          "text": "To encrypt the script content, making it unreadable to unauthorized users.",
          "misconception": "Targets [encryption vs signing confusion]: Students who believe signing is a form of confidentiality."
        },
        {
          "text": "To automatically install the script on the target system.",
          "misconception": "Targets [misunderstanding of signing mechanism]: Students who confuse signing with deployment or execution."
        },
        {
          "text": "To reduce the file size of the script for faster transmission.",
          "misconception": "Targets [unrelated benefit]: Students who associate digital signatures with file optimization."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Signing a PowerShell script uses a digital certificate to create a signature that verifies the script's origin and ensures its content has not been altered since it was signed. This is crucial for security policies like RemoteSigned.",
        "distractor_analysis": "The first distractor confuses signing with encryption, which provides confidentiality. The second incorrectly suggests signing is for installation. The third proposes a benefit unrelated to digital signatures.",
        "analogy": "Signing a script is like a notary public stamping a document. The notary's stamp verifies the identity of the person who signed the document and confirms the document hasn't been altered since it was notarized."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_SIGNING_BASICS",
        "PKI_CERTIFICATES"
      ]
    },
    {
      "question_text": "Which PowerShell execution policy requires scripts to have a digital signature from a trusted publisher?",
      "correct_answer": "AllSigned",
      "distractors": [
        {
          "text": "Restricted",
          "misconception": "Targets [policy misunderstanding]: Students who confuse 'no execution' with 'signed execution'."
        },
        {
          "text": "Unrestricted",
          "misconception": "Targets [policy misunderstanding]: Students who think any policy allows all scripts without checks."
        },
        {
          "text": "RemoteSigned",
          "misconception": "Targets [policy nuance confusion]: Students who know RemoteSigned requires signing but not for all scripts."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'AllSigned' execution policy mandates that all scripts, whether local or remote, must possess a valid digital signature from a trusted publisher. This ensures that only verified and untampered code can be executed.",
        "distractor_analysis": "'Restricted' prevents all scripts, 'Unrestricted' allows all scripts, and 'RemoteSigned' allows local scripts to be unsigned but requires remote scripts to be signed.",
        "analogy": "Imagine a security checkpoint. 'AllSigned' is like requiring every person to have a verified ID badge from the organization before entering, no exceptions. 'RemoteSigned' is like allowing employees to enter without an ID if they are already inside the building, but requiring it for visitors."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "POWERSHELL_EXECUTION_POLICIES"
      ]
    },
    {
      "question_text": "What is the role of a code-signing certificate in PowerShell?",
      "correct_answer": "It binds a digital signature to a script, asserting the identity of the publisher and the script's integrity.",
      "distractors": [
        {
          "text": "It encrypts the script's content to protect its confidentiality.",
          "misconception": "Targets [encryption vs signing confusion]: Students who believe certificates are primarily for encryption."
        },
        {
          "text": "It grants the script elevated privileges to run on the system.",
          "misconception": "Targets [privilege confusion]: Students who associate certificates with permission granting."
        },
        {
          "text": "It provides a timestamp to indicate when the script was last modified.",
          "misconception": "Targets [timestamping confusion]: Students who mix code signing with file versioning or timestamping."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A code-signing certificate, issued by a trusted Certificate Authority (CA), is used with Authenticode to digitally sign scripts. This process creates a signature that confirms the script's publisher and ensures it hasn't been altered since signing, aligning with PKI principles.",
        "distractor_analysis": "Certificates for code signing do not encrypt script content; that's a separate cryptographic function. They don't grant privileges directly, and while timestamps can be included, their primary role is not to indicate modification time.",
        "analogy": "A code-signing certificate is like a wax seal on a letter. The seal, imprinted with a unique crest (the certificate's identity), proves who sent the letter and that it hasn't been opened or tampered with."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PKI_CERTIFICATES",
        "CRYPTO_SIGNING"
      ]
    },
    {
      "question_text": "Which PowerShell cmdlet is used to sign a script file with a specified certificate?",
      "correct_answer": "Set-AuthenticodeSignature",
      "distractors": [
        {
          "text": "New-SelfSignedCertificate",
          "misconception": "Targets [certificate generation vs signing confusion]: Students who confuse creating a certificate with using it to sign."
        },
        {
          "text": "Get-AuthenticodeSignature",
          "misconception": "Targets [cmdlet function confusion]: Students who confuse verifying a signature with applying one."
        },
        {
          "text": "Set-ExecutionPolicy",
          "misconception": "Targets [cmdlet purpose confusion]: Students who confuse managing execution policies with signing scripts."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>Set-AuthenticodeSignature</code> cmdlet applies an Authenticode signature to a script file using a specified code-signing certificate. This process is fundamental to PowerShell script security and compliance with execution policies.",
        "distractor_analysis": "<code>New-SelfSignedCertificate</code> creates certificates, <code>Get-AuthenticodeSignature</code> verifies them, and <code>Set-ExecutionPolicy</code> manages system-wide script execution rules.",
        "analogy": "If signing a script is like sealing a letter, <code>Set-AuthenticodeSignature</code> is the tool (like a stamp or wax seal applicator) you use to apply the seal to the envelope."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "POWERSHELL_CMDLETS",
        "CRYPTO_SIGNING"
      ]
    },
    {
      "question_text": "When using <code>New-SelfSignedCertificate</code> in PowerShell for code signing, what is the purpose of the <code>-CodeSigningCert</code> parameter?",
      "correct_answer": "It specifies that the certificate should be created with the intended purpose of code signing.",
      "distractors": [
        {
          "text": "It ensures the certificate is automatically trusted by all systems.",
          "misconception": "Targets [trust model confusion]: Students who believe self-signed certificates are inherently trusted."
        },
        {
          "text": "It encrypts the private key associated with the certificate.",
          "misconception": "Targets [key management confusion]: Students who confuse certificate creation parameters with key protection."
        },
        {
          "text": "It automatically signs the script using the newly created certificate.",
          "misconception": "Targets [signing process confusion]: Students who confuse certificate generation with the signing action."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>-CodeSigningCert</code> parameter, when used with <code>New-SelfSignedCertificate</code>, configures the certificate's Extended Key Usage (EKU) to specifically allow for code signing. This is essential for the certificate to be recognized and used correctly by signing tools like <code>Set-AuthenticodeSignature</code>.",
        "distractor_analysis": "Self-signed certificates are not automatically trusted by default. The parameter relates to the certificate's purpose, not private key encryption or the act of signing the script itself.",
        "analogy": "When ordering a custom tool, specifying 'for woodworking' (<code>-CodeSigningCert</code>) ensures the tool is designed for that specific task, rather than being a general-purpose tool or one for metalworking."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PKI_CERTIFICATES",
        "POWERSHELL_CMDLETS"
      ]
    },
    {
      "question_text": "What is a potential security risk if a PowerShell script is signed with a compromised code-signing certificate?",
      "correct_answer": "Malicious code could be signed and appear legitimate, bypassing execution policy checks and deceiving users.",
      "distractors": [
        {
          "text": "The script would be automatically deleted by PowerShell.",
          "misconception": "Targets [unrelated security response]: Students who assume a compromised certificate triggers automatic deletion."
        },
        {
          "text": "The certificate would be immediately revoked by the CA.",
          "misconception": "Targets [revocation process confusion]: Students who think revocation is instantaneous and automatic upon compromise."
        },
        {
          "text": "The script's execution would be significantly slowed down.",
          "misconception": "Targets [performance confusion]: Students who associate certificate compromise with performance degradation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "If a code-signing certificate is compromised, an attacker can use it to sign malicious scripts, making them appear trustworthy and authentic. This bypasses security measures like PowerShell's execution policies, allowing the malware to run and potentially cause significant damage.",
        "distractor_analysis": "PowerShell does not automatically delete scripts due to certificate compromise. Revocation by a CA is a process that takes time. Performance degradation is not a direct consequence of a compromised signing certificate.",
        "analogy": "If a trusted organization's official stamp (the compromised certificate) falls into the wrong hands, counterfeit documents bearing that stamp can be created, making them look official and fooling people into accepting them."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "CRYPTO_SIGNING_COMPROMISE",
        "PKI_CERTIFICATE_AUTHORITY"
      ]
    },
    {
      "question_text": "Which of the following is NOT a file type that PowerShell checks for Authenticode signatures?",
      "correct_answer": ".txt",
      "distractors": [
        {
          "text": ".ps1",
          "misconception": "Targets [file type knowledge]: Students who don't know common script file extensions."
        },
        {
          "text": ".psm1",
          "misconception": "Targets [file type knowledge]: Students who don't know common module file extensions."
        },
        {
          "text": ".psd1",
          "misconception": "Targets [file type knowledge]: Students who don't know common manifest/data file extensions."
        }
      ],
      "detailed_explanation": {
        "core_logic": "PowerShell's Authenticode signature checking applies to executable script files and module-related files like <code>.ps1</code>, <code>.psm1</code>, and <code>.psd1</code>. Plain text files (<code>.txt</code>) are not typically checked for digital signatures as they are not executable code.",
        "distractor_analysis": "PowerShell specifically checks <code>.ps1</code> (scripts), <code>.psm1</code> (modules), and <code>.psd1</code> (module manifests/data) files for signatures. <code>.txt</code> files are general text documents and do not fall under this security check.",
        "analogy": "Think of checking for official seals on documents. PowerShell checks seals on official reports (<code>.ps1</code>), policy documents (<code>.psm1</code>), and supporting data sheets (<code>.psd1</code>), but not on simple notes (<code>.txt</code>)."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "POWERSHELL_FILE_TYPES"
      ]
    },
    {
      "question_text": "What is the primary difference between <code>AllSigned</code> and <code>RemoteSigned</code> execution policies in PowerShell regarding script signing?",
      "correct_answer": "<code>AllSigned</code> requires all scripts (local and remote) to be signed, while <code>RemoteSigned</code> only requires remote scripts to be signed.",
      "distractors": [
        {
          "text": "<code>AllSigned</code> requires signing only for remote scripts, while <code>RemoteSigned</code> requires signing for all scripts.",
          "misconception": "Targets [policy scope confusion]: Students who reverse the scope of the policies."
        },
        {
          "text": "<code>AllSigned</code> uses asymmetric encryption for signing, while <code>RemoteSigned</code> uses symmetric encryption.",
          "misconception": "Targets [encryption type confusion]: Students who mix signing policies with encryption algorithms."
        },
        {
          "text": "<code>AllSigned</code> checks for publisher trust, while <code>RemoteSigned</code> only checks for file integrity.",
          "misconception": "Targets [trust vs integrity confusion]: Students who misunderstand what each policy verifies."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>AllSigned</code> policy enforces that every script, regardless of its origin (local or remote), must have a valid digital signature. In contrast, <code>RemoteSigned</code> allows locally created scripts to run unsigned but mandates that scripts downloaded from remote sources must be signed, providing a balance between security and convenience.",
        "distractor_analysis": "The first distractor incorrectly swaps the signing requirements for local and remote scripts. The second introduces irrelevant encryption types. The third misrepresents what each policy verifies.",
        "analogy": "Imagine two security guards at a building entrance. The 'AllSigned' guard checks everyone's ID, whether they work there or are visitors. The 'RemoteSigned' guard only checks IDs for visitors; employees who are already inside can enter without an ID."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "POWERSHELL_EXECUTION_POLICIES"
      ]
    },
    {
      "question_text": "In the context of PowerShell script signing, what does it mean for a certificate to be 'trusted'?",
      "correct_answer": "The certificate's issuer (Certificate Authority) is recognized and trusted by the operating system or PowerShell environment.",
      "distractors": [
        {
          "text": "The certificate has been personally vouched for by the user running the script.",
          "misconception": "Targets [trust model confusion]: Students who think trust is solely user-defined for system policies."
        },
        {
          "text": "The certificate is stored in the local machine's registry.",
          "misconception": "Targets [storage vs trust confusion]: Students who confuse certificate location with its trust status."
        },
        {
          "text": "The certificate has a very long validity period.",
          "misconception": "Targets [attribute confusion]: Students who associate trust with certificate lifespan."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A 'trusted' certificate in PowerShell script signing means its issuing Certificate Authority (CA) is present in the system's trusted root certificate store. This trust chain allows PowerShell to validate the authenticity of the signature applied by the certificate.",
        "distractor_analysis": "User-level trust is insufficient for system-wide execution policies. Storage location doesn't guarantee trust. While validity period is important, it's distinct from the trust established by the CA's presence in the trusted store.",
        "analogy": "Trusting a certificate is like recognizing a government-issued ID. If the ID was issued by a recognized government agency (the CA), you trust it. If it's homemade or from an unknown source, you don't."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PKI_TRUST_MODEL",
        "CRYPTO_SIGNING"
      ]
    },
    {
      "question_text": "What is the purpose of a timestamp server when signing PowerShell scripts?",
      "correct_answer": "To cryptographically prove that the script was signed at a specific time, preventing issues with expired certificates.",
      "distractors": [
        {
          "text": "To encrypt the script content before signing.",
          "misconception": "Targets [encryption vs timestamping confusion]: Students who confuse timestamping with confidentiality."
        },
        {
          "text": "To verify the identity of the script's author.",
          "misconception": "Targets [identity vs time confusion]: Students who believe timestamps verify authorship."
        },
        {
          "text": "To automatically update the script's version number.",
          "misconception": "Targets [versioning confusion]: Students who associate timestamps with software version control."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Timestamping a signed script provides proof that the signature was applied before the signing certificate expired. This is crucial because certificates have a limited validity period, and a signature made with a valid certificate remains trusted even after the certificate expires, thanks to the timestamp.",
        "distractor_analysis": "Timestamping is not encryption. It verifies the time of signing, not the author's identity directly (that's the certificate's job). It's also separate from version control.",
        "analogy": "A timestamp on a signed document is like a postmark on a mailed letter. It proves the letter was sent on a certain date, even if the stamp itself (the certificate) later becomes invalid."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_SIGNING",
        "PKI_CERTIFICATES"
      ]
    },
    {
      "question_text": "Consider a scenario where a PowerShell script is signed with a certificate that is later revoked. How does PowerShell typically handle this script's execution under the <code>RemoteSigned</code> policy?",
      "correct_answer": "The script will likely be blocked because PowerShell checks for revocation status, even if the signature was valid at the time of signing.",
      "distractors": [
        {
          "text": "The script will execute without issue, as the signature was valid when applied.",
          "misconception": "Targets [revocation status confusion]: Students who believe signature validity is static and ignores revocation."
        },
        {
          "text": "PowerShell will prompt the user to manually trust the script.",
          "misconception": "Targets [user interaction confusion]: Students who assume manual intervention for all policy exceptions."
        },
        {
          "text": "The script will be automatically quarantined and analyzed for malware.",
          "misconception": "Targets [automated response confusion]: Students who assume a specific automated response for revoked signatures."
        }
      ],
      "detailed_explanation": {
        "core_logic": "While a timestamp proves a signature was valid when applied, modern security practices and PowerShell's <code>RemoteSigned</code> policy often involve checking the current revocation status of the signing certificate. If the certificate has been revoked, PowerShell will typically block the script's execution to prevent potential risks from compromised keys.",
        "distractor_analysis": "Execution is usually blocked if a certificate is revoked, not allowed to proceed based solely on the original validity. Manual prompting is less common for policy enforcement than outright blocking. Automatic quarantine is not the standard response for revoked signatures.",
        "analogy": "Imagine a security pass that was valid yesterday but was reported stolen today. Even though it was valid when issued, the security guard (PowerShell) will deny entry because the pass is now known to be compromised (revoked)."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "scenario",
      "bloom_level": "analyze",
      "prerequisites": [
        "POWERSHELL_EXECUTION_POLICIES",
        "PKI_REVOCATION"
      ]
    },
    {
      "question_text": "What is the CA/Browser Forum's role concerning code signing certificates used for PowerShell scripts?",
      "correct_answer": "They establish baseline requirements for the issuance and management of publicly-trusted code signing certificates.",
      "distractors": [
        {
          "text": "They develop and maintain the PowerShell scripting language.",
          "misconception": "Targets [organizational role confusion]: Students who confuse PKI standards bodies with language developers."
        },
        {
          "text": "They directly issue all code signing certificates to developers.",
          "misconception": "Targets [issuance process confusion]: Students who believe the forum itself is a Certificate Authority."
        },
        {
          "text": "They enforce specific PowerShell execution policies on end-user systems.",
          "misconception": "Targets [policy enforcement confusion]: Students who confuse standards bodies with OS/application policy managers."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The CA/Browser Forum sets industry-wide standards (Baseline Requirements) for Certificate Authorities (CAs) that issue publicly trusted code signing certificates. These requirements ensure a baseline level of security and trust, which indirectly impacts how PowerShell handles signed scripts by defining the trustworthiness of the issuing CAs.",
        "distractor_analysis": "The CA/Browser Forum is a standards body, not a language developer, direct certificate issuer, or policy enforcer for specific applications like PowerShell.",
        "analogy": "The CA/Browser Forum is like a building code committee. They don't build the houses (issue certificates) or enforce local zoning laws (PowerShell policies), but they set the safety standards (baseline requirements) that builders must follow."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PKI_CERTIFICATE_AUTHORITY",
        "CYBERSECURITY_STANDARDS"
      ]
    },
    {
      "question_text": "Why is it important to use a separate, dedicated code-signing certificate for PowerShell scripts rather than reusing a personal SSL/TLS certificate?",
      "correct_answer": "Code-signing certificates have specific Extended Key Usage (EKU) attributes for code signing, and separating them minimizes the risk if one type of certificate is compromised.",
      "distractors": [
        {
          "text": "Personal SSL/TLS certificates are too short-lived for signing scripts.",
          "misconception": "Targets [certificate type confusion]: Students who confuse validity periods of different certificate types."
        },
        {
          "text": "Code-signing certificates use symmetric encryption, while SSL/TLS uses asymmetric.",
          "misconception": "Targets [encryption type confusion]: Students who mix certificate types with encryption algorithms."
        },
        {
          "text": "PowerShell only recognizes certificates explicitly marked for code signing.",
          "misconception": "Targets [technical limitation confusion]: Students who believe PowerShell has rigid, hardcoded certificate type checks."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Code-signing certificates are specifically issued and configured with the 'Code Signing' EKU, differentiating them from SSL/TLS certificates used for website authentication. Using separate certificates adheres to the principle of least privilege and limits the blast radius if one type is compromised, as the compromise of an SSL certificate wouldn't automatically allow an attacker to sign malicious code.",
        "distractor_analysis": "While validity periods differ, it's not the primary reason for separation. Both code signing and SSL/TLS typically use asymmetric cryptography. PowerShell relies on the EKU attribute, not a rigid type check, to determine suitability for signing.",
        "analogy": "It's like using different tools for different jobs. You wouldn't use a hammer (SSL/TLS cert) to tighten a screw (code signing); you use the right tool (code-signing cert) for the specific task to ensure effectiveness and avoid damaging the wrong tool."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "PKI_CERTIFICATES",
        "CRYPTO_SIGNING"
      ]
    },
    {
      "question_text": "What is the function of the <code>Get-AuthenticodeSignature</code> cmdlet?",
      "correct_answer": "To retrieve the signature information for a specified file, including the signer's certificate and validity status.",
      "distractors": [
        {
          "text": "To apply a new Authenticode signature to a file.",
          "misconception": "Targets [cmdlet function confusion]: Students who confuse verification with application of signatures."
        },
        {
          "text": "To generate a new self-signed certificate.",
          "misconception": "Targets [cmdlet purpose confusion]: Students who confuse signature verification with certificate generation."
        },
        {
          "text": "To change the PowerShell execution policy for the current session.",
          "misconception": "Targets [cmdlet scope confusion]: Students who confuse signature inspection with policy management."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>Get-AuthenticodeSignature</code> cmdlet is used to inspect the digital signature of a file. It returns details about the signature, such as the certificate used, the timestamp, and whether the signature is valid according to the system's trust store and revocation checks, thereby enabling verification.",
        "distractor_analysis": "<code>Set-AuthenticodeSignature</code> applies signatures. <code>New-SelfSignedCertificate</code> creates certificates. <code>Set-ExecutionPolicy</code> manages execution policies.",
        "analogy": "If <code>Set-AuthenticodeSignature</code> is like applying a seal to a document, <code>Get-AuthenticodeSignature</code> is like examining that seal to ensure it's intact, authentic, and applied by someone trustworthy."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "POWERSHELL_CMDLETS",
        "CRYPTO_SIGNING"
      ]
    },
    {
      "question_text": "In PowerShell, what is the primary security benefit of signing scripts using a certificate from a publicly trusted Certificate Authority (CA) versus a self-signed certificate?",
      "correct_answer": "Scripts signed with a publicly trusted CA certificate are automatically trusted by the operating system, whereas self-signed certificates require manual trust configuration.",
      "distractors": [
        {
          "text": "Publicly trusted CA certificates are inherently more secure against brute-force attacks.",
          "misconception": "Targets [security attribute confusion]: Students who confuse trust model with cryptographic strength."
        },
        {
          "text": "Self-signed certificates cannot be used with the <code>AllSigned</code> execution policy.",
          "misconception": "Targets [policy restriction confusion]: Students who misunderstand policy requirements for self-signed certs."
        },
        {
          "text": "Publicly trusted CA certificates guarantee the script will run faster.",
          "misconception": "Targets [performance confusion]: Students who associate trust with execution speed."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Certificates from publicly trusted CAs are pre-installed in the operating system's trusted root store, meaning PowerShell automatically trusts signatures made with them. Self-signed certificates, conversely, are not inherently trusted and must be explicitly added to the trusted store, which is a manual administrative step.",
        "distractor_analysis": "The cryptographic strength of the certificate itself isn't necessarily higher for public CAs; the trust is in the CA's vetting process. Self-signed certificates *can* be used with <code>AllSigned</code> if manually trusted. Trust does not directly impact script execution speed.",
        "analogy": "A publicly trusted CA is like a government-issued passport – automatically recognized worldwide. A self-signed certificate is like a homemade ID – it might be valid for you, but others need to explicitly accept it as legitimate."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "PKI_TRUST_MODEL",
        "CRYPTO_SIGNING"
      ]
    },
    {
      "question_text": "What is the main difference in how PowerShell handles unsigned scripts under the <code>Restricted</code> and <code>RemoteSigned</code> execution policies?",
      "correct_answer": "Under <code>Restricted</code>, all scripts are blocked regardless of origin; under <code>RemoteSigned</code>, unsigned scripts created locally are allowed, but remote ones are blocked.",
      "distractors": [
        {
          "text": "<code>Restricted</code> blocks only remote unsigned scripts, while <code>RemoteSigned</code> blocks all unsigned scripts.",
          "misconception": "Targets [policy scope confusion]: Students who reverse the blocking behavior of the policies."
        },
        {
          "text": "<code>Restricted</code> allows unsigned scripts if they are digitally signed, while <code>RemoteSigned</code> blocks all unsigned scripts.",
          "misconception": "Targets [signing requirement confusion]: Students who misunderstand the role of signing in each policy."
        },
        {
          "text": "<code>Restricted</code> requires scripts to be signed by a specific Microsoft CA, while <code>RemoteSigned</code> accepts any signature.",
          "misconception": "Targets [CA trust confusion]: Students who misunderstand the trust requirements for each policy."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>Restricted</code> execution policy is the most secure, preventing any script execution. The <code>RemoteSigned</code> policy offers a balance by allowing locally created unsigned scripts to run while enforcing digital signatures for scripts originating from remote sources, thus mitigating risks from untrusted downloads.",
        "distractor_analysis": "The first distractor incorrectly defines the scope of blocking for both policies. The second confuses the requirement for signing with the policy's stance on unsigned scripts. The third introduces a specific CA requirement not inherent to these policies.",
        "analogy": "Imagine two security gates. The 'Restricted' gate is always closed. The 'RemoteSigned' gate is open for people already inside the facility (local scripts) but requires a valid pass for anyone coming from outside (remote scripts)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "POWERSHELL_EXECUTION_POLICIES"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 16,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "PowerShell Script Signing 001_Cryptography best practices",
    "latency_ms": 23333.699
  },
  "timestamp": "2026-01-18T16:08:46.000403",
  "_av_safe_encoded": true,
  "_encoding_note": "Educational content encoded with HTML entities to prevent antivirus false positives. Content renders normally in Anki."
}