{
  "topic_title": "Authenticode Signing",
  "category": "001_Cryptography - 009_Public Key Infrastructure (PKI)",
  "flashcards": [
    {
      "question_text": "What is the primary purpose of Authenticode signing in software distribution?",
      "correct_answer": "To provide assurance of the software publisher's identity and that the code has not been tampered with since it was signed.",
      "distractors": [
        {
          "text": "To encrypt the software to protect its intellectual property from reverse engineering.",
          "misconception": "Targets [encryption vs integrity confusion]: Students who believe encryption inherently provides integrity and protection against modification."
        },
        {
          "text": "To verify that the software meets specific performance benchmarks.",
          "misconception": "Targets [performance vs authenticity confusion]: Students who confuse code signing with software quality assurance or performance testing."
        },
        {
          "text": "To automatically update the software to the latest version available.",
          "misconception": "Targets [signing vs update mechanism confusion]: Students who conflate the act of signing with software update delivery mechanisms."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Authenticode signing uses digital signatures to verify the publisher's identity and ensure code integrity, because it leverages public-key cryptography to create a tamper-evident seal.",
        "distractor_analysis": "The first distractor incorrectly equates signing with encryption for IP protection. The second confuses signing with performance validation. The third mixes signing with software update functionality.",
        "analogy": "Think of Authenticode like a notary seal on a document. The notary's stamp verifies who signed the document and that the document hasn't been altered since it was notarized, but it doesn't encrypt the document's contents."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PKI_BASICS",
        "DIGITAL_SIGNATURES"
      ]
    },
    {
      "question_text": "Which cryptographic primitive is fundamental to Authenticode signing?",
      "correct_answer": "Digital Signatures",
      "distractors": [
        {
          "text": "Symmetric Encryption",
          "misconception": "Targets [symmetric vs asymmetric confusion]: Students who don't differentiate between encryption methods and digital signatures."
        },
        {
          "text": "Hashing Algorithms",
          "misconception": "Targets [hashing vs signing confusion]: Students who understand hashing is involved but miss that it's part of a larger digital signature process."
        },
        {
          "text": "Key Derivation Functions",
          "misconception": "Targets [key derivation vs signing confusion]: Students who confuse functions that generate keys with those that create signatures."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Digital signatures are essential because they provide non-repudiation and integrity, which are achieved by signing a hash of the code with the publisher's private key.",
        "distractor_analysis": "Symmetric encryption is for confidentiality, not integrity verification. Hashing is a component, but not the primary primitive for signing. Key derivation functions generate keys, not signatures.",
        "analogy": "Digital signatures are like a handwritten signature on a contract. They prove who agreed to the terms (identity) and that the contract hasn't been changed after signing (integrity)."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "DIGITAL_SIGNATURES",
        "PUBLIC_KEY_CRYPTOGRAPHY"
      ]
    },
    {
      "question_text": "What role does a hash function play in Authenticode signing?",
      "correct_answer": "It creates a fixed-size digest of the code, which is then encrypted with the private key to form the digital signature.",
      "distractors": [
        {
          "text": "It encrypts the entire code file to ensure confidentiality.",
          "misconception": "Targets [hashing vs encryption confusion]: Students who believe hashing itself provides confidentiality or encrypts the data."
        },
        {
          "text": "It verifies the identity of the software publisher.",
          "misconception": "Targets [hashing vs identity verification confusion]: Students who confuse the role of hashing with the role of the digital certificate in identity verification."
        },
        {
          "text": "It generates a unique key pair for signing the code.",
          "misconception": "Targets [hashing vs key generation confusion]: Students who mix up the purpose of hashing with key generation processes."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Hashing is crucial because it creates a unique, fixed-size fingerprint of the code. This digest is then signed, ensuring that even a minor change to the code results in a different hash, thus invalidating the signature.",
        "distractor_analysis": "The first distractor incorrectly assigns encryption and confidentiality to hashing. The second assigns identity verification, which is the certificate's role. The third confuses hashing with key pair generation.",
        "analogy": "A hash function is like creating a unique summary or checksum for a book. If even one letter in the book is changed, the summary will be completely different, indicating the book has been altered."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_HASHING",
        "DIGITAL_SIGNATURES"
      ]
    },
    {
      "question_text": "What is the purpose of the digital certificate associated with an Authenticode signature?",
      "correct_answer": "To bind the public key to the identity of the software publisher, allowing verification of the signature.",
      "distractors": [
        {
          "text": "To encrypt the software code itself for protection.",
          "misconception": "Targets [certificate vs encryption confusion]: Students who believe certificates are used for encrypting the software content."
        },
        {
          "text": "To provide a timestamp for when the code was originally created.",
          "misconception": "Targets [certificate vs timestamping confusion]: Students who confuse the certificate's role with that of a timestamping authority."
        },
        {
          "text": "To store the actual software code that is being signed.",
          "misconception": "Targets [certificate vs code storage confusion]: Students who think the certificate contains the software itself."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The digital certificate is vital because it acts as a verifiable credential, linking the public key used for signature verification to a specific, trusted entity (the publisher), thereby establishing authenticity.",
        "distractor_analysis": "Certificates do not encrypt the code. While they can be used with timestamping authorities, their primary role isn't to provide the timestamp itself. They do not store the software code.",
        "analogy": "A digital certificate is like an ID card issued by a trusted authority (like a government). It proves who you are and contains information (like your public key) that others can use to verify your identity."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PKI_CERTIFICATES",
        "DIGITAL_SIGNATURES"
      ]
    },
    {
      "question_text": "When verifying an Authenticode signature, what is the first step a system typically performs?",
      "correct_answer": "It extracts the public key from the digital certificate embedded within the signature.",
      "distractors": [
        {
          "text": "It decrypts the entire software code using the publisher's private key.",
          "misconception": "Targets [verification vs decryption confusion]: Students who confuse signature verification with decrypting the software."
        },
        {
          "text": "It sends the code to a trusted third-party server for validation.",
          "misconception": "Targets [local vs remote verification confusion]: Students who believe signature verification always requires an external server."
        },
        {
          "text": "It compares the code's current hash with a pre-stored hash value.",
          "misconception": "Targets [pre-stored hash vs signature verification confusion]: Students who think verification relies on a pre-existing hash rather than the signature itself."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Verification begins with obtaining the public key because it's necessary to decrypt the signature hash. This allows comparison with a newly computed hash of the code, confirming integrity.",
        "distractor_analysis": "Verification uses the public key to decrypt the signature, not the private key to decrypt the code. While some checks might involve network lookups (like CRLs), the core verification is local. Verification uses the signature, not a pre-stored hash.",
        "analogy": "To verify a signature on a check, you first look at the signature itself and then compare it to a known sample of the person's signature (their 'public key' equivalent) to see if they match."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "DIGITAL_SIGNATURE_VERIFICATION",
        "PKI_CERTIFICATES"
      ]
    },
    {
      "question_text": "What is the role of a Timestamping Authority (TSA) in the context of Authenticode signing?",
      "correct_answer": "To cryptographically prove that the code was signed at a specific point in time, even if the signing certificate later expires or is revoked.",
      "distractors": [
        {
          "text": "To encrypt the code to ensure its confidentiality.",
          "misconception": "Targets [timestamping vs encryption confusion]: Students who confuse the purpose of a TSA with encryption services."
        },
        {
          "text": "To verify the identity of the software publisher.",
          "misconception": "Targets [timestamping vs identity verification confusion]: Students who believe a TSA is responsible for publisher identity verification."
        },
        {
          "text": "To generate the private key used for signing the code.",
          "misconception": "Targets [timestamping vs key generation confusion]: Students who confuse the TSA's function with private key management."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A TSA is important because it provides an immutable record of when a signature was applied. This ensures that a signature remains valid even after the signing certificate's expiry, as the timestamp proves it was valid at the time of signing.",
        "distractor_analysis": "TSAs do not encrypt code. Publisher identity is verified by the Certificate Authority (CA) that issued the signing certificate, not the TSA. TSAs do not generate private keys.",
        "analogy": "A timestamp is like a postmark on a letter. It proves when the letter was sent, regardless of when you receive it or if the sender's address later becomes invalid."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "TIMESTAMPING_AUTHORITY",
        "DIGITAL_SIGNATURES"
      ]
    },
    {
      "question_text": "Which of the following scenarios would MOST likely lead to an Authenticode signature verification failure due to tampering?",
      "correct_answer": "A malicious actor modifies a single byte within the executable file after it has been signed.",
      "distractors": [
        {
          "text": "The signing certificate has expired, but a valid timestamp was applied.",
          "misconception": "Targets [expired certificate vs valid timestamp confusion]: Students who believe an expired certificate always invalidates a signature, ignoring the role of timestamps."
        },
        {
          "text": "The software is copied to a different operating system.",
          "misconception": "Targets [platform compatibility vs tampering confusion]: Students who confuse platform compatibility issues with code tampering."
        },
        {
          "text": "The user's antivirus software flags the executable as potentially unwanted.",
          "misconception": "Targets [AV flagging vs signature tampering confusion]: Students who confuse antivirus heuristics or warnings with actual signature invalidation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Tampering fails verification because modifying even a single bit changes the code's hash. Since the signature is based on the original hash, the mismatch proves the code was altered after signing.",
        "distractor_analysis": "A valid timestamp can keep an expired signature valid. Platform differences don't alter the signed code itself. Antivirus flags are separate from signature integrity checks.",
        "analogy": "If you change a single word in a book after it's been summarized, the new summary won't match the original, indicating the book was altered."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "analyze",
      "prerequisites": [
        "DIGITAL_SIGNATURE_VERIFICATION",
        "CRYPTO_HASHING"
      ]
    },
    {
      "question_text": "What is the primary security benefit provided by the CA/Browser Forum's Baseline Requirements for Code Signing Certificates?",
      "correct_answer": "To establish a consistent and rigorous set of rules for Certificate Authorities (CAs) to follow, enhancing trust in code signing.",
      "distractors": [
        {
          "text": "To mandate specific encryption algorithms for all code signing.",
          "misconception": "Targets [requirements vs algorithm mandate confusion]: Students who believe requirements dictate specific algorithms rather than processes."
        },
        {
          "text": "To provide a free, global repository of all signed software.",
          "misconception": "Targets [requirements vs software repository confusion]: Students who confuse policy documents with software distribution platforms."
        },
        {
          "text": "To automatically revoke any certificate found to be misused.",
          "misconception": "Targets [requirements vs automated revocation confusion]: Students who believe requirements automatically enforce revocation without process."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The Baseline Requirements are crucial because they standardize practices among CAs, ensuring a higher level of trust and security for publicly-trusted code signing certificates, as outlined by [cabforum.org](https://cabforum.org/working-groups/code-signing/requirements/).",
        "distractor_analysis": "The requirements focus on processes and policies, not mandating specific algorithms. They do not create a software repository. Automated revocation is a function of CA operations, not the requirements document itself.",
        "analogy": "The Baseline Requirements are like building codes for houses. They ensure all houses are built to a minimum safety standard, making them more trustworthy and reliable."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PKI_STANDARDS",
        "CODE_SIGNING_CERTIFICATES"
      ]
    },
    {
      "question_text": "How does Authenticode signing help mitigate the risk of malware distribution?",
      "correct_answer": "By allowing users to verify the source of the software and detect if it has been modified by malicious actors.",
      "distractors": [
        {
          "text": "By encrypting the malware to make it unreadable.",
          "misconception": "Targets [signing vs malware encryption confusion]: Students who believe code signing encrypts the software, thus hiding malware."
        },
        {
          "text": "By automatically removing any detected malware from the system.",
          "misconception": "Targets [signing vs malware removal confusion]: Students who confuse code signing with antivirus or anti-malware functionality."
        },
        {
          "text": "By preventing the software from running if it's not from a trusted publisher.",
          "misconception": "Targets [signing vs execution prevention confusion]: Students who believe a signature alone prevents execution, rather than informing the user."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Authenticode mitigates malware risk because it provides a verifiable link to the publisher and ensures code integrity. Users can trust software from known publishers and detect if it has been altered with malicious intent.",
        "distractor_analysis": "Signing does not encrypt malware. It is not an anti-malware tool. While OSs may use signatures to inform security policies, the signature itself doesn't inherently prevent execution.",
        "analogy": "It's like a tamper-evident seal on a medicine bottle. It assures you the medicine is from the legitimate manufacturer and hasn't been tampered with, reducing the risk of taking a harmful counterfeit."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "analyze",
      "prerequisites": [
        "DIGITAL_SIGNATURES",
        "MALWARE_MITIGATION"
      ]
    },
    {
      "question_text": "What is the significance of the 'Code Signing Certificate' identifier specified by the CA/Browser Forum?",
      "correct_answer": "It is a Certificate Policy Identifier (OID) that CAs use to assert compliance with the Baseline Requirements for code signing.",
      "distractors": [
        {
          "text": "It is a unique identifier for the software publisher's company.",
          "misconception": "Targets [policy identifier vs publisher identifier confusion]: Students who confuse policy OIDs with organizational identifiers."
        },
        {
          "text": "It is a cryptographic hash of the entire code signing specification.",
          "misconception": "Targets [policy identifier vs hash confusion]: Students who confuse policy identifiers with cryptographic hashes."
        },
        {
          "text": "It is a timestamp that proves the certificate's validity period.",
          "misconception": "Targets [policy identifier vs timestamp confusion]: Students who confuse policy OIDs with time-based validity information."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The Certificate Policy Identifier is significant because it formally declares a CA's adherence to the specific rules for issuing code signing certificates, as detailed in the CA/Browser Forum's Baseline Requirements ([cabforum.org](https://cabforum.org/working-groups/code-signing/requirements/)).",
        "distractor_analysis": "The identifier is a policy declaration, not a publisher ID. It's an Object Identifier (OID), not a hash. It relates to policy compliance, not the certificate's validity timestamp.",
        "analogy": "It's like a specific certification mark on a product (e.g., 'UL Listed') that tells consumers the product meets a particular set of safety standards."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PKI_CERTIFICATES",
        "CERTIFICATE_POLICY"
      ]
    },
    {
      "question_text": "Consider a scenario where a software publisher uses Authenticode to sign their application. Later, a vulnerability is discovered in the application, and the publisher releases a patch. What is the recommended practice for signing the patched software?",
      "correct_answer": "The publisher should re-sign the patched software with a new digital signature, potentially using an updated certificate.",
      "distractors": [
        {
          "text": "The original signature remains valid as long as the publisher's certificate has not expired.",
          "misconception": "Targets [original signature vs patch integrity confusion]: Students who believe an original signature covers subsequent modifications."
        },
        {
          "text": "The patch should be signed using a different type of key, like a symmetric key.",
          "misconception": "Targets [signing method for patches confusion]: Students who suggest changing the fundamental signing mechanism for updates."
        },
        {
          "text": "The original signature can be digitally appended to the patch file.",
          "misconception": "Targets [appending signatures vs re-signing confusion]: Students who misunderstand how signatures apply to modified code."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Re-signing is necessary because any modification to the code, including a patch, invalidates the original hash. Therefore, the new code must be hashed and signed again to ensure integrity and authenticity of the updated version.",
        "distractor_analysis": "The original signature only covers the code as it was at the time of signing. Using a symmetric key is inappropriate for code signing. Signatures are not appended; the entire modified code must be re-signed.",
        "analogy": "If you update a contract by adding an amendment, you need a new signature and date on the amended document, not just attach the original signature to the amendment."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "DIGITAL_SIGNATURES",
        "SOFTWARE_PATCHING"
      ]
    },
    {
      "question_text": "What is the difference between a Code Signing Certificate and an EV (Extended Validation) Code Signing Certificate?",
      "correct_answer": "EV Code Signing Certificates require a more rigorous vetting process by the Certificate Authority to establish the publisher's legal identity and operational existence.",
      "distractors": [
        {
          "text": "EV certificates use stronger encryption algorithms than standard code signing certificates.",
          "misconception": "Targets [EV vs algorithm strength confusion]: Students who confuse the vetting process with cryptographic algorithm strength."
        },
        {
          "text": "EV certificates are only valid for a shorter period than standard certificates.",
          "misconception": "Targets [EV vs validity period confusion]: Students who confuse the vetting rigor with certificate lifespan."
        },
        {
          "text": "Standard code signing certificates are used for internal applications, while EV certificates are for public distribution.",
          "misconception": "Targets [internal vs public use confusion]: Students who incorrectly assign use cases based on certificate type rather than vetting level."
        }
      ],
      "detailed_explanation": {
        "core_logic": "EV certificates provide a higher level of trust because the CA performs extensive due diligence on the applicant's legal and operational status, as mandated by [cabforum.org](https://cabforum.org/working-groups/code-signing/requirements/). This rigorous vetting is the key differentiator.",
        "distractor_analysis": "Both types of certificates use industry-standard, strong algorithms. Validity periods are typically similar. While EV is often for public distribution, the core difference is the vetting process, not the intended use case alone.",
        "analogy": "A standard driver's license verifies your identity to drive. An EV Code Signing Certificate is like a high-security clearance badge that requires extensive background checks and verification of your identity and authorization."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "EV_CERTIFICATES",
        "CODE_SIGNING_CERTIFICATES",
        "PKI_VETTING"
      ]
    },
    {
      "question_text": "According to NIST guidelines, what is a key consideration for the secure implementation of code signing?",
      "correct_answer": "Protecting the private key used for signing is paramount, as its compromise allows attackers to impersonate legitimate software publishers.",
      "distractors": [
        {
          "text": "Ensuring the code signing certificate is publicly accessible.",
          "misconception": "Targets [certificate accessibility vs private key security confusion]: Students who confuse the public nature of certificates with the need to protect private keys."
        },
        {
          "text": "Using the same private key for both code signing and SSL/TLS certificates.",
          "misconception": "Targets [key reuse vs security confusion]: Students who believe reusing keys across different functions is secure practice."
        },
        {
          "text": "Storing the private key on the same machine that develops the code.",
          "misconception": "Targets [key storage location vs security confusion]: Students who fail to understand the importance of isolating private keys."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Private key security is critical because it's the foundation of trust in code signing; its compromise enables forgery, as attackers can then sign malicious code as if they were the legitimate publisher ([csrc.nist.gov/pubs/sp/800/63/4/final](https://csrc.nist.gov/pubs/sp/800/63/4/final)).",
        "distractor_analysis": "Certificates are meant to be public for verification. Reusing keys is a security risk. Storing the private key on a development machine increases its exposure.",
        "analogy": "The private key is like the master key to a vault. If that key is lost or stolen, anyone can access and misuse the vault's contents."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "defense",
      "bloom_level": "analyze",
      "prerequisites": [
        "PRIVATE_KEY_SECURITY",
        "PKI_BEST_PRACTICES",
        "NIST_SP800_63"
      ]
    },
    {
      "question_text": "What is the potential security risk if a code signing certificate is issued based on insufficient validation of the publisher's identity?",
      "correct_answer": "Malicious actors could obtain a certificate and sign malware, making it appear as legitimate software.",
      "distractors": [
        {
          "text": "The signing process would become significantly slower.",
          "misconception": "Targets [validation rigor vs performance confusion]: Students who confuse the impact of vetting on signing speed."
        },
        {
          "text": "The certificate would be automatically revoked by the operating system.",
          "misconception": "Targets [insufficient validation vs automatic revocation confusion]: Students who believe insufficient validation leads to immediate, automatic revocation."
        },
        {
          "text": "The signed code would be unable to run on older operating systems.",
          "misconception": "Targets [validation rigor vs compatibility confusion]: Students who confuse vetting standards with software compatibility."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Insufficient validation is dangerous because it allows untrusted entities to acquire legitimate-looking certificates. This enables them to sign malicious code, bypassing security checks that rely on publisher trust ([cabforum.org](https://cabforum.org/working-groups/code-signing/requirements/)).",
        "distractor_analysis": "Vetting primarily affects trust, not signing speed. Automatic revocation is a separate process. Compatibility issues are typically unrelated to the certificate vetting process.",
        "analogy": "It's like giving a security badge to someone without properly checking their background. They could then use that badge to gain unauthorized access."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "PKI_VETTING",
        "CODE_SIGNING_CERTIFICATES",
        "MALWARE_DISTRIBUTION"
      ]
    },
    {
      "question_text": "How does the concept of 'non-repudiation' apply to Authenticode signing?",
      "correct_answer": "It ensures that the software publisher cannot later deny having signed the specific version of the code.",
      "distractors": [
        {
          "text": "It guarantees that the code will not be modified after signing.",
          "misconception": "Targets [non-repudiation vs integrity guarantee confusion]: Students who confuse non-repudiation with absolute integrity."
        },
        {
          "text": "It prevents the publisher from revoking their own certificate.",
          "misconception": "Targets [non-repudiation vs revocation confusion]: Students who confuse non-repudiation with the ability to revoke certificates."
        },
        {
          "text": "It ensures the code is free from all known vulnerabilities.",
          "misconception": "Targets [non-repudiation vs vulnerability status confusion]: Students who confuse non-repudiation with a guarantee of code security."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Non-repudiation is achieved because the digital signature, created with the publisher's unique private key, provides undeniable proof of origin. Since only the publisher possesses the private key, they cannot credibly deny signing the code.",
        "distractor_analysis": "Non-repudiation proves origin, not absolute integrity (tampering can still occur if not detected). It doesn't prevent certificate revocation. It doesn't guarantee the code is vulnerability-free.",
        "analogy": "Non-repudiation is like a signed contract. The signature proves you agreed to the terms, and you can't later claim you never signed it."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "NON_REPUDIATION",
        "DIGITAL_SIGNATURES"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Authenticode Signing 001_Cryptography best practices",
    "latency_ms": 22112.948
  },
  "timestamp": "2026-01-18T16:08:44.379324"
}