{
  "topic_title": "Salsa20",
  "category": "001_Cryptography - 003_Symmetric 001_Cryptography",
  "flashcards": [
    {
      "question_text": "What is the primary characteristic of Salsa20 as a stream cipher?",
      "correct_answer": "It generates a pseudorandom keystream that is XORed with the plaintext to produce ciphertext.",
      "distractors": [
        {
          "text": "It encrypts data in fixed-size blocks using a key and an initialization vector.",
          "misconception": "Targets [block cipher confusion]: Students confuse stream ciphers with block ciphers like AES."
        },
        {
          "text": "It uses a public key and private key pair for encryption and decryption.",
          "misconception": "Targets [symmetric/asymmetric confusion]: Students incorrectly associate stream ciphers with asymmetric cryptography."
        },
        {
          "text": "It relies on a lookup table to perform its cryptographic operations.",
          "misconception": "Targets [implementation detail confusion]: Students believe stream ciphers require lookup tables, which Salsa20 avoids."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Salsa20 functions as a stream cipher by generating a long pseudorandom keystream. This keystream is then XORed with the plaintext, providing confidentiality because the XOR operation is its own inverse, allowing decryption with the same keystream.",
        "distractor_analysis": "The first distractor describes block ciphers. The second incorrectly attributes asymmetric cryptography principles to Salsa20. The third is factually incorrect as Salsa20 avoids lookup tables to prevent timing attacks.",
        "analogy": "Think of Salsa20 as a unique, long, and secret code word generator. You XOR your message with this code word to scramble it, and then XOR the scrambled message with the same code word to unscramble it."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_BASICS",
        "CRYPTO_STREAM_CIPHERS"
      ]
    },
    {
      "question_text": "What is the key size for the Salsa20 stream cipher?",
      "correct_answer": "256 bits",
      "distractors": [
        {
          "text": "128 bits",
          "misconception": "Targets [key size confusion]: Students may confuse it with other ciphers like AES-128 or common symmetric key lengths."
        },
        {
          "text": "192 bits",
          "misconception": "Targets [key size confusion]: Students may incorrectly recall or associate it with less common key sizes."
        },
        {
          "text": "512 bits",
          "misconception": "Targets [block size confusion]: Students might confuse the key size with block sizes or internal state sizes of related algorithms."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Salsa20 utilizes a 256-bit key, which provides a large keyspace, making brute-force attacks computationally infeasible. This robust key size is fundamental to its security, ensuring that guessing the key is practically impossible.",
        "distractor_analysis": "128 and 192 bits are common key sizes for other ciphers, leading to confusion. 512 bits is not a standard key size for Salsa20 and might be confused with block or internal state sizes.",
        "analogy": "The key is like the master key to a very complex vault. A 256-bit key means there are an astronomical number of possible combinations, making it virtually impossible for someone to guess the correct one."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "CRYPTO_BASICS",
        "CRYPTO_SYMMETRIC_KEYS"
      ]
    },
    {
      "question_text": "Which of the following is a key advantage of Salsa20 regarding side-channel attacks?",
      "correct_answer": "It avoids lookup tables, making it resistant to timing attacks.",
      "distractors": [
        {
          "text": "It uses a complex substitution-box (S-box) that is difficult to analyze.",
          "misconception": "Targets [block cipher confusion]: Students associate S-boxes with block ciphers like AES, not stream ciphers like Salsa20."
        },
        {
          "text": "It requires a hardware security module (HSM) for secure operation.",
          "misconception": "Targets [implementation requirement confusion]: Students may overstate security requirements, thinking specialized hardware is mandatory."
        },
        {
          "text": "It employs a large number of rounds to obscure its internal state.",
          "misconception": "Targets [security through obscurity confusion]: Students might believe obscurity, rather than algorithmic design, provides security."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Salsa20 is designed to be resistant to timing attacks because it does not rely on lookup tables. This algorithmic property ensures that its execution time is constant regardless of the input, preventing attackers from inferring secret information based on execution speed.",
        "distractor_analysis": "The first distractor describes S-boxes, typical of block ciphers. The second incorrectly mandates HSMs. The third suggests a security through obscurity approach, which is not Salsa20's primary defense mechanism.",
        "analogy": "Salsa20 is like a chef who uses only basic, consistent cooking steps without needing a secret recipe book (lookup table). This consistency means an observer can't tell what dish they're making just by how long each step takes."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_BASICS",
        "CRYPTO_SIDE_CHANNEL_ATTACKS"
      ]
    },
    {
      "question_text": "What is the role of the nonce (number used once) in Salsa20 encryption?",
      "correct_answer": "To ensure that each message encrypted with the same key produces a unique ciphertext.",
      "distractors": [
        {
          "text": "To provide the secret key for the encryption process.",
          "misconception": "Targets [key/nonce confusion]: Students confuse the nonce's role with that of the secret key."
        },
        {
          "text": "To authenticate the origin of the encrypted message.",
          "misconception": "Targets [authentication confusion]: Students may think the nonce provides message authentication, which is not its primary function."
        },
        {
          "text": "To increase the block size of the plaintext being encrypted.",
          "misconception": "Targets [parameter confusion]: Students may confuse the nonce with parameters that affect data size or structure."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The nonce is crucial for security because it guarantees that even with the same key, identical plaintexts will result in different ciphertexts. This uniqueness prevents attacks that exploit repeated keystreams, such as those targeting the 'two-time pad' vulnerability.",
        "distractor_analysis": "The first distractor wrongly equates the nonce with the secret key. The second incorrectly assigns an authentication role. The third misunderstands the nonce's function, which is about uniqueness, not data size.",
        "analogy": "The nonce is like a unique serial number for each message you send with the same key. Even if you send the same message twice, the serial number changes, making each encrypted message look completely different."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_BASICS",
        "CRYPTO_NONCE"
      ]
    },
    {
      "question_text": "What is the recommended practice regarding nonce reuse with Salsa20?",
      "correct_answer": "Never reuse a nonce with the same key.",
      "distractors": [
        {
          "text": "Reusing a nonce is acceptable if the message is short.",
          "misconception": "Targets [nonce reuse vulnerability]: Students underestimate the severity of nonce reuse, believing message length mitigates the risk."
        },
        {
          "text": "Reusing a nonce is acceptable if the key is changed frequently.",
          "misconception": "Targets [nonce reuse vulnerability]: Students incorrectly assume key rotation negates the need for unique nonces per message."
        },
        {
          "text": "Reusing a nonce is acceptable as long as the ciphertext is different.",
          "misconception": "Targets [nonce reuse vulnerability]: Students confuse the *result* (different ciphertext) with the *cause* (unique nonce), which is the actual security requirement."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Reusing a nonce with the same key is a critical security flaw because it can lead to the same keystream being generated for different messages. This allows attackers to potentially recover both plaintexts by XORing the ciphertexts, compromising confidentiality.",
        "distractor_analysis": "All distractors suggest scenarios where nonce reuse might seem acceptable but is fundamentally insecure. The core principle is that a nonce MUST be unique for each encryption under a given key.",
        "analogy": "Using the same nonce with the same key is like using the same combination for two different safety deposit boxes. If someone knows the combination, they can potentially access both, regardless of how often you change the combination for other boxes."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "analyze",
      "prerequisites": [
        "CRYPTO_BASICS",
        "CRYPTO_NONCE",
        "CRYPTO_STREAM_CIPHER_ATTACKS"
      ]
    },
    {
      "question_text": "How does Salsa20 handle the block counter internally?",
      "correct_answer": "It uses a dedicated 64-bit block counter to avoid incrementing the nonce after each block.",
      "distractors": [
        {
          "text": "It increments the nonce directly for each block processed.",
          "misconception": "Targets [nonce/counter confusion]: Students incorrectly assume the nonce itself is incremented for each block, rather than a separate counter."
        },
        {
          "text": "It uses a variable-length counter that adjusts based on plaintext size.",
          "misconception": "Targets [counter size confusion]: Students may incorrectly assume the counter size is flexible or dependent on data length."
        },
        {
          "text": "It does not use a counter; it relies solely on the nonce for uniqueness.",
          "misconception": "Targets [mechanism confusion]: Students may believe the nonce alone manages the keystream generation for multiple blocks."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Salsa20 employs an internal 64-bit block counter, which is combined with the nonce and key to generate the keystream. This dedicated counter allows for efficient generation of large amounts of pseudorandom data without needing to increment the nonce for every single block, simplifying implementation and avoiding nonce exhaustion.",
        "distractor_analysis": "The first distractor incorrectly states the nonce is incremented per block. The second suggests a variable counter, which is not how Salsa20 operates. The third denies the existence of a counter, overlooking its role in keystream generation.",
        "analogy": "Imagine writing a long book. Instead of changing the chapter number (nonce) for every single sentence (block), you use a page number (counter) within the current chapter. The nonce is set once per book, and the counter keeps track of progress within that book."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_BASICS",
        "CRYPTO_STREAM_CIPHERS",
        "CRYPTO_NONCE"
      ]
    },
    {
      "question_text": "What is the relationship between Salsa20 and ChaCha20?",
      "correct_answer": "ChaCha20 is a variant of Salsa20, often considered faster on modern processors due to its simpler operations.",
      "distractors": [
        {
          "text": "Salsa20 is a successor to ChaCha20, offering improved security.",
          "misconception": "Targets [algorithm lineage confusion]: Students may incorrectly assume newer algorithms always supersede older ones in security."
        },
        {
          "text": "They are identical algorithms with different naming conventions.",
          "misconception": "Targets [algorithm distinction confusion]: Students may think different names imply no functional difference."
        },
        {
          "text": "Salsa20 is a block cipher, while ChaCha20 is a stream cipher.",
          "misconception": "Targets [cipher type confusion]: Students may confuse the fundamental nature (block vs. stream) of these related algorithms."
        }
      ],
      "detailed_explanation": {
        "core_logic": "ChaCha20 is derived from Salsa20, modifying the internal round function to use addition, XOR, and rotations, which often perform better on modern CPUs compared to Salsa20's quarter-round function. Both are stream ciphers designed for high performance and security.",
        "distractor_analysis": "The first distractor reverses the lineage. The second incorrectly states they are identical. The third misclassifies Salsa20 as a block cipher.",
        "analogy": "Think of Salsa20 as the original blueprint for a fast car engine. ChaCha20 is like an updated version of that blueprint, tweaking some parts (like the quarter-round function) to make it even faster on today's roads (processors)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "CRYPTO_BASICS",
        "CRYPTO_STREAM_CIPHERS"
      ]
    },
    {
      "question_text": "What is the purpose of the Poly1305 authenticator when used with ChaCha20 (as in ChaCha20-Poly1305)?",
      "correct_answer": "To provide data integrity and authenticity in addition to confidentiality.",
      "distractors": [
        {
          "text": "To increase the speed of the ChaCha20 encryption process.",
          "misconception": "Targets [performance confusion]: Students may assume combining algorithms always boosts speed, rather than adding functionality."
        },
        {
          "text": "To generate the secret key used by ChaCha20.",
          "misconception": "Targets [key generation confusion]: Students may confuse the role of an authenticator with key derivation or generation."
        },
        {
          "text": "To enable the use of public-key cryptography with ChaCha20.",
          "misconception": "Targets [cryptographic primitive confusion]: Students may incorrectly associate authentication mechanisms with asymmetric cryptography."
        }
      ],
      "detailed_explanation": {
        "core_logic": "ChaCha20-Poly1305 is an Authenticated Encryption with Associated Data (AEAD) mode. Poly1305 acts as a Message Authentication Code (MAC) algorithm, ensuring that the ciphertext is not only confidential (thanks to ChaCha20) but also that it hasn't been tampered with and originates from the expected sender.",
        "distractor_analysis": "The first distractor incorrectly assumes performance enhancement as the primary goal. The second confuses Poly1305 with key management. The third wrongly links Poly1305 to public-key cryptography.",
        "analogy": "Using ChaCha20-Poly1305 is like sending a sealed, tamper-evident package. ChaCha20 ensures only the intended recipient can read the contents (confidentiality), while Poly1305 ensures the package hasn't been opened or altered (integrity and authenticity)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_BASICS",
        "CRYPTO_AEAD",
        "CRYPTO_MAC"
      ]
    },
    {
      "question_text": "What is the 'quarter round' function in Salsa20?",
      "correct_answer": "A basic building block operation that mixes four words using addition, XOR, and rotations.",
      "distractors": [
        {
          "text": "The final hashing step that produces the output digest.",
          "misconception": "Targets [hashing confusion]: Students may confuse cryptographic primitives or mistake a component for the final output function."
        },
        {
          "text": "A function used to derive the secret key from a password.",
          "misconception": "Targets [key derivation confusion]: Students may confuse internal operations with key derivation functions (KDFs)."
        },
        {
          "text": "The process of encrypting a single 64-byte block of data.",
          "misconception": "Targets [block processing confusion]: Students may confuse a fundamental operation with the overall encryption of a data block."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The quarter round is a core component of Salsa20's internal state transformation. It takes four 32-bit words and applies a specific sequence of additions, XORs, and bitwise rotations, mixing the data. Multiple applications of the quarter round, combined in different ways, form the basis of the Salsa20 algorithm's diffusion and confusion.",
        "distractor_analysis": "The first distractor misidentifies the quarter round's role, confusing it with hashing. The second incorrectly assigns it a key derivation function role. The third wrongly equates it with the full block encryption process.",
        "analogy": "The quarter round is like a fundamental mixing step in a recipe. It takes a few ingredients (words) and combines them in a specific way (add, XOR, rotate) to start creating the final dish (keystream). Many such mixing steps are needed for the complete recipe."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_BASICS",
        "CRYPTO_STREAM_CIPHERS",
        "CRYPTO_BITWISE_OPERATIONS"
      ]
    },
    {
      "question_text": "What is the 'XSalsa20' construction?",
      "correct_answer": "An extended-nonce variant of Salsa20 that uses a larger nonce size for increased security.",
      "distractors": [
        {
          "text": "A faster version of Salsa20 that sacrifices security for speed.",
          "misconception": "Targets [performance/security trade-off confusion]: Students may assume extensions always prioritize speed over security."
        },
        {
          "text": "A version of Salsa20 designed specifically for hardware implementations.",
          "misconception": "Targets [implementation specialization confusion]: Students may incorrectly assume algorithm variants are tied to specific hardware types."
        },
        {
          "text": "A mode of operation that combines Salsa20 with Poly1305 for authentication.",
          "misconception": "Targets [mode of operation confusion]: Students may confuse nonce extension with authenticated encryption modes."
        }
      ],
      "detailed_explanation": {
        "core_logic": "XSalsa20 extends the nonce size from 64 bits to 192 bits. This larger nonce space significantly reduces the probability of accidental nonce reuse, especially in scenarios where keys are long-lived or many messages are encrypted, thereby enhancing overall security.",
        "distractor_analysis": "The first distractor incorrectly suggests a security sacrifice. The second wrongly ties XSalsa20 to hardware. The third confuses nonce extension with authenticated encryption modes like Poly1305.",
        "analogy": "If Salsa20's nonce is like a daily ticket number, XSalsa20 is like a ticket number that includes the date and year. This much larger number makes it virtually impossible to accidentally issue the same ticket twice over a very long period."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_BASICS",
        "CRYPTO_STREAM_CIPHERS",
        "CRYPTO_NONCE"
      ]
    },
    {
      "question_text": "Why is Salsa20 considered suitable for high-speed applications?",
      "correct_answer": "Its design avoids complex operations and lookup tables, allowing for efficient software and hardware implementation.",
      "distractors": [
        {
          "text": "It uses a very short key, which speeds up the encryption process.",
          "misconception": "Targets [key size/speed confusion]: Students may incorrectly associate shorter keys with faster performance, ignoring security implications."
        },
        {
          "text": "It relies on computationally intensive mathematical functions like modular exponentiation.",
          "misconception": "Targets [algorithm complexity confusion]: Students may incorrectly assume complex math equals better security or performance."
        },
        {
          "text": "It is designed to be used only with specialized hardware accelerators.",
          "misconception": "Targets [implementation dependency confusion]: Students may incorrectly believe high speed requires dedicated hardware, overlooking efficient software designs."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Salsa20's efficiency stems from its use of simple arithmetic operations (addition, XOR) and bitwise rotations, which are fast on most processors. The absence of lookup tables also prevents cache-timing attacks and simplifies implementation, making it ideal for high-throughput scenarios.",
        "distractor_analysis": "The first distractor incorrectly links short keys to speed. The second wrongly attributes computationally intensive functions to Salsa20. The third incorrectly mandates specialized hardware.",
        "analogy": "Salsa20 is like a streamlined assembly line. It uses simple, repeatable steps that can be performed very quickly without needing specialized, complex machinery for each step, allowing for high production volume."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "CRYPTO_BASICS",
        "CRYPTO_STREAM_CIPHERS",
        "CRYPTO_PERFORMANCE"
      ]
    },
    {
      "question_text": "What is the output size of the Salsa20 keystream generated for each block?",
      "correct_answer": "64 bytes (512 bits)",
      "distractors": [
        {
          "text": "32 bytes (256 bits)",
          "misconception": "Targets [output size confusion]: Students may confuse the keystream block size with the key size or other parameters."
        },
        {
          "text": "16 bytes (128 bits)",
          "misconception": "Targets [output size confusion]: Students may confuse it with common block cipher block sizes like AES."
        },
        {
          "text": "Variable, depending on the input message length.",
          "misconception": "Targets [fixed vs. variable output confusion]: Students may incorrectly assume stream cipher output varies with message length, rather than being a fixed-size keystream block."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Salsa20 operates by hashing the key, nonce, and block number to produce a 64-byte (512-bit) pseudorandom block. This block is then XORed with the plaintext block. This fixed output size per block ensures consistent processing and efficient generation of the keystream.",
        "distractor_analysis": "The distractors suggest incorrect block sizes (256 bits, 128 bits) or a variable output, which contradicts Salsa20's fixed 64-byte keystream block generation.",
        "analogy": "Each time Salsa20 generates a piece of the secret code (keystream), it always produces exactly one page (64 bytes) of code, regardless of how long the message you want to encrypt is. You then use this page of code to encrypt a corresponding page of your message."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "CRYPTO_BASICS",
        "CRYPTO_STREAM_CIPHERS"
      ]
    },
    {
      "question_text": "In the context of Salsa20, what does '20' in Salsa20/20 refer to?",
      "correct_answer": "The number of rounds the core algorithm performs.",
      "distractors": [
        {
          "text": "The key size in bits.",
          "misconception": "Targets [parameter confusion]: Students may confuse the number in the name with the key size."
        },
        {
          "text": "The nonce size in bits.",
          "misconception": "Targets [parameter confusion]: Students may confuse the number in the name with the nonce size."
        },
        {
          "text": "The block size in bytes.",
          "misconception": "Targets [parameter confusion]: Students may confuse the number in the name with the block size."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The notation 'Salsa20/X' indicates the number of rounds (X) performed by the core Salsa20 algorithm. Salsa20/20, using 20 rounds, is considered secure against known attacks, while reduced-round versions like Salsa20/8 or Salsa20/12 offer higher speed at the cost of some security margin.",
        "distractor_analysis": "The distractors incorrectly associate the '20' with key size, nonce size, or block size, which are distinct parameters of the cipher.",
        "analogy": "Think of the rounds as 'mixing steps' in a recipe. Salsa20/20 means the recipe has 20 mixing steps. A recipe with fewer steps (e.g., Salsa20/8) might be faster to make but potentially less thoroughly mixed."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_BASICS",
        "CRYPTO_STREAM_CIPHERS"
      ]
    },
    {
      "question_text": "What is the primary security goal achieved by using Salsa20 for encryption?",
      "correct_answer": "Confidentiality: ensuring that only authorized parties can read the message.",
      "distractors": [
        {
          "text": "Integrity: ensuring that the message has not been altered.",
          "misconception": "Targets [confidentiality/integrity confusion]: Students may confuse the primary goal of encryption with data integrity."
        },
        {
          "text": "Authenticity: ensuring that the message originates from the claimed sender.",
          "misconception": "Targets [confidentiality/authenticity confusion]: Students may confuse the primary goal of encryption with message authentication."
        },
        {
          "text": "Non-repudiation: ensuring the sender cannot deny sending the message.",
          "misconception": "Targets [confidentiality/non-repudiation confusion]: Students may confuse encryption's goal with non-repudiation, which typically requires digital signatures."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The fundamental purpose of encryption algorithms like Salsa20 is to provide confidentiality. By transforming plaintext into ciphertext using a secret key, it ensures that unauthorized individuals cannot understand the message content, protecting sensitive information.",
        "distractor_analysis": "Integrity and authenticity are typically provided by MACs or digital signatures, often used in conjunction with encryption (AEAD). Non-repudiation is also a function of digital signatures, not basic encryption.",
        "analogy": "Salsa20 is like putting your message in a locked box. The main goal is that only someone with the key can open the box and read what's inside (confidentiality). Ensuring the box wasn't tampered with (integrity) or proving who sent it (authenticity) requires additional measures."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_BASICS",
        "CRYPTO_CONFIDENTIALITY"
      ]
    },
    {
      "question_text": "Which RFC defines ChaCha20 and Poly1305 for IETF Protocols?",
      "correct_answer": "RFC 8439",
      "distractors": [
        {
          "text": "RFC 7539",
          "misconception": "Targets [obsolete standard confusion]: Students may recall the predecessor RFC but not the updated one."
        },
        {
          "text": "RFC 2119",
          "misconception": "Targets [irrelevant standard confusion]: Students may confuse RFCs related to cryptographic standards with those defining keywords like 'MUST', 'SHOULD'."
        },
        {
          "text": "RFC 5116",
          "misconception": "Targets [related but incorrect RFC confusion]: Students may recall other RFCs related to authenticated encryption but not the specific ChaCha20/Poly1305 definition."
        }
      ],
      "detailed_explanation": {
        "core_logic": "RFC 8439, published in June 2018, defines the ChaCha20 stream cipher and the Poly1305 authenticator, including their use as an Authenticated Encryption with Associated Data (AEAD) algorithm. It supersedes RFC 7539 and incorporates errata, serving as the current standard for IETF protocols.",
        "distractor_analysis": "RFC 7539 is the predecessor. RFC 2119 defines 'MUST', 'SHOULD', etc. RFC 5116 relates to nonce-based AEAD but is not the specific definition for ChaCha20-Poly1305.",
        "analogy": "Think of RFCs as official instruction manuals. RFC 8439 is the current, updated manual for using ChaCha20 and Poly1305 in internet protocols, replacing the older manual (RFC 7539)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "CRYPTO_BASICS",
        "CRYPTO_STANDARDS",
        "CRYPTO_STREAM_CIPHERS"
      ]
    },
    {
      "question_text": "What is the 'extended-nonce construction' (XSalsa20) generally recommended over raw Salsa20 for?",
      "correct_answer": "Safely generating nonces, especially when keys are reused extensively.",
      "distractors": [
        {
          "text": "Increasing the encryption speed.",
          "misconception": "Targets [performance misconception]: Students may assume extensions primarily aim for speed improvements."
        },
        {
          "text": "Reducing the key size required for security.",
          "misconception": "Targets [key size misconception]: Students may incorrectly believe nonce extensions allow for smaller keys."
        },
        {
          "text": "Providing built-in message authentication.",
          "misconception": "Targets [authentication misconception]: Students may confuse nonce management with message authentication features."
        }
      ],
      "detailed_explanation": {
        "core_logic": "XSalsa20 uses a larger nonce (192 bits vs. 64 bits for Salsa20), which significantly expands the possible nonce values. This makes it much easier to ensure nonce uniqueness, a critical security requirement, particularly in long-lived key scenarios where accidental reuse is a higher risk.",
        "distractor_analysis": "The primary benefit of XSalsa20 is enhanced nonce security, not speed, reduced key size, or built-in authentication.",
        "analogy": "Using XSalsa20 is like having a much larger calendar for your unique ticket numbers (nonces). This makes it far less likely you'll accidentally issue the same ticket number twice, even if you're issuing tickets for a very long time."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "analyze",
      "prerequisites": [
        "CRYPTO_BASICS",
        "CRYPTO_STREAM_CIPHERS",
        "CRYPTO_NONCE"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 16,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Salsa20 001_Cryptography best practices",
    "latency_ms": 23551.443
  },
  "timestamp": "2026-01-18T15:35:38.256052"
}