{
  "topic_title": "OpenSSL Implementation",
  "category": "001_Cryptography - 005_Asymmetric 001_Cryptography",
  "flashcards": [
    {
      "question_text": "When implementing TLS/DTLS using OpenSSL, what is the primary recommendation from RFC 9325 regarding protocol versions?",
      "correct_answer": "Prefer TLS 1.3 and DTLS 1.3, and disable older, less secure versions like SSLv3, TLS 1.0, and TLS 1.1.",
      "distractors": [
        {
          "text": "Use TLS 1.2 exclusively as it offers the best balance of security and compatibility.",
          "misconception": "Targets [protocol version preference]: Students who believe TLS 1.2 is the current secure standard without acknowledging TLS 1.3's advancements."
        },
        {
          "text": "Enable all TLS and DTLS versions to ensure maximum compatibility with legacy systems.",
          "misconception": "Targets [compatibility vs. security]: Students who prioritize broad compatibility over known security vulnerabilities in older protocols."
        },
        {
          "text": "Prioritize DTLS 1.2 for UDP-based applications and TLS 1.2 for TCP-based applications.",
          "misconception": "Targets [protocol version selection]: Students who misunderstand the versioning recommendations and focus on transport layer rather than protocol security."
        }
      ],
      "detailed_explanation": {
        "core_logic": "RFC 9325 recommends prioritizing TLS 1.3 and DTLS 1.3 because they offer significant security improvements and deprecate older, vulnerable versions. This ensures stronger protection against known attacks.",
        "distractor_analysis": "The first distractor incorrectly suggests TLS 1.2 is the best, ignoring TLS 1.3. The second prioritizes compatibility over security. The third misapplies versioning based on transport layer.",
        "analogy": "It's like choosing the latest, most secure lock for your house (TLS 1.3) instead of an older, potentially pickable one (TLS 1.2 or older), even if the older one fits more doors."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "TLS_BASICS",
        "DTLS_BASICS",
        "CRYPTO_VERSIONS"
      ]
    },
    {
      "question_text": "According to RFC 9325, what is a key recommendation for cipher suites when configuring TLS/DTLS in OpenSSL?",
      "correct_answer": "Prefer cipher suites that use authenticated encryption with associated data (AEAD) modes, such as GCM or ChaCha20-Poly1305, and avoid older, non-AEAD modes.",
      "distractors": [
        {
          "text": "Use cipher suites that offer the highest bit-strength encryption, regardless of mode.",
          "misconception": "Targets [cipher suite selection criteria]: Students who focus solely on key length and overlook the importance of authenticated encryption modes."
        },
        {
          "text": "Prioritize cipher suites that are widely compatible, even if they use older modes like CBC.",
          "misconception": "Targets [compatibility vs. security]: Students who believe older, widely supported cipher suites are acceptable despite known vulnerabilities."
        },
        {
          "text": "Always use cipher suites that include both encryption and integrity checks separately.",
          "misconception": "Targets [AEAD understanding]: Students who don't grasp that AEAD modes combine encryption and integrity more efficiently and securely than separate mechanisms."
        }
      ],
      "detailed_explanation": {
        "core_logic": "RFC 9325 recommends AEAD cipher suites because they provide both confidentiality and integrity in a single, efficient operation, mitigating attacks like padding oracle attacks that affect older modes like CBC. This is crucial for secure data transmission.",
        "distractor_analysis": "The first distractor overemphasizes key length. The second wrongly prioritizes compatibility over security. The third misunderstands AEAD's integrated approach.",
        "analogy": "Using an AEAD cipher suite is like having a secure, tamper-evident package. You know the contents are protected (confidentiality) and that no one has opened or altered it (integrity), all in one step."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "analyze",
      "prerequisites": [
        "TLS_CIPHER_SUITES",
        "AEAD_MODES",
        "CRYPTO_INTEGRITY"
      ]
    },
    {
      "question_text": "What is the recommended approach for managing private keys when using OpenSSL for server certificates, according to general best practices?",
      "correct_answer": "Protect private keys with strong passphrases, store them securely with restricted file permissions, and avoid hardcoding them in code.",
      "distractors": [
        {
          "text": "Store private keys in plain text for easy access and faster server startup.",
          "misconception": "Targets [key security]: Students who misunderstand the critical need for confidentiality and integrity of private keys."
        },
        {
          "text": "Encrypt private keys using a symmetric algorithm like AES, but without a passphrase.",
          "misconception": "Targets [key protection mechanisms]: Students who know encryption is needed but fail to understand the necessity of a strong key for the encryption itself (passphrase)."
        },
        {
          "text": "Embed private keys directly within the application code for simplicity.",
          "misconception": "Targets [secure deployment practices]: Students who prioritize convenience over fundamental security principles like separation of secrets."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Private keys are the foundation of asymmetric cryptography; therefore, they must be protected with strong passphrases and restricted access. This prevents unauthorized use, upholding the integrity and confidentiality of cryptographic operations.",
        "distractor_analysis": "The first distractor suggests insecure storage. The second omits the crucial passphrase for encryption. The third advocates for embedding secrets, a major security flaw.",
        "analogy": "Your private key is like the master key to your vault. You wouldn't leave it lying around or share it carelessly; you'd keep it safe, perhaps with a strong combination lock, and never embed it in your house plans."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "ASYMMETRIC_CRYPTO",
        "PRIVATE_KEY_SECURITY"
      ]
    },
    {
      "question_text": "When generating a self-signed certificate using OpenSSL, what is a common pitfall regarding the certificate's validity period?",
      "correct_answer": "Setting an excessively long validity period, which increases the risk if the key is compromised.",
      "distractors": [
        {
          "text": "Setting the validity period too short, causing frequent re-issuance.",
          "misconception": "Targets [validity period management]: Students who focus on the inconvenience of short validity rather than the security implications of long validity."
        },
        {
          "text": "Using the current date as the 'not before' date and the same date as 'not after'.",
          "misconception": "Targets [date logic]: Students who misunderstand how 'not before' and 'not after' dates define a valid window."
        },
        {
          "text": "Not specifying a validity period at all, letting OpenSSL use a default.",
          "misconception": "Targets [configuration best practices]: Students who overlook the importance of explicitly defining security parameters like validity."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A long validity period for a self-signed certificate increases the attack surface because if the private key is compromised, the certificate remains trusted for an extended duration. Therefore, shorter, manageable periods are preferred.",
        "distractor_analysis": "The first distractor focuses on operational inconvenience. The second describes a logically invalid certificate. The third suggests neglecting explicit configuration.",
        "analogy": "Issuing a long-term ID card (certificate) with a weak security feature (compromised key) means that invalid ID remains usable for a long time, posing a prolonged risk."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "X509_CERTIFICATES",
        "CERTIFICATE_LIFECYCLE"
      ]
    },
    {
      "question_text": "What is the purpose of the 'subject alternative name' (SAN) extension in X.509 certificates generated with OpenSSL?",
      "correct_answer": "To specify multiple hostnames or IP addresses that the certificate is valid for, beyond the common name (CN).",
      "distractors": [
        {
          "text": "To encrypt the certificate's contents for secure transmission.",
          "misconception": "Targets [certificate purpose confusion]: Students who confuse certificate extensions with encryption mechanisms."
        },
        {
          "text": "To digitally sign the certificate, ensuring its authenticity.",
          "misconception": "Targets [certificate extensions vs. signing]: Students who mix the function of extensions with the process of certificate signing."
        },
        {
          "text": "To specify the certificate's revocation list (CRL) distribution points.",
          "misconception": "Targets [certificate extension functions]: Students who confuse SAN with extensions related to certificate revocation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The Subject Alternative Name (SAN) extension allows a single certificate to be valid for multiple identities (like different domain names or IP addresses), which is crucial for modern web servers hosting multiple sites. This enhances flexibility and reduces the need for numerous certificates.",
        "distractor_analysis": "The first distractor confuses SAN with encryption. The second mixes SAN with digital signatures. The third incorrectly associates SAN with CRLs.",
        "analogy": "Think of the 'Common Name' (CN) as your primary address, and SANs as additional addresses listed on your ID card. This allows you to receive mail (secure connections) at any of the listed addresses."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "X509_CERTIFICATES",
        "TLS_SERVER_AUTH"
      ]
    },
    {
      "question_text": "When using OpenSSL to generate a Certificate Signing Request (CSR), what information is typically included?",
      "correct_answer": "Distinguished Name (DN) information such as Common Name (CN), Organization (O), and Country (C), along with the public key.",
      "distractors": [
        {
          "text": "The private key corresponding to the public key.",
          "misconception": "Targets [CSR contents]: Students who misunderstand that private keys must never be shared, especially in a CSR."
        },
        {
          "text": "The full certificate chain, including intermediate and root certificates.",
          "misconception": "Targets [CSR vs. Certificate Chain]: Students who confuse the request for a certificate with the final issued certificate or its trust chain."
        },
        {
          "text": "Only the public key, without any identifying information.",
          "misconception": "Targets [CSR purpose]: Students who fail to recognize that a CSR must contain identifying information for the Certificate Authority (CA) to issue a certificate."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A CSR is sent to a Certificate Authority (CA) to request a signed certificate. It must contain the public key and the requester's identity (Distinguished Name) so the CA knows who to issue the certificate to and can verify the identity.",
        "distractor_analysis": "The first distractor suggests including the private key, which is a critical security failure. The second confuses the CSR with the final certificate chain. The third omits essential identity information.",
        "analogy": "A CSR is like filling out an application form to get a passport. You provide your personal details (DN) and a photo (public key), but you don't send your house keys (private key) or your existing travel documents (certificate chain)."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "ASYMMETRIC_CRYPTO",
        "X509_CERTIFICATES",
        "CERTIFICATE_AUTHORITY"
      ]
    },
    {
      "question_text": "What is the primary security benefit of using TLS 1.3, as recommended for OpenSSL implementations?",
      "correct_answer": "It significantly reduces the handshake latency and eliminates many older, vulnerable cipher suites and negotiation options.",
      "distractors": [
        {
          "text": "It provides stronger encryption algorithms that are computationally impossible to break.",
          "misconception": "Targets [cryptographic certainty]: Students who misunderstand that 'strong' encryption is relative and not 'impossible to break'."
        },
        {
          "text": "It mandates the use of Diffie-Hellman key exchange for all connections.",
          "misconception": "Targets [TLS 1.3 features]: Students who incorrectly assume DH is the *only* key exchange method used, ignoring other options like RSA-PSS."
        },
        {
          "text": "It guarantees perfect forward secrecy for all past and future sessions.",
          "misconception": "Targets [forward secrecy understanding]: Students who misunderstand that PFS applies to *future* sessions derived from the current session's keys, not necessarily all past sessions."
        }
      ],
      "detailed_explanation": {
        "core_logic": "TLS 1.3 streamlines the handshake process, reducing round trips and improving performance. Crucially, it removes obsolete and insecure cipher suites and negotiation features, thereby enhancing security by default and preventing downgrade attacks.",
        "distractor_analysis": "The first distractor overstates the 'unbreakable' nature of encryption. The second incorrectly limits key exchange options. The third misapplies the concept of forward secrecy to past sessions.",
        "analogy": "TLS 1.3 is like upgrading from a slow, multi-step process to a quick, streamlined one. It not only gets you there faster but also removes unnecessary, potentially risky detours."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "TLS_VERSIONS",
        "CRYPTO_HANDSHAKE",
        "FORWARD_SECRECY"
      ]
    },
    {
      "question_text": "When configuring OpenSSL for secure communication, what is the role of a Certificate Authority (CA)?",
      "correct_answer": "To verify the identity of entities requesting certificates and digitally sign those certificates to vouch for their authenticity.",
      "distractors": [
        {
          "text": "To encrypt the communication channel between client and server.",
          "misconception": "Targets [CA role confusion]: Students who confuse the CA's role (issuance/verification) with the function of TLS/SSL itself (encryption)."
        },
        {
          "text": "To generate the private keys for clients and servers.",
          "misconception": "Targets [key management vs. CA]: Students who misunderstand that private key generation is typically done by the end-entity, not the CA."
        },
        {
          "text": "To store and manage all client and server certificates securely.",
          "misconception": "Targets [CA responsibilities]: Students who believe the CA is solely a certificate repository rather than an active issuer and verifier."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A CA acts as a trusted third party. It verifies the identity of certificate applicants and then digitally signs their public key certificates. This signature allows other parties (relying parties) to trust the certificate because they trust the CA.",
        "distractor_analysis": "The first distractor assigns the encryption role to the CA. The second wrongly attributes private key generation to the CA. The third describes a passive storage role, ignoring the active verification and signing functions.",
        "analogy": "A CA is like a passport office. They verify your identity and documents, then issue you a passport (certificate) that others can trust because they trust the passport office."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PKI",
        "X509_CERTIFICATES",
        "DIGITAL_SIGNATURES"
      ]
    },
    {
      "question_text": "What is the significance of the 'key usage' extension in an X.509 certificate generated by OpenSSL?",
      "correct_answer": "It specifies the intended cryptographic operations for which the public key in the certificate can be used (e.g., digital signature, key encipherment).",
      "distractors": [
        {
          "text": "It indicates the geographical location where the certificate is valid.",
          "misconception": "Targets [extension function confusion]: Students who confuse cryptographic purpose with geographical or administrative constraints."
        },
        {
          "text": "It defines the encryption algorithm that must be used with the public key.",
          "misconception": "Targets [key usage vs. algorithm specification]: Students who misunderstand that key usage defines *purpose*, not the specific algorithm."
        },
        {
          "text": "It lists all the IP addresses the certificate is associated with.",
          "misconception": "Targets [key usage vs. SAN]: Students who confuse the 'key usage' extension with the 'Subject Alternative Name' (SAN) extension."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'key usage' extension is critical because it restricts the public key to specific cryptographic purposes, enhancing security by preventing its misuse. For example, a key intended for signing should not be used for encryption.",
        "distractor_analysis": "The first distractor assigns a geographical role. The second incorrectly suggests it dictates the algorithm. The third confuses it with the SAN extension.",
        "analogy": "The 'key usage' is like a label on a tool, indicating its intended purpose: 'Screwdriver - For screws only', not for hammering nails. This prevents misuse."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "X509_CERTIFICATES",
        "PUBLIC_KEY_CRYPTOGRAPHY"
      ]
    },
    {
      "question_text": "When implementing certificate pinning using OpenSSL, what is the primary goal?",
      "correct_answer": "To mitigate Man-in-the-Middle (MitM) attacks by restricting the set of trusted Certificate Authorities (CAs) or specific certificates.",
      "distractors": [
        {
          "text": "To speed up the TLS handshake process.",
          "misconception": "Targets [pinning vs. performance]: Students who confuse security measures with performance optimizations."
        },
        {
          "text": "To encrypt the server's private key.",
          "misconception": "Targets [pinning vs. key security]: Students who misunderstand that pinning relates to trust validation, not private key protection."
        },
        {
          "text": "To automatically renew certificates before they expire.",
          "misconception": "Targets [pinning vs. certificate lifecycle]: Students who confuse pinning with automated certificate management processes."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Certificate pinning enhances security by allowing an application to trust only specific, pre-defined certificates or CAs. This prevents attackers from using rogue CAs to issue fraudulent certificates and conduct MitM attacks, as the application will reject unexpected certificates.",
        "distractor_analysis": "The first distractor wrongly associates pinning with performance. The second confuses pinning with private key encryption. The third mixes pinning with certificate renewal processes.",
        "analogy": "Certificate pinning is like having a VIP list for a club. Only people on the list (pinned certificates/CAs) are allowed in. Anyone else, even if they look legitimate, is denied entry, preventing imposters."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "TLS_SECURITY",
        "MITM_ATTACKS",
        "CERTIFICATE_PINNING"
      ]
    },
    {
      "question_text": "What is the recommended practice for handling Diffie-Hellman (DH) parameters when using OpenSSL for TLS?",
      "correct_answer": "Use pre-generated, strong DH parameters (e.g., 2048-bit or higher) and ensure they are not static across all servers to avoid vulnerabilities.",
      "distractors": [
        {
          "text": "Generate DH parameters on-the-fly for each connection to maximize security.",
          "misconception": "Targets [DH parameter generation]: Students who misunderstand the performance implications and security risks of on-the-fly generation versus pre-generation."
        },
        {
          "text": "Use the default DH parameters provided by OpenSSL, as they are always secure.",
          "misconception": "Targets [default parameter security]: Students who assume default settings are always optimal or secure without verification."
        },
        {
          "text": "Use static, well-known DH parameters across all servers for consistency.",
          "misconception": "Targets [static DH parameter risk]: Students who fail to recognize that static DH parameters can be vulnerable to precomputation attacks."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Using strong, pre-generated DH parameters (e.g., 2048-bit or higher) ensures robust key exchange. Avoiding static parameters across multiple servers prevents attackers from pre-computing discrete logarithms once and compromising multiple sessions.",
        "distractor_analysis": "The first distractor ignores performance and potential security issues of on-the-fly generation. The second wrongly trusts default parameters. The third highlights the danger of static parameters.",
        "analogy": "DH parameters are like the secret handshake rules. Using strong, unique rules for each interaction (or at least not the same rule everywhere) makes it much harder for an eavesdropper to learn and impersonate."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "DH_KEY_EXCHANGE",
        "TLS_SECURITY",
        "OPENSSL_CONFIG"
      ]
    },
    {
      "question_text": "In the context of OpenSSL and certificate validation, what does 'revocation' refer to?",
      "correct_answer": "The process of invalidating a previously issued certificate before its scheduled expiration date, typically due to compromise or change in status.",
      "distractors": [
        {
          "text": "The process of encrypting a certificate to protect its contents.",
          "misconception": "Targets [revocation vs. encryption]: Students who confuse certificate status management with data confidentiality."
        },
        {
          "text": "The process of extending the validity period of an existing certificate.",
          "misconception": "Targets [revocation vs. renewal]: Students who misunderstand revocation as an extension rather than an invalidation."
        },
        {
          "text": "The process of digitally signing a certificate to confirm its authenticity.",
          "misconception": "Targets [revocation vs. signing]: Students who confuse the act of invalidation with the act of issuance and verification."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Certificate revocation is essential for security. If a private key is compromised, the corresponding certificate must be invalidated immediately to prevent its misuse. This is typically communicated via Certificate Revocation Lists (CRLs) or Online Certificate Status Protocol (OCSP).",
        "distractor_analysis": "The first distractor assigns an encryption role. The second confuses revocation with renewal. The third mixes revocation with the initial signing process.",
        "analogy": "Revocation is like canceling a credit card. If it's lost or stolen (compromised), you invalidate it so no one else can use it, even though its printed expiry date is still in the future."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "X509_CERTIFICATES",
        "PKI",
        "CERTIFICATE_REVOCATION"
      ]
    },
    {
      "question_text": "What is the purpose of using a strong, unique salt when hashing passwords with OpenSSL utilities?",
      "correct_answer": "To ensure that identical passwords produce different hash outputs, preventing attackers from using precomputed rainbow tables.",
      "distractors": [
        {
          "text": "To increase the speed of the hashing process.",
          "misconception": "Targets [salt vs. performance]: Students who misunderstand that salting adds computational overhead, not speed."
        },
        {
          "text": "To allow password recovery by reversing the hash.",
          "misconception": "Targets [hashing vs. reversibility]: Students who confuse hashing with encryption or believe salts enable recovery."
        },
        {
          "text": "To reduce the storage space required for password hashes.",
          "misconception": "Targets [salt vs. storage]: Students who misunderstand that salts increase storage requirements (hash + salt). "
        }
      ],
      "detailed_explanation": {
        "core_logic": "A unique salt is combined with a password before hashing. This ensures that even if two users have the same password, their resulting hashes will be different. Therefore, precomputed rainbow tables, which rely on identical hashes for identical inputs, become ineffective.",
        "distractor_analysis": "The first distractor incorrectly links salting to speed. The second wrongly suggests password recovery is possible. The third misrepresents the impact on storage.",
        "analogy": "A salt is like adding a unique, random ingredient to each cake batter before baking. Even if two cakes use the same base ingredients (passwords), the final baked cakes (hashes) will be distinct because of the unique added ingredient (salt)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "PASSWORD_SECURITY",
        "CRYPTO_HASHING",
        "SALTING"
      ]
    },
    {
      "question_text": "When configuring OpenSSL for TLS, what is the security implication of disabling TLS compression?",
      "correct_answer": "Disabling compression mitigates the CRIME attack, which exploits vulnerabilities in TLS compression to steal session cookies.",
      "distractors": [
        {
          "text": "It significantly slows down the TLS handshake process.",
          "misconception": "Targets [compression vs. handshake speed]: Students who confuse the impact of compression on handshake versus data transfer, or its security implications."
        },
        {
          "text": "It prevents the use of modern, secure cipher suites.",
          "misconception": "Targets [compression vs. cipher suites]: Students who incorrectly link compression status to the availability of secure algorithms."
        },
        {
          "text": "It forces the use of symmetric encryption for all data.",
          "misconception": "Targets [compression vs. encryption type]: Students who misunderstand that compression is independent of the encryption method used."
        }
      ],
      "detailed_explanation": {
        "core_logic": "TLS compression, particularly when combined with certain encryption modes, can be exploited by the CRIME (Compression Ratio Info-leakage Exploit) attack. By observing changes in the compressed ciphertext size, an attacker can infer secret information like session cookies. Disabling it is a key defense.",
        "distractor_analysis": "The first distractor wrongly attributes a significant performance impact to disabling compression during the handshake. The second incorrectly states it blocks secure cipher suites. The third misrepresents its effect on encryption types.",
        "analogy": "Disabling TLS compression is like removing a shortcut that turned out to be a trap. While the shortcut might have been faster, the risk of being caught (attacked) is too high, so you take the longer, safer route."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "analyze",
      "prerequisites": [
        "TLS_SECURITY",
        "COMPRESSION_ATTACKS",
        "OPENSSL_CONFIG"
      ]
    },
    {
      "question_text": "What is the primary function of the 'Extended Key Usage' (EKU) extension in an OpenSSL-generated certificate?",
      "correct_answer": "To further specify the intended purpose of the public key beyond general key usage, such as for server authentication or client authentication.",
      "distractors": [
        {
          "text": "To define the specific encryption algorithm to be used.",
          "misconception": "Targets [EKU vs. algorithm]: Students who confuse purpose specification with algorithm selection."
        },
        {
          "text": "To list all acceptable domain names for the certificate.",
          "misconception": "Targets [EKU vs. SAN]: Students who confuse EKU with the Subject Alternative Name (SAN) extension."
        },
        {
          "text": "To indicate the geographical region where the certificate is valid.",
          "misconception": "Targets [EKU vs. geographical scope]: Students who assign a location-based function to a purpose-based extension."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The Extended Key Usage (EKU) extension refines the 'Key Usage' by specifying more granular purposes, like 'Server Authentication' (OID 1.3.6.1.5.5.7.3.1) or 'Client Authentication' (OID 1.3.6.1.5.5.7.3.2). This ensures the certificate is used only for its intended role in protocols like TLS.",
        "distractor_analysis": "The first distractor wrongly assigns algorithm specification. The second confuses EKU with the SAN extension. The third incorrectly attributes a geographical scope.",
        "analogy": "If 'Key Usage' is like saying a tool is for 'woodworking', 'Extended Key Usage' is like specifying 'for cutting wood' (saw) versus 'for joining wood' (hammer), providing more precise instructions."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "X509_CERTIFICATES",
        "TLS_AUTHENTICATION",
        "CERTIFICATE_EXTENSIONS"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "OpenSSL Implementation 001_Cryptography best practices",
    "latency_ms": 29700.286
  },
  "timestamp": "2026-01-18T16:00:36.856391"
}