{
  "topic_title": "Shared Secret Computation",
  "category": "001_Cryptography - 005_Asymmetric 001_Cryptography",
  "flashcards": [
    {
      "question_text": "What is the primary goal of shared secret computation in cryptography?",
      "correct_answer": "To enable two or more parties to compute a function on their private inputs without revealing those inputs to each other.",
      "distractors": [
        {
          "text": "To encrypt data so only one party can decrypt it.",
          "misconception": "Targets [encryption vs computation]: Students confuse the goal of secret sharing with single-party encryption."
        },
        {
          "text": "To securely store sensitive data on a public server.",
          "misconception": "Targets [storage vs computation]: Students conflate secure computation with secure data storage."
        },
        {
          "text": "To verify the identity of a user through a cryptographic challenge.",
          "misconception": "Targets [computation vs authentication]: Students mix up the purpose of shared secret computation with authentication protocols."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Shared secret computation allows parties to jointly compute a function on their private inputs, producing a public output, without revealing their individual inputs. This is achieved through protocols that distribute computation securely, enabling collaborative analysis or processing.",
        "distractor_analysis": "The first distractor describes standard encryption, not collaborative computation. The second focuses on secure storage, a different cryptographic goal. The third describes authentication, which uses cryptographic principles but has a different objective than shared secret computation.",
        "analogy": "Imagine two people want to know the average of their secret salaries. Instead of telling each other their salary, they use a special method to calculate the average together without revealing their individual salaries."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_BASICS",
        "CRYPTO_PRIVACY"
      ]
    },
    {
      "question_text": "Which cryptographic primitive is fundamental to many shared secret computation protocols, allowing parties to agree on a secret value without prior shared knowledge?",
      "correct_answer": "Diffie-Hellman Key Exchange (DHKE)",
      "distractors": [
        {
          "text": "RSA encryption",
          "misconception": "Targets [asymmetric encryption vs key exchange]: Students confuse general asymmetric encryption with specific key agreement protocols."
        },
        {
          "text": "AES block cipher",
          "misconception": "Targets [symmetric encryption vs key exchange]: Students mistake symmetric encryption algorithms for key establishment mechanisms."
        },
        {
          "text": "SHA-256 hashing",
          "misconception": "Targets [hashing vs key exchange]: Students confuse one-way hash functions with protocols for generating shared secrets."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Diffie-Hellman Key Exchange (DHKE) is a foundational protocol that enables two parties to establish a shared secret over an insecure channel. It works by leveraging modular arithmetic and discrete logarithms, allowing each party to compute the same secret value without ever transmitting it directly.",
        "distractor_analysis": "RSA is primarily for encryption and digital signatures, not direct key agreement. AES is a symmetric cipher used for encrypting data once a key is established. SHA-256 is a hash function, used for integrity and message digests, not for establishing shared secrets.",
        "analogy": "DHKE is like two people agreeing on a secret paint color by each mixing their private color with a public color, then exchanging the mixed colors. When they add their original private color to the exchanged mix, they both arrive at the same final secret color."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_DHKE",
        "CRYPTO_ASYMMETRIC"
      ]
    },
    {
      "question_text": "In the context of shared secret computation, what is the role of a 'protocol'?",
      "correct_answer": "A defined sequence of steps and rules that parties follow to securely compute a function on their private inputs.",
      "distractors": [
        {
          "text": "A mathematical algorithm that encrypts data.",
          "misconception": "Targets [protocol vs algorithm]: Students confuse the procedural aspect of a protocol with the underlying mathematical operations of an algorithm."
        },
        {
          "text": "A secure storage mechanism for shared secrets.",
          "misconception": "Targets [protocol vs storage]: Students mistake the communication and computation process for a passive storage solution."
        },
        {
          "text": "A method for verifying user credentials.",
          "misconception": "Targets [protocol vs authentication]: Students conflate protocols for collaborative computation with those for identity verification."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A protocol in shared secret computation defines the precise steps and communication exchanges required for parties to compute a function on their private inputs without revealing them. It ensures that the computation is performed correctly and securely, leveraging cryptographic primitives.",
        "distractor_analysis": "An algorithm is a set of rules for computation, but a protocol is the sequence of interactions. Secure storage is about data persistence, not collaborative computation. Authentication is about proving identity, not jointly computing on private data.",
        "analogy": "A recipe is like a protocol for cooking. It outlines the ingredients (inputs), the steps (exchanges), and the final dish (output), ensuring a consistent result."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_PROTOCOLS"
      ]
    },
    {
      "question_text": "Consider a scenario where two parties, Alice and Bob, want to compute the sum of their private numbers, 'a' and 'b', respectively, without revealing 'a' or 'b' to each other. Which type of cryptographic technique is most suitable for this task?",
      "correct_answer": "Secure Multi-Party Computation (SMPC)",
      "distractors": [
        {
          "text": "Homomorphic Encryption",
          "misconception": "Targets [SMPC vs Homomorphic Encryption]: Students confuse a specific technique (HE) with the broader field (SMPC) that can utilize it."
        },
        {
          "text": "Zero-Knowledge Proofs (ZKPs)",
          "misconception": "Targets [SMPC vs ZKPs]: Students confuse proving knowledge of something without revealing it with computing a function on private inputs."
        },
        {
          "text": "Secret Sharing Schemes",
          "misconception": "Targets [SMPC vs Secret Sharing]: Students confuse splitting a secret into parts with jointly computing a function on separate private inputs."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Secure Multi-Party Computation (SMPC) is the cryptographic field dedicated to enabling multiple parties to jointly compute a function over their private inputs. Homomorphic Encryption is a tool that can be used within SMPC, while ZKPs and Secret Sharing serve different, though related, privacy-preserving goals.",
        "distractor_analysis": "Homomorphic Encryption is a *method* that can enable SMPC, but SMPC is the overall goal. ZKPs are for proving knowledge without revealing it. Secret Sharing splits a secret, not for joint computation on separate inputs.",
        "analogy": "SMPC is like a secure voting system where each person casts a private vote, and the system tallies the total votes without ever knowing who voted for whom. Homomorphic Encryption could be one way to build such a tallying system."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "CRYPTO_SMPC",
        "CRYPTO_HE",
        "CRYPTO_ZK",
        "CRYPTO_SECRET_SHARING"
      ]
    },
    {
      "question_text": "What is a key challenge in designing and implementing secure multi-party computation (SMPC) protocols?",
      "correct_answer": "Balancing security guarantees with computational efficiency and communication overhead.",
      "distractors": [
        {
          "text": "Ensuring that all parties have identical hardware.",
          "misconception": "Targets [hardware vs protocol design]: Students focus on environmental factors rather than inherent protocol challenges."
        },
        {
          "text": "Making the protocol compatible with all existing encryption algorithms.",
          "misconception": "Targets [compatibility vs efficiency]: Students overemphasize broad compatibility over practical performance."
        },
        {
          "text": "Guaranteeing that the output is always a prime number.",
          "misconception": "Targets [output format vs security/efficiency]: Students focus on arbitrary output properties instead of core protocol challenges."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SMPC protocols often involve complex cryptographic operations and significant communication between parties. Therefore, a major challenge is to design protocols that provide strong security guarantees (like privacy and correctness) while remaining computationally feasible and minimizing the amount of data that needs to be exchanged.",
        "distractor_analysis": "Hardware uniformity is not a primary cryptographic challenge for SMPC protocols. While compatibility is good, the core challenge is performance trade-offs. Guaranteeing specific output properties like primality is unrelated to the fundamental challenges of SMPC.",
        "analogy": "Building a complex, secure drone that can fly long distances without running out of battery is challenging. You have to balance powerful engines (computation) and large fuel tanks (communication) with the drone's weight and structural integrity (security)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "CRYPTO_SMPC",
        "CRYPTO_PERFORMANCE"
      ]
    },
    {
      "question_text": "How does Homomorphic Encryption (HE) contribute to shared secret computation?",
      "correct_answer": "It allows computations to be performed directly on encrypted data without decrypting it first.",
      "distractors": [
        {
          "text": "It enables parties to securely exchange keys using asymmetric cryptography.",
          "misconception": "Targets [HE vs Key Exchange]: Students confuse the function of HE with key establishment protocols like DHKE."
        },
        {
          "text": "It provides a way to prove knowledge of a secret without revealing the secret.",
          "misconception": "Targets [HE vs Zero-Knowledge Proofs]: Students mix up HE's computational capabilities with the verification function of ZKPs."
        },
        {
          "text": "It splits a secret into multiple shares that can be reconstructed.",
          "misconception": "Targets [HE vs Secret Sharing]: Students confuse HE's ability to compute on ciphertext with the distribution of secrets in secret sharing."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Homomorphic Encryption allows specific mathematical operations (like addition or multiplication) to be performed on ciphertexts, and the result, when decrypted, matches the result of performing the same operations on the original plaintexts. This is crucial for SMPC as it enables computation on private data without decryption.",
        "distractor_analysis": "HE is not primarily for key exchange. It's distinct from Zero-Knowledge Proofs, which focus on verification. HE also differs from secret sharing, which distributes a secret rather than enabling computation on encrypted data.",
        "analogy": "HE is like being able to mix ingredients in a locked box, and the final mixture is the same as if you had mixed them outside the box. You can perform actions on the contents without ever opening the box."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_HE",
        "CRYPTO_SMPC"
      ]
    },
    {
      "question_text": "What is the 'privacy' guarantee in the context of shared secret computation?",
      "correct_answer": "Ensuring that each party's private input remains confidential from all other participating parties.",
      "distractors": [
        {
          "text": "Ensuring that the final computed output is kept secret.",
          "misconception": "Targets [input privacy vs output privacy]: Students confuse the confidentiality of inputs with the confidentiality of the result."
        },
        {
          "text": "Ensuring that the communication channel is encrypted.",
          "misconception": "Targets [channel security vs input privacy]: Students focus on transport security rather than the privacy of the data itself during computation."
        },
        {
          "text": "Ensuring that only authorized parties can participate.",
          "misconception": "Targets [privacy vs access control]: Students conflate data privacy with access control mechanisms."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The core privacy guarantee in shared secret computation is that each participant's individual input data is not revealed to any other participant during or after the computation. The protocol is designed such that only the desired function's output is made public or shared as intended.",
        "distractor_analysis": "The output might be public or shared, so its secrecy isn't the primary privacy goal. While encrypted channels help, they don't guarantee input privacy if the protocol itself leaks information. Access control ensures who can join, not what they learn about others' inputs.",
        "analogy": "In a private survey, each person submits their answers confidentially. The privacy guarantee means no one else sees your individual answers, only the aggregated results (like the average response)."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_PRIVACY",
        "CRYPTO_SMPC"
      ]
    },
    {
      "question_text": "Which NIST Special Publication provides recommendations for key-establishment schemes using discrete logarithm cryptography, a basis for many shared secret computations?",
      "correct_answer": "NIST SP 800-56A Rev. 3",
      "distractors": [
        {
          "text": "NIST SP 800-56B Rev. 2",
          "misconception": "Targets [discrete log vs integer factorization]: Students confuse schemes based on discrete logarithms with those based on integer factorization (like RSA)."
        },
        {
          "text": "NIST SP 800-56C Rev. 2",
          "misconception": "Targets [key establishment vs key derivation]: Students confuse the overall key establishment process with the specific methods for deriving keys from established material."
        },
        {
          "text": "NIST SP 800-108",
          "misconception": "Targets [key establishment vs key derivation methods]: Students confuse general key establishment recommendations with specific key derivation methods."
        }
      ],
      "detailed_explanation": {
        "core_logic": "NIST SP 800-56A Rev. 3 specifically details key-establishment schemes based on discrete logarithm problems, including variations of Diffie-Hellman and MQV. These schemes are fundamental for establishing shared secrets, which are often prerequisites for secure multi-party computation protocols.",
        "distractor_analysis": "SP 800-56B covers integer factorization (RSA) based schemes. SP 800-56C focuses on key derivation methods. SP 800-108 is also about key derivation. SP 800-56A Rev. 3 is the correct document for discrete logarithm-based key establishment.",
        "analogy": "Think of NIST SPs as official blueprints. SP 800-56A Rev. 3 is the blueprint for building secure communication channels using a specific type of mathematical lock (discrete logarithms), which is essential for many secret computations."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "CRYPTO_DHKE",
        "CRYPTO_NIST"
      ]
    },
    {
      "question_text": "What is the 'correctness' guarantee in shared secret computation?",
      "correct_answer": "Ensuring that the computed output is the correct result of the function applied to the parties' private inputs.",
      "distractors": [
        {
          "text": "Ensuring that the protocol completes within a fixed time.",
          "misconception": "Targets [correctness vs performance]: Students confuse the accuracy of the result with the speed of the computation."
        },
        {
          "text": "Ensuring that all parties agree on the final output value.",
          "misconception": "Targets [correctness vs consensus]: Students confuse the accuracy of the result with the agreement among parties (which is implied but not the primary definition)."
        },
        {
          "text": "Ensuring that the protocol is resistant to denial-of-service attacks.",
          "misconception": "Targets [correctness vs availability]: Students mix up the accuracy of the computation with the system's resilience to attacks."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The correctness guarantee ensures that the output produced by a shared secret computation protocol accurately reflects the intended function applied to the private inputs. This means that if the protocol is followed correctly, the result will be mathematically sound, regardless of other parties' inputs.",
        "distractor_analysis": "Performance is a separate concern from the accuracy of the result. While agreement is necessary, correctness focuses on the mathematical validity of the output. Resistance to DoS attacks relates to availability, not the accuracy of a successful computation.",
        "analogy": "If you ask a group to calculate the average of their secret numbers, the correctness guarantee means the final average reported is the actual mathematical average, not a randomly generated number or a miscalculation."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_SMPC",
        "CRYPTO_CORRECTNESS"
      ]
    },
    {
      "question_text": "What is a potential vulnerability if a shared secret computation protocol does not properly handle invalid inputs or corrupted messages?",
      "correct_answer": "The protocol may produce incorrect results or leak private information.",
      "distractors": [
        {
          "text": "The protocol may become excessively fast.",
          "misconception": "Targets [vulnerability vs performance]: Students incorrectly associate input handling issues with performance improvements."
        },
        {
          "text": "The protocol may automatically encrypt all subsequent communications.",
          "misconception": "Targets [vulnerability vs unintended functionality]: Students imagine unrelated cryptographic functions being triggered."
        },
        {
          "text": "The protocol may reveal the public parameters used.",
          "misconception": "Targets [vulnerability vs parameter leakage]: Students confuse input validation issues with the leakage of public, non-sensitive information."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Improper handling of invalid inputs or corrupted messages can break the security guarantees of an SMPC protocol. An attacker might exploit this to force incorrect computations or manipulate the protocol's execution to infer private information from other participants.",
        "distractor_analysis": "Input errors typically degrade performance or security, not improve speed. Automatic encryption is an unrelated function. Leaking public parameters is usually a different type of vulnerability; the primary risk here is incorrect results or privacy breaches.",
        "analogy": "If a recipe (protocol) doesn't specify how to handle spoiled ingredients (invalid inputs), you might end up with a ruined dish (incorrect result) or accidentally reveal secret family recipes (private information)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "CRYPTO_SMPC",
        "CRYPTO_ATTACKS"
      ]
    },
    {
      "question_text": "Which of the following best describes the relationship between Diffie-Hellman Key Exchange (DHKE) and Secure Multi-Party Computation (SMPC)?",
      "correct_answer": "DHKE is often used as a building block within more complex SMPC protocols to establish initial shared secrets or session keys.",
      "distractors": [
        {
          "text": "SMPC is a type of DHKE that allows more than two parties.",
          "misconception": "Targets [SMPC as extension of DHKE vs building block]: Students see SMPC as just a scaled-up DHKE, rather than a broader field using DHKE."
        },
        {
          "text": "DHKE is used to encrypt the final output of an SMPC computation.",
          "misconception": "Targets [DHKE function vs output encryption]: Students confuse key agreement with data encryption."
        },
        {
          "text": "SMPC protocols completely replace the need for DHKE.",
          "misconception": "Targets [SMPC replacing DHKE vs using DHKE]: Students believe SMPC makes DHKE obsolete, rather than leveraging it."
        }
      ],
      "detailed_explanation": {
        "core_logic": "DHKE is a fundamental protocol for establishing shared secrets between two parties. Many SMPC protocols require such shared secrets as a prerequisite for their operation, either for initial setup or for deriving session keys used during the computation. Thus, DHKE serves as a crucial component within the larger SMPC framework.",
        "distractor_analysis": "SMPC is a broader field than just multi-party DHKE; it encompasses various techniques. DHKE establishes keys, it doesn't encrypt the final output. SMPC often relies on DHKE, not replaces it.",
        "analogy": "DHKE is like building the foundation of a house. SMPC is the entire house, which uses that foundation but also includes walls, roof, and rooms (other cryptographic techniques and protocols)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "CRYPTO_DHKE",
        "CRYPTO_SMPC"
      ]
    },
    {
      "question_text": "What is the purpose of 'key confirmation' in key-establishment schemes relevant to shared secret computation?",
      "correct_answer": "To provide assurance to both parties that they have successfully established the same shared secret key.",
      "distractors": [
        {
          "text": "To encrypt the shared secret key itself during transmission.",
          "misconception": "Targets [confirmation vs encryption]: Students confuse the act of verifying receipt with encrypting the secret."
        },
        {
          "text": "To derive multiple session keys from a single master secret.",
          "misconception": "Targets [confirmation vs key derivation]: Students mix up confirmation with the process of generating multiple keys from one."
        },
        {
          "text": "To authenticate the identity of the parties involved.",
          "misconception": "Targets [confirmation vs authentication]: Students conflate verifying shared material with verifying identity."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Key confirmation protocols are appended to key agreement schemes (like DHKE) to ensure that both parties have computed the identical shared secret. This prevents scenarios where one party might have a different key due to errors or manipulation, which could compromise subsequent secure computations.",
        "distractor_analysis": "Key confirmation doesn't encrypt the key; it verifies its successful establishment. Key derivation is a separate process. Authentication verifies who the parties are, not necessarily that they've agreed on the same secret.",
        "analogy": "After agreeing on a secret handshake (shared secret), key confirmation is like both people doing the handshake and giving a nod to confirm they both know and performed it correctly."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_KEY_ESTABLISHMENT",
        "CRYPTO_DHKE"
      ]
    },
    {
      "question_text": "In the context of shared secret computation, what does 'semi-honest' (or '<bos>honest-but-curious') security model imply?",
      "correct_answer": "Participants follow the protocol correctly but may try to learn more information than they are entitled to from the protocol's execution.",
      "distractors": [
        {
          "text": "Participants follow the protocol exactly as specified and do not attempt to learn extra information.",
          "misconception": "Targets [semi-honest vs perfectly honest]: Students confuse the semi-honest model with a stricter, perfectly honest model."
        },
        {
          "text": "Participants may deviate from the protocol or send malicious messages.",
          "misconception": "Targets [semi-honest vs malicious]: Students confuse the semi-honest model with the more robust, but often more complex, malicious model."
        },
        {
          "text": "Participants only reveal their final computed result, nothing else.",
          "misconception": "Targets [semi-honest vs output-only]: Students assume the model implies only the output is ever revealed, ignoring intermediate steps."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The semi-honest model assumes participants are not actively malicious (e.g., they don't abort the protocol or send garbage). However, they are 'curious' and will try to deduce private information about other participants' inputs by analyzing the messages they receive during the protocol's execution.",
        "distractor_analysis": "The first option describes perfect honesty. The third option describes a stronger privacy guarantee than semi-honest typically provides. The third option describes the malicious model, where participants actively try to break the protocol.",
        "analogy": "Imagine a group playing a card game where everyone must play their cards correctly according to the rules. However, one player might try to peek at others' hands or guess their cards based on how they play (curiosity)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_SMPC",
        "CRYPTO_SECURITY_MODELS"
      ]
    },
    {
      "question_text": "What is the primary advantage of using protocols like Oblivious Transfer (OT) within shared secret computation frameworks?",
      "correct_answer": "OT enables a sender to transfer one of multiple pieces of information to a receiver, where the sender doesn't know which piece was chosen, and the receiver only learns the chosen piece.",
      "distractors": [
        {
          "text": "OT allows parties to securely exchange symmetric keys.",
          "misconception": "Targets [OT vs Key Exchange]: Students confuse OT's function with key agreement protocols like DHKE."
        },
        {
          "text": "OT enables computation on encrypted data without decryption.",
          "misconception": "Targets [OT vs Homomorphic Encryption]: Students mistake OT's selective information transfer for HE's computational capabilities."
        },
        {
          "text": "OT guarantees the integrity of all transmitted messages.",
          "misconception": "Targets [OT vs Integrity]: Students confuse OT's privacy-preserving transfer with message integrity checks."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Oblivious Transfer is a fundamental cryptographic primitive that allows a sender to transmit one of several items to a receiver, ensuring privacy for both: the sender doesn't know which item the receiver chose, and the receiver only learns the chosen item. This is vital for constructing SMPC protocols where parties need to selectively receive information without revealing their choices.",
        "distractor_analysis": "OT is not primarily for symmetric key exchange. It's distinct from Homomorphic Encryption, which operates on encrypted data. OT focuses on privacy of selection during transfer, not message integrity.",
        "analogy": "OT is like a vending machine where you select an item (input), but the machine doesn't know which button you pressed. You only get the item you selected, and the machine operator doesn't learn your preference."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_OT",
        "CRYPTO_SMPC"
      ]
    },
    {
      "question_text": "How do Zero-Knowledge Proofs (ZKPs) relate to shared secret computation?",
      "correct_answer": "ZKPs can be used to prove that a computation was performed correctly or that a party possesses certain private information without revealing the underlying data.",
      "distractors": [
        {
          "text": "ZKPs are used to establish the initial shared secret key between parties.",
          "misconception": "Targets [ZKP vs Key Establishment]: Students confuse ZKPs' verification function with key agreement protocols."
        },
        {
          "text": "ZKPs allow computations to be performed directly on encrypted data.",
          "misconception": "Targets [ZKP vs Homomorphic Encryption]: Students mistake ZKPs' proof capabilities with HE's computational abilities on ciphertexts."
        },
        {
          "text": "ZKPs ensure that all parties in a computation are honest.",
          "misconception": "Targets [ZKP vs Malicious Security]: Students believe ZKPs inherently enforce honesty, rather than proving properties about potentially dishonest parties."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Zero-Knowledge Proofs allow one party (the prover) to convince another party (the verifier) that a statement is true, without revealing any information beyond the truth of the statement itself. In SMPC, ZKPs can be used to prove the correctness of a computation or that a party holds valid inputs, enhancing security and trust.",
        "distractor_analysis": "ZKPs are not for establishing shared secrets. They are distinct from Homomorphic Encryption. While ZKPs can help build protocols secure against malicious adversaries, they don't inherently guarantee all parties are honest; they prove specific claims.",
        "analogy": "ZKP is like proving you know the password to a secret room without telling anyone the password. You can demonstrate you know it (e.g., by opening the door), but no one learns the password itself."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "CRYPTO_ZK",
        "CRYPTO_SMPC"
      ]
    },
    {
      "question_text": "What is a 'garbled circuit' in the context of shared secret computation?",
      "correct_answer": "A representation of a function as a circuit where each wire is encrypted, and computation involves processing these encrypted wires.",
      "distractors": [
        {
          "text": "A circuit diagram used for encrypting data using AES.",
          "misconception": "Targets [garbled circuit vs AES circuit]: Students confuse the concept of garbled circuits with the internal structure of a specific symmetric cipher."
        },
        {
          "text": "A secure method for storing private keys.",
          "misconception": "Targets [garbled circuit vs key storage]: Students mistake a computational technique for a key management solution."
        },
        {
          "text": "A protocol for verifying digital signatures.",
          "misconception": "Targets [garbled circuit vs signature verification]: Students confuse a method for secure computation with a method for authentication."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Garbled circuits are a technique used in SMPC, particularly for the 'free- முரசு' (free- முரசு) model. A function is 'garbled' by encrypting its logic and wires. Computation then involves parties processing these encrypted components, allowing them to evaluate the function on private inputs without revealing those inputs.",
        "distractor_analysis": "Garbled circuits are not directly related to AES encryption algorithms. They are a computational technique, not a key storage method. They are also distinct from digital signature verification processes.",
        "analogy": "Imagine a complex Lego structure (function) where each connection point (wire) is locked with a unique, secret key. Building the final structure (computation) involves using these locked connections without ever knowing the original key for each point."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_SMPC",
        "CRYPTO_GARBLED_CIRCUITS"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 16,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Shared Secret Computation 001_Cryptography best practices",
    "latency_ms": 28622.851000000002
  },
  "timestamp": "2026-01-18T15:48:35.424447"
}