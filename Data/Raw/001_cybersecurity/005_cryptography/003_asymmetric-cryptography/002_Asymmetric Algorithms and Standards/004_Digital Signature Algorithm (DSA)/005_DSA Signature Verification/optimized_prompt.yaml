version: '2.0'
metadata:
  topic_title: DSA Signature Verification
  hierarchy:
    level_1_category: Cybersecurity
    level_2_domain: 001_Cryptography
    level_3_subdomain: 005_Asymmetric 001_Cryptography
    level_4_entry_domain: 002_Asymmetric Algorithms and Standards
    level_5_entry_subdomain: Digital Signature Algorithm (DSA)
    level_6_topic: DSA Signature Verification
  curriculum_type: cybersecurity
  source_folders:
    category: 001_cybersecurity
    domain: 005_cryptography
    subdomain: 003_asymmetric-cryptography
  exa_sources: []
  voting:
    consensus_reached: true
    approval_percentage: 0.67
    total_voters: 7
  generation_timestamp: '2026-01-18T15:47:47.337919'
learning_objectives:
  remember:
  - objective: Define key terminology
    verbs:
    - define
    measurable: true
  apply:
  - objective: Apply knowledge to scenarios
    verbs:
    - apply
    measurable: true
  understand:
  - objective: Explain core concepts
    verbs:
    - explain
    measurable: true
  analyze:
  - objective: Analyze relationships
    verbs:
    - analyze
    measurable: true
active_learning:
  discussion_prompt: How would you apply this concept in your work environment?
  peer_teaching: In pairs, one student generates a DSA signature for a sample message using provided parameters (p, q, g,
    private key x) and shares the signature (r, s) with their partner. The partner verifies it using the public key y, explaining
    each step verbally (hash, modular inverse, exponentiation). Switch roles and discuss any errors encountered.
  problem_solving: 'Given a real-world scenario where a software update is signed with DSA but verification fails, students
    debug the issue: is it tampering, wrong key, parameter mismatch, or invalid hash? Implement verification in Python using
    the cryptography library (e.g., hazmat.primitives.asymmetric.dsa), input sample data, identify the cause, and propose
    fixes.'
  additional_activities: []
scaffolding:
- level: 1
  name: Foundation
  focus: Basic terminology and definitions
  content: ''
- level: 2
  name: Components
  focus: Framework components and structure
  content: ''
- level: 3
  name: Implementation
  focus: Practical implementation steps
  content: ''
- level: 4
  name: Integration
  focus: Advanced integration and optimization
  content: ''
flashcard_generation:
  output_schema:
    question: string
    correct_answer: string
    distractors:
    - text: string
      explanation: string
    explanation: string
    bloom_level: enum
    topic_hierarchy: object
  distractor_protocol: 'For MCQ (60% of cards): Generate 3 plausible distractors based on common misconceptions:

    - Distractor 1: Superficially similar but wrong value (e.g., swap u1/u2).

    - Distractor 2: Off-by-one error or invalid range (e.g., r >= q).

    - Distractor 3: Confusion with signing process or RSA (e.g., direct exponentiation without hash).

    Ensure one correct, three wrong; randomize order.'
system_prompt: "You are an expert flashcard generator for cybersecurity education, specializing in DSA Signature Verification.\
  \ Your goal is to create high-quality, spaced-repetition-friendly flashcards that promote mastery via Bloom's Taxonomy,\
  \ active recall, and scaffolding.\n\n**Context and Content:** Use the exact scaffolding layers, learning objectives, active\
  \ learning activities, topic hierarchy, research context (FIPS 186-5, core concepts like parameters p/q/g/y, verification\
  \ steps with w/u1/u2/v, vulnerabilities), and voter suggestions provided. Ensure prior knowledge links (hash, mod arith)\
  \ and big picture (FIPS compliance, ECDSA migration).\n\n**Detailed Verification Process:** 1. Check r,s in (0,q). 2. h=hash(m)\
  \ mod q. 3. w=s^{-1} mod q. 4. u1=h*w mod q. 5. u2=r*w mod q. 6. v=(g^{u1} * y^{u2} mod p) mod q. 7. v==r?\n\n**Flashcard\
  \ Generation Instructions:**\n- Generate exactly 30 flashcards covering all 4 scaffolding layers proportionally and all\
  \ 6 learning objectives.\n- Strictly follow the flashcard_schema: Output a JSON array of 30 objects, each with type, front,\
  \ back, explanation, bloom_level, scaffolding_layer.\n- Incorporate active learning: Include cards prompting comparison\
  \ (DSA vs RSA), peer-style computation, debugging scenarios.\n- Use precise math notation (e.g., mod q). Reference Python\
  \ pow() for exp.\n- Distractors per protocol: Plausible errors only.\n- Ensure university-level rigor: No spoilers in fronts;\
  \ explanations tie to pedagogy.\n\nOutput ONLY the JSON array, e.g., [\n  {\"type\": \"MCQ\", \"front\": \"...\", ...},\n\
  \  ...\n]. No other text."
