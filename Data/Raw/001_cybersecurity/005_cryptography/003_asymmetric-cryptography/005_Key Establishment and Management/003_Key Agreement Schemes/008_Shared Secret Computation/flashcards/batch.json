{
  "topic_title": "Shared Secret Computation",
  "category": "001_Cryptography - 005_Asymmetric 001_Cryptography",
  "flashcards": [
    {
      "question_text": "What is the primary goal of a shared secret computation (SSC) protocol in cryptography?",
      "correct_answer": "To allow two or more parties to jointly compute a function over their private inputs without revealing those inputs to each other.",
      "distractors": [
        {
          "text": "To securely transmit a secret key between two parties.",
          "misconception": "Targets [key exchange confusion]: Students confuse SSC with key agreement protocols like Diffie-Hellman."
        },
        {
          "text": "To encrypt data such that only the sender can decrypt it.",
          "misconception": "Targets [encryption confusion]: Students mistake SSC for standard symmetric or asymmetric encryption."
        },
        {
          "text": "To verify the identity of a party through a cryptographic challenge.",
          "misconception": "Targets [authentication confusion]: Students confuse SSC with authentication mechanisms like digital signatures or challenges."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SSC protocols enable joint computation on private inputs, ensuring privacy because the function's output is revealed without exposing individual inputs. This works by employing cryptographic techniques like homomorphic encryption or secure multi-party computation (MPC).",
        "distractor_analysis": "The first distractor describes key exchange, the second describes encryption, and the third describes authentication, all of which are distinct cryptographic goals from shared secret computation.",
        "analogy": "Imagine two people want to know the average of their salaries without telling each other their exact salary. SSC is like a secure method where they can input their salaries into a 'black box' and only get the average back, keeping their individual salaries private."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_BASICS",
        "CRYPTO_PRIVACY"
      ]
    },
    {
      "question_text": "Which cryptographic primitive is fundamental to many Shared Secret Computation (SSC) protocols, allowing computations on encrypted data?",
      "correct_answer": "Homomorphic Encryption",
      "distractors": [
        {
          "text": "Secure Hash Functions",
          "misconception": "Targets [hashing confusion]: Students confuse one-way hashing with the ability to perform computations on encrypted data."
        },
        {
          "text": "Symmetric Encryption Algorithms (e.g., AES)",
          "misconception": "Targets [symmetric encryption confusion]: Students believe standard symmetric encryption can operate on ciphertext without decryption."
        },
        {
          "text": "Digital Signatures",
          "misconception": "Targets [digital signature confusion]: Students confuse data integrity and non-repudiation with the ability to compute on encrypted data."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Homomorphic encryption is crucial because it allows computations (like addition or multiplication) to be performed directly on ciphertext, producing an encrypted result that, when decrypted, matches the result of operations on the original plaintext. This enables SSC by keeping inputs private throughout the computation.",
        "distractor_analysis": "Secure hash functions are one-way and not designed for computation on encrypted data. Symmetric encryption requires decryption before computation. Digital signatures are for integrity and authentication, not computation on encrypted data.",
        "analogy": "Homomorphic encryption is like being able to add numbers written on sealed envelopes without opening them. You get a new sealed envelope with the sum, and only when you open it do you see the final result."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_HOMOMORPHIC_ENCRYPTION",
        "CRYPTO_SSC"
      ]
    },
    {
      "question_text": "Consider a scenario where Alice and Bob want to compute the sum of their private numbers, x and y, without revealing x or y to each other. Which SSC approach would be most suitable if they can agree on a trusted third party?",
      "correct_answer": "Using a trusted third party to perform the computation on encrypted inputs.",
      "distractors": [
        {
          "text": "Alice encrypts x with Bob's public key, and Bob encrypts y with Alice's public key.",
          "misconception": "Targets [asymmetric encryption misuse]: Students misunderstand how asymmetric encryption works for joint computation and privacy."
        },
        {
          "text": "They use a standard Diffie-Hellman key exchange to establish a shared secret, then use it for computation.",
          "misconception": "Targets [key exchange vs computation]: Students confuse key agreement protocols with protocols for computing functions on private data."
        },
        {
          "text": "Alice hashes x and sends it to Bob, who hashes y and sends it back for comparison.",
          "misconception": "Targets [hashing for privacy]: Students believe hashing can be used to hide inputs during computation, rather than just for integrity checks."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When a trusted third party is available, they can receive encrypted inputs (e.g., using homomorphic encryption) and perform the desired computation (summation). This works because the third party operates on the encrypted data, and only the final encrypted result is returned, which can then be decrypted by Alice and Bob.",
        "distractor_analysis": "The first option uses asymmetric encryption incorrectly for joint computation. The second option confuses key exchange with function computation. The third option uses hashing, which is irreversible and unsuitable for computing a sum.",
        "analogy": "It's like Alice and Bob putting their secret numbers into separate, locked boxes, sending the boxes to a trusted friend who can add the numbers inside without unlocking them, and then returning a new locked box with the sum."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "CRYPTO_SSC",
        "CRYPTO_HOMOMORPHIC_ENCRYPTION",
        "CRYPTO_TRUSTED_THIRD_PARTY"
      ]
    },
    {
      "question_text": "What is the main challenge addressed by Secure Multi-Party Computation (SMPC) protocols in the context of shared secret computation?",
      "correct_answer": "Enabling multiple parties to jointly compute a function on their private inputs while ensuring that no party learns more than the output of the function and their own input.",
      "distractors": [
        {
          "text": "Ensuring the confidentiality of data during transmission.",
          "misconception": "Targets [confidentiality vs privacy]: Students confuse general data confidentiality with the specific privacy guarantees of SMPC regarding intermediate computations."
        },
        {
          "text": "Achieving efficient key exchange between two parties.",
          "misconception": "Targets [key exchange confusion]: Students mistake SMPC for protocols like Diffie-Hellman, which are for establishing shared secrets, not computing functions."
        },
        {
          "text": "Providing data integrity and non-repudiation for computations.",
          "misconception": "Targets [integrity vs privacy]: Students confuse the goals of digital signatures or MACs with the privacy guarantees of SMPC."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SMPC protocols are designed to solve the problem of joint computation on private data. They work by using cryptographic techniques like secret sharing or garbled circuits, ensuring that each party only learns the final output and their own input, thus preserving the privacy of other parties' inputs.",
        "distractor_analysis": "Confidentiality during transmission is a related but distinct problem. Key exchange is about establishing secrets, not computing functions. Integrity and non-repudiation are typically handled by digital signatures, not SMPC's primary goal.",
        "analogy": "SMPC is like a group of people wanting to play a card game where each player's hand is secret. The game's rules (the function) are public, and the outcome (who wins) is revealed, but no one sees anyone else's cards until the game ends."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_SMPC",
        "CRYPTO_PRIVACY"
      ]
    },
    {
      "question_text": "Which of the following is a common technique used in Secure Multi-Party Computation (SMPC) to enable computation on private inputs?",
      "correct_answer": "Garbled Circuits",
      "distractors": [
        {
          "text": "Public Key Infrastructure (PKI)",
          "misconception": "Targets [PKI confusion]: Students confuse the role of PKI in managing digital certificates with the mechanisms of SMPC."
        },
        {
          "text": "Message Authentication Codes (MACs)",
          "misconception": "Targets [MAC confusion]: Students mistake MACs, used for integrity, for a method to compute on private data."
        },
        {
          "text": "Random Oracles",
          "misconception": "Targets [random oracle confusion]: Students confuse the theoretical model of a random oracle with practical SMPC techniques."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Garbled circuits are a key technique in SMPC. They work by 'garbling' a circuit representing the function to be computed, allowing parties to evaluate the circuit on their encrypted inputs without revealing them. This enables joint computation while maintaining input privacy.",
        "distractor_analysis": "PKI is for identity management. MACs are for integrity. Random oracles are a theoretical construct, not a direct SMPC technique for computation.",
        "analogy": "Garbled circuits are like creating a secret decoder ring for a specific puzzle. Each person has a piece of the key, and by combining their pieces and using the decoder, they can solve the puzzle without revealing their individual key pieces."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_SMPC",
        "CRYPTO_GARBLED_CIRCUITS"
      ]
    },
    {
      "question_text": "What is the primary security guarantee provided by protocols based on NIST SP 800-56A Rev. 3 for key establishment?",
      "correct_answer": "Key agreement, ensuring that two parties derive the same shared secret key without it being exposed to eavesdroppers.",
      "distractors": [
        {
          "text": "Confidentiality of transmitted data using the established key.",
          "misconception": "Targets [key establishment vs encryption]: Students confuse the purpose of establishing a key with the use of that key for encryption."
        },
        {
          "text": "Authentication of the communicating parties.",
          "misconception": "Targets [key establishment vs authentication]: Students believe key agreement protocols inherently provide authentication, which often requires additional mechanisms."
        },
        {
          "text": "Integrity of messages exchanged during the key agreement process.",
          "misconception": "Targets [key establishment vs integrity]: Students confuse the security goals of key agreement with those of message integrity checks."
        }
      ],
      "detailed_explanation": {
        "core_logic": "NIST SP 800-56A Rev. 3 specifies schemes for key agreement, primarily using discrete logarithm cryptography. The core function is to enable two parties to derive a shared secret key securely, meaning an eavesdropper cannot determine the key, because the underlying mathematical problem (like Diffie-Hellman) is computationally hard to solve.",
        "distractor_analysis": "While the established key is used for confidentiality, the protocol's primary goal is the secure derivation of the key itself. Authentication is often a separate, though related, concern. Integrity is also a separate security property.",
        "analogy": "NIST SP 800-56A is like a secure method for two people to agree on a secret handshake over a noisy phone line. The goal is that they both end up knowing the same handshake, and no one listening in can figure it out."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_KEY_AGREEMENT",
        "CRYPTO_NIST_SP800_56A"
      ]
    },
    {
      "question_text": "According to NIST SP 800-56C Rev. 2, what is the purpose of Key Derivation Functions (KDFs) in key establishment schemes?",
      "correct_answer": "To derive one or more cryptographically strong keys from a shared secret or master key.",
      "distractors": [
        {
          "text": "To encrypt the shared secret itself for transmission.",
          "misconception": "Targets [unknown]: Not specified"
        },
        {
          "text": "To authenticate the parties involved in the key exchange.",
          "misconception": "Targets [KDF vs authentication]: Students mistake KDFs for authentication mechanisms."
        },
        {
          "text": "To generate random nonces for key agreement protocols.",
          "misconception": "Targets [KDF vs nonce generation]: Students confuse KDFs with the generation of random values used in protocols."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Key Derivation Functions (KDFs) are essential in key establishment because they take a shared secret (often established via a key agreement protocol like Diffie-Hellman) and deterministically generate one or more new keys. This works by using cryptographic primitives like hash functions or pseudorandom functions (PRFs) to expand or extract keying material, ensuring the derived keys are suitable for specific cryptographic operations.",
        "distractor_analysis": "KDFs do not encrypt the shared secret; they use it as input. They are not primarily for authentication, nor for generating random nonces, although nonces might be used as input to a KDF.",
        "analogy": "A KDF is like a recipe for making specific tools (keys) from a raw material (shared secret). The recipe ensures you get the right kind of tool, suitable for a particular job, from the raw material."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_KDF",
        "CRYPTO_KEY_ESTABLISHMENT",
        "CRYPTO_NIST_SP800_56C"
      ]
    },
    {
      "question_text": "Which of the following best describes the 'extraction-then-expansion' method for key derivation, as discussed in NIST SP 800-108?",
      "correct_answer": "First, extract a fixed-length pseudorandom key from the shared secret, then expand this key into multiple keys of desired lengths.",
      "distractors": [
        {
          "text": "Expand the shared secret directly into multiple keys of varying lengths.",
          "misconception": "Targets [expansion-only confusion]: Students miss the 'extraction' step and assume direct expansion from the shared secret."
        },
        {
          "text": "Extract multiple keys of varying lengths directly from the shared secret.",
          "misconception": "Targets [extraction-only confusion]: Students miss the 'expansion' step and assume direct extraction of multiple keys."
        },
        {
          "text": "Use a symmetric cipher to encrypt the shared secret, then hash the result.",
          "misconception": "Targets [encryption/hashing confusion]: Students confuse KDF processes with standard encryption and hashing operations."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The extraction-then-expansion method, detailed in NIST SP 800-108, first uses a pseudorandom function (PRF) like HMAC to extract a fixed-length pseudorandom key (PRK) from the potentially variable-length shared secret. Then, this PRK is used with another PRF to expand it into multiple keys of specific lengths required for different cryptographic operations. This two-step process ensures better key strength and flexibility.",
        "distractor_analysis": "The first distractor omits the extraction step. The second distractor omits the expansion step. The third distractor describes unrelated cryptographic operations.",
        "analogy": "It's like taking a large block of raw clay (shared secret), shaping it into a standard-sized ball (extraction), and then using that ball to sculpt multiple different items like bowls and figures (expansion)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "CRYPTO_KDF",
        "CRYPTO_NIST_SP800_108",
        "CRYPTO_PRF"
      ]
    },
    {
      "question_text": "In the context of shared secret computation, what is a potential security risk if a Key Derivation Function (KDF) is not properly implemented or chosen?",
      "correct_answer": "The derived keys may be weak, predictable, or share vulnerabilities with the underlying shared secret, compromising overall security.",
      "distractors": [
        {
          "text": "The KDF might inadvertently reveal the shared secret during derivation.",
          "misconception": "Targets [KDF leakage]: Students incorrectly assume KDFs are prone to leaking the master secret, rather than producing weak keys."
        },
        {
          "text": "The KDF could cause denial-of-service by consuming excessive computational resources.",
          "misconception": "Targets [KDF performance vs security]: Students focus on potential performance issues rather than the cryptographic weakness of derived keys."
        },
        {
          "text": "The KDF might generate keys that are too short for modern cryptographic standards.",
          "misconception": "Targets [key length vs KDF quality]: Students focus solely on key length, ignoring other cryptographic weaknesses a poor KDF might introduce."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A poorly chosen or implemented KDF can fail to adequately obscure the shared secret or introduce biases, leading to derived keys that are cryptographically weak. This means attackers might be able to guess or brute-force the keys more easily, or even recover the original shared secret, because the KDF did not properly 'expand' or 'extract' secure keying material.",
        "distractor_analysis": "While some KDFs might have performance implications, the primary security risk is weak key generation. Accidental leakage of the shared secret is less common than producing predictable keys. Focusing only on key length ignores other potential cryptographic flaws.",
        "analogy": "Using a faulty tool to cut wood for furniture. The wood might be the right size, but if the tool is flawed, the cuts might be uneven or weak, making the final furniture unstable."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "CRYPTO_KDF",
        "CRYPTO_KEY_STRENGTH"
      ]
    },
    {
      "question_text": "What is the core principle behind the Diffie-Hellman key exchange protocol, a foundational method for shared secret computation?",
      "correct_answer": "Leveraging the difficulty of computing discrete logarithms in a finite field or on elliptic curves to derive a shared secret from public parameters and private keys.",
      "distractors": [
        {
          "text": "Using a pre-shared secret key that is exchanged over an insecure channel.",
          "misconception": "Targets [pre-shared key confusion]: Students confuse Diffie-Hellman with methods that rely on prior secret distribution."
        },
        {
          "text": "Encrypting a session key with the recipient's public key.",
          "misconception": "Targets [asymmetric encryption confusion]: Students mistake Diffie-Hellman for RSA or similar public-key encryption schemes."
        },
        {
          "text": "Hashing the public keys of both parties to derive a shared secret.",
          "misconception": "Targets [hashing confusion]: Students believe hashing public keys can create a shared secret, ignoring the mathematical properties required."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Diffie-Hellman works by having each party generate a private key and compute a public key based on shared public parameters (a generator and a modulus). They exchange public keys, and each party uses their own private key and the other's public key to compute the same shared secret. This is secure because computing the private key from the public keys and parameters is computationally infeasible due to the discrete logarithm problem.",
        "distractor_analysis": "Diffie-Hellman does not require pre-shared keys. It is a key agreement protocol, not an encryption scheme like RSA. Hashing public keys does not yield a secure shared secret.",
        "analogy": "Alice and Bob agree on a common paint color (public parameters). Alice mixes her secret color (private key) with the common color and shows Bob the result (public key). Bob does the same with his secret color. When they mix their results, they both arrive at the same final secret color, but an observer only sees the intermediate mixed colors."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_DIFFIE_HELLMAN",
        "CRYPTO_DISCRETE_LOGARITHM",
        "CRYPTO_ASYMMETRIC_CRYPTO"
      ]
    },
    {
      "question_text": "What is a key difference between Diffie-Hellman (DH) key exchange and an authenticated key agreement protocol like those specified in NIST SP 800-56A Rev. 3?",
      "correct_answer": "Authenticated key agreement protocols include mechanisms (like digital signatures) to verify the identity of the parties involved, preventing man-in-the-middle attacks, whereas basic DH does not.",
      "distractors": [
        {
          "text": "DH uses symmetric keys, while authenticated protocols use asymmetric keys.",
          "misconception": "Targets [symmetric/asymmetric confusion]: Students confuse the key exchange mechanism with the type of keys used."
        },
        {
          "text": "DH derives a single shared secret, while authenticated protocols derive multiple keys.",
          "misconception": "Targets [key derivation scope]: Students confuse the number of keys derived with the authentication property."
        },
        {
          "text": "DH is vulnerable to eavesdropping, while authenticated protocols are not.",
          "misconception": "Targets [DH eavesdropping vulnerability]: Students misunderstand that basic DH is vulnerable to MITM, not passive eavesdropping on the key itself if parameters are exchanged securely."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Basic Diffie-Hellman is susceptible to man-in-the-middle (MITM) attacks because parties exchange public keys without verifying their origin. Authenticated key agreement protocols, such as those in NIST SP 800-56A Rev. 3, incorporate authentication steps (e.g., using digital signatures tied to the ephemeral keys) to ensure parties are communicating with whom they believe they are, thus preventing MITM attacks.",
        "distractor_analysis": "Both DH and authenticated protocols typically use asymmetric cryptography principles. The number of keys derived is a KDF function, not the core difference. Basic DH is vulnerable to MITM, but not passive eavesdropping on the final key if the exchange is secure; the vulnerability is active interception.",
        "analogy": "Basic DH is like two people shouting their paint colors across a crowded room â€“ they can agree on a final mixed color, but someone in between could intercept and substitute their own colors. Authenticated DH is like them showing ID badges while shouting their colors, proving who they are before mixing."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "CRYPTO_DIFFIE_HELLMAN",
        "CRYPTO_AUTHENTICATED_KEY_AGREEMENT",
        "CRYPTO_MITM_ATTACK",
        "CRYPTO_NIST_SP800_56A"
      ]
    },
    {
      "question_text": "What is the primary security concern with using a static Diffie-Hellman (DH) public key throughout multiple sessions?",
      "correct_answer": "If the static private key is compromised, all past and future sessions established using that key can be decrypted.",
      "distractors": [
        {
          "text": "It prevents the derivation of multiple session keys from a single shared secret.",
          "misconception": "Targets [static key vs key derivation]: Students confuse the persistence of a static key with the process of deriving multiple session keys."
        },
        {
          "text": "It makes the Diffie-Hellman exchange vulnerable to passive eavesdropping.",
          "misconception": "Targets [static key vs eavesdropping]: Students incorrectly believe static keys inherently expose the exchange to passive eavesdropping, rather than retroactive decryption."
        },
        {
          "text": "It requires a larger key size compared to ephemeral Diffie-Hellman.",
          "misconception": "Targets [static vs ephemeral key size]: Students incorrectly assume static keys necessitate larger sizes than ephemeral ones for comparable security."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Using a static DH private key means that if an attacker compromises it, they can retroactively decrypt all past communications secured with keys derived from that static key, because they can re-compute the shared secret for any past session. This is known as 'harvest now, decrypt later'. Ephemeral DH, where a new key pair is generated for each session, avoids this risk because compromising one session's private key does not affect others.",
        "distractor_analysis": "Static keys do not inherently prevent multiple key derivations. The primary risk is retroactive decryption, not passive eavesdropping during the exchange itself (though MITM is still a risk). Key size is generally determined by security requirements, not solely by static vs. ephemeral usage.",
        "analogy": "Using the same key to lock your house every day. If a burglar steals that key, they can not only get into your house today but also go back and open any doors they previously locked with that same key."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "CRYPTO_DIFFIE_HELLMAN",
        "CRYPTO_STATIC_VS_EPHEMERAL_KEYS",
        "CRYPTO_HARVEST_NOW_DECRYPT_LATER"
      ]
    },
    {
      "question_text": "What is the role of a 'nonce' (number used once) in certain key establishment or shared secret computation protocols?",
      "correct_answer": "To ensure that a cryptographic key or secret is unique for each session or operation, preventing replay attacks and ensuring forward secrecy.",
      "distractors": [
        {
          "text": "To encrypt the final shared secret key.",
          "misconception": "Targets [nonce vs encryption]: Students confuse the purpose of a nonce with encryption functions."
        },
        {
          "text": "To provide data integrity for the exchanged parameters.",
          "misconception": "Targets [nonce vs integrity]: Students mistake nonces for mechanisms that ensure data integrity, like MACs."
        },
        {
          "text": "To serve as the primary shared secret key itself.",
          "misconception": "Targets [nonce vs shared secret]: Students confuse the role of a nonce as a unique identifier with the actual secret key."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Nonces are random or pseudo-random numbers used only once within a specific cryptographic context. In key establishment, they help ensure that each session derives a unique shared secret, even if other parameters are identical. This prevents replay attacks where an attacker might reuse old session parameters. By ensuring uniqueness, nonces contribute to forward secrecy, meaning a compromise of long-term keys doesn't compromise past sessions.",
        "distractor_analysis": "Nonces are not used for encryption, data integrity, or as the shared secret itself. Their purpose is to provide uniqueness and prevent attacks related to reusing cryptographic material.",
        "analogy": "A nonce is like a unique ticket number for each movie showing. Even if the movie is the same, each ticket number ensures you get a specific seat for that specific showing, preventing someone from using an old ticket for a new showing."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_NONCE",
        "CRYPTO_REPLAY_ATTACK",
        "CRYPTO_FORWARD_SECRECY"
      ]
    },
    {
      "question_text": "Consider the scenario of establishing a shared secret between Alice and Bob using ephemeral Diffie-Hellman. What is the main security benefit of using ephemeral keys compared to static keys?",
      "correct_answer": "Forward Secrecy: If Alice's or Bob's long-term private key (used for authentication) is compromised, past session keys derived from ephemeral keys remain secure.",
      "distractors": [
        {
          "text": "Increased computational efficiency during key exchange.",
          "misconception": "Targets [efficiency vs security]: Students incorrectly assume ephemeral keys are computationally cheaper than static ones."
        },
        {
          "text": "Guaranteed authentication of both parties without additional mechanisms.",
          "misconception": "Targets [authentication guarantee]: Students believe ephemeral DH inherently provides authentication, which is not true without additional steps."
        },
        {
          "text": "Reduced key size requirements for equivalent security levels.",
          "misconception": "Targets [key size]: Students incorrectly assume ephemeral keys allow for smaller key sizes compared to static keys."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Ephemeral Diffie-Hellman generates a new, temporary private key for each session. This provides forward secrecy because even if a long-term private key (used for signing or identity) is later compromised, past session keys cannot be recalculated. This works because the ephemeral private keys used to generate the session secret are discarded after the session, making them unavailable for retroactive decryption.",
        "distractor_analysis": "Ephemeral key generation can be computationally more intensive than using a static key. Authentication requires separate mechanisms (like signatures). Key size is determined by the algorithm and security level, not primarily by static vs. ephemeral usage.",
        "analogy": "Using a different, disposable key to lock your house each day. If someone steals today's key, they can't use it to unlock your house from yesterday or tomorrow. Your main house key (long-term key) might still be safe."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "analyze",
      "prerequisites": [
        "CRYPTO_EPHEMERAL_DH",
        "CRYPTO_FORWARD_SECRECY",
        "CRYPTO_STATIC_VS_EPHEMERAL_KEYS"
      ]
    },
    {
      "question_text": "In the context of shared secret computation, what is the 'online' phase?",
      "correct_answer": "The phase where parties interactively exchange messages to compute the function, typically involving cryptographic protocols.",
      "distractors": [
        {
          "text": "The phase where parties pre-process data or set up cryptographic structures.",
          "misconception": "Targets [online vs offline phase]: Students confuse the interactive computation phase with the setup or offline phase."
        },
        {
          "text": "The phase where the final computed result is decrypted and revealed.",
          "misconception": "Targets [online phase vs output revelation]: Students mistake the final output step for the interactive computation process."
        },
        {
          "text": "The phase where parties generate their private keys.",
          "misconception": "Targets [online phase vs key generation]: Students confuse key generation with the interactive computation phase."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The online phase of a shared secret computation protocol is the period during which parties actively communicate and exchange messages to perform the computation. This phase typically relies on cryptographic primitives and protocols (like garbled circuits or secret sharing interactions) to ensure privacy and correctness of the computed function's output.",
        "distractor_analysis": "The setup or offline phase involves preparation before interaction. Key generation is usually part of setup. Revealing the final result is the conclusion of the online phase, not the phase itself.",
        "analogy": "In a collaborative puzzle-solving session, the 'online' phase is when everyone is actively discussing clues, exchanging puzzle pieces, and working together to assemble the picture. The 'offline' phase might be gathering the puzzle pieces beforehand."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_SSC",
        "CRYPTO_PROTOCOL_PHASES"
      ]
    },
    {
      "question_text": "What security property is primarily ensured by using techniques like secret sharing in Secure Multi-Party Computation (SMPC)?",
      "correct_answer": "Input Privacy: Ensures that individual parties' inputs are not revealed to other participants during the computation.",
      "distractors": [
        {
          "text": "Output Confidentiality: Ensures the final computed result is kept secret from all parties.",
          "misconception": "Targets [output confidentiality vs input privacy]: Students confuse the privacy of inputs with the confidentiality of the output."
        },
        {
          "text": "Computational Efficiency: Ensures the computation completes quickly.",
          "misconception": "Targets [privacy vs efficiency]: Students mistake a security goal for a performance goal."
        },
        {
          "text": "Non-repudiation: Ensures that a party cannot deny having participated in the computation.",
          "misconception": "Targets [privacy vs non-repudiation]: Students confuse input privacy with the non-repudiation property typically provided by digital signatures."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Secret sharing schemes, a core technique in SMPC, work by splitting a party's input into multiple shares distributed among participants. The function can then be computed on these shares. Crucially, individual shares do not reveal the original input, thus preserving input privacy. Only when enough shares are combined (often at the end or during specific steps) can the result be reconstructed, ensuring no party learns more than the function's output and their own input.",
        "distractor_analysis": "SMPC aims to reveal the output, not keep it confidential from participants. Efficiency is a performance goal, not the primary security property. Non-repudiation is typically achieved through digital signatures, not secret sharing alone.",
        "analogy": "Imagine dividing a secret message into pieces and giving one piece to each friend. No single friend can read the message from their piece alone, but together they can reconstruct it. This protects the individual pieces (inputs) while allowing collaborative reading (computation)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_SMPC",
        "CRYPTO_SECRET_SHARING",
        "CRYPTO_INPUT_PRIVACY"
      ]
    },
    {
      "question_text": "What is the 'man-in-the-middle' (MITM) attack in the context of key agreement protocols?",
      "correct_answer": "An attacker intercepts communications between two parties, establishing separate shared secrets with each, and relaying messages between them while potentially altering them.",
      "distractors": [
        {
          "text": "An attacker passively listens to the communication channel to capture the final shared secret.",
          "misconception": "Targets [MITM vs eavesdropping]: Students confuse active interception and manipulation with passive listening."
        },
        {
          "text": "An attacker uses a known weak key to decrypt all communications.",
          "misconception": "Targets [MITM vs weak key attack]: Students confuse an active interception attack with exploiting known cryptographic weaknesses."
        },
        {
          "text": "An attacker forces one party to reveal their private key.",
          "misconception": "Targets [MITM vs key compromise]: Students confuse an interception attack with direct compromise of a private key."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A man-in-the-middle attack exploits the lack of authentication in basic key agreement protocols like unauthenticated Diffie-Hellman. The attacker actively intercepts the public key exchange. They pretend to be the intended recipient to one party and the intended sender to the other, establishing two separate shared secrets. This allows the attacker to decrypt, read, and potentially modify all subsequent communication between the legitimate parties.",
        "distractor_analysis": "Passive eavesdropping doesn't involve manipulation. Weak key attacks exploit cryptographic flaws, not protocol interaction. Forcing key disclosure is a different type of attack.",
        "analogy": "Imagine Alice wants to send a secret message to Bob via Charlie. A MITM attacker (Charlie) intercepts Alice's message, reads it, changes it, and then sends it to Bob. Charlie does the same when relaying Bob's reply to Alice, making them think they are communicating directly."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "attack",
      "bloom_level": "apply",
      "prerequisites": [
        "CRYPTO_MITM_ATTACK",
        "CRYPTO_KEY_AGREEMENT",
        "CRYPTO_AUTHENTICATION"
      ]
    },
    {
      "question_text": "Which cryptographic concept is essential for defending against replay attacks in key establishment protocols?",
      "correct_answer": "Nonces (Numbers used once) or Timestamps",
      "distractors": [
        {
          "text": "Symmetric Encryption",
          "misconception": "Targets [encryption vs replay defense]: Students believe encryption alone prevents replay attacks, ignoring the need for unique session identifiers."
        },
        {
          "text": "Hashing Algorithms",
          "misconception": "Targets [hashing vs replay defense]: Students confuse data integrity checks with mechanisms to prevent reusing old messages."
        },
        {
          "text": "Public Key Infrastructure (PKI)",
          "misconception": "Targets [PKI vs replay defense]: Students mistake PKI's role in authentication for preventing message replays."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Replay attacks involve an attacker capturing valid communication (like a key exchange) and re-transmitting it later to impersonate a party or reuse a session. Nonces or timestamps are critical defenses because they ensure that each message or session is unique and time-bound. The receiving party checks the nonce/timestamp to ensure it hasn't been seen before or is within an acceptable time window, thus rejecting replayed messages. This works by adding a unique, unpredictable element to each interaction.",
        "distractor_analysis": "Symmetric encryption secures data but doesn't inherently prevent reuse of encrypted messages. Hashing ensures integrity but not uniqueness over time. PKI manages identities but doesn't directly prevent replay without additional protocol elements.",
        "analogy": "Using a unique, single-use ticket number for each event entry. If someone tries to reuse an old ticket number, the system recognizes it's already been used for a past event and denies entry."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "CRYPTO_REPLAY_ATTACK",
        "CRYPTO_NONCE",
        "CRYPTO_KEY_ESTABLISHMENT"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 18,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Shared Secret Computation 001_Cryptography best practices",
    "latency_ms": 37333.168
  },
  "timestamp": "2026-01-18T15:50:54.582690"
}