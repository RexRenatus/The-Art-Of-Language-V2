{
  "topic_title": "PGP/GPG 006_Key Management",
  "category": "001_Cryptography - 006_Key Management",
  "flashcards": [
    {
      "question_text": "What is the primary purpose of a Public Key Infrastructure (PKI) in the context of PGP/GPG key management?",
      "correct_answer": "To bind public keys to verified identities through trusted third-party certificates.",
      "distractors": [
        {
          "text": "To securely store and encrypt private keys on a user's local machine.",
          "misconception": "Targets [storage vs. identity binding]: Students confuse the role of PKI with local key storage mechanisms."
        },
        {
          "text": "To automatically generate random symmetric encryption keys for secure communication.",
          "misconception": "Targets [PKI vs. key generation]: Students misunderstand that PKI is about identity verification, not key generation."
        },
        {
          "text": "To provide a decentralized ledger for all public keys and their associated revocations.",
          "misconception": "Targets [PKI vs. blockchain]: Students incorrectly associate PKI with distributed ledger technologies like blockchain."
        }
      ],
      "detailed_explanation": {
        "core_logic": "PKI establishes trust by using Certificate Authorities (CAs) to issue digital certificates that bind public keys to identities. This allows users to verify the authenticity of a public key before using it for encryption or signature verification, because the CA acts as a trusted third party.",
        "distractor_analysis": "The first distractor describes local key storage, not PKI's function. The second misrepresents PKI as a key generation service. The third incorrectly attributes blockchain-like features to PKI.",
        "analogy": "Think of a PKI like a government issuing official IDs. The ID (certificate) proves your identity (public key) is genuinely yours, vouched for by a trusted authority (CA)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_PKI",
        "CRYPTO_DIGITAL_SIGNATURES"
      ]
    },
    {
      "question_text": "According to NIST SP 800-57 Part 1 Rev. 5, what is a critical best practice for managing cryptographic keys?",
      "correct_answer": "Keys should be protected with the same or higher level of security as the data they protect.",
      "distractors": [
        {
          "text": "Keys can be stored unencrypted if they are used infrequently.",
          "misconception": "Targets [key protection level]: Students underestimate the importance of protecting keys even if access is infrequent."
        },
        {
          "text": "Symmetric keys can be shared openly between parties for convenience.",
          "misconception": "Targets [symmetric key security]: Students fail to grasp that symmetric keys must be kept secret by all parties."
        },
        {
          "text": "Public keys do not require protection as they are meant to be shared.",
          "misconception": "Targets [public key security]: Students confuse public keys with private keys and overlook the need for integrity and authenticity checks."
        }
      ],
      "detailed_explanation": {
        "core_logic": "NIST SP 800-57 emphasizes that cryptographic keys are the foundation of secure communication; therefore, they must be protected with a security level commensurate with the data they secure. This is because compromised keys can lead to the compromise of all protected data.",
        "distractor_analysis": "The first distractor suggests lax security for infrequent keys, which is incorrect. The second promotes insecure sharing of symmetric keys. The third incorrectly implies public keys need no protection, ignoring integrity and authenticity.",
        "analogy": "Treat your encryption keys like the keys to your most valuable safe. You wouldn't leave them lying around, even if you only opened the safe once a month."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "CRYPTO_KEY_MANAGEMENT",
        "NIST_SP_800_57"
      ]
    },
    {
      "question_text": "In GPG (GNU Privacy Guard), what is the purpose of the <code>--quick-generate-key</code> command?",
      "correct_answer": "To generate a standard OpenPGP key with a single user ID without interactive prompts.",
      "distractors": [
        {
          "text": "To import an existing public key into the user's keyring.",
          "misconception": "Targets [key generation vs. import]: Students confuse key creation with the process of adding external keys."
        },
        {
          "text": "To revoke a previously generated key due to compromise.",
          "misconception": "Targets [key generation vs. revocation]: Students mix up the command for creating keys with the command for invalidating them."
        },
        {
          "text": "To encrypt a file using a specified symmetric cipher.",
          "misconception": "Targets [key generation vs. encryption]: Students confuse key management operations with file encryption operations."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>--quick-generate-key</code> command in GPG is designed for rapid, non-interactive key creation, making it useful for scripting or when default settings are acceptable. It streamlines the process compared to the more detailed <code>--generate-key</code> command, because it bypasses user prompts.",
        "distractor_analysis": "The first distractor describes importing keys, not generating them. The second refers to key revocation, a different lifecycle management task. The third is about file encryption, not key generation.",
        "analogy": "It's like using a 'quick start' button on a device versus going through a full setup wizard. The quick start gets you going fast with defaults."
      },
      "code_snippets": [
        {
          "language": "bash",
          "code": "<pre><code>class=\"language-bash\"\n--quick-generate-key user-id [algo [usage [expire]]]\n</code></pre>",
          "context": "explanation"
        }
      ],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "GPG_BASICS",
        "CRYPTO_KEY_GENERATION"
      ],
      "_code_snippets_html": "<div class=\"code-snippet code-explanation\">\n<span class=\"code-label\">Code Example</span>\n<pre><code class=\"language-bash\">&lt;pre&gt;&lt;code&gt;class=&quot;language-bash&quot;\n--quick-generate-key user-id [algo [usage [expire]]]\n&lt;/code&gt;&lt;/pre&gt;</code></pre>\n</div>"
    },
    {
      "question_text": "What is the role of a Nonce (Number used once) in cryptographic protocols, particularly in key management contexts?",
      "correct_answer": "To ensure that a specific key or message is never reused in a cryptographic operation, preventing replay attacks.",
      "distractors": [
        {
          "text": "To provide a unique, fixed-length identifier for encrypted messages.",
          "misconception": "Targets [nonce vs. hash]: Students confuse the purpose of a nonce with that of a cryptographic hash function."
        },
        {
          "text": "To establish a shared secret key between two parties during initial communication.",
          "misconception": "Targets [nonce vs. key agreement]: Students mix up the role of a nonce with protocols like Diffie-Hellman for key exchange."
        },
        {
          "text": "To encrypt the actual message content, ensuring confidentiality.",
          "misconception": "Targets [nonce vs. encryption algorithm]: Students misunderstand that a nonce is a parameter, not the encryption mechanism itself."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A nonce is a random or pseudo-random number that is intended to be used only once in a cryptographic communication. Its purpose is to prevent replay attacks by ensuring that a message or key exchange cannot be validly re-submitted, because the nonce would be different each time.",
        "distractor_analysis": "The first distractor describes a hash function's output. The second describes key agreement protocols. The third incorrectly assigns the role of encryption to a nonce.",
        "analogy": "A nonce is like a unique ticket number for a specific event entry. You can only use that ticket number once; trying to use it again for the same event won't work."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_NONCE",
        "CRYPTO_REPLAY_ATTACKS"
      ]
    },
    {
      "question_text": "When using GPG, what is the significance of a key's expiration date?",
      "correct_answer": "It enforces a periodic re-evaluation and potential renewal of trust in the key.",
      "distractors": [
        {
          "text": "It automatically invalidates the key and prevents its use after the date.",
          "misconception": "Targets [expiration vs. automatic invalidation]: Students believe expiration automatically breaks the key, rather than signaling a need for review."
        },
        {
          "text": "It indicates the key's strength and the algorithm used for encryption.",
          "misconception": "Targets [expiration vs. key strength]: Students confuse the time-based validity with the cryptographic strength of the key."
        },
        {
          "text": "It is primarily used to track the key's usage history for auditing purposes.",
          "misconception": "Targets [expiration vs. audit trail]: Students misunderstand that expiration is about trust lifecycle, not a detailed usage log."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Setting an expiration date for a GPG key is a best practice for key management, as recommended by standards like NIST SP 800-57. It ensures that keys are periodically reviewed and re-validated, because the trust in a key's association with an identity can degrade over time.",
        "distractor_analysis": "The first distractor overstates the effect of expiration; keys don't automatically break. The second incorrectly links expiration to key strength. The third misinterprets its purpose as an audit log.",
        "analogy": "An expiration date on a driver's license doesn't mean the license is invalid; it means you need to renew it to continue using it legally."
      },
      "code_snippets": [
        {
          "language": "bash",
          "code": "<pre><code>class=\"language-bash\"\n--quick-gen-key user-id --expire YYYY-MM-DD\n</code></pre>",
          "context": "explanation"
        }
      ],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "GPG_BASICS",
        "CRYPTO_KEY_LIFECYCLE"
      ],
      "_code_snippets_html": "<div class=\"code-snippet code-explanation\">\n<span class=\"code-label\">Code Example</span>\n<pre><code class=\"language-bash\">&lt;pre&gt;&lt;code&gt;class=&quot;language-bash&quot;\n--quick-gen-key user-id --expire YYYY-MM-DD\n&lt;/code&gt;&lt;/pre&gt;</code></pre>\n</div>"
    },
    {
      "question_text": "What is the primary security concern addressed by using a 'salt' when hashing passwords in systems like those managed by GPG?",
      "correct_answer": "To prevent attackers from using precomputed rainbow tables to crack password hashes.",
      "distractors": [
        {
          "text": "To encrypt the password before hashing, adding an extra layer of confidentiality.",
          "misconception": "Targets [salt vs. encryption]: Students confuse salting with applying a separate encryption step before hashing."
        },
        {
          "text": "To ensure that identical passwords produce different hash values.",
          "misconception": "Targets [salt vs. unique hash generation]: While true, this is a consequence, not the primary security concern addressed by salting against rainbow tables."
        },
        {
          "text": "To reduce the computational cost of hashing for faster authentication.",
          "misconception": "Targets [salt vs. performance]: Students believe salting improves performance, when it actually increases computational effort."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A salt is a random value added to a password before hashing. This unique salt, stored alongside the hash, ensures that even identical passwords generate different hashes, thereby thwarting rainbow table attacks because precomputed tables become ineffective.",
        "distractor_analysis": "The first distractor confuses salting with encryption. The second describes a side effect rather than the main security goal. The third incorrectly suggests performance benefits.",
        "analogy": "Imagine each person using a unique, random secret ingredient (salt) when baking their cookies (password). Even if two people bake the same cookie recipe (password), the final product (hash) will taste different and won't match a pre-made 'standard' cookie."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "analyze",
      "prerequisites": [
        "CRYPTO_PASSWORD_HASHING",
        "CRYPTO_SALTING",
        "CRYPTO_RAINBOW_TABLES"
      ]
    },
    {
      "question_text": "How does GPG's key management system facilitate secure communication between two parties who have never met?",
      "correct_answer": "By allowing each party to exchange their public keys, which can then be used to encrypt messages for the other party.",
      "distractors": [
        {
          "text": "By automatically generating a shared secret key upon initial connection.",
          "misconception": "Targets [key exchange vs. automatic generation]: Students believe keys are magically created upon connection, rather than being exchanged."
        },
        {
          "text": "By relying on a central server to broker all encrypted messages.",
          "misconception": "Targets [decentralized vs. centralized]: Students confuse GPG's decentralized model with centralized communication systems."
        },
        {
          "text": "By encrypting messages with a universally known public key.",
          "misconception": "Targets [universal key vs. individual keys]: Students misunderstand that encryption requires the recipient's specific public key."
        }
      ],
      "detailed_explanation": {
        "core_logic": "GPG uses asymmetric cryptography, where each user has a public key and a private key. To communicate securely, users exchange their public keys. Since the public key can only encrypt messages that the corresponding private key can decrypt, this enables secure communication without prior secret sharing, because the public key is safe to share.",
        "distractor_analysis": "The first distractor describes automatic key generation, which isn't how GPG works. The second incorrectly assumes a centralized server model. The third suggests a single, universal public key, which is insecure and impractical.",
        "analogy": "It's like exchanging phone numbers (public keys). Once you have someone's number, you can call them (encrypt messages) knowing only they can answer (decrypt messages) with their phone (private key)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "CRYPTO_ASYMMETRIC_ENCRYPTION",
        "CRYPTO_PUBLIC_KEY_EXCHANGE"
      ]
    },
    {
      "question_text": "What is the primary function of a Certificate Authority (CA) within a Public Key Infrastructure (PKI)?",
      "correct_answer": "To issue and manage digital certificates that bind public keys to specific entities.",
      "distractors": [
        {
          "text": "To generate all public and private keys for users within the system.",
          "misconception": "Targets [CA vs. key generation]: Students confuse the CA's role in verifying identity with generating cryptographic keys."
        },
        {
          "text": "To encrypt and decrypt all messages exchanged between users.",
          "misconception": "Targets [CA vs. encryption/decryption]: Students misunderstand that CAs manage certificates, not perform message encryption."
        },
        {
          "text": "To store and distribute all public keys securely across the network.",
          "misconception": "Targets [CA vs. public key repository]: While CAs are part of the infrastructure, their primary role is issuance, not just storage/distribution."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A CA is a trusted third party that verifies the identity of an entity (person, organization, server) and issues a digital certificate containing that entity's public key. This process establishes trust in the public key, because the CA's reputation is on the line.",
        "distractor_analysis": "The first distractor wrongly assigns key generation to CAs. The second misattributes message encryption/decryption. The third oversimplifies the CA's role to mere storage, ignoring the critical verification and issuance functions.",
        "analogy": "A CA is like the Department of Motor Vehicles (DMV). It verifies your identity and issues you a driver's license (digital certificate) that proves who you are."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_PKI",
        "CRYPTO_DIGITAL_CERTIFICATES"
      ]
    },
    {
      "question_text": "In the context of PGP/GPG, what does it mean to 'sign' a message with your private key?",
      "correct_answer": "To create a digital signature that verifies the sender's identity and ensures the message has not been altered.",
      "distractors": [
        {
          "text": "To encrypt the message so only the intended recipient can read it.",
          "misconception": "Targets [signing vs. encryption]: Students confuse the purpose of signing (authentication/integrity) with encryption (confidentiality)."
        },
        {
          "text": "To create a unique, one-time code for message transmission.",
          "misconception": "Targets [signing vs. nonce]: Students mix up digital signatures with nonces used to prevent replay attacks."
        },
        {
          "text": "To hash the message content into a fixed-size digest.",
          "misconception": "Targets [signing vs. hashing]: Students confuse the signing process with the hashing process, which is a component but not the whole."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Signing a message involves hashing the message content and then encrypting that hash with the sender's private key. This creates a digital signature. The recipient can then verify the signature using the sender's public key, confirming both the sender's identity and the message's integrity, because only the private key holder could have created it.",
        "distractor_analysis": "The first distractor describes encryption, not signing. The second describes a nonce. The third describes only the hashing part of the signing process.",
        "analogy": "Signing a document is like putting your unique handwritten signature on it. It proves you wrote it and that the document hasn't been changed after you signed it."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_DIGITAL_SIGNATURES",
        "CRYPTO_PRIVATE_KEY_USAGE"
      ]
    },
    {
      "question_text": "What is the primary risk associated with reusing a private key across multiple PGP/GPG key management operations?",
      "correct_answer": "A single compromise of the private key would expose all associated communications and identities.",
      "distractors": [
        {
          "text": "It reduces the overall security strength of the encryption algorithms used.",
          "misconception": "Targets [key reuse vs. algorithm strength]: Students confuse the impact of key reuse on security with the inherent strength of cryptographic algorithms."
        },
        {
          "text": "It causes the public key to become invalid, preventing future communications.",
          "misconception": "Targets [private key compromise vs. public key validity]: Students incorrectly believe compromising a private key invalidates its corresponding public key."
        },
        {
          "text": "It significantly increases the computational resources required for signing and encryption.",
          "misconception": "Targets [key reuse vs. performance]: Students wrongly assume key reuse impacts performance rather than security."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Reusing a private key across different functions (e.g., signing, decrypting) amplifies the impact of a single compromise. If the private key is stolen, an attacker can impersonate the user, decrypt past and future messages, and forge signatures, because the key is the sole basis for these operations.",
        "distractor_analysis": "The first distractor incorrectly links key reuse to algorithm strength. The second wrongly states that private key compromise invalidates the public key. The third suggests a performance impact, which is not the primary concern.",
        "analogy": "Using the same master key for your house, car, and safe deposit box. If that one key is lost or stolen, all three are compromised."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "analyze",
      "prerequisites": [
        "CRYPTO_KEY_LIFECYCLE",
        "CRYPTO_PRIVATE_KEY_SECURITY"
      ]
    },
    {
      "question_text": "According to NIST SP 800-57 Part 2 Rev. 1, what is a key element of effective institutional key management?",
      "correct_answer": "Establishing clear policies and procedures for key lifecycle management (generation, distribution, storage, revocation).",
      "distractors": [
        {
          "text": "Using the strongest available encryption algorithm for all keys.",
          "misconception": "Targets [policy vs. algorithm choice]: Students focus on algorithm strength, overlooking the critical need for process and policy."
        },
        {
          "text": "Implementing a single, centralized key server for all cryptographic operations.",
          "misconception": "Targets [centralization vs. policy]: Students assume a specific architecture is the key, rather than well-defined policies that can support various architectures."
        },
        {
          "text": "Requiring users to change their private keys every month.",
          "misconception": "Targets [specific policy vs. general policy]: Students focus on a single, arbitrary policy (monthly changes) instead of the broader need for lifecycle management."
        }
      ],
      "detailed_explanation": {
        "core_logic": "NIST SP 800-57 Part 2 emphasizes that effective key management requires comprehensive policies and documented procedures covering the entire key lifecycle. This structured approach ensures consistency and security, because it addresses potential vulnerabilities at each stage of a key's existence.",
        "distractor_analysis": "The first distractor focuses solely on algorithm choice, ignoring management processes. The second promotes a specific architecture (centralized server) which may not always be appropriate or sufficient. The third suggests a rigid, potentially unnecessary, specific policy.",
        "analogy": "Running a library effectively requires not just having many books (algorithms), but also clear policies for cataloging, lending, and returning them (key lifecycle)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "CRYPTO_KEY_MANAGEMENT",
        "NIST_SP_800_57"
      ]
    },
    {
      "question_text": "What is the difference between a 'salt' and an 'Initialization Vector (IV)' in cryptography?",
      "correct_answer": "A salt is used with hashing (e.g., passwords) to prevent rainbow table attacks, while an IV is used with block cipher modes (e.g., CBC) to ensure unique ciphertext for identical plaintext blocks.",
      "distractors": [
        {
          "text": "A salt is used for symmetric encryption, while an IV is used for asymmetric encryption.",
          "misconception": "Targets [salt/IV application]: Students confuse the contexts in which salts and IVs are applied (hashing vs. block ciphers)."
        },
        {
          "text": "A salt is always secret, while an IV is always public.",
          "misconception": "Targets [salt/IV secrecy]: Students misunderstand that salts are typically stored with hashes (publicly), while IVs are often transmitted with ciphertext (publicly)."
        },
        {
          "text": "Both salts and IVs are used to prevent replay attacks.",
          "misconception": "Targets [salt/IV function]: Students incorrectly attribute the prevention of replay attacks to both salts and IVs; this is primarily a nonce function."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Salts are random data added to passwords before hashing to defeat precomputed attacks like rainbow tables, and are typically stored alongside the hash. IVs are used in block cipher modes to ensure that identical plaintext blocks encrypt to different ciphertext blocks, thus preventing pattern analysis, and are often transmitted with the ciphertext.",
        "distractor_analysis": "The first distractor incorrectly assigns salts to symmetric and IVs to asymmetric encryption. The second makes an incorrect generalization about their secrecy. The third wrongly attributes replay attack prevention to both.",
        "analogy": "A salt is like a unique secret ingredient added to each batch of cookies (passwords) before they are baked (hashed) to make them unique. An IV is like a unique starting pattern used for each row of identical bricks (plaintext blocks) when building a wall (ciphertext) to make the wall look varied."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "CRYPTO_SALTING",
        "CRYPTO_INITIALIZATION_VECTOR",
        "CRYPTO_BLOCK_CIPHER_MODES"
      ]
    },
    {
      "question_text": "What is the primary security benefit of using a Key Derivation Function (KDF) in PGP/GPG key management?",
      "correct_answer": "To securely generate cryptographic keys from a shared secret (like a password) or other input, often with added salt and iterations.",
      "distractors": [
        {
          "text": "To encrypt the actual message content using a derived key.",
          "misconception": "Targets [KDF vs. encryption algorithm]: Students confuse the key generation process with the encryption process itself."
        },
        {
          "text": "To securely store and manage the master encryption keys.",
          "misconception": "Targets [KDF vs. key storage]: Students mistake KDFs for key storage solutions, rather than key generation tools."
        },
        {
          "text": "To digitally sign messages, proving the sender's identity.",
          "misconception": "Targets [KDF vs. digital signatures]: Students confuse key derivation with the process of creating digital signatures."
        }
      ],
      "detailed_explanation": {
        "core_logic": "KDFs are essential for deriving strong, unique cryptographic keys from potentially weaker input material (like passwords) or other secrets. They incorporate mechanisms like salting and multiple iterations to increase computational cost, making brute-force attacks infeasible, because they strengthen the derived key.",
        "distractor_analysis": "The first distractor describes the function of an encryption algorithm, not a KDF. The second incorrectly positions KDFs as key storage mechanisms. The third confuses key derivation with digital signing.",
        "analogy": "A KDF is like a sophisticated recipe for making a strong, pure ingredient (key) from simpler, less pure ingredients (password/secret). The recipe includes steps (iterations, salting) to ensure the final ingredient is robust."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_KDF",
        "CRYPTO_PASSWORD_BASED_ENCRYPTION"
      ]
    },
    {
      "question_text": "In the context of OpenPGP, what is the purpose of a 'revocation certificate'?",
      "correct_answer": "To publicly declare that a specific public key is no longer trustworthy or valid.",
      "distractors": [
        {
          "text": "To encrypt a message that permanently deletes the recipient's private key.",
          "misconception": "Targets [revocation vs. key destruction]: Students confuse revoking a key's validity with attempting to destroy the associated private key."
        },
        {
          "text": "To automatically generate a new, stronger public key.",
          "misconception": "Targets [revocation vs. key generation]: Students mix up the process of invalidating a key with creating a new one."
        },
        {
          "text": "To provide a backup of a user's private key in case it is lost.",
          "misconception": "Targets [revocation vs. backup]: Students confuse a certificate that invalidates a key with a mechanism for backing up a key."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A revocation certificate is a special type of signature created by the key owner to invalidate their own public key. This is crucial for key management because it allows users to inform others that their key has been compromised or is otherwise untrustworthy, preventing further misuse, since the key should no longer be relied upon.",
        "distractor_analysis": "The first distractor describes an impossible and malicious action. The second confuses revocation with key generation. The third incorrectly suggests it's a backup mechanism.",
        "analogy": "A revocation certificate is like publishing a notice that your credit card has been lost or stolen. It tells everyone not to accept that card anymore."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "GPG_BASICS",
        "CRYPTO_KEY_REVOCATION"
      ]
    },
    {
      "question_text": "Why is it important to protect your GPG private key with a strong passphrase?",
      "correct_answer": "Because the passphrase is used to encrypt the private key itself, preventing unauthorized access if the key file is stolen.",
      "distractors": [
        {
          "text": "Because the passphrase is used to sign all outgoing messages.",
          "misconception": "Targets [passphrase vs. signing]: Students confuse the passphrase's role in protecting the key file with its use in signing operations."
        },
        {
          "text": "Because the passphrase is transmitted to the recipient to decrypt messages.",
          "misconception": "Targets [passphrase vs. transmission]: Students incorrectly believe the passphrase is sent to the recipient, which would be a major security flaw."
        },
        {
          "text": "Because the passphrase determines the strength of the encryption algorithm used.",
          "misconception": "Targets [passphrase vs. algorithm strength]: Students confuse the passphrase's role in protecting the key with the inherent strength of the encryption algorithm."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When you set a passphrase for your GPG private key, GPG uses it to encrypt the private key file itself. Therefore, if the key file is compromised (e.g., stolen), the attacker still needs the passphrase to decrypt and use the private key, because the passphrase acts as the final layer of protection.",
        "distractor_analysis": "The first distractor incorrectly states the passphrase is used for signing. The second wrongly claims the passphrase is transmitted to the recipient. The third confuses the passphrase's role with algorithm strength.",
        "analogy": "Your passphrase is like the combination to a safe where you store your house keys (private key). Even if someone steals the safe (key file), they still need the combination (passphrase) to open it."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "GPG_BASICS",
        "CRYPTO_PRIVATE_KEY_SECURITY"
      ]
    },
    {
      "question_text": "What is the primary difference between symmetric and asymmetric key management in PGP/GPG?",
      "correct_answer": "Symmetric key management involves a single shared secret key for both encryption and decryption, while asymmetric key management uses a pair of keys (public and private).",
      "distractors": [
        {
          "text": "Symmetric keys are used for signing, while asymmetric keys are used for encryption.",
          "misconception": "Targets [key type vs. function]: Students incorrectly assign specific functions (signing/encryption) exclusively to one key type."
        },
        {
          "text": "Symmetric keys are managed by Certificate Authorities, while asymmetric keys are managed by users.",
          "misconception": "Targets [key management model]: Students confuse the management models, associating CAs solely with symmetric keys and users with asymmetric."
        },
        {
          "text": "Symmetric keys are always longer than asymmetric keys.",
          "misconception": "Targets [key length]: Students incorrectly assume a fixed relationship between key type and key length, ignoring algorithm standards."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Symmetric cryptography uses one secret key shared between parties for both encryption and decryption, making key distribution a challenge. Asymmetric cryptography uses a public key for encryption (or signature verification) and a private key for decryption (or signature creation), solving the key distribution problem but being computationally more intensive.",
        "distractor_analysis": "The first distractor incorrectly assigns exclusive functions to each key type. The second misrepresents how CAs and users manage keys. The third makes an unfounded claim about key lengths.",
        "analogy": "Symmetric key management is like sharing a single house key with a friend. Asymmetric key management is like having a mailbox: anyone can drop mail (encrypt) using the public slot (public key), but only you have the key (private key) to open it and retrieve the mail (decrypt)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "CRYPTO_SYMMETRIC_ENCRYPTION",
        "CRYPTO_ASYMMETRIC_ENCRYPTION"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 16,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "PGP/GPG 006_Key Management 001_Cryptography best practices",
    "latency_ms": 30857.013
  },
  "timestamp": "2026-01-18T16:24:06.397966"
}