{
  "topic_title": "Subresource Integrity (SRI)",
  "category": "008_Application Security - Web 008_Application Security",
  "flashcards": [
    {
      "question_text": "What is the primary security goal of Subresource Integrity (SRI)?",
      "correct_answer": "To ensure that fetched resources (like scripts or stylesheets) have not been tampered with or manipulated during delivery.",
      "distractors": [
        {
          "text": "To encrypt all resources loaded from external domains",
          "misconception": "Targets [encryption confusion]: Confuses integrity checking with data encryption."
        },
        {
          "text": "To prevent cross-site scripting (XSS) attacks by sanitizing input",
          "misconception": "Targets [attack vector confusion]: Misunderstands SRI's role as a defense against content manipulation, not input sanitization."
        },
        {
          "text": "To enforce Content Security Policy (CSP) directives for loaded resources",
          "misconception": "Targets [mechanism confusion]: Confuses SRI with CSP, which controls resource loading policies but not their integrity."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI works by verifying that a fetched resource's cryptographic hash matches a pre-defined value, ensuring its integrity because it prevents the execution of modified or malicious code.",
        "distractor_analysis": "The distractors misrepresent SRI's function by confusing it with encryption, XSS prevention, or CSP, failing to grasp its core purpose of integrity verification.",
        "analogy": "SRI is like a tamper-evident seal on a package; if the seal is broken (the hash doesn't match), you know the contents might have been altered."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "APPSEC_WEB_BASICS",
        "APPSEC_CLIENT_SIDE"
      ]
    },
    {
      "question_text": "How does Subresource Integrity (SRI) achieve its security goal?",
      "correct_answer": "By comparing a cryptographic hash of the fetched resource against a hash provided in the <code>integrity</code> attribute.",
      "distractors": [
        {
          "text": "By verifying the digital signature of the resource's origin server",
          "misconception": "Targets [signature vs hash confusion]: Mixes digital signatures (authentication of origin) with hashes (integrity of content)."
        },
        {
          "text": "By checking if the resource is loaded over HTTPS",
          "misconception": "Targets [protocol vs integrity confusion]: Confuses transport layer security (HTTPS) with content integrity verification (SRI)."
        },
        {
          "text": "By analyzing the resource's code for known malicious patterns",
          "misconception": "Targets [static analysis confusion]: Misunderstands SRI as a form of static code analysis rather than a hash-based integrity check."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI functions by requiring the browser to calculate a hash of the downloaded resource and compare it to the hash specified in the <code>integrity</code> attribute. If they match, the resource is trusted; otherwise, it's blocked because the integrity check failed.",
        "distractor_analysis": "Distractors incorrectly suggest SRI uses digital signatures, HTTPS alone, or code analysis, rather than its fundamental mechanism of cryptographic hash comparison.",
        "analogy": "It's like checking if the barcode on a product matches the one on the shelf. If they don't match, something is wrong with the product or its labeling."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "APPSEC_SRI_BASICS",
        "CRYPTO_HASHING"
      ]
    },
    {
      "question_text": "Which HTML attributes are used to implement Subresource Integrity (SRI) for a script or stylesheet?",
      "correct_answer": "<code>integrity</code> and <code>crossorigin</code>",
      "distractors": [
        {
          "text": "<code>src</code> and <code>href</code>",
          "misconception": "Targets [attribute confusion]: These attributes specify the resource location, not its integrity."
        },
        {
          "text": "<code>nonce</code> and <code>sha256</code>",
          "misconception": "Targets [attribute confusion]: `nonce` is for CSP, and `sha256` is a hash algorithm prefix, not a standalone attribute."
        },
        {
          "text": "<code>defer</code> and <code>async</code>",
          "misconception": "Targets [attribute confusion]: These attributes control script execution timing, not resource integrity."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>integrity</code> attribute holds the cryptographic hash, and <code>crossorigin=&quot;anonymous&quot;</code> is required for cross-origin resources to ensure the browser can fetch the resource and perform the integrity check correctly because it enables CORS headers.",
        "distractor_analysis": "The distractors list attributes related to resource loading or security policies but not the specific pair required for SRI implementation.",
        "analogy": "Think of <code>src</code>/<code>href</code> as the address to get the package, and <code>integrity</code>/<code>crossorigin</code> as the unique serial number and delivery confirmation needed to ensure it's the right package."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "APPSEC_SRI_IMPLEMENTATION",
        "HTML_ATTRIBUTES"
      ]
    },
    {
      "question_text": "Why is the <code>crossorigin=&quot;anonymous&quot;</code> attribute often required when using SRI with external resources?",
      "correct_answer": "It allows the browser to fetch the resource from a different origin and perform the integrity check without violating same-origin policy restrictions for CORS requests.",
      "distractors": [
        {
          "text": "It encrypts the resource before it is loaded",
          "misconception": "Targets [encryption confusion]: Misunderstands `crossorigin` as an encryption mechanism."
        },
        {
          "text": "It ensures the resource is loaded only once",
          "misconception": "Targets [caching confusion]: Confuses `crossorigin` with caching behavior or resource loading optimization."
        },
        {
          "text": "It enables the browser to execute the script immediately",
          "misconception": "Targets [execution timing confusion]: Misinterprets `crossorigin` as controlling script execution order or speed."
        }
      ],
      "detailed_explanation": {
        "core_logic": "For resources loaded from a different origin, <code>crossorigin=&quot;anonymous&quot;</code> is necessary because it signals to the server to send appropriate Cross-Origin Resource Sharing (CORS) headers, allowing the browser to fetch the resource and perform the SRI check, thus maintaining security.",
        "distractor_analysis": "The distractors incorrectly associate <code>crossorigin</code> with encryption, caching, or execution timing, failing to recognize its role in enabling secure cross-origin resource fetching for integrity verification.",
        "analogy": "It's like needing a special permit to receive a package from a foreign country; <code>crossorigin</code> is that permit, allowing the integrity check to happen across borders."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "APPSEC_SRI_IMPLEMENTATION",
        "WEB_CORS"
      ]
    },
    {
      "question_text": "What are the common cryptographic hash algorithms supported by SRI?",
      "correct_answer": "SHA-256, SHA-384, and SHA-512",
      "distractors": [
        {
          "text": "MD5, SHA-1, and SHA-256",
          "misconception": "Targets [outdated algorithm confusion]: Includes MD5 and SHA-1, which are cryptographically weak and not recommended for SRI."
        },
        {
          "text": "AES, RSA, and SHA-3",
          "misconception": "Targets [algorithm type confusion]: Mixes symmetric (AES) and asymmetric (RSA) encryption algorithms with hashing algorithms."
        },
        {
          "text": "SHA-256, SHA-512, and SHA-3",
          "misconception": "Targets [algorithm support confusion]: While SHA-256 and SHA-512 are supported, SHA-3 is not a standard SRI algorithm prefix."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI supports modern, strong hashing algorithms like SHA-256, SHA-384, and SHA-512 because these provide sufficient cryptographic strength to ensure resource integrity, preventing collisions and making tampering detectable.",
        "distractor_analysis": "Distractors include outdated/weak algorithms (MD5, SHA-1) or incorrect algorithm types (AES, RSA), or algorithms not officially supported by SRI specifications.",
        "analogy": "These are like different types of security seals: SHA-256, SHA-384, and SHA-512 are the current, strong, and trusted seals that browsers recognize for SRI."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "APPSEC_SRI_BASICS",
        "CRYPTO_HASHING_ALGORITHMS"
      ]
    },
    {
      "question_text": "Consider a scenario where a Content Delivery Network (CDN) hosting a JavaScript library is compromised. How does SRI protect a website that uses this library?",
      "correct_answer": "The browser will refuse to load the compromised JavaScript file because its calculated hash will not match the hash specified in the website's <code>integrity</code> attribute.",
      "distractors": [
        {
          "text": "The browser will automatically download a clean version of the library from a backup source",
          "misconception": "Targets [fallback confusion]: SRI does not provide automatic fallback mechanisms; it simply blocks the tampered resource."
        },
        {
          "text": "The website's server will detect the compromise and block the request",
          "misconception": "Targets [client-side vs server-side confusion]: SRI is a client-side browser mechanism, not a server-side detection system."
        },
        {
          "text": "The compromised script will execute but its malicious actions will be neutralized by SRI",
          "misconception": "Targets [execution prevention confusion]: SRI prevents execution entirely if the integrity check fails; it does not neutralize malicious code."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI protects the website because the browser, upon fetching the tampered resource, calculates its hash and finds it doesn't match the expected hash in the <code>integrity</code> attribute. Therefore, the browser blocks the script from executing, preventing the attacker's code from running.",
        "distractor_analysis": "The distractors propose incorrect responses like automatic fallbacks, server-side detection, or neutralization of malicious code, all of which are outside SRI's actual function.",
        "analogy": "If a store receives a shipment of goods with a broken security seal, they refuse to accept it. SRI acts like that seal for web resources."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "APPSEC_SRI_USE_CASES",
        "APPSEC_CDN_RISKS"
      ]
    },
    {
      "question_text": "What is a potential drawback of implementing Subresource Integrity (SRI)?",
      "correct_answer": "Updating a resource (e.g., a library) requires manually updating the hash in the <code>integrity</code> attribute, which can be cumbersome.",
      "distractors": [
        {
          "text": "It significantly slows down the loading time of all web resources",
          "misconception": "Targets [performance confusion]: While there's a minor overhead, SRI doesn't 'significantly' slow down loading for typical use cases."
        },
        {
          "text": "It prevents the use of Content Delivery Networks (CDNs)",
          "misconception": "Targets [CDN compatibility confusion]: SRI is specifically designed to work with CDNs and external resources."
        },
        {
          "text": "It requires the server hosting the resource to be on the same domain",
          "misconception": "Targets [origin confusion]: SRI is most useful for cross-origin resources, and `crossorigin` attribute handles this."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A key challenge with SRI is managing hash updates; when a resource is updated, its hash changes, necessitating a manual update to the <code>integrity</code> attribute. This is because SRI relies on static, pre-defined hashes to guarantee integrity, making dynamic updates a manual process.",
        "distractor_analysis": "The distractors incorrectly claim SRI hinders performance, blocks CDNs, or requires same-domain hosting, ignoring its design purpose and typical implementation.",
        "analogy": "It's like having to manually re-write the serial number on a product's packaging every time the product inside is updated; it's a necessary step for verification but can be tedious."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "APPSEC_SRI_CONSIDERATIONS",
        "APPSEC_WEB_MANAGEMENT"
      ]
    },
    {
      "question_text": "Which of the following is NOT a valid prefix for a hash algorithm in an SRI <code>integrity</code> attribute?",
      "correct_answer": "sha1",
      "distractors": [
        {
          "text": "sha256",
          "misconception": "Targets [algorithm support confusion]: SHA-256 is a valid and commonly used algorithm prefix for SRI."
        },
        {
          "text": "sha384",
          "misconception": "Targets [algorithm support confusion]: SHA-384 is a valid and commonly used algorithm prefix for SRI."
        },
        {
          "text": "sha512",
          "misconception": "Targets [algorithm support confusion]: SHA-512 is a valid and commonly used algorithm prefix for SRI."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The SRI specification explicitly supports SHA-256, SHA-384, and SHA-512. SHA-1 is considered cryptographically weak and is therefore not recommended or supported for SRI integrity checks because it is vulnerable to collision attacks.",
        "distractor_analysis": "The distractors correctly identify valid SRI hash prefixes, while the incorrect option lists SHA-1, an outdated and insecure algorithm not permitted by the SRI standard.",
        "analogy": "Think of these prefixes like different types of security stamps. 'sha1' is an old, easily forged stamp that's no longer accepted, while 'sha256', 'sha384', and 'sha512' are the current, trusted ones."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "APPSEC_SRI_BASICS",
        "CRYPTO_HASHING_ALGORITHMS"
      ]
    },
    {
      "question_text": "How can a developer generate the correct SRI hash for a resource?",
      "correct_answer": "By using command-line tools like <code>openssl</code> or online SRI hash generators to compute the hash of the resource file.",
      "distractors": [
        {
          "text": "By asking the CDN provider for the hash value",
          "misconception": "Targets [trust model confusion]: While providers might offer it, relying solely on them without independent verification is risky."
        },
        {
          "text": "By using the file's creation date as the hash",
          "misconception": "Targets [hash mechanism confusion]: File metadata like creation date is not a cryptographic hash."
        },
        {
          "text": "By performing a simple checksum calculation",
          "misconception": "Targets [checksum vs hash confusion]: Checksums are generally not cryptographically secure like SHA hashes used in SRI."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Developers generate SRI hashes by using cryptographic tools (like <code>openssl dgst -sha384 -binary file | openssl base64 -A</code>) or dedicated SRI hash generator websites. This ensures the hash is computed correctly and securely because it uses standard cryptographic functions.",
        "distractor_analysis": "The distractors suggest unreliable methods like trusting the CDN blindly, using file metadata, or employing weak checksums, instead of the secure, verifiable methods required for SRI.",
        "analogy": "It's like getting a unique fingerprint for a document. You can use a special machine (like <code>openssl</code> or a generator) to create that fingerprint, not just guess it or ask someone else."
      },
      "code_snippets": [
        {
          "language": "text",
          "code": "$ curl -s https://example.com/resource.js | openssl dgst -sha384 -binary | openssl base64 -A",
          "context": "explanation"
        }
      ],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "APPSEC_SRI_IMPLEMENTATION",
        "CLI_TOOLS"
      ],
      "_code_snippets_html": "<div class=\"code-snippet code-explanation\">\n<span class=\"code-label\">Code Example</span>\n<pre><code class=\"language-text\">$ curl -s https://example.com/resource.js | openssl dgst -sha384 -binary | openssl base64 -A</code></pre>\n</div>"
    },
    {
      "question_text": "What is the relationship between Subresource Integrity (SRI) and Content Security Policy (CSP)?",
      "correct_answer": "SRI and CSP are complementary security mechanisms; CSP controls *what* resources can be loaded, while SRI verifies the *integrity* of those loaded resources.",
      "distractors": [
        {
          "text": "SRI is a part of the CSP standard and cannot be used independently",
          "misconception": "Targets [standard relationship confusion]: SRI and CSP are distinct but often used together; SRI is not a subset of CSP."
        },
        {
          "text": "CSP enforces SRI by automatically generating and checking hashes",
          "misconception": "Targets [mechanism confusion]: CSP does not generate or check hashes; it defines loading policies."
        },
        {
          "text": "SRI replaces the need for CSP when loading external resources",
          "misconception": "Targets [redundancy confusion]: Both provide different layers of security and are best used in conjunction."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CSP defines policies for which origins are allowed to load resources, acting as a whitelist. SRI then provides an additional layer of defense by ensuring that if a resource *is* loaded from an allowed origin, it hasn't been tampered with, because it verifies the content's cryptographic hash.",
        "distractor_analysis": "The distractors incorrectly describe SRI as part of CSP, suggest CSP enforces SRI, or claim SRI makes CSP redundant, misunderstanding their distinct but complementary roles.",
        "analogy": "CSP is like a bouncer checking IDs at the door (allowing only authorized guests). SRI is like a security check inside the venue, ensuring that even authorized guests haven't brought anything dangerous."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "APPSEC_SRI_BASICS",
        "WEB_CSP"
      ]
    },
    {
      "question_text": "When would a website developer choose NOT to implement SRI for a third-party script?",
      "correct_answer": "If the third-party script is frequently updated by its provider, making manual hash updates impractical and prone to breaking the site.",
      "distractors": [
        {
          "text": "If the script is loaded from the same domain as the website",
          "misconception": "Targets [use case confusion]: SRI is still beneficial for same-domain resources if the server is compromised, though less critical than for CDNs."
        },
        {
          "text": "If the script is only a few kilobytes in size",
          "misconception": "Targets [size relevance confusion]: File size does not determine the need for integrity protection."
        },
        {
          "text": "If the script is loaded over HTTPS",
          "misconception": "Targets [protocol vs integrity confusion]: HTTPS protects data in transit but not against a compromised source server; SRI addresses the latter."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Implementing SRI requires maintaining accurate hashes. If a third-party resource is updated frequently, the developer must constantly update the <code>integrity</code> attribute. This can become unmanageable, leading to broken site functionality if hashes aren't updated promptly, thus making SRI impractical in such cases.",
        "distractor_analysis": "The distractors suggest reasons unrelated to SRI's core function or implementation challenges, such as script size, HTTPS usage, or same-domain loading, which do not negate the need for integrity checks.",
        "analogy": "It's like trying to put a tamper-evident seal on a product that's constantly being opened and resealed; the seal loses its effectiveness and becomes a nuisance."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "evaluate",
      "prerequisites": [
        "APPSEC_SRI_CONSIDERATIONS",
        "APPSEC_WEB_MANAGEMENT"
      ]
    },
    {
      "question_text": "What is the purpose of the <code>integrity</code> attribute in Subresource Integrity (SRI)?",
      "correct_answer": "To provide the cryptographic hash(es) that the browser will use to verify the integrity of the fetched resource.",
      "distractors": [
        {
          "text": "To specify the allowed origins from which the resource can be loaded",
          "misconception": "Targets [policy confusion]: This describes the function of CSP's `script-src` or `style-src` directives, not the `integrity` attribute."
        },
        {
          "text": "To indicate the preferred order of loading for multiple resources",
          "misconception": "Targets [loading order confusion]: Attributes like `defer` or `async` control loading order, not `integrity`."
        },
        {
          "text": "To define the encryption algorithm used for the resource",
          "misconception": "Targets [encryption confusion]: The `integrity` attribute is for hashing and integrity checks, not encryption."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>integrity</code> attribute is central to SRI because it contains the expected cryptographic hash value(s). The browser calculates the hash of the downloaded resource and compares it to the value(s) in this attribute; if they match, the resource is considered trustworthy because its integrity is confirmed.",
        "distractor_analysis": "The distractors misattribute functions related to resource origin control, loading order, or encryption to the <code>integrity</code> attribute, failing to recognize its specific role in hash-based integrity verification.",
        "analogy": "The <code>integrity</code> attribute is like the unique serial number printed on a security tag; the browser checks if the tag's number matches the expected number to ensure authenticity."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "APPSEC_SRI_IMPLEMENTATION",
        "HTML_ATTRIBUTES"
      ]
    },
    {
      "question_text": "How does SRI help mitigate risks associated with compromised CDNs?",
      "correct_answer": "By ensuring that if a CDN resource is tampered with, the browser will detect the mismatch between the expected hash and the actual resource hash, and refuse to load it.",
      "distractors": [
        {
          "text": "By encrypting the connection between the browser and the CDN",
          "misconception": "Targets [transport security confusion]: This describes HTTPS, not SRI's function against compromised source content."
        },
        {
          "text": "By forcing the CDN to use only secure algorithms for serving files",
          "misconception": "Targets [server-side control confusion]: SRI is a client-side browser mechanism; it doesn't dictate server-side algorithm choices beyond hash generation."
        },
        {
          "text": "By providing a list of trusted CDN providers to the browser",
          "misconception": "Targets [trust list confusion]: SRI relies on specific hashes, not a general list of trusted providers."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When a CDN is compromised, attackers might alter files. SRI mitigates this because the browser compares the hash of the fetched file against the <code>integrity</code> attribute. If they differ, the browser blocks the resource, preventing malicious code execution because the integrity check failed.",
        "distractor_analysis": "The distractors propose solutions related to transport encryption, server-side controls, or trust lists, which are not how SRI functions to protect against compromised CDN content.",
        "analogy": "It's like having a unique fingerprint for a document. If someone tries to substitute the document with a forged one, the fingerprint won't match, and the substitution is detected."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "APPSEC_SRI_USE_CASES",
        "APPSEC_CDN_RISKS"
      ]
    },
    {
      "question_text": "What is the role of the <code>sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC</code> string in an SRI implementation?",
      "correct_answer": "It represents a base64-encoded SHA-384 cryptographic hash of the expected resource content.",
      "distractors": [
        {
          "text": "It is a digital signature used to authenticate the resource's origin",
          "misconception": "Targets [signature vs hash confusion]: This string is a hash, not a digital signature which verifies the sender's identity."
        },
        {
          "text": "It is a unique identifier for the resource on the CDN",
          "misconception": "Targets [identifier confusion]: While unique, it's a content hash, not a CDN-specific identifier."
        },
        {
          "text": "It is a Content Security Policy (CSP) directive for resource loading",
          "misconception": "Targets [policy confusion]: This format is specific to SRI's `integrity` attribute, not CSP directives."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The string <code>sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC</code> specifies the hashing algorithm (<code>sha384</code>) and the base64-encoded hash value itself. This allows the browser to verify the resource's integrity because it provides a verifiable fingerprint of the expected content.",
        "distractor_analysis": "The distractors incorrectly identify the string as a digital signature, CDN identifier, or CSP directive, failing to recognize its specific function as an SRI hash value.",
        "analogy": "It's like a unique serial number combined with the type of lock used on a vault. The browser checks if the actual vault's lock matches the description and if the serial number is correct."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "APPSEC_SRI_IMPLEMENTATION",
        "CRYPTO_HASHING"
      ]
    },
    {
      "question_text": "Which of the following best describes the security benefit of using SRI for JavaScript files loaded from a third-party domain?",
      "correct_answer": "It prevents an attacker who compromises the third-party domain from injecting malicious JavaScript into the file, as the browser would detect the hash mismatch.",
      "distractors": [
        {
          "text": "It ensures the JavaScript file is always the latest version available",
          "misconception": "Targets [versioning confusion]: SRI locks a resource to a specific version's hash, preventing updates unless the hash is manually changed."
        },
        {
          "text": "It automatically blocks all JavaScript execution from third-party domains",
          "misconception": "Targets [overly broad blocking confusion]: SRI only blocks if the integrity check fails; it doesn't block all third-party scripts by default."
        },
        {
          "text": "It allows the browser to execute malicious JavaScript safely",
          "misconception": "Targets [safety confusion]: SRI's purpose is to prevent the execution of malicious or tampered JavaScript."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI provides a critical defense against compromised third-party resources because it ensures that the JavaScript file loaded by the browser matches the exact content specified by the hash. If an attacker modifies the file on the third-party server, the hash will not match, and the browser will refuse to execute the script, thereby preventing malicious code injection.",
        "distractor_analysis": "The distractors propose incorrect outcomes such as forcing updates, blocking all scripts, or enabling safe execution of malicious code, fundamentally misunderstanding SRI's role in integrity verification.",
        "analogy": "It's like having a specific, unique key for a lock. If someone tries to use a different key (a modified file), it won't work, and the door (the script execution) remains locked."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "APPSEC_SRI_USE_CASES",
        "APPSEC_THIRD_PARTY_RISKS"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Subresource Integrity (SRI) 008_Application Security best practices",
    "latency_ms": 26530.504
  },
  "timestamp": "2026-01-18T12:15:59.092623"
}