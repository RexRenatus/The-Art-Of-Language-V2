{
  "topic_title": "CORS Configuration Testing",
  "category": "008_Application Security - Web 008_Application Security",
  "flashcards": [
    {
      "question_text": "What is the primary security concern when a web server incorrectly configures the <code>Access-Control-Allow-Origin</code> header to allow any origin (<code>*</code>)?",
      "correct_answer": "Unauthorized origins can read sensitive data from the server's responses.",
      "distractors": [
        {
          "text": "The server will be unable to serve static assets.",
          "misconception": "Targets [functional confusion]: Confuses CORS with asset delivery mechanisms."
        },
        {
          "text": "Cross-site scripting (XSS) attacks become impossible.",
          "misconception": "Targets [misplaced confidence]: Believes CORS configuration prevents all client-side attacks."
        },
        {
          "text": "The browser's same-origin policy is permanently disabled.",
          "misconception": "Targets [policy misunderstanding]: Incorrectly assumes CORS overrides the fundamental browser security policy."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>Access-Control-Allow-Origin: *</code> header permits any origin to make requests and read responses, bypassing the intended security boundaries because browsers rely on this header for cross-origin access control.",
        "distractor_analysis": "The first distractor misunderstands CORS's role in asset delivery. The second incorrectly links CORS to XSS prevention. The third misinterprets how CORS interacts with the same-origin policy.",
        "analogy": "It's like leaving your house unlocked with a sign saying 'Anyone can enter,' allowing strangers to take anything they want."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "analyze",
      "prerequisites": [
        "CORS_BASICS",
        "SAME_ORIGIN_POLICY"
      ]
    },
    {
      "question_text": "Which HTTP request method is typically used by browsers for CORS pre-flight checks before sending the actual cross-origin request?",
      "correct_answer": "OPTIONS",
      "distractors": [
        {
          "text": "GET",
          "misconception": "Targets [method confusion]: Associates pre-flight checks with standard data retrieval methods."
        },
        {
          "text": "POST",
          "misconception": "Targets [method confusion]: Associates pre-flight checks with data submission methods."
        },
        {
          "text": "HEAD",
          "misconception": "Targets [method confusion]: Confuses pre-flight with lightweight request methods."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Browsers use the HTTP OPTIONS method for CORS pre-flight requests because it allows them to query the server about the allowed methods and headers without actually performing the intended action, thus ensuring security before the main request.",
        "distractor_analysis": "Distractors represent common HTTP methods that are not used for CORS pre-flight checks, targeting students who confuse the purpose of different HTTP verbs.",
        "analogy": "It's like asking for permission before entering a restricted area, using a specific 'inquiry' signal (OPTIONS) rather than trying to barge in (GET/POST)."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CORS_PREFLIGHT",
        "HTTP_METHODS"
      ]
    },
    {
      "question_text": "In CORS, what is the significance of the <code>Access-Control-Allow-Credentials</code> response header?",
      "correct_answer": "It indicates whether the server permits cross-origin requests to include credentials (e.g., cookies, HTTP authentication).",
      "distractors": [
        {
          "text": "It specifies which HTTP methods are allowed for cross-origin requests.",
          "misconception": "Targets [header confusion]: Confuses it with `Access-Control-Allow-Methods`."
        },
        {
          "text": "It defines the allowed origins that can access the resource.",
          "misconception": "Targets [header confusion]: Confuses it with `Access-Control-Allow-Origin`."
        },
        {
          "text": "It sets the maximum age for caching pre-flight responses.",
          "misconception": "Targets [header confusion]: Confuses it with `Access-Control-Max-Age`."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>Access-Control-Allow-Credentials</code> header is crucial because it explicitly controls whether credentials can be sent with cross-origin requests, which is a significant security consideration, as it prevents unauthorized access to user-specific data.",
        "distractor_analysis": "Each distractor incorrectly assigns the function of another CORS-related header, targeting students who are unsure of the specific purpose of each header.",
        "analogy": "This header is like a bouncer checking IDs at a club; it determines if you're allowed in with your personal identification (credentials)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CORS_HEADERS",
        "HTTP_AUTHENTICATION"
      ]
    },
    {
      "question_text": "A web application hosted on <code>app.example.com</code> needs to fetch data from an API at <code>api.example.com</code>. What is the minimum CORS configuration required on the <code>api.example.com</code> server to allow this specific request?",
      "correct_answer": "Set <code>Access-Control-Allow-Origin: https://app.example.com</code> in the API's response.",
      "distractors": [
        {
          "text": "Set <code>Access-Control-Allow-Origin: *</code> in the API's response.",
          "misconception": "Targets [overly permissive configuration]: Recommends a wildcard that is less secure than a specific origin."
        },
        {
          "text": "Set <code>Access-Control-Allow-Methods: GET</code> in the API's response.",
          "misconception": "Targets [missing origin header]: Focuses on allowed methods but neglects the critical origin check."
        },
        {
          "text": "No CORS configuration is needed as both are on <code>.com</code> domains.",
          "misconception": "Targets [subdomain confusion]: Believes subdomains share the same origin implicitly for CORS."
        }
      ],
      "detailed_explanation": {
        "core_logic": "To allow a specific origin like <code>https://app.example.com</code> to access resources from <code>api.example.com</code>, the API server must explicitly permit that origin via the <code>Access-Control-Allow-Origin</code> header, because browsers enforce the same-origin policy for cross-domain requests.",
        "distractor_analysis": "The first distractor suggests a less secure wildcard. The second focuses on the wrong header. The third misunderstands that different subdomains are considered different origins for CORS.",
        "analogy": "It's like giving a specific key to a trusted friend (app.example.com) to access your house (api.example.com), rather than leaving the door open for anyone."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "CORS_ORIGINS",
        "SAME_ORIGIN_POLICY"
      ]
    },
    {
      "question_text": "What is the primary security risk associated with misconfiguring <code>Access-Control-Allow-Headers</code> in CORS?",
      "correct_answer": "It could allow malicious clients to send custom, potentially harmful headers to the server.",
      "distractors": [
        {
          "text": "It prevents legitimate clients from sending necessary request headers.",
          "misconception": "Targets [opposite effect]: Believes misconfiguration blocks legitimate traffic rather than enabling malicious traffic."
        },
        {
          "text": "It exposes the server's internal IP addresses to the client.",
          "misconception": "Targets [unrelated vulnerability]: Confuses header configuration with network information disclosure."
        },
        {
          "text": "It causes the browser to ignore the <code>Access-Control-Allow-Origin</code> header.",
          "misconception": "Targets [interdependency confusion]: Incorrectly assumes one CORS header's misconfiguration affects another's functionality."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>Access-Control-Allow-Headers</code> header specifies which HTTP headers can be used in a cross-origin request. If misconfigured to allow arbitrary headers, it can enable attackers to inject malicious data or bypass security checks by sending unexpected headers.",
        "distractor_analysis": "The first distractor describes a denial-of-service rather than a security exploit. The second links header configuration to network exposure. The third incorrectly suggests a dependency between different CORS headers.",
        "analogy": "It's like allowing anyone to write anything on the return address of a package; malicious actors could use this to send harmful instructions or disguises."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "CORS_HEADERS",
        "HTTP_REQUEST_HEADERS"
      ]
    },
    {
      "question_text": "Consider a scenario where a web application uses <code>XMLHttpRequest</code> to send a <code>PUT</code> request with custom headers to a different origin. What type of CORS request is this, and what is typically required?",
      "correct_answer": "A non-simple request, requiring a pre-flight OPTIONS request.",
      "distractors": [
        {
          "text": "A simple request, requiring no pre-flight.",
          "misconception": "Targets [simple vs. non-simple confusion]: Incorrectly classifies a request with custom headers or non-standard methods as simple."
        },
        {
          "text": "A pre-flight request itself, not a data request.",
          "misconception": "Targets [request type confusion]: Misunderstands that the OPTIONS request is a precursor, not the actual data request."
        },
        {
          "text": "A simple request, but requiring <code>Access-Control-Allow-Credentials</code>.",
          "misconception": "Targets [simple request definition]: Incorrectly assumes credentials automatically make a request non-simple."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Requests using methods other than GET, HEAD, or POST, or requests including custom headers, are classified as non-simple requests in CORS. Browsers automatically send a pre-flight OPTIONS request to check server permissions before executing the actual non-simple request, ensuring security.",
        "distractor_analysis": "The first distractor misidentifies the request type. The second confuses the pre-flight request with the actual data request. The third incorrectly defines simple requests.",
        "analogy": "It's like needing to get a special permit (pre-flight OPTIONS) before you can deliver a large, unusual package (non-simple PUT request with custom headers)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "analyze",
      "prerequisites": [
        "CORS_PREFLIGHT",
        "HTTP_METHODS",
        "HTTP_REQUEST_HEADERS"
      ]
    },
    {
      "question_text": "What is the security implication of setting <code>Access-Control-Allow-Origin: https://trusted.com</code> but reflecting the <code>Origin</code> header in the response for requests from <code>https://untrusted.com</code>?",
      "correct_answer": "It can lead to sensitive data exposure if the server incorrectly trusts and echoes the <code>Origin</code> header.",
      "distractors": [
        {
          "text": "It prevents <code>https://untrusted.com</code> from making any requests.",
          "misconception": "Targets [misinterpretation of reflection]: Believes reflecting the origin header inherently blocks requests."
        },
        {
          "text": "It allows <code>https://trusted.com</code> to perform actions on behalf of <code>https://untrusted.com</code>.",
          "misconception": "Targets [cross-site request forgery confusion]: Confuses CORS reflection with CSRF vulnerabilities."
        },
        {
          "text": "It causes the browser to reject all subsequent CORS requests.",
          "misconception": "Targets [overstated consequence]: Exaggerates the impact of a single misconfiguration."
        }
      ],
      "detailed_explanation": {
        "core_logic": "While <code>Access-Control-Allow-Origin</code> is set to <code>https://trusted.com</code>, if the server blindly reflects the <code>Origin</code> header from <code>https://untrusted.com</code> in its response, it might inadvertently grant access to sensitive data to the untrusted origin, bypassing the intended restriction.",
        "distractor_analysis": "The first distractor assumes blocking, not potential exposure. The second confuses CORS reflection with CSRF. The third overstates the browser's reaction.",
        "analogy": "It's like having a specific guest list (<code>Access-Control-Allow-Origin</code>), but then asking every guest for their name and writing it down without checking if they are on the list, potentially letting unauthorized people in."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "evaluate",
      "prerequisites": [
        "CORS_ORIGINS",
        "HTTP_ORIGIN_HEADER",
        "DATA_EXPOSURE"
      ]
    },
    {
      "question_text": "Which of the following is NOT considered a 'simple' request in the context of CORS, thus typically requiring a pre-flight OPTIONS request?",
      "correct_answer": "A request using the <code>PUT</code> HTTP method.",
      "distractors": [
        {
          "text": "A request using the <code>GET</code> HTTP method.",
          "misconception": "Targets [simple request definition]: Incorrectly classifies GET as non-simple."
        },
        {
          "text": "A request using the <code>HEAD</code> HTTP method.",
          "misconception": "Targets [simple request definition]: Incorrectly classifies HEAD as non-simple."
        },
        {
          "text": "A request using the <code>POST</code> HTTP method with specific content types.",
          "misconception": "Targets [simple request definition]: Incorrectly classifies POST with allowed content types as non-simple."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Simple requests in CORS are limited to GET, HEAD, or POST methods with specific, safe content types. Any other method, like PUT, or requests with custom headers, are considered non-simple and trigger a pre-flight OPTIONS request because they pose a greater potential risk.",
        "distractor_analysis": "The distractors represent methods and content types that are explicitly defined as 'simple' in CORS specifications, targeting students who misunderstand these definitions.",
        "analogy": "Simple requests are like sending a postcard (GET, HEAD, POST with basic content) - straightforward and low-risk. A PUT request is more like sending a registered package with special instructions, requiring extra checks."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CORS_PREFLIGHT",
        "HTTP_METHODS"
      ]
    },
    {
      "question_text": "When testing CORS configurations, what is the primary goal of examining the <code>Access-Control-Expose-Headers</code> response header?",
      "correct_answer": "To determine which non-standard response headers are made available to the client-side script.",
      "distractors": [
        {
          "text": "To verify that the server is allowing requests from the specified origin.",
          "misconception": "Targets [header confusion]: Confuses it with `Access-Control-Allow-Origin`."
        },
        {
          "text": "To check if the server permits specific HTTP methods.",
          "misconception": "Targets [header confusion]: Confuses it with `Access-Control-Allow-Methods`."
        },
        {
          "text": "To ensure that credentials are not being sent with the request.",
          "misconception": "Targets [header confusion]: Confuses it with `Access-Control-Allow-Credentials`."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>Access-Control-Expose-Headers</code> header explicitly lists response headers that the browser should make accessible to client-side JavaScript. Testing this ensures that sensitive or custom information isn't inadvertently exposed beyond what's intended.",
        "distractor_analysis": "Each distractor incorrectly assigns the function of a different CORS header, targeting students who struggle to differentiate the purpose of each header.",
        "analogy": "This header is like a list of items allowed out of a secure room; it specifies which custom labels (headers) on the returned package are visible to the recipient."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "CORS_HEADERS",
        "HTTP_RESPONSE_HEADERS"
      ]
    },
    {
      "question_text": "What is the security risk if a server incorrectly configures <code>Access-Control-Allow-Credentials</code> to <code>true</code> when <code>Access-Control-Allow-Origin</code> is set to <code>*</code>?",
      "correct_answer": "It allows any origin to send credentials with requests, potentially leading to session hijacking or unauthorized actions.",
      "distractors": [
        {
          "text": "It prevents any origin from sending credentials, enhancing security.",
          "misconception": "Targets [opposite effect]: Believes the configuration enhances security by blocking credentials."
        },
        {
          "text": "It only affects requests made with GET or POST methods.",
          "misconception": "Targets [method scope confusion]: Incorrectly limits the scope of credential handling."
        },
        {
          "text": "It causes the server to reject all requests containing cookies.",
          "misconception": "Targets [unrelated consequence]: Describes a blocking behavior rather than a security vulnerability."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Allowing credentials (<code>Access-Control-Allow-Credentials: true</code>) from any origin (<code>Access-Control-Allow-Origin: *</code>) is extremely dangerous because it enables malicious sites to potentially steal session cookies or other sensitive authentication tokens, thus compromising user accounts.",
        "distractor_analysis": "The first distractor suggests a security improvement, which is the opposite of the actual risk. The second incorrectly limits the scope of the vulnerability. The third describes a blocking behavior, not the intended security flaw.",
        "analogy": "It's like leaving your house keys (<code>credentials</code>) with a sign saying 'Anyone can take them,' allowing anyone to potentially unlock your door and enter."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "CORS_CREDENTIALS",
        "SESSION_HIJACKING",
        "ORIGIN_WILDCARD"
      ]
    },
    {
      "question_text": "Which of the following is a common best practice for CORS configuration to minimize security risks?",
      "correct_answer": "Specify the exact origins allowed, rather than using a wildcard (<code>*</code>).",
      "distractors": [
        {
          "text": "Always set <code>Access-Control-Allow-Credentials</code> to <code>true</code> for maximum flexibility.",
          "misconception": "Targets [overly permissive configuration]: Recommends enabling credentials without considering the risks."
        },
        {
          "text": "Use <code>Access-Control-Allow-Origin: *</code> for all responses to simplify development.",
          "misconception": "Targets [development vs. security trade-off]: Prioritizes ease of development over security best practices."
        },
        {
          "text": "Disable pre-flight OPTIONS requests to improve performance.",
          "misconception": "Targets [performance over security]: Advocates disabling a critical security mechanism for speed."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Specifying exact origins (<code>Access-Control-Allow-Origin: https://specific.com</code>) is a fundamental security best practice because it adheres to the principle of least privilege, ensuring only trusted domains can access resources, unlike the wildcard which opens access to all.",
        "distractor_analysis": "The first distractor promotes insecure credential handling. The second advocates for the insecure wildcard. The third suggests disabling a vital security check.",
        "analogy": "It's like giving specific, individual keys to trusted people, rather than making a master key that works for everyone."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "CORS_BEST_PRACTICES",
        "LEAST_PRIVILEGE"
      ]
    },
    {
      "question_text": "When testing CORS, what does it mean if a server reflects the <code>Origin</code> header in the <code>Access-Control-Allow-Origin</code> response header without proper validation?",
      "correct_answer": "It's a vulnerability where any origin can potentially be granted access if the server blindly echoes the header.",
      "distractors": [
        {
          "text": "It's a standard practice for enabling dynamic cross-origin access.",
          "misconception": "Targets [misunderstanding of reflection]: Believes echoing the origin is a feature, not a potential flaw."
        },
        {
          "text": "It indicates that the server is correctly enforcing the same-origin policy.",
          "misconception": "Targets [policy misunderstanding]: Confuses reflection with enforcement of the same-origin policy."
        },
        {
          "text": "It means the server is only allowing requests from the same domain.",
          "misconception": "Targets [opposite effect]: Assumes reflection restricts access, when it can expand it."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Blindly reflecting the <code>Origin</code> header in <code>Access-Control-Allow-Origin</code> is a vulnerability because it allows a client to specify an origin (even a malicious one) and have the server potentially grant access based on that input, bypassing intended access controls.",
        "distractor_analysis": "The first distractor misinterprets the reflection as a feature. The second incorrectly equates reflection with policy enforcement. The third describes the opposite of what can happen.",
        "analogy": "It's like a security guard asking 'Who are you?' and then writing down whatever name is given on the official access list, without checking if that name is actually approved."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "CORS_ORIGINS",
        "HTTP_ORIGIN_HEADER",
        "VULNERABILITY_TYPES"
      ]
    },
    {
      "question_text": "What is the purpose of the <code>Access-Control-Request-Method</code> header sent by the browser during a CORS pre-flight request?",
      "correct_answer": "To inform the server about the HTTP method the client intends to use for the actual request.",
      "distractors": [
        {
          "text": "To specify the origin of the client making the request.",
          "misconception": "Targets [header confusion]: Confuses it with the `Origin` header."
        },
        {
          "text": "To list all allowed HTTP methods the server supports.",
          "misconception": "Targets [role reversal]: Believes the client dictates server capabilities, not queries them."
        },
        {
          "text": "To request permission to send credentials with the request.",
          "misconception": "Targets [header confusion]: Confuses it with `Access-Control-Allow-Credentials`."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>Access-Control-Request-Method</code> header is sent by the browser during a pre-flight request to clearly state the HTTP method (e.g., PUT, DELETE) the client intends to use. This allows the server to check if that specific method is permitted for cross-origin access.",
        "distractor_analysis": "The first distractor confuses it with the <code>Origin</code> header. The second reverses the roles of client and server regarding method permissions. The third incorrectly links it to credential handling.",
        "analogy": "It's like telling the gatekeeper, 'I want to use the delivery entrance (method) today,' so they can check if that entrance is open for you."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CORS_PREFLIGHT",
        "HTTP_METHODS"
      ]
    },
    {
      "question_text": "In the context of CORS, what is the security implication of a server misconfiguring <code>Access-Control-Allow-Methods</code> to include potentially dangerous HTTP verbs like <code>DELETE</code> or <code>PUT</code> for an origin that should only read data?",
      "correct_answer": "It allows unauthorized modification or deletion of resources by the client.",
      "distractors": [
        {
          "text": "It prevents the client from accessing any resources.",
          "misconception": "Targets [opposite effect]: Believes misconfiguration blocks access rather than enabling risky operations."
        },
        {
          "text": "It exposes the server's source code to the client.",
          "misconception": "Targets [unrelated vulnerability]: Confuses method permissions with code disclosure."
        },
        {
          "text": "It causes the browser to block all subsequent requests from that origin.",
          "misconception": "Targets [overstated consequence]: Exaggerates the browser's reaction to a specific header misconfiguration."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Allowing dangerous methods like <code>DELETE</code> or <code>PUT</code> via <code>Access-Control-Allow-Methods</code> for an origin that should only perform read operations (e.g., GET) creates a vulnerability, as it permits unauthorized data modification or deletion by the client.",
        "distractor_analysis": "The first distractor suggests a denial of service. The second incorrectly links method permissions to source code exposure. The third overstates the browser's response.",
        "analogy": "It's like giving someone permission to use a 'delete' button on your files, even though they should only have permission to 'view' them."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "CORS_METHODS",
        "DATA_MODIFICATION",
        "RESOURCE_CONTROL"
      ]
    },
    {
      "question_text": "What is the primary function of the <code>Origin</code> header in a CORS request initiated by the browser?",
      "correct_answer": "To identify the origin (scheme, host, port) of the web page making the request.",
      "distractors": [
        {
          "text": "To specify the target URL of the resource being requested.",
          "misconception": "Targets [header confusion]: Confuses it with the request URL itself."
        },
        {
          "text": "To authenticate the user making the request.",
          "misconception": "Targets [authentication confusion]: Believes the origin header provides user identity."
        },
        {
          "text": "To indicate the preferred language for the response.",
          "misconception": "Targets [header confusion]: Confuses it with the `Accept-Language` header."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>Origin</code> header is automatically sent by the browser to indicate the source of the cross-origin request. This allows the server to determine if the request is coming from a trusted domain, which is fundamental for CORS security.",
        "distractor_analysis": "The first distractor confuses the origin with the destination URL. The second incorrectly assigns an authentication role. The third confuses it with language preference headers.",
        "analogy": "It's like putting your return address on an envelope; it tells the recipient where the letter came from."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CORS_ORIGINS",
        "HTTP_ORIGIN_HEADER"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "CORS Configuration Testing 008_Application Security best practices",
    "latency_ms": 26561.475000000002
  },
  "timestamp": "2026-01-18T12:16:04.165786"
}