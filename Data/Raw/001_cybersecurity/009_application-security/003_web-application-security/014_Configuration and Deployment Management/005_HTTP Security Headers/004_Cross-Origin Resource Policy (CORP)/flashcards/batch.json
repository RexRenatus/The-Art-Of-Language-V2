{
  "topic_title": "Cross-Origin Resource Policy (CORP)",
  "category": "008_Application Security - Web 008_Application Security",
  "flashcards": [
    {
      "question_text": "What is the primary purpose of the Cross-Origin Resource Policy (CORP) HTTP header?",
      "correct_answer": "To allow websites to opt-in to protection against certain cross-origin requests, mitigating speculative side-channel and Cross-Site Script Inclusion attacks.",
      "distractors": [
        {
          "text": "To enforce the same-origin policy for all web resources.",
          "misconception": "Targets [scope confusion]: Confuses CORP with the fundamental same-origin policy, which is a browser default, not an opt-in header."
        },
        {
          "text": "To enable cross-origin resource sharing (CORS) for APIs.",
          "misconception": "Targets [conflicting technology confusion]: Mixes CORP, which restricts access, with CORS, which enables controlled cross-origin access."
        },
        {
          "text": "To encrypt sensitive data transmitted between different origins.",
          "misconception": "Targets [functional confusion]: Attributes encryption capabilities to CORP, which is a policy header for resource loading, not data encryption."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CORP is an opt-in security feature that uses the <code>Cross-Origin-Resource-Policy</code> header to block certain cross-origin requests, thereby preventing sensitive data leaks and mitigating attacks like Spectre, because it controls which origins can load a resource.",
        "distractor_analysis": "The first distractor overstates CORP's role by equating it to the same-origin policy. The second confuses CORP with CORS, a different mechanism for cross-origin access. The third incorrectly assigns encryption functionality to CORP.",
        "analogy": "Think of CORP as a bouncer at a club (the resource) deciding who gets in. The same-origin policy is the club's general dress code, CORS is a VIP list for specific guests, and CORP is an extra layer of security the club owner can add to control who enters, even if they meet the general code or are on a list."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CORP_FUNDAMENTALS",
        "HTTP_HEADERS"
      ]
    },
    {
      "question_text": "Which directive for the <code>Cross-Origin-Resource-Policy</code> header restricts resource loading to only requests originating from the exact same scheme, host, and port?",
      "correct_answer": "<code>same-origin</code>",
      "distractors": [
        {
          "text": "<code>same-site</code>",
          "misconception": "Targets [granularity error]: Confuses 'site' (registrable domain) with 'origin' (scheme+host+port), allowing subdomains."
        },
        {
          "text": "<code>cross-origin</code>",
          "misconception": "Targets [scope confusion]: This directive allows any origin, the opposite of the question's requirement."
        },
        {
          "text": "<code>any-origin</code>",
          "misconception": "Targets [non-existent directive]: This is not a valid directive for CORP."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>same-origin</code> directive ensures that a resource can only be loaded by requests originating from the identical scheme, host, and port. This is because it enforces the strictest level of origin matching, unlike <code>same-site</code> which allows subdomains.",
        "distractor_analysis": "<code>same-site</code> allows subdomains, <code>cross-origin</code> allows any origin, and <code>any-origin</code> is not a valid CORP directive, making them incorrect choices for restricting to the exact same origin.",
        "analogy": "Imagine a private club. <code>same-origin</code> means only members with the exact same membership card (scheme, host, port) can enter. <code>same-site</code> would be like allowing members from any branch of the same club chain (subdomains included). <code>cross-origin</code> would be like letting anyone from any club in."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "CORP_DIRECTIVES",
        "ORIGIN_VS_SITE"
      ]
    },
    {
      "question_text": "When would a web application typically use <code>Cross-Origin-Resource-Policy: same-site</code>?",
      "correct_answer": "For resources shared across multiple subdomains of the same parent domain, such as a company CDN serving static assets to different internal applications.",
      "distractors": [
        {
          "text": "For highly sensitive user data APIs that should only be accessed by the originating application.",
          "misconception": "Targets [security level mismatch]: `same-site` is less restrictive than `same-origin`, making it unsuitable for highly sensitive data."
        },
        {
          "text": "For public-facing images or scripts intended to be embedded on any website globally.",
          "misconception": "Targets [scope confusion]: `same-site` restricts to the same site, while public resources often need `cross-origin`."
        },
        {
          "text": "For internal configuration files that should never be exposed externally.",
          "misconception": "Targets [access control confusion]: While restrictive, `same-site` might still allow access from other subdomains, which could be unintended for highly sensitive internal files."
        }
      ],
      "detailed_explanation": {
        "core_logic": "<code>same-site</code> is used when resources need to be accessible by different origins within the same registrable domain (e.g., subdomains), such as a shared CDN or an authentication service used across multiple company sites, because it balances security with intra-site resource sharing.",
        "distractor_analysis": "The first distractor describes a use case for <code>same-origin</code>. The second describes a use case for <code>cross-origin</code>. The third suggests a scenario where <code>same-origin</code> or even stricter controls might be more appropriate than <code>same-site</code>.",
        "analogy": "Imagine a large company with several departments (subdomains) under one corporate umbrella (the site). <code>same-site</code> allows resources to be shared between these departments, like a central HR portal accessible by all. <code>same-origin</code> would be like a resource only accessible within a single department. <code>cross-origin</code> would be like a public park accessible to everyone."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "analyze",
      "prerequisites": [
        "CORP_DIRECTIVES",
        "ORIGIN_VS_SITE",
        "CDN_BASICS"
      ]
    },
    {
      "question_text": "What is the main security benefit of using <code>Cross-Origin-Resource-Policy: same-origin</code>?",
      "correct_answer": "It prevents sensitive resources, such as private API responses or user data, from being leaked to unauthorized cross-origin websites.",
      "distractors": [
        {
          "text": "It ensures that all network requests are encrypted using TLS.",
          "misconception": "Targets [protocol confusion]: Mixes CORP's access control with TLS's encryption function."
        },
        {
          "text": "It automatically sanitizes all user inputs to prevent injection attacks.",
          "misconception": "Targets [vulnerability confusion]: Attributes input sanitization capabilities to CORP, which is unrelated to preventing injection."
        },
        {
          "text": "It enforces strong password policies for user authentication.",
          "misconception": "Targets [security domain confusion]: Relates CORP to authentication mechanisms rather than resource access control."
        }
      ],
      "detailed_explanation": {
        "core_logic": "<code>same-origin</code> provides strong protection against cross-origin information leaks because it strictly limits resource access to the originating site, preventing unauthorized sites from fetching sensitive data, thus mitigating XS-Leaks and Spectre-like attacks.",
        "distractor_analysis": "The distractors incorrectly associate CORP with network encryption (TLS), input sanitization (injection prevention), and password policies (authentication), all of which are separate security concerns.",
        "analogy": "Using <code>same-origin</code> is like having a private diary. Only you (the same origin) can read it. If someone from another house (cross-origin) tries to peek, the diary is locked away and unreadable to them. It doesn't encrypt your writing or change your password, it just controls who can physically access the diary."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "CORP_DIRECTIVES",
        "XS_LEAKS",
        "SPECTRE_ATTACKS"
      ]
    },
    {
      "question_text": "How does CORP prevent speculative side-channel attacks like Spectre?",
      "correct_answer": "By blocking <code>no-cors</code> cross-origin requests, it prevents untrusted origins from loading resources that could be exploited by speculative execution to leak data.",
      "distractors": [
        {
          "text": "By encrypting the data transferred during speculative execution.",
          "misconception": "Targets [mechanism confusion]: Attributes encryption to CORP, which is an access control mechanism, not an encryption protocol."
        },
        {
          "text": "By disabling speculative execution in the browser's rendering engine.",
          "misconception": "Targets [scope confusion]: CORP does not disable browser features like speculative execution; it controls resource loading."
        },
        {
          "text": "By requiring all cross-origin requests to use authenticated channels.",
          "misconception": "Targets [protocol confusion]: Mixes CORP's resource policy with authentication requirements for requests."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CORP mitigates Spectre-like attacks because these vulnerabilities exploit speculative execution to leak data via cross-origin requests. By blocking <code>no-cors</code> cross-origin requests to sensitive resources, CORP prevents the attacker's origin from triggering or observing these leaks, thus protecting the integrity of the execution environment.",
        "distractor_analysis": "The distractors incorrectly suggest CORP encrypts data, disables speculative execution, or mandates authenticated channels, none of which are its functions. CORP's mechanism is blocking specific types of cross-origin resource loading.",
        "analogy": "Spectre is like a nosy neighbor trying to eavesdrop on your conversations (speculative execution) by asking for small favors (cross-origin requests). CORP acts like a security guard at your property line, refusing to hand over any information or allow any interaction (<code>no-cors</code> requests) to that nosy neighbor, thus preventing them from gathering clues."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "SPECTRE_ATTACKS",
        "SIDE_CHANNEL_ATTACKS",
        "CORP_FUNDAMENTALS"
      ]
    },
    {
      "question_text": "What is the role of the <code>cross-origin</code> directive in <code>Cross-Origin-Resource-Policy</code>?",
      "correct_answer": "It explicitly allows resources to be loaded by any origin, often used in conjunction with <code>Cross-Origin-Embedder-Policy</code> (COEP) for resources that must be shared widely.",
      "distractors": [
        {
          "text": "It enforces that resources can only be loaded from the same origin.",
          "misconception": "Targets [directive confusion]: This describes the `same-origin` directive, not `cross-origin`."
        },
        {
          "text": "It restricts resources to be loaded only from the same site.",
          "misconception": "Targets [directive confusion]: This describes the `same-site` directive, not `cross-origin`."
        },
        {
          "text": "It blocks all cross-origin requests by default.",
          "misconception": "Targets [default behavior confusion]: `cross-origin` is an opt-out of CORP's default blocking behavior for cross-origin requests."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>cross-origin</code> directive serves as an opt-out, explicitly permitting resources to be loaded by any origin. This is crucial when a resource needs to be embedded by external sites, especially when paired with <code>Cross-Origin-Embedder-Policy</code> (COEP) to ensure those external sites are also secure.",
        "distractor_analysis": "The distractors incorrectly define <code>cross-origin</code> as <code>same-origin</code>, <code>same-site</code>, or a default blocking mechanism, when in fact it's an explicit allowance for any origin.",
        "analogy": "If <code>same-origin</code> is a private party where only invited guests from your house can come, and <code>same-site</code> is a neighborhood block party, then <code>cross-origin</code> is like setting up a public booth at a festival – anyone can approach and interact with it. It's an explicit permission for broad access."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CORP_DIRECTIVES",
        "COEP",
        "HTTP_HEADERS"
      ]
    },
    {
      "question_text": "What is a potential drawback or consideration when implementing CORP?",
      "correct_answer": "Older browsers may not support CORP, potentially requiring fallback mechanisms or accepting a reduced security posture for those users.",
      "distractors": [
        {
          "text": "CORP significantly increases server load and processing time for every request.",
          "misconception": "Targets [performance misconception]: CORP is a client-side (browser) policy enforced via response headers; it doesn't add significant server-side processing per request."
        },
        {
          "text": "CORP conflicts with Content Security Policy (CSP) and cannot be used together.",
          "misconception": "Targets [compatibility confusion]: CORP and CSP are complementary security headers and can be used together effectively."
        },
        {
          "text": "CORP requires all resources to be served over HTTPS, disabling HTTP.",
          "misconception": "Targets [protocol requirement confusion]: CORP is independent of the transport protocol (HTTP/HTTPS); it controls cross-origin access."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A key consideration for CORP is browser compatibility, as older browsers lack support, meaning the policy's protections won't be applied. This necessitates careful planning for degraded security or alternative measures for unsupported clients, because the header's effectiveness is dependent on browser implementation.",
        "distractor_analysis": "The distractors incorrectly claim CORP increases server load, conflicts with CSP, or mandates HTTPS. CORP is a browser-enforced policy, works alongside CSP, and is protocol-agnostic.",
        "analogy": "Implementing CORP is like installing a new type of security lock on your doors. While it's great for modern houses (browsers), older houses (browsers) might not have the right frame for it, so you might need to leave some doors unlocked or use an older, less secure lock for those houses."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "CORP_FUNDAMENTALS",
        "BROWSER_SECURITY",
        "HTTP_HEADERS"
      ]
    },
    {
      "question_text": "Which HTTP header is often used in conjunction with <code>Cross-Origin-Resource-Policy</code> to enable secure embedding of cross-origin resources?",
      "correct_answer": "<code>Cross-Origin-Embedder-Policy</code> (COEP)",
      "distractors": [
        {
          "text": "<code>Content-Security-Policy</code> (CSP)",
          "misconception": "Targets [related technology confusion]: CSP is a security header but focuses on controlling content sources, not specifically enabling cross-origin embedding."
        },
        {
          "text": "<code>Access-Control-Allow-Origin</code> (CORS)",
          "misconception": "Targets [conflicting technology confusion]: CORS *allows* cross-origin access, while CORP/COEP are about *controlling* or *enabling secure* cross-origin embedding."
        },
        {
          "text": "<code>Strict-Transport-Security</code> (HSTS)",
          "misconception": "Targets [protocol security confusion]: HSTS enforces HTTPS connections, unrelated to cross-origin embedding policies."
        }
      ],
      "detailed_explanation": {
        "core_logic": "COEP works with CORP to create a secure context for embedding cross-origin resources. When a document has COEP set, it requires its subresources to either be same-origin or explicitly opt-in via <code>Cross-Origin-Resource-Policy: cross-origin</code>, thereby enabling secure cross-origin embedding.",
        "distractor_analysis": "CSP controls content sources, CORS enables cross-origin requests but doesn't secure embedding, and HSTS enforces HTTPS. COEP is the header specifically designed to work with CORP for secure cross-origin embedding.",
        "analogy": "Imagine building a secure house (a document). CORP defines which materials (resources) from outside your property line are allowed in. COEP is like saying, 'If I'm going to use materials from *other* specific, trusted suppliers (cross-origin resources), those suppliers must also have their own security certifications (CORP: cross-origin header) to prove they are safe to use.' CSP is like a general building code, and CORS is like a permit to bring *any* materials in, without necessarily verifying their safety."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "CORP_FUNDAMENTALS",
        "COEP",
        "HTTP_HEADERS"
      ]
    },
    {
      "question_text": "A web application serves sensitive user profile data via an API endpoint. Which CORP directive is MOST appropriate to protect this data from being leaked to arbitrary external websites?",
      "correct_answer": "<code>same-origin</code>",
      "distractors": [
        {
          "text": "<code>same-site</code>",
          "misconception": "Targets [security level mismatch]: `same-site` is less restrictive and would allow access from subdomains, which might not be desired for sensitive data."
        },
        {
          "text": "<code>cross-origin</code>",
          "misconception": "Targets [security risk]: This directive explicitly allows any origin to access the resource, directly contradicting the goal of protecting sensitive data."
        },
        {
          "text": "No CORP header should be used, relying solely on CORS.",
          "misconception": "Targets [defense-in-depth confusion]: Relying only on CORS is insufficient; CORP provides an additional layer of defense from the server's perspective."
        }
      ],
      "detailed_explanation": {
        "core_logic": "For sensitive user profile data, <code>same-origin</code> is the most appropriate CORP directive because it strictly limits access to requests originating from the exact same scheme, host, and port. This prevents unauthorized cross-origin or even cross-site requests from fetching the data, thereby protecting user privacy and security.",
        "distractor_analysis": "<code>same-site</code> is too permissive for sensitive data, <code>cross-origin</code> is actively dangerous for such data, and omitting CORP entirely while relying only on CORS leaves a significant security gap.",
        "analogy": "Protecting sensitive user data with <code>same-origin</code> is like keeping your personal diary locked in your own private room (<code>same-origin</code>). <code>same-site</code> would be like leaving it in a common area accessible to anyone in your household (<code>same-site</code>). <code>cross-origin</code> would be like leaving it on a public park bench (<code>cross-origin</code>)."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "CORP_DIRECTIVES",
        "API_SECURITY",
        "DATA_PRIVACY"
      ]
    },
    {
      "question_text": "Consider a scenario where a website uses a third-party CDN for static assets like images and JavaScript files. What CORP directive is generally recommended for these CDN-hosted assets if they are not sensitive?",
      "correct_answer": "<code>cross-origin</code>",
      "distractors": [
        {
          "text": "<code>same-origin</code>",
          "misconception": "Targets [scope mismatch]: This would prevent the CDN, being a different origin, from serving the assets to the main website."
        },
        {
          "text": "<code>same-site</code>",
          "misconception": "Targets [scope mismatch]: This might prevent the CDN from serving assets if it's considered a different site, depending on domain configuration."
        },
        {
          "text": "No CORP header should be set on CDN assets.",
          "misconception": "Targets [security best practice]: While `cross-origin` is permissive, explicitly setting it is better than relying on the absence of a header, especially if COEP is in use."
        }
      ],
      "detailed_explanation": {
        "core_logic": "For non-sensitive assets hosted on a third-party CDN, <code>cross-origin</code> is the recommended CORP directive because the CDN is inherently a different origin. This directive explicitly allows any origin, including the main website, to load these resources, ensuring proper functionality without compromising security for public assets.",
        "distractor_analysis": "<code>same-origin</code> and <code>same-site</code> would block the CDN from serving assets. While not setting a header might seem like an option, explicitly setting <code>cross-origin</code> is a clearer signal, especially when COEP is involved.",
        "analogy": "If your website is a house and the CDN is a public art gallery displaying your company's public images, <code>cross-origin</code> is like saying the gallery is open to everyone (<code>cross-origin</code>). <code>same-origin</code> would be like saying only people living in your house can view the art. <code>same-site</code> might be like allowing people from the same neighborhood to view it. For public assets, open access is intended."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "CORP_DIRECTIVES",
        "CDN_BASICS",
        "HTTP_HEADERS"
      ]
    },
    {
      "question_text": "What is the primary mechanism by which CORP enforces its policy?",
      "correct_answer": "The browser inspects the <code>Cross-Origin-Resource-Policy</code> response header and, based on the directive and the request's origin, either allows the resource body to be loaded or strips it.",
      "distractors": [
        {
          "text": "The server actively blocks incoming requests that do not match the policy.",
          "misconception": "Targets [enforcement point confusion]: CORP is a browser-side policy, not a server-side request filter."
        },
        {
          "text": "CORP relies on JavaScript to dynamically block resource loading.",
          "misconception": "Targets [implementation confusion]: CORP is an HTTP header policy, not a JavaScript-based security control."
        },
        {
          "text": "CORP uses encryption to prevent unauthorized access to resource bodies.",
          "misconception": "Targets [functional confusion]: CORP is about access control, not data encryption."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CORP functions as a browser-level security policy. When a browser receives a resource with a CORP header, it evaluates the directive against the request's origin. If the policy is violated, the browser prevents the response body from being accessed by the requesting script or element, effectively blocking the leak, because the enforcement happens client-side.",
        "distractor_analysis": "The distractors incorrectly place enforcement on the server, attribute it to JavaScript, or confuse it with encryption. CORP's core mechanism is browser-based header inspection and conditional response body access.",
        "analogy": "CORP is like a security guard at the entrance of a building (the resource). The guard checks the ID (request origin) against a list (CORP header directive). If the ID doesn't match the allowed list, the guard doesn't let the person (response body) into the building, even if they managed to get to the door."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "understand",
      "prerequisites": [
        "CORP_FUNDAMENTALS",
        "HTTP_HEADERS",
        "BROWSER_SECURITY"
      ]
    },
    {
      "question_text": "Which of the following is a key difference between CORP and CORS?",
      "correct_answer": "CORP is a policy set by the resource owner (server-side) to restrict who can load it, while CORS is a mechanism (server-side configuration) to allow specific cross-origin requests.",
      "distractors": [
        {
          "text": "CORP is used for client-side security, while CORS is for server-side security.",
          "misconception": "Targets [enforcement point confusion]: Both CORP and CORS involve server-side configuration (headers) but are enforced by the browser (client-side)."
        },
        {
          "text": "CORP encrypts data, while CORS only allows access.",
          "misconception": "Targets [functional confusion]: Neither CORP nor CORS inherently encrypts data; CORP restricts access, CORS permits it."
        },
        {
          "text": "CORP applies only to <code>GET</code> requests, while CORS applies to all HTTP methods.",
          "misconception": "Targets [request type limitation]: CORP applies to `no-cors` requests, and CORS can be configured for various methods."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CORP and CORS serve complementary but distinct roles. CORP acts as a server-side declaration of policy on what origins can load a resource, enforced by the browser to prevent leaks. CORS, conversely, is a server-side mechanism that explicitly grants permission for specific cross-origin requests, enabling controlled interaction.",
        "distractor_analysis": "The distractors misrepresent the enforcement points, functionalities (encryption vs. access), and request type limitations of CORP and CORS.",
        "analogy": "Think of CORP as a 'Do Not Disturb' sign on your door (resource). It tells people outside not to bother you. CORS is like putting up a sign saying, 'Welcome, friends from specific addresses only!' It's an invitation. CORP restricts, CORS permits."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "CORP_FUNDAMENTALS",
        "CORS",
        "HTTP_HEADERS"
      ]
    },
    {
      "question_text": "What is the significance of the <code>no-cors</code> request mode in relation to CORP?",
      "correct_answer": "CORP primarily protects against <code>no-cors</code> cross-origin requests, as these are the types of requests that might bypass standard CORS preflight checks and could be used in XS-Leaks.",
      "distractors": [
        {
          "text": "CORP only affects <code>cors</code> requests, preventing them from accessing resources.",
          "misconception": "Targets [request mode confusion]: CORP's main impact is on `no-cors` requests, not standard `cors` requests which already have access controls."
        },
        {
          "text": "<code>no-cors</code> requests are always blocked by default, and CORP is redundant.",
          "misconception": "Targets [default behavior confusion]: `no-cors` requests are allowed by default but have limitations; CORP adds an explicit policy layer."
        },
        {
          "text": "CORP requires all requests, including <code>no-cors</code>, to be authenticated.",
          "misconception": "Targets [authentication confusion]: CORP is about origin policy, not authentication requirements for `no-cors` requests."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CORP's effectiveness is most pronounced against <code>no-cors</code> cross-origin requests because these requests, often initiated by elements like <code>&lt;img&gt;</code> or <code>&lt;script&gt;</code>, do not trigger CORS preflight checks and can be exploited for XS-Leaks. By blocking these specific types of requests, CORP prevents sensitive data from being exfiltrated.",
        "distractor_analysis": "The distractors incorrectly state CORP affects <code>cors</code> requests, that <code>no-cors</code> are always blocked, or that CORP mandates authentication, all of which misrepresent its function regarding request modes.",
        "analogy": "Imagine <code>no-cors</code> requests are like anonymous letters sent from outside your neighborhood. CORP acts like a mail screener who specifically checks these anonymous letters for sensitive information before delivering them. Standard <code>cors</code> requests are like letters from known friends, which might already be handled by a different security system (like a gatekeeper)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "CORP_FUNDAMENTALS",
        "FETCH_API",
        "XS_LEAKS"
      ]
    },
    {
      "question_text": "A web developer is configuring HTTP security headers. They want to ensure that a specific sensitive API endpoint can only be accessed by their own web application and not by any other website. Which CORP directive should they implement?",
      "correct_answer": "<code>same-origin</code>",
      "distractors": [
        {
          "text": "<code>same-site</code>",
          "misconception": "Targets [granularity error]: This would allow access from subdomains, which might be considered different sites and potentially less secure than strictly the same origin."
        },
        {
          "text": "<code>cross-origin</code>",
          "misconception": "Targets [security risk]: This directive explicitly allows any origin to access the resource, defeating the purpose of protecting a sensitive API."
        },
        {
          "text": "No CORP header",
          "misconception": "Targets [security gap]: Relying on no header means the resource is accessible by default to any origin, leaving it vulnerable."
        }
      ],
      "detailed_explanation": {
        "core_logic": "To ensure a sensitive API endpoint is only accessible by the originating web application, the <code>same-origin</code> directive is the most appropriate choice. This is because it enforces the strictest access control, allowing requests only from the exact same scheme, host, and port, thereby preventing unauthorized cross-origin access.",
        "distractor_analysis": "<code>same-site</code> is less restrictive, <code>cross-origin</code> is insecure for sensitive APIs, and omitting the header leaves the API exposed by default.",
        "analogy": "Protecting a sensitive API with <code>same-origin</code> is like having a private key to your own house. Only someone with that exact key (same origin) can get in. <code>same-site</code> would be like giving keys to all your neighbors. <code>cross-origin</code> would be like leaving your front door wide open."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "CORP_DIRECTIVES",
        "API_SECURITY",
        "HTTP_HEADERS"
      ]
    },
    {
      "question_text": "What is the primary function of the <code>Cross-Origin-Resource-Policy</code> header in web security?",
      "correct_answer": "To control which origins are allowed to load a web resource, thereby mitigating cross-origin information leaks.",
      "distractors": [
        {
          "text": "To enforce encryption for all data transferred between origins.",
          "misconception": "Targets [functional confusion]: CORP is about access control, not data encryption like TLS."
        },
        {
          "text": "To validate the authenticity of incoming requests using digital signatures.",
          "misconception": "Targets [authentication confusion]: CORP does not perform request authentication; it focuses on origin policy."
        },
        {
          "text": "To prevent cross-site scripting (XSS) attacks by sanitizing input.",
          "misconception": "Targets [vulnerability confusion]: CORP is not designed to sanitize input or directly prevent XSS, which requires different defenses."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>Cross-Origin-Resource-Policy</code> header allows websites to define policies for resource loading, specifically restricting which origins can access them. This is crucial because it prevents sensitive data from being leaked to unauthorized cross-origin requests, a common vector for attacks like XS-Leaks.",
        "distractor_analysis": "The distractors incorrectly attribute encryption, request authentication, or XSS prevention capabilities to CORP, which are functions of other security mechanisms.",
        "analogy": "CORP is like a gatekeeper for your property (resources). It checks the address (origin) of anyone trying to enter and decides whether to let them in based on the owner's rules (the policy directives). It doesn't encrypt the property or check IDs for authenticity, just the address."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CORP_FUNDAMENTALS",
        "HTTP_HEADERS",
        "WEB_SECURITY_BASICS"
      ]
    },
    {
      "question_text": "When configuring CORP, which directive offers the least restrictive access, allowing resources to be loaded by any origin?",
      "correct_answer": "<code>cross-origin</code>",
      "distractors": [
        {
          "text": "<code>same-origin</code>",
          "misconception": "Targets [directive confusion]: This directive is the most restrictive, allowing access only from the exact same origin."
        },
        {
          "text": "<code>same-site</code>",
          "misconception": "Targets [directive confusion]: This directive allows access from the same site (including subdomains), which is more restrictive than `cross-origin`."
        },
        {
          "text": "<code>any</code>",
          "misconception": "Targets [non-existent directive]: This is not a valid directive for the `Cross-Origin-Resource-Policy` header."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>cross-origin</code> directive explicitly permits resources to be loaded by any origin, making it the least restrictive option. This is useful for public resources or when working with <code>Cross-Origin-Embedder-Policy</code> (COEP) to ensure resources are available for embedding by external, secure contexts.",
        "distractor_analysis": "<code>same-origin</code> and <code>same-site</code> are progressively more restrictive. <code>any</code> is not a valid directive, making <code>cross-origin</code> the correct answer for least restrictive access.",
        "analogy": "If <code>same-origin</code> is a private party, <code>same-site</code> is a neighborhood gathering, then <code>cross-origin</code> is an open invitation to the public festival – anyone can come and access the resources."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "CORP_DIRECTIVES",
        "HTTP_HEADERS"
      ]
    },
    {
      "question_text": "A web application needs to serve a public image file that might be embedded on other websites. To ensure this is possible while still signaling intent, what CORP directive should be used?",
      "correct_answer": "<code>cross-origin</code>",
      "distractors": [
        {
          "text": "<code>same-origin</code>",
          "misconception": "Targets [scope mismatch]: This would prevent the image from being loaded by any other website trying to embed it."
        },
        {
          "text": "<code>same-site</code>",
          "misconception": "Targets [scope mismatch]: This would only allow the image to be loaded by resources from the same site, not arbitrary external websites."
        },
        {
          "text": "No CORP header",
          "misconception": "Targets [best practice gap]: While technically allowing access, explicitly setting `cross-origin` is a clearer signal and works better with COEP."
        }
      ],
      "detailed_explanation": {
        "core_logic": "For public resources like images intended for embedding on other websites, the <code>cross-origin</code> directive is the correct choice. It explicitly allows any origin to load the resource, ensuring the image displays correctly when embedded elsewhere, and signals to the browser that this resource is intended for broad use.",
        "distractor_analysis": "<code>same-origin</code> and <code>same-site</code> are too restrictive for public, embeddable resources. Explicitly setting <code>cross-origin</code> is preferred over omitting the header for clarity and compatibility with other security policies like COEP.",
        "analogy": "Serving a public image is like putting up a poster in a public square. <code>cross-origin</code> is like saying, 'Anyone can look at this poster.' <code>same-origin</code> would be like only allowing people from your own house to see it. <code>same-site</code> would be like only allowing people from your street."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "CORP_DIRECTIVES",
        "HTTP_HEADERS",
        "WEB_ASSETS"
      ]
    },
    {
      "question_text": "What is a potential security risk if a web application incorrectly uses <code>Cross-Origin-Resource-Policy: cross-origin</code> for sensitive resources?",
      "correct_answer": "Sensitive data or resources could be leaked to arbitrary external websites, undermining the intended security protections.",
      "distractors": [
        {
          "text": "The website might become inaccessible to legitimate users.",
          "misconception": "Targets [availability confusion]: `cross-origin` generally enhances availability for embedding, not reduces it, unless other policies are misconfigured."
        },
        {
          "text": "The server might be overwhelmed with too many cross-origin requests.",
          "misconception": "Targets [performance confusion]: CORP is a browser policy; it doesn't inherently cause server overload, though excessive requests can strain resources."
        },
        {
          "text": "User sessions might be hijacked through cross-origin requests.",
          "misconception": "Targets [attack vector confusion]: While data leaks can contribute to session compromise, `cross-origin` itself doesn't directly cause session hijacking; it enables data exfiltration."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Using <code>cross-origin</code> for sensitive resources is a significant security risk because it explicitly allows any origin to load that resource. This directly contradicts the need for protection, potentially leading to data exfiltration and exposure of private information, because the policy fails to restrict access.",
        "distractor_analysis": "The distractors incorrectly focus on availability, server overload, or direct session hijacking as primary risks of misusing <code>cross-origin</code>. The core risk is the intended exposure of sensitive data.",
        "analogy": "Using <code>cross-origin</code> for sensitive data is like leaving your bank vault door wide open (<code>cross-origin</code>) hoping no one will steal anything. While it makes access easy, it completely removes security, potentially leading to theft (data leaks)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "CORP_DIRECTIVES",
        "WEB_SECURITY_BASICS",
        "DATA_LEAKS"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 18,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Cross-Origin Resource Policy (CORP) 008_Application Security best practices",
    "latency_ms": 35877.853
  },
  "timestamp": "2026-01-18T12:15:55.578353"
}