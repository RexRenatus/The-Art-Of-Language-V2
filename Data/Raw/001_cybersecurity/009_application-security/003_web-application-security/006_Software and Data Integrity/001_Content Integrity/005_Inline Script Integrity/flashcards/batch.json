{
  "topic_title": "Inline Script Integrity",
  "category": "008_Application Security - Web 008_Application Security",
  "flashcards": [
    {
      "question_text": "What is the primary security goal of Subresource Integrity (SRI)?",
      "correct_answer": "To ensure that fetched resources (like scripts or stylesheets) have not been tampered with or manipulated during transit.",
      "distractors": [
        {
          "text": "To encrypt all client-side scripts to prevent reverse engineering.",
          "misconception": "Targets [confidentiality vs integrity confusion]: Confuses SRI's integrity check with encryption's confidentiality goal."
        },
        {
          "text": "To validate the authenticity of the server hosting the external resource.",
          "misconception": "Targets [authentication vs integrity confusion]: Misunderstands SRI as a server authentication mechanism rather than resource integrity."
        },
        {
          "text": "To enforce Content Security Policy (CSP) directives for script execution.",
          "misconception": "Targets [related technology confusion]: Mixes SRI with CSP, which are complementary but distinct security mechanisms."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI works by comparing a cryptographic hash of a fetched resource against a known, trusted hash provided by the developer. This ensures integrity because any modification to the resource would change its hash, causing the browser to reject it.",
        "distractor_analysis": "The distractors incorrectly associate SRI with encryption, server authentication, or CSP enforcement, rather than its core function of verifying resource integrity against tampering.",
        "analogy": "SRI is like a tamper-evident seal on a package. If the seal is broken (the hash doesn't match), you know the contents might have been altered."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "APPSEC_BASICS",
        "WEBSEC_BASICS"
      ]
    },
    {
      "question_text": "How does Subresource Integrity (SRI) achieve its security goal?",
      "correct_answer": "By requiring the browser to compare a cryptographic hash of the fetched resource against a hash provided in the <code>integrity</code> attribute.",
      "distractors": [
        {
          "text": "By encrypting the resource using a key shared between the server and browser.",
          "misconception": "Targets [mechanism confusion]: Incorrectly assumes SRI uses encryption rather than hashing for integrity checks."
        },
        {
          "text": "By verifying the digital signature of the resource's origin server.",
          "misconception": "Targets [signature vs hash confusion]: Confuses SRI's hash-based integrity with digital signature-based authentication."
        },
        {
          "text": "By checking if the resource is loaded over HTTPS.",
          "misconception": "Targets [protocol confusion]: Mistakenly believes SRI is solely dependent on HTTPS, ignoring its independent integrity mechanism."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI functions by embedding a cryptographic hash (e.g., SHA-384) within the HTML tag for a resource. The browser calculates the hash of the downloaded resource and compares it to the provided hash. If they match, the resource is trusted; otherwise, it's blocked, ensuring integrity.",
        "distractor_analysis": "Distractors incorrectly suggest encryption, digital signatures, or HTTPS as the mechanism, rather than the core process of hash comparison for integrity.",
        "analogy": "It's like checking if a downloaded file's checksum matches the one listed on the website. If they don't match, the download might be corrupted or malicious."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "APPSEC_BASICS",
        "WEBSEC_BASICS",
        "CRYPTO_HASHING"
      ]
    },
    {
      "question_text": "Which HTML attributes are used to implement Subresource Integrity (SRI)?",
      "correct_answer": "<code>integrity</code> and <code>crossorigin</code>",
      "distractors": [
        {
          "text": "<code>src</code> and <code>href</code>",
          "misconception": "Targets [attribute confusion]: These attributes specify the resource location, not its integrity check."
        },
        {
          "text": "<code>nonce</code> and <code>script-src</code>",
          "misconception": "Targets [CSP vs SRI confusion]: These are related to Content Security Policy, not SRI."
        },
        {
          "text": "<code>referrer-policy</code> and <code>content-type</code>",
          "misconception": "Targets [unrelated attribute confusion]: These attributes control referrer information and content type, respectively."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>integrity</code> attribute holds the cryptographic hash(es) for the resource, while <code>crossorigin=&quot;anonymous&quot;</code> is required for SRI to function correctly with resources loaded from different origins, enabling the browser to perform the integrity check.",
        "distractor_analysis": "Distractors list attributes related to resource linking (<code>src</code>, <code>href</code>), Content Security Policy (<code>nonce</code>, <code>script-src</code>), or general HTTP headers (<code>referrer-policy</code>, <code>content-type</code>), none of which are the primary attributes for SRI implementation.",
        "analogy": "Think of <code>src</code>/<code>href</code> as the address on a package, and <code>integrity</code>/<code>crossorigin</code> as the unique serial number and a note saying 'handle with care from another department' that you check to ensure the package hasn't been tampered with."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "APPSEC_BASICS",
        "WEBSEC_BASICS",
        "SRI_BASICS"
      ]
    },
    {
      "question_text": "Why is the <code>crossorigin=&quot;anonymous&quot;</code> attribute often required when using Subresource Integrity (SRI) for external resources?",
      "correct_answer": "It allows the browser to fetch the resource without sending credentials and enables the integrity check for cross-origin resources.",
      "distractors": [
        {
          "text": "It ensures the external resource is loaded using HTTPS.",
          "misconception": "Targets [protocol confusion]: Confuses the `crossorigin` attribute's role with HTTPS enforcement."
        },
        {
          "text": "It prevents the external resource from executing any JavaScript.",
          "misconception": "Targets [execution control confusion]: Misunderstands `crossorigin` as a script execution blocker."
        },
        {
          "text": "It forces the browser to cache the external resource for faster loading.",
          "misconception": "Targets [caching confusion]: Incorrectly associates `crossorigin` with browser caching behavior."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>crossorigin=&quot;anonymous&quot;</code> attribute is necessary because SRI checks the integrity of resources fetched from a different origin. This attribute ensures the browser fetches the resource without sending cookies or authentication headers, which is a prerequisite for the browser to perform the integrity check and for the CDN to serve the resource correctly.",
        "distractor_analysis": "The distractors incorrectly link <code>crossorigin</code> to HTTPS, script execution prevention, or caching, rather than its actual function in enabling cross-origin integrity checks.",
        "analogy": "It's like asking a delivery person from another company to bring a package. <code>crossorigin=&quot;anonymous&quot;</code> tells the delivery person to just drop it off without asking for your personal ID or company secrets, so you can then check if the package itself is intact."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "APPSEC_BASICS",
        "WEBSEC_BASICS",
        "SRI_BASICS",
        "CORS_BASICS"
      ]
    },
    {
      "question_text": "What are the common cryptographic hash algorithms used with Subresource Integrity (SRI)?",
      "correct_answer": "SHA-256, SHA-384, and SHA-512",
      "distractors": [
        {
          "text": "MD5 and SHA-1",
          "misconception": "Targets [outdated algorithm confusion]: These algorithms are considered cryptographically weak and deprecated for integrity checks."
        },
        {
          "text": "AES and RSA",
          "misconception": "Targets [encryption vs hashing confusion]: These are symmetric and asymmetric encryption algorithms, not hashing algorithms for integrity."
        },
        {
          "text": "SHA-3 and BLAKE2",
          "misconception": "Targets [algorithm scope confusion]: While strong, these are less commonly supported or specified for SRI compared to SHA-2 variants."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI specifies the use of strong, modern cryptographic hash functions. SHA-256, SHA-384, and SHA-512 are part of the SHA-2 family and are widely supported by browsers for integrity verification, providing a robust defense against tampering.",
        "distractor_analysis": "Distractors include deprecated hashing algorithms (MD5, SHA-1), encryption algorithms (AES, RSA), and newer but less universally supported hashing algorithms, failing to identify the standard SRI-compatible algorithms.",
        "analogy": "When checking a package's seal (SRI), you need to use a specific type of scanner (hash algorithm). SRI specifies using scanners like SHA-256, SHA-384, or SHA-512, not older, less reliable ones like MD5, or tools meant for something else like encryption (AES/RSA)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "APPSEC_BASICS",
        "WEBSEC_BASICS",
        "CRYPTO_HASHING"
      ]
    },
    {
      "question_text": "Consider a scenario where a Content Delivery Network (CDN) hosting a JavaScript library is compromised. How does SRI help protect a website that uses this library?",
      "correct_answer": "The browser will refuse to load the compromised JavaScript file because its calculated hash will not match the hash specified in the website's <code>integrity</code> attribute.",
      "distractors": [
        {
          "text": "The browser will automatically block all scripts from that CDN.",
          "misconception": "Targets [overly broad blocking confusion]: Assumes SRI blocks the entire CDN, rather than just the specific tampered file."
        },
        {
          "text": "The website's server will detect the compromise and alert the administrator.",
          "misconception": "Targets [client-side vs server-side confusion]: SRI is a browser-side mechanism; it doesn't directly involve the origin server in detecting the compromise."
        },
        {
          "text": "The compromised script will execute but its malicious actions will be neutralized by SRI.",
          "misconception": "Targets [misunderstanding of SRI's action]: SRI prevents execution entirely if the integrity check fails; it does not neutralize malicious code."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI provides a defense-in-depth strategy. When a CDN is compromised and a script file is altered, its cryptographic hash changes. Because the browser compares the downloaded file's hash against the <code>integrity</code> attribute value, it detects the mismatch and blocks the script, preventing the malicious code from running.",
        "distractor_analysis": "Distractors incorrectly suggest broad CDN blocking, server-side detection, or partial neutralization of malicious code, rather than the specific mechanism of hash mismatch leading to script blocking.",
        "analogy": "If a trusted supplier (CDN) sends you a product with a broken security seal (tampered script), you won't accept it because the seal (hash) doesn't match what you expected, thus protecting you from potentially counterfeit goods."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "APPSEC_BASICS",
        "WEBSEC_BASICS",
        "SRI_BASICS",
        "CDN_RISKS"
      ]
    },
    {
      "question_text": "What is a potential drawback of using Subresource Integrity (SRI)?",
      "correct_answer": "If a legitimate update to an external resource changes its hash, the website might break until the <code>integrity</code> attribute is updated.",
      "distractors": [
        {
          "text": "It significantly increases the page load time for all resources.",
          "misconception": "Targets [performance exaggeration]: While there's a minor overhead, it doesn't significantly impact overall page load time for all resources."
        },
        {
          "text": "It requires the external resource to be hosted on the same domain as the website.",
          "misconception": "Targets [origin restriction confusion]: SRI is specifically designed for cross-origin resources and requires `crossorigin` attribute."
        },
        {
          "text": "It is not supported by any modern web browsers.",
          "misconception": "Targets [browser support ignorance]: SRI is widely supported by major modern browsers."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI binds a resource to its specific hash. Therefore, when the resource provider updates the file (e.g., for a security patch or new feature), the hash changes. The website's <code>integrity</code> attribute must be manually updated to reflect the new hash; otherwise, the browser will block the updated resource, causing the website functionality to break.",
        "distractor_analysis": "Distractors incorrectly claim significant performance degradation, same-origin requirements, or lack of browser support, overlooking the practical challenge of managing hash updates.",
        "analogy": "Imagine you have a specific key (hash) to open a specific lockbox (resource). If the manufacturer changes the lock (updates the resource), your old key won't work anymore, and you need a new key (updated <code>integrity</code> attribute) to access the updated box."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "APPSEC_BASICS",
        "WEBSEC_BASICS",
        "SRI_BASICS"
      ]
    },
    {
      "question_text": "How can a developer generate the correct cryptographic hash for the <code>integrity</code> attribute?",
      "correct_answer": "By using command-line tools like <code>openssl</code> or <code>shasum</code> on the resource file, then base64-encoding the output.",
      "distractors": [
        {
          "text": "By asking the CDN provider to supply the hash.",
          "misconception": "Targets [reliance on provider confusion]: While providers might offer hashes, direct generation ensures control and verification."
        },
        {
          "text": "By using browser developer tools to inspect the resource's properties.",
          "misconception": "Targets [tool limitation confusion]: Browser dev tools typically don't directly provide the SRI-compatible hash."
        },
        {
          "text": "By performing a simple file size check.",
          "misconception": "Targets [weak check confusion]: File size is not a cryptographic hash and provides no integrity guarantee."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Generating SRI hashes involves using cryptographic hashing utilities available on most operating systems. Commands like <code>openssl dgst -sha384 -binary &lt;file&gt; | openssl base64 -A</code> or <code>shasum -b -a 384 &lt;file&gt; | base64</code> compute the hash and then encode it into the base64 format required for the <code>integrity</code> attribute.",
        "distractor_analysis": "Distractors suggest relying solely on the provider, using inappropriate browser tools, or employing a non-cryptographic check (file size), failing to identify the standard method of generating hashes via command-line tools.",
        "analogy": "To get the unique serial number (hash) for a product, you don't just ask the factory worker (CDN provider) or guess based on its weight (file size); you use a specific scanner (openssl/shasum) and then write down the number in a standard format (base64)."
      },
      "code_snippets": [
        {
          "language": "text",
          "code": "curl -s https://code.jquery.com/jquery-3.6.0.min.js | openssl dgst -sha384 -binary | openssl base64 -A",
          "context": "explanation"
        }
      ],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "APPSEC_BASICS",
        "WEBSEC_BASICS",
        "SRI_BASICS",
        "COMMAND_LINE_TOOLS"
      ],
      "_code_snippets_html": "<div class=\"code-snippet code-explanation\">\n<span class=\"code-label\">Code Example</span>\n<pre><code class=\"language-text\">curl -s https://code.jquery.com/jquery-3.6.0.min.js | openssl dgst -sha384 -binary | openssl base64 -A</code></pre>\n</div>"
    },
    {
      "question_text": "What is the relationship between Subresource Integrity (SRI) and Content Security Policy (CSP)?",
      "correct_answer": "They are complementary security mechanisms; CSP controls *what* resources can be loaded and from *where*, while SRI verifies the *integrity* of those loaded resources.",
      "distractors": [
        {
          "text": "SRI is a directive within CSP that enforces hash checking.",
          "misconception": "Targets [hierarchical confusion]: Incorrectly places SRI as a sub-component of CSP, rather than a separate but related control."
        },
        {
          "text": "CSP is used to generate SRI hashes, while SRI enforces CSP policies.",
          "misconception": "Targets [functional role confusion]: Reverses or misattributes the primary functions of each technology."
        },
        {
          "text": "They are redundant and serve the same purpose, so only one needs to be implemented.",
          "misconception": "Targets [redundancy misconception]: Overlooks the distinct but synergistic roles they play in web security."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CSP acts as a gatekeeper, defining allowed sources and types of content. SRI acts as a seal checker, ensuring that content allowed by CSP hasn't been tampered with. Implementing both provides a stronger security posture by controlling resource loading and verifying resource integrity.",
        "distractor_analysis": "Distractors misrepresent the relationship as hierarchical, functional reversal, or redundancy, failing to grasp that CSP governs *what* can load and SRI verifies *that it hasn't changed*.",
        "analogy": "CSP is like a security guard at a building entrance deciding who is allowed in. SRI is like a quality control inspector at the loading dock, checking that the items brought in by authorized personnel haven't been damaged or swapped."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "APPSEC_BASICS",
        "WEBSEC_BASICS",
        "SRI_BASICS",
        "CSP_BASICS"
      ]
    },
    {
      "question_text": "Which of the following is an example of a valid <code>integrity</code> attribute value for SRI?",
      "correct_answer": "<code>sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC</code>",
      "distractors": [
        {
          "text": "<code>sha256-abcdef1234567890</code>",
          "misconception": "Targets [format error]: While SHA-256 is valid, this hash is too short and likely not a real base64-encoded hash."
        },
        {
          "text": "<code>md5-Z3Q8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC</code>",
          "misconception": "Targets [algorithm error]: MD5 is not a recommended or standard algorithm for SRI."
        },
        {
          "text": "<code>integrity=sha512-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC</code>",
          "misconception": "Targets [syntax error]: The `integrity=` prefix is incorrect; the attribute value itself is the hash string."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A valid SRI <code>integrity</code> attribute value consists of a prefix indicating the hash algorithm (e.g., <code>sha384-</code>), followed by the base64-encoded cryptographic hash of the resource. The provided correct answer follows this format with a recognized algorithm and a plausible base64 hash.",
        "distractor_analysis": "Distractor 1 uses a valid algorithm prefix but an incomplete hash. Distractor 2 uses a deprecated algorithm. Distractor 3 incorrectly includes the attribute name within the value.",
        "analogy": "This is like checking a product's serial number. The correct format includes the manufacturer code (algorithm prefix) and the unique serial number (base64 hash), not the label 'Serial Number:' itself."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "APPSEC_BASICS",
        "WEBSEC_BASICS",
        "SRI_BASICS",
        "CRYPTO_HASHING"
      ]
    },
    {
      "question_text": "What is the purpose of the <code>integrity</code> attribute in Subresource Integrity (SRI)?",
      "correct_answer": "To provide the cryptographic hash(es) of the expected resource content.",
      "distractors": [
        {
          "text": "To specify the allowed domains from which the resource can be loaded.",
          "misconception": "Targets [CSP confusion]: This function is typically handled by Content Security Policy (CSP) directives like `script-src`."
        },
        {
          "text": "To define fallback resources if the primary resource fails to load.",
          "misconception": "Targets [fallback mechanism confusion]: SRI does not inherently provide fallback mechanisms; it primarily blocks failed integrity checks."
        },
        {
          "text": "To indicate the version number of the external script.",
          "misconception": "Targets [versioning confusion]: SRI uses hashes, not version numbers, to ensure integrity."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>integrity</code> attribute is the core of SRI. It contains one or more base64-encoded cryptographic hashes. The browser calculates the hash of the fetched resource and compares it against the value(s) in the <code>integrity</code> attribute. A match ensures the resource has not been altered since the hash was generated.",
        "distractor_analysis": "Distractors incorrectly assign roles related to domain control (CSP's job), fallback loading, or versioning, missing the fundamental purpose of the <code>integrity</code> attribute for hash-based verification.",
        "analogy": "The <code>integrity</code> attribute is like a unique fingerprint for the file. If the fingerprint doesn't match the one you have on record, you know the file isn't the original."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "APPSEC_BASICS",
        "WEBSEC_BASICS",
        "SRI_BASICS"
      ]
    },
    {
      "question_text": "Can Subresource Integrity (SRI) protect against a compromised origin server that serves the main website's HTML?",
      "correct_answer": "No, SRI protects resources fetched *by* the HTML, but if the HTML itself is compromised, SRI cannot prevent the malicious HTML from being delivered.",
      "distractors": [
        {
          "text": "Yes, SRI checks all resources linked within the HTML, including the HTML itself.",
          "misconception": "Targets [scope confusion]: SRI applies to linked subresources (scripts, stylesheets), not the HTML document initiating the load."
        },
        {
          "text": "Yes, if the HTML is compromised, the browser will detect the integrity mismatch.",
          "misconception": "Targets [mechanism misunderstanding]: SRI integrity checks are applied to linked resources, not the HTML document itself."
        },
        {
          "text": "Yes, SRI works in conjunction with HTTPS to secure the entire delivery chain.",
          "misconception": "Targets [overstated capability]: While HTTPS secures the transport layer, SRI secures the content integrity of specific subresources, not the HTML origin."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI is designed to protect against tampering of external resources (like scripts from a CDN). It relies on the integrity of the HTML document that specifies the <code>integrity</code> attribute. If the HTML document itself is compromised (e.g., by a server-side vulnerability), an attacker could modify the <code>integrity</code> hashes or remove SRI checks altogether, rendering SRI ineffective for that load.",
        "distractor_analysis": "Distractors incorrectly extend SRI's scope to the HTML document itself, misunderstand its mechanism, or overstate its relationship with HTTPS, failing to recognize that SRI assumes the integrity of the HTML document providing the hashes.",
        "analogy": "SRI is like checking the authenticity of individual ingredients (scripts, CSS) you order for a recipe. It doesn't help if the recipe book itself (HTML) has been altered by someone who tampered with your order."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "APPSEC_BASICS",
        "WEBSEC_BASICS",
        "SRI_BASICS",
        "HTML_SECURITY"
      ]
    },
    {
      "question_text": "What is the primary risk that Subresource Integrity (SRI) aims to mitigate?",
      "correct_answer": "Malicious code injection into external resources hosted on third-party servers like CDNs.",
      "distractors": [
        {
          "text": "Cross-Site Request Forgery (CSRF) attacks.",
          "misconception": "Targets [attack type confusion]: CSRF involves tricking a user into performing unwanted actions; SRI addresses resource integrity."
        },
        {
          "text": "SQL Injection vulnerabilities.",
          "misconception": "Targets [attack type confusion]: SQL Injection targets database interactions; SRI is for client-side resource integrity."
        },
        {
          "text": "Denial of Service (DoS) attacks.",
          "misconception": "Targets [attack type confusion]: DoS aims to make a service unavailable; SRI focuses on preventing execution of malicious code."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Websites often rely on external resources. If a CDN or third-party host is compromised, an attacker can modify these resources to include malicious scripts. SRI mitigates this by ensuring that the browser only executes the resource if its content hash matches the one specified in the HTML, thereby preventing the execution of tampered code.",
        "distractor_analysis": "Distractors list other common web vulnerabilities (CSRF, SQLi, DoS) that SRI is not designed to prevent, failing to identify the specific risk of compromised external resources.",
        "analogy": "SRI is like a security guard checking the ID of every delivery person (external resource) trying to enter your building (browser). It prevents unauthorized or potentially harmful individuals (malicious code) from getting in, even if they claim to be from a known company (CDN)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "APPSEC_BASICS",
        "WEBSEC_BASICS",
        "SRI_BASICS",
        "ATTACK_TYPES"
      ]
    },
    {
      "question_text": "When would a developer typically generate SRI hashes for resources?",
      "correct_answer": "When linking to external scripts or stylesheets hosted on CDNs or other third-party domains.",
      "distractors": [
        {
          "text": "Only for inline scripts defined directly within the HTML.",
          "misconception": "Targets [scope confusion]: SRI is primarily for external resources; inline scripts can be protected differently (e.g., CSP nonces/hashes)."
        },
        {
          "text": "For all resources, including images and fonts.",
          "misconception": "Targets [over-application confusion]: SRI is typically applied to executable code (JS) and critical styling (CSS), not all asset types."
        },
        {
          "text": "Never, as modern browsers handle integrity checks automatically.",
          "misconception": "Targets [browser capability ignorance]: Browsers perform the check *if* the `integrity` attribute is provided; they don't generate it."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The primary use case for SRI is to secure resources loaded from external sources, such as JavaScript libraries or CSS frameworks hosted on CDNs. This is because these external resources are outside the direct control of the website owner, making them potential targets for compromise. By providing a hash, the website ensures the integrity of these critical external dependencies.",
        "distractor_analysis": "Distractors incorrectly suggest SRI applies to inline scripts, all resource types, or is automatically handled by browsers, missing the core scenario of securing untrusted external dependencies.",
        "analogy": "You'd put a special lock (SRI hash) on a package delivered by an unknown courier (CDN) to ensure it's the correct item, but you wouldn't bother locking your own toolbox (inline scripts) if you know it's secure."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "APPSEC_BASICS",
        "WEBSEC_BASICS",
        "SRI_BASICS",
        "CDN_RISKS"
      ]
    },
    {
      "question_text": "What is the role of cryptographic hashes in Subresource Integrity (SRI)?",
      "correct_answer": "They act as unique fingerprints for resources, allowing browsers to detect any modifications.",
      "distractors": [
        {
          "text": "They encrypt the resource to ensure confidentiality.",
          "misconception": "Targets [encryption vs hashing confusion]: Hashes are for integrity, not confidentiality; encryption is used for confidentiality."
        },
        {
          "text": "They authenticate the identity of the resource provider.",
          "misconception": "Targets [authentication vs integrity confusion]: Hashes verify content integrity, not the identity of the source."
        },
        {
          "text": "They compress the resource to improve loading speed.",
          "misconception": "Targets [compression confusion]: Hashes are fixed-size digests and do not compress the original resource."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Cryptographic hashes are one-way functions that produce a fixed-size output (the hash) from an input (the resource). Even a tiny change in the input results in a drastically different hash. SRI leverages this property: the browser calculates the hash of the fetched resource and compares it to the known hash. A mismatch signifies tampering, thus ensuring integrity.",
        "distractor_analysis": "Distractors incorrectly attribute encryption, authentication, or compression functions to cryptographic hashes in the context of SRI, failing to recognize their role in integrity verification.",
        "analogy": "A hash is like a unique barcode for a product. If the barcode on the product you receive doesn't match the one listed in the catalog (HTML <code>integrity</code> attribute), you know the product has been swapped or altered."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "APPSEC_BASICS",
        "WEBSEC_BASICS",
        "CRYPTO_HASHING"
      ]
    },
    {
      "question_text": "Which of the following best describes the 'Subresource Integrity' (SRI) mechanism?",
      "correct_answer": "A security feature that allows browsers to verify that fetched resources (e.g., from a CDN) are delivered without unexpected manipulation by comparing cryptographic hashes.",
      "distractors": [
        {
          "text": "A method for encrypting all JavaScript code before it is sent to the browser.",
          "misconception": "Targets [encryption vs integrity confusion]: SRI focuses on integrity, not encrypting code for confidentiality."
        },
        {
          "text": "A protocol for authenticating the origin server of external resources.",
          "misconception": "Targets [authentication vs integrity confusion]: SRI verifies resource content, not the trustworthiness of the server itself."
        },
        {
          "text": "A Content Security Policy directive that blocks all external scripts.",
          "misconception": "Targets [CSP confusion]: SRI is a separate mechanism, not a CSP directive, and doesn't necessarily block all external scripts, only those failing integrity checks."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI provides a crucial layer of defense against attacks that compromise third-party resources. By embedding a cryptographic hash in the HTML, developers instruct the browser to validate the integrity of the fetched resource. If the hash doesn't match, the browser refuses to load it, preventing potentially malicious code from executing.",
        "distractor_analysis": "Distractors mischaracterize SRI as encryption, server authentication, or a CSP directive, failing to identify its core function of verifying resource integrity via hash comparison.",
        "analogy": "SRI is like having a specific, unique key (hash) for each external tool (resource) you borrow. If the tool you receive doesn't fit your key, you know it's not the right one and refuse to use it."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "APPSEC_BASICS",
        "WEBSEC_BASICS",
        "SRI_BASICS"
      ]
    },
    {
      "question_text": "What is the primary security benefit of implementing Subresource Integrity (SRI)?",
      "correct_answer": "It prevents the execution of tampered or malicious code injected into externally hosted resources.",
      "distractors": [
        {
          "text": "It ensures that all external resources are always available.",
          "misconception": "Targets [availability vs integrity confusion]: SRI focuses on integrity; it doesn't guarantee resource availability."
        },
        {
          "text": "It automatically updates external resources to their latest secure versions.",
          "misconception": "Targets [update mechanism confusion]: SRI requires manual updates of hashes when resources change; it doesn't automate updates."
        },
        {
          "text": "It encrypts sensitive data transferred between the browser and the CDN.",
          "misconception": "Targets [confidentiality vs integrity confusion]: SRI ensures integrity, while HTTPS handles transport layer encryption for confidentiality."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The core benefit of SRI is preventing attacks where an attacker compromises a CDN or third-party host and injects malicious code into files like JavaScript libraries. By requiring a hash match, SRI ensures that only the originally intended, untampered code is executed by the browser, thus protecting the user and the website.",
        "distractor_analysis": "Distractors incorrectly associate SRI with availability, automatic updates, or data encryption, missing its primary function of preventing the execution of compromised code.",
        "analogy": "SRI is like a bouncer checking IDs at a club. The main goal is to keep out unauthorized individuals (malicious code) who might try to sneak in, even if they claim to be invited guests (external resources)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "APPSEC_BASICS",
        "WEBSEC_BASICS",
        "SRI_BASICS"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 17,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Inline Script Integrity 008_Application Security best practices",
    "latency_ms": 28014.063000000002
  },
  "timestamp": "2026-01-18T12:07:03.406038"
}