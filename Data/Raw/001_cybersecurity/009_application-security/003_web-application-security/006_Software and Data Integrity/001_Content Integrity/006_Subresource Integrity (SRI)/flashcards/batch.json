{
  "topic_title": "Subresource Integrity (SRI)",
  "category": "008_Application Security - Web 008_Application Security",
  "flashcards": [
    {
      "question_text": "What is the primary security goal of Subresource Integrity (SRI)?",
      "correct_answer": "To ensure that fetched resources (like scripts or stylesheets) have not been tampered with during transit or from the source.",
      "distractors": [
        {
          "text": "To encrypt all data transferred between the client and server.",
          "misconception": "Targets [scope confusion]: Confuses SRI with general encryption protocols like TLS/SSL."
        },
        {
          "text": "To prevent Cross-Site Scripting (XSS) attacks by sanitizing user input.",
          "misconception": "Targets [misapplication of defense]: Confuses SRI with input validation/sanitization techniques."
        },
        {
          "text": "To enforce Content Security Policy (CSP) directives for resource loading.",
          "misconception": "Targets [related but distinct control]: SRI is a complementary control, not the enforcement mechanism for CSP."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI works by providing a cryptographic hash that the browser verifies against the fetched resource. This ensures integrity because if the resource is altered, the hash will not match, preventing its execution.",
        "distractor_analysis": "The distractors incorrectly associate SRI with general encryption, XSS prevention, or CSP enforcement, rather than its specific function of verifying resource integrity.",
        "analogy": "SRI is like a tamper-evident seal on a package. If the seal is broken (the hash doesn't match), you know the contents might have been altered and you shouldn't accept the package."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "APPSEC_WEB_BASICS",
        "CRYPTO_HASHING"
      ]
    },
    {
      "question_text": "How does Subresource Integrity (SRI) protect against compromised Content Delivery Networks (CDNs)?",
      "correct_answer": "By requiring the browser to match a pre-defined cryptographic hash of the resource, preventing the loading of modified or malicious files served by a compromised CDN.",
      "distractors": [
        {
          "text": "By encrypting the communication channel with the CDN using TLS.",
          "misconception": "Targets [transport vs content integrity]: Confuses channel security (TLS) with content integrity (SRI)."
        },
        {
          "text": "By blocking all requests to external domains listed in a deny-list.",
          "misconception": "Targets [blocking mechanism confusion]: SRI doesn't block domains, it verifies specific resources from allowed domains."
        },
        {
          "text": "By forcing the CDN to use multi-factor authentication for file uploads.",
          "misconception": "Targets [source vs delivery integrity]: Focuses on CDN security practices rather than browser verification of delivered content."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI protects against compromised CDNs because the browser checks the integrity hash before executing the resource. If an attacker modifies files on the CDN, the hash mismatch will cause the browser to reject the resource, thus preventing malicious code execution.",
        "distractor_analysis": "Distractors incorrectly attribute SRI's function to TLS encryption, domain blocking, or CDN-side authentication, missing its core mechanism of client-side hash verification.",
        "analogy": "It's like having a specific fingerprint for a library book. If someone tries to swap the book with a different one, its fingerprint won't match the one you have on record, and you'll know it's not the correct book."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "analyze",
      "prerequisites": [
        "APPSEC_WEB_BASICS",
        "CDN_RISKS",
        "CRYPTO_HASHING"
      ]
    },
    {
      "question_text": "Which HTML attribute is used to specify the cryptographic hash for Subresource Integrity (SRI)?",
      "correct_answer": "integrity",
      "distractors": [
        {
          "text": "src",
          "misconception": "Targets [attribute confusion]: This attribute specifies the resource URL, not its integrity hash."
        },
        {
          "text": "crossorigin",
          "misconception": "Targets [related attribute confusion]: This attribute is related to CORS but does not specify the SRI hash."
        },
        {
          "text": "sha384",
          "misconception": "Targets [value vs attribute confusion]: This is a hash algorithm prefix, not the attribute name itself."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>integrity</code> attribute is specifically designed to hold the SRI hash value. Browsers use this attribute to compare the hash of the fetched resource against the expected value, ensuring content integrity.",
        "distractor_analysis": "Distractors represent common confusions: <code>src</code> for the URL, <code>crossorigin</code> for CORS settings, and <code>sha384</code> as a hash algorithm rather than the attribute holding the hash.",
        "analogy": "If you're asking someone to fetch a specific book from a library, the <code>src</code> attribute is like telling them *which* library and shelf to go to, while the <code>integrity</code> attribute is like giving them the book's ISBN to confirm they brought back the exact right edition."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "HTML_BASICS",
        "SRI_IMPLEMENTATION"
      ]
    },
    {
      "question_text": "What are the common cryptographic hash algorithms supported by Subresource Integrity (SRI)?",
      "correct_answer": "SHA-256, SHA-384, and SHA-512",
      "distractors": [
        {
          "text": "MD5, SHA-1, and SHA-256",
          "misconception": "Targets [outdated algorithms]: MD5 and SHA-1 are considered cryptographically weak and generally not recommended for SRI."
        },
        {
          "text": "SHA-3, BLAKE2b, and SHA-512",
          "misconception": "Targets [unsupported algorithms]: While strong, SHA-3 and BLAKE2b are not standardly supported by SRI implementations."
        },
        {
          "text": "AES, RSA, and DES",
          "misconception": "Targets [algorithm type confusion]: These are symmetric and asymmetric encryption algorithms, not hashing algorithms used for integrity checks."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI implementations commonly support SHA-256, SHA-384, and SHA-512 because these algorithms provide a good balance of security and performance for generating integrity hashes. Browsers are designed to recognize and process these specific algorithms.",
        "distractor_analysis": "Distractors include outdated (MD5, SHA-1), unsupported (SHA-3, BLAKE2b), or incorrect algorithm types (AES, RSA, DES), representing common misunderstandings about cryptographic standards.",
        "analogy": "Think of these hash algorithms like different types of locks. SRI supports specific, strong lock types (SHA-256, 384, 512) that are widely recognized and trusted for ensuring a package hasn't been opened."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_HASHING",
        "SRI_IMPLEMENTATION"
      ]
    },
    {
      "question_text": "When using SRI, what is the purpose of the <code>crossorigin</code> attribute on a script or link tag?",
      "correct_answer": "It enables Cross-Origin Resource Sharing (CORS) checks, allowing the browser to fetch resources from a different origin (domain) than the document itself, which is often required for CDNs.",
      "distractors": [
        {
          "text": "It specifies the origin from which the resource is being loaded.",
          "misconception": "Targets [attribute function confusion]: The `src` or `href` attribute specifies the origin, not `crossorigin`."
        },
        {
          "text": "It indicates that the resource should only be loaded over HTTPS.",
          "misconception": "Targets [security protocol confusion]: HTTPS is enforced by the URL scheme, not this attribute."
        },
        {
          "text": "It tells the browser to ignore SRI checks if the resource comes from a different origin.",
          "misconception": "Targets [opposite functionality]: `crossorigin` is necessary *for* SRI to work with external resources, not to bypass it."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>crossorigin</code> attribute is crucial because SRI verifies resources fetched from external origins (like CDNs). CORS headers must be correctly set by the resource server to allow the browser to fetch and verify the resource, enabling SRI to function correctly.",
        "distractor_analysis": "Distractors misinterpret <code>crossorigin</code> as specifying the origin, enforcing HTTPS, or disabling SRI, failing to grasp its role in enabling cross-origin resource fetching and verification.",
        "analogy": "Imagine you need a tool from a neighbor's shed (<code>crossorigin</code> resource). The <code>crossorigin</code> attribute is like asking your neighbor for permission to borrow it. Without permission (CORS headers), you can't get the tool, even if you know exactly which one it is (SRI hash)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CORS_BASICS",
        "SRI_IMPLEMENTATION",
        "APPSEC_WEB_BASICS"
      ]
    },
    {
      "question_text": "What is a potential drawback of implementing Subresource Integrity (SRI)?",
      "correct_answer": "If a legitimate update to a resource on a CDN changes its hash, the website using SRI will break until the integrity attribute is updated.",
      "distractors": [
        {
          "text": "SRI significantly slows down website loading times due to constant hashing.",
          "misconception": "Targets [performance exaggeration]: SRI verification is a one-time check per resource load and has minimal performance impact."
        },
        {
          "text": "SRI is incompatible with modern JavaScript frameworks.",
          "misconception": "Targets [compatibility myth]: SRI is compatible with all resources loaded via script/link tags, including frameworks."
        },
        {
          "text": "SRI requires all resources to be self-hosted, increasing server load.",
          "misconception": "Targets [misunderstanding of purpose]: SRI is specifically designed for external resources like those from CDNs."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Because SRI relies on exact hash matches, any legitimate update to a resource (e.g., a new version of a library) that changes its content will also change its hash. This mismatch will cause the browser to block the resource, breaking the site until the developer updates the <code>integrity</code> attribute.",
        "distractor_analysis": "Distractors incorrectly claim SRI causes significant slowdowns, framework incompatibility, or mandates self-hosting, ignoring its specific function and compatibility.",
        "analogy": "It's like having a specific serial number for a spare part. If the manufacturer legitimately updates the part and changes the serial number, your system won't accept the new part because the number doesn't match your records, even though it's a valid upgrade."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SRI_IMPLEMENTATION",
        "APPSEC_WEB_BASICS"
      ]
    },
    {
      "question_text": "Consider a scenario where a website includes a script from a third-party CDN. Which of the following SRI implementations provides the strongest protection against a compromised CDN serving malicious JavaScript?",
      "correct_answer": "Using a <code>sha512</code> hash in the <code>integrity</code> attribute, along with <code>crossorigin=&quot;anonymous&quot;</code>.",
      "distractors": [
        {
          "text": "Using a <code>sha256</code> hash in the <code>integrity</code> attribute without <code>crossorigin</code>.",
          "misconception": "Targets [weak hash/missing CORS]: SHA-256 is acceptable but weaker than SHA-512, and omitting `crossorigin` may prevent verification for external resources."
        },
        {
          "text": "Using only the <code>crossorigin=&quot;anonymous&quot;</code> attribute.",
          "misconception": "Targets [missing integrity check]: `crossorigin` enables CORS but does not verify the resource's content integrity."
        },
        {
          "text": "Embedding the script directly into the HTML file instead of using a CDN.",
          "misconception": "Targets [alternative but less secure approach]: While self-hosting avoids CDN compromise, it doesn't inherently guarantee integrity if the self-hosted file is compromised."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A stronger hash algorithm like SHA-512 provides a larger hash space, making collisions less likely. The <code>crossorigin=&quot;anonymous&quot;</code> attribute is essential for allowing the browser to fetch and verify resources from external origins, which is the primary use case for SRI with CDNs.",
        "distractor_analysis": "Distractors either use weaker hashes, omit necessary attributes (<code>crossorigin</code>), or suggest an alternative that doesn't inherently solve the integrity problem if the source itself is compromised.",
        "analogy": "You're hiring a security guard (SRI) to check packages (scripts) from a delivery service (CDN). Using a stronger verification method (SHA-512) and ensuring the guard has the proper credentials to accept packages from outside your building (crossorigin) provides the best security."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "SRI_IMPLEMENTATION",
        "APPSEC_WEB_BASICS",
        "CRYPTO_HASHING"
      ]
    },
    {
      "question_text": "Which of the following best describes the relationship between Content Security Policy (CSP) and Subresource Integrity (SRI)?",
      "correct_answer": "CSP defines *which* external resources are allowed to be loaded, while SRI verifies the *integrity* of those allowed resources.",
      "distractors": [
        {
          "text": "CSP enforces SRI by specifying the allowed hashes for resources.",
          "misconception": "Targets [control overlap confusion]: CSP directives control sources/types; SRI provides integrity hashes for specific resources."
        },
        {
          "text": "SRI is a type of CSP directive used to block malicious scripts.",
          "misconception": "Targets [categorization error]: SRI is a separate mechanism, not a CSP directive, though they work together."
        },
        {
          "text": "Both CSP and SRI are used to encrypt resources before they are served.",
          "misconception": "Targets [encryption vs integrity confusion]: Neither CSP nor SRI are primarily encryption mechanisms; SRI focuses on integrity."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CSP acts as a whitelist, controlling *what* resources (from which domains, of which types) a browser is permitted to load. SRI then provides a mechanism to verify that the *specific version* of an allowed resource has not been altered, adding a layer of content integrity on top of CSP's source control.",
        "distractor_analysis": "Distractors incorrectly merge their functions, suggesting CSP enforces SRI hashes, SRI is a CSP directive, or both are encryption methods, missing their distinct roles in web security.",
        "analogy": "CSP is like a bouncer at a club deciding *who* is allowed in (which domains/scripts). SRI is like checking the ID of each person *after* they're allowed in, ensuring they are who they claim to be and haven't been impersonated."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "CSP_BASICS",
        "SRI_IMPLEMENTATION"
      ]
    },
    {
      "question_text": "Why is it important to generate SRI hashes using a secure and reliable method, such as a trusted tool or command-line utility?",
      "correct_answer": "An attacker could potentially provide a tampered resource with a matching, but incorrect, hash if the generation process itself is compromised or weak.",
      "distractors": [
        {
          "text": "To ensure the hash algorithm is compatible with older browsers.",
          "misconception": "Targets [compatibility vs security focus]: Hash generation security is about preventing manipulation, not browser compatibility."
        },
        {
          "text": "To reduce the file size of the integrity attribute.",
          "misconception": "Targets [irrelevant goal]: Hash generation method doesn't significantly impact the size of the integrity attribute string."
        },
        {
          "text": "To automatically update the hash whenever the resource is updated.",
          "misconception": "Targets [automation misunderstanding]: Hash generation is a manual or scripted process tied to a specific resource version, not automatic updates."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The security of SRI hinges on the integrity of the hash itself. If an attacker can manipulate both the resource *and* the hash generation process to create a valid-looking but incorrect hash, the entire protection mechanism is undermined. Therefore, using trusted tools ensures the hash accurately reflects the intended resource.",
        "distractor_analysis": "Distractors focus on irrelevant aspects like browser compatibility, file size, or automatic updates, missing the critical security implication of ensuring the hash generation process itself is trustworthy.",
        "analogy": "If you're creating a unique code to verify a valuable item, you need to be sure the method you use to create that code is secure. If the code-creation method itself can be tricked, the code becomes useless for verification."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "evaluate",
      "prerequisites": [
        "SRI_IMPLEMENTATION",
        "CRYPTO_HASHING",
        "APPSEC_ATTACKS"
      ]
    },
    {
      "question_text": "What is the role of the <code>Access-Control-Allow-Origin</code> (CORS) header in relation to Subresource Integrity (SRI)?",
      "correct_answer": "It allows the browser to fetch resources from a different origin (e.g., a CDN) when SRI is enabled, ensuring the resource server permits cross-origin requests.",
      "distractors": [
        {
          "text": "It encrypts the resource before it is sent to the browser.",
          "misconception": "Targets [encryption vs access control confusion]: CORS deals with access permissions, not encryption."
        },
        {
          "text": "It specifies the SRI hash algorithm to be used.",
          "misconception": "Targets [header function confusion]: The `integrity` attribute specifies the algorithm, not CORS headers."
        },
        {
          "text": "It prevents the browser from loading resources if the SRI hash does not match.",
          "misconception": "Targets [mechanism confusion]: The browser's SRI implementation prevents loading on hash mismatch, not the CORS header itself."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When a resource is loaded from a different origin (like a CDN), the browser's security policies restrict access. The <code>Access-Control-Allow-Origin</code> header, set by the resource server, explicitly permits the requesting origin (your website) to access the resource, which is a prerequisite for the browser to even attempt the SRI hash check.",
        "distractor_analysis": "Distractors misrepresent CORS as an encryption mechanism, a hash specifier, or the direct enforcer of SRI hash mismatches, failing to recognize its role in enabling cross-origin fetches.",
        "analogy": "CORS is like a doorman at a building (CDN) checking your invitation (origin) before letting you in to pick up a package (resource). SRI is then checking the contents of that package once you have it. You need the doorman's permission first."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CORS_BASICS",
        "SRI_IMPLEMENTATION",
        "APPSEC_WEB_BASICS"
      ]
    },
    {
      "question_text": "Which of the following is NOT a typical use case for Subresource Integrity (SRI)?",
      "correct_answer": "Verifying the integrity of dynamically generated content served directly from the same origin server.",
      "distractors": [
        {
          "text": "Ensuring the integrity of JavaScript libraries loaded from a CDN.",
          "misconception": "Targets [common use case]: This is a primary and highly recommended use case for SRI."
        },
        {
          "text": "Validating the integrity of CSS stylesheets hosted on a third-party server.",
          "misconception": "Targets [common use case]: SRI applies to stylesheets as well as scripts from external sources."
        },
        {
          "text": "Protecting against man-in-the-middle attacks altering external resources.",
          "misconception": "Targets [attack mitigation]: This is a core security benefit SRI provides against specific attack vectors."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI's primary value lies in protecting against manipulation of resources fetched from *external* origins (like CDNs). Dynamically generated content served from the same origin is typically protected by other means (e.g., server-side security, TLS), and SRI doesn't add significant value or is not designed for this specific scenario.",
        "distractor_analysis": "Distractors describe common and valid use cases or benefits of SRI, making them incorrect answers to the 'NOT' question.",
        "analogy": "SRI is like checking the seal on a pre-packaged meal kit delivered to your door (external resource). It's not typically used to check the freshness of ingredients you picked yourself from your own garden (same-origin dynamic content)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SRI_IMPLEMENTATION",
        "APPSEC_WEB_BASICS"
      ]
    },
    {
      "question_text": "How can a developer generate the correct Subresource Integrity (SRI) hash for a resource?",
      "correct_answer": "By downloading the resource and using a command-line tool like <code>openssl dgst -sha384 -binary | openssl base64 -A</code> on the downloaded file.",
      "distractors": [
        {
          "text": "By asking the CDN provider for the hash value.",
          "misconception": "Targets [trust vs verification]: While providers may offer hashes, direct verification is more secure against compromised providers."
        },
        {
          "text": "By using a browser extension that automatically detects the hash.",
          "misconception": "Targets [tooling confusion]: Browser extensions might help, but direct generation ensures accuracy and control."
        },
        {
          "text": "By calculating the hash based on the file name and version number.",
          "misconception": "Targets [incorrect calculation method]: Hashes are cryptographic functions of file content, not metadata like name or version."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The most reliable method is to obtain the resource file yourself and use a cryptographic tool (like OpenSSL) to compute the hash of its exact content. This ensures the hash corresponds precisely to the version of the file you intend to use, bypassing potential trust issues with third-party hash lists.",
        "distractor_analysis": "Distractors suggest relying solely on the provider (risky), using potentially unreliable browser tools, or using incorrect methods based on metadata instead of content.",
        "analogy": "To verify a signature on a document, you wouldn't just trust someone who says 'it's signed'. You'd compare it directly to a known, genuine signature. Similarly, you compute the hash directly from the file content."
      },
      "code_snippets": [
        {
          "language": "text",
          "code": "<pre><code>openssl dgst -sha384 -binary | openssl base64 -A</code></pre>",
          "context": "explanation"
        }
      ],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "SRI_IMPLEMENTATION",
        "CRYPTO_HASHING",
        "COMMAND_LINE_TOOLS"
      ],
      "_code_snippets_html": "<div class=\"code-snippet code-explanation\">\n<span class=\"code-label\">Code Example</span>\n<pre><code class=\"language-text\">&lt;pre&gt;&lt;code&gt;openssl dgst -sha384 -binary | openssl base64 -A&lt;/code&gt;&lt;/pre&gt;</code></pre>\n</div>"
    },
    {
      "question_text": "What is the significance of the <code>anonymous</code> keyword in <code>crossorigin=&quot;anonymous&quot;</code> when used with SRI?",
      "correct_answer": "It indicates that the request to fetch the external resource should be made without sending credentials (like cookies or HTTP authentication), which is often required for SRI verification.",
      "distractors": [
        {
          "text": "It means the resource is available to anyone without authentication.",
          "misconception": "Targets [public access confusion]: It relates to request credentials, not general resource accessibility."
        },
        {
          "text": "It tells the browser to ignore SRI checks if the resource is anonymous.",
          "misconception": "Targets [opposite functionality]: It enables SRI checks for cross-origin resources, not bypasses them."
        },
        {
          "text": "It signifies that the resource itself does not contain user-identifiable information.",
          "misconception": "Targets [content vs request confusion]: It pertains to the request headers, not the content of the resource itself."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When fetching resources from a different origin, browsers often restrict requests that include credentials (like cookies) to prevent potential security issues. Setting <code>crossorigin=&quot;anonymous&quot;</code> signals that the request should be made without credentials, allowing the browser to proceed with fetching and verifying the SRI hash for external resources.",
        "distractor_analysis": "Distractors incorrectly interpret <code>anonymous</code> as relating to public access, bypassing SRI, or describing resource content, rather than its specific function concerning request credentials for cross-origin fetches.",
        "analogy": "It's like sending a package via a courier service without including your return address or personal contact details. This is often required by certain secure delivery protocols to ensure the package is handled purely based on its destination and contents, not the sender's identity."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CORS_BASICS",
        "SRI_IMPLEMENTATION"
      ]
    },
    {
      "question_text": "If a website uses SRI to load a JavaScript file from a CDN, and the CDN is updated with a new version of the file, what is the immediate consequence for the website?",
      "correct_answer": "The browser will refuse to load the new JavaScript file because its hash will not match the <code>integrity</code> attribute value, potentially breaking website functionality.",
      "distractors": [
        {
          "text": "The browser will automatically update the <code>integrity</code> attribute.",
          "misconception": "Targets [automation misunderstanding]: SRI requires manual updates to the integrity attribute."
        },
        {
          "text": "The browser will load the new file but issue a security warning.",
          "misconception": "Targets [warning vs blocking]: Browsers typically block the resource entirely on SRI mismatch, not just warn."
        },
        {
          "text": "The website will continue to function normally, as SRI only checks for malicious modifications, not updates.",
          "misconception": "Targets [misunderstanding of integrity]: SRI checks for *any* modification, including legitimate updates, against the specified hash."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI enforces strict integrity. Since a file update changes its content, its cryptographic hash will also change. The browser, comparing the new hash against the old one specified in the <code>integrity</code> attribute, will find a mismatch and block the resource, preventing the website from loading the updated script.",
        "distractor_analysis": "Distractors incorrectly assume automatic updates, mere warnings, or that SRI ignores legitimate updates, failing to grasp the strict nature of hash verification.",
        "analogy": "It's like a security checkpoint where you must present a specific ticket (hash). If you try to use a ticket for a different event (updated file), even if it's a valid ticket for *that* event, you'll be denied entry because it's not the *exact* ticket required."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "analyze",
      "prerequisites": [
        "SRI_IMPLEMENTATION",
        "APPSEC_WEB_BASICS"
      ]
    },
    {
      "question_text": "Which of the following statements accurately describes the security benefit of using multiple hashes within a single SRI <code>integrity</code> attribute?",
      "correct_answer": "It allows the resource to be loaded if it matches any of the provided hashes, offering flexibility if different versions or algorithms are used across environments.",
      "distractors": [
        {
          "text": "It increases the cryptographic strength by combining the hashes.",
          "misconception": "Targets [combination misunderstanding]: Multiple hashes don't combine strength; they offer alternative valid matches."
        },
        {
          "text": "It ensures that the resource is loaded only if all specified hashes match.",
          "misconception": "Targets [logical AND vs OR]: The browser loads if *any* hash matches (logical OR), not if all match (logical AND)."
        },
        {
          "text": "It is primarily used to specify different encryption algorithms.",
          "misconception": "Targets [algorithm type confusion]: SRI uses hashing algorithms for integrity, not encryption algorithms."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When multiple hashes (e.g., <code>sha256-hash1 sha384-hash2</code>) are provided, separated by whitespace, the browser attempts to match the fetched resource against each hash. If the resource's hash matches *any* of the provided hashes, it is considered valid and loaded. This provides flexibility, for instance, if a resource is available with different hash algorithms.",
        "distractor_analysis": "Distractors incorrectly suggest combined strength, require all hashes to match, or confuse hashing with encryption, missing the 'match any' logic and the purpose of using multiple hash types.",
        "analogy": "It's like having multiple keys (hashes) that can open the same lock (resource). If you have any one of the correct keys, you can open it. You don't need all of them simultaneously."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SRI_IMPLEMENTATION",
        "CRYPTO_HASHING"
      ]
    },
    {
      "question_text": "What is the primary risk addressed by Subresource Integrity (SRI) when loading external resources like JavaScript or CSS?",
      "correct_answer": "The risk that an attacker compromises the external resource host (e.g., CDN) and injects malicious code into the files, which would then be executed by users' browsers.",
      "distractors": [
        {
          "text": "The risk that the external resource is unavailable due to network issues.",
          "misconception": "Targets [availability vs integrity confusion]: SRI addresses integrity, not resource availability or network reliability."
        },
        {
          "text": "The risk that the external resource is not optimized for mobile devices.",
          "misconception": "Targets [performance vs security confusion]: SRI is a security control, unrelated to performance optimization or device compatibility."
        },
        {
          "text": "The risk that the external resource violates the website's branding guidelines.",
          "misconception": "Targets [compliance vs security confusion]: SRI is a security measure, not a tool for enforcing design or branding standards."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI directly combats the threat of content tampering. By verifying a cryptographic hash, it ensures that the resource loaded by the browser is identical to the one the developer intended. This prevents attackers from substituting malicious code for legitimate scripts or stylesheets hosted on external servers.",
        "distractor_analysis": "Distractors focus on availability, performance, or branding, which are outside the scope of SRI's security function, which is specifically about content integrity against tampering.",
        "analogy": "It's like receiving a sealed package. SRI ensures the seal is intact, proving no one has tampered with the contents during delivery. It doesn't guarantee the package is the right size or color, just that it hasn't been opened and altered."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "APPSEC_WEB_BASICS",
        "SRI_IMPLEMENTATION"
      ]
    },
    {
      "question_text": "Consider a scenario where a website developer wants to use SRI for a critical JavaScript library hosted on a CDN. What is the MOST secure approach for managing the SRI integrity hashes?",
      "correct_answer": "Regularly audit the integrity hashes against known-good sources and automate the update process for legitimate library version changes.",
      "distractors": [
        {
          "text": "Manually update the integrity hash every time a new library version is released by the CDN.",
          "misconception": "Targets [manual process inefficiency]: While manual updates are possible, they are error-prone and slow; automation is preferred for legitimate updates."
        },
        {
          "text": "Embed the JavaScript library directly into the HTML to avoid CDN risks entirely.",
          "misconception": "Targets [alternative solution misunderstanding]: Self-hosting avoids CDN compromise but doesn't inherently guarantee integrity if the self-hosted file is compromised."
        },
        {
          "text": "Use only SHA-256 hashes, as they are the fastest to generate and verify.",
          "misconception": "Targets [performance over security]: While faster, SHA-256 is cryptographically weaker than SHA-384/512, and security should be prioritized for critical libraries."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The most secure approach involves a combination of vigilance and automation. Regularly verifying hashes ensures they haven't been tampered with, and automating updates for legitimate version changes streamlines maintenance while minimizing the window where a site might break due to an outdated hash.",
        "distractor_analysis": "Distractors suggest inefficient manual processes, an alternative that bypasses SRI's CDN use case without guaranteeing integrity, or prioritizing speed over security for hash selection.",
        "analogy": "Managing SRI hashes is like managing security keys for a building. You need to ensure you have the correct keys (hashes), regularly check they haven't been copied or altered (audit), and update them promptly when legitimate lock changes occur (version updates)."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "scenario",
      "bloom_level": "create",
      "prerequisites": [
        "SRI_IMPLEMENTATION",
        "APPSEC_WEB_BASICS",
        "CRYPTO_HASHING"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 17,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Subresource Integrity (SRI) 008_Application Security best practices",
    "latency_ms": 29768.073
  },
  "timestamp": "2026-01-18T12:06:46.264862"
}