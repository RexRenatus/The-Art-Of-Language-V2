{
  "topic_title": "Dynamic Content Integrity",
  "category": "008_Application Security - Web 008_Application Security",
  "flashcards": [
    {
      "question_text": "What is the primary security goal of Subresource Integrity (SRI)?",
      "correct_answer": "To ensure that fetched resources (like scripts or stylesheets) have not been tampered with during transit or from the host server.",
      "distractors": [
        {
          "text": "To encrypt all dynamic content served to the client",
          "misconception": "Targets [encryption confusion]: Confuses integrity checking with data confidentiality."
        },
        {
          "text": "To validate the user's identity before serving content",
          "misconception": "Targets [authentication confusion]: Mixes content integrity with user authentication."
        },
        {
          "text": "To prevent cross-site scripting (XSS) attacks by sanitizing input",
          "misconception": "Targets [attack vector confusion]: Confuses integrity of external resources with input sanitization for XSS prevention."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI works by providing a cryptographic hash of a resource, which the browser verifies against the fetched resource. This ensures integrity because if the resource is altered, the hash will not match, preventing its execution.",
        "distractor_analysis": "The first distractor incorrectly suggests encryption, the second confuses integrity with authentication, and the third conflates external resource integrity with input sanitization for XSS.",
        "analogy": "SRI is like a tamper-evident seal on a package. If the seal is broken when you receive it, you know something might be wrong inside, and you shouldn't use the contents."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "WEB_SECURITY_BASICS",
        "CRYPTO_HASHING"
      ]
    },
    {
      "question_text": "How does Subresource Integrity (SRI) protect against compromised Content Delivery Networks (CDNs)?",
      "correct_answer": "By requiring the browser to verify a cryptographic hash of the resource against a known good hash before loading it.",
      "distractors": [
        {
          "text": "By enforcing HTTPS connections between the CDN and the browser",
          "misconception": "Targets [protocol confusion]: Confuses integrity checking with transport layer security."
        },
        {
          "text": "By instructing the browser to only load resources from the same origin",
          "misconception": "Targets [origin policy confusion]: Misunderstands SRI's purpose of allowing trusted external resources."
        },
        {
          "text": "By digitally signing all resources served by the CDN",
          "misconception": "Targets [signing vs hashing confusion]: Mixes digital signatures with integrity hashes."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI protects against CDN compromise because even if an attacker modifies files on the CDN, the browser will reject the resource if its calculated hash doesn't match the integrity attribute's value, thus preventing malicious code execution.",
        "distractor_analysis": "The first distractor conflates integrity with transport security (HTTPS). The second misunderstands SRI's allowance of cross-origin resources. The third incorrectly suggests digital signatures instead of cryptographic hashes.",
        "analogy": "Imagine a trusted librarian provides you with a specific edition of a book. SRI is like checking the ISBN and page count against the librarian's record; if it doesn't match, you know it's not the correct book."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "WEB_SECURITY_BASICS",
        "SRI_IMPLEMENTATION"
      ]
    },
    {
      "question_text": "Which attribute is used in HTML to specify the cryptographic hash for Subresource Integrity (SRI)?",
      "correct_answer": "<code>integrity</code>",
      "distractors": [
        {
          "text": "<code>hash</code>",
          "misconception": "Targets [attribute name confusion]: Uses a generic term instead of the specific HTML attribute."
        },
        {
          "text": "<code>sri-hash</code>",
          "misconception": "Targets [attribute naming convention]: Invents a prefix based on the technology name."
        },
        {
          "text": "<code>checksum</code>",
          "misconception": "Targets [terminology confusion]: Uses a related but incorrect term for the attribute."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>integrity</code> attribute is crucial for SRI because it holds the base64-encoded cryptographic hash (e.g., sha384-...) that the browser compares against the fetched resource. This comparison ensures the resource's integrity.",
        "distractor_analysis": "The distractors propose incorrect attribute names: 'hash' is too generic, 'sri-hash' is a plausible but incorrect invention, and 'checksum' is a related concept but not the correct HTML attribute.",
        "analogy": "In a recipe, the <code>integrity</code> attribute is like the specific measurement for an ingredient (e.g., '2 cups of flour'). If you use a different amount, the recipe might not turn out right."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "HTML_BASICS",
        "SRI_IMPLEMENTATION"
      ]
    },
    {
      "question_text": "What are the common cryptographic hash algorithms supported by Subresource Integrity (SRI)?",
      "correct_answer": "SHA-256, SHA-384, and SHA-512",
      "distractors": [
        {
          "text": "MD5, SHA-1, and SHA-256",
          "misconception": "Targets [outdated algorithm confusion]: Includes deprecated algorithms like MD5 and SHA-1."
        },
        {
          "text": "SHA-3, SHA-256, and SHA-512",
          "misconception": "Targets [algorithm set confusion]: Includes SHA-3 which is not currently a primary SRI standard."
        },
        {
          "text": "AES, RSA, and SHA-256",
          "misconception": "Targets [algorithm type confusion]: Mixes symmetric/asymmetric encryption algorithms with hashing algorithms."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI supports SHA-256, SHA-384, and SHA-512 because these algorithms provide sufficient cryptographic strength for integrity checking, unlike older or weaker algorithms like MD5 or SHA-1, which are vulnerable to collisions.",
        "distractor_analysis": "The first distractor includes insecure algorithms. The second incorrectly includes SHA-3 as a primary SRI algorithm. The third mixes encryption algorithms (AES, RSA) with hashing algorithms.",
        "analogy": "When you're asked to identify a specific book, you might use its ISBN (like SHA-256), publisher code (like SHA-384), or a unique identifier (like SHA-512). You wouldn't use an outdated or incorrect identifier."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_HASHING",
        "SRI_IMPLEMENTATION"
      ]
    },
    {
      "question_text": "What is the purpose of the <code>crossorigin=&quot;anonymous&quot;</code> attribute when using Subresource Integrity (SRI)?",
      "correct_answer": "It ensures that the browser sends a request for the resource with CORS headers, allowing it to be loaded from a different origin without exposing sensitive information.",
      "distractors": [
        {
          "text": "It encrypts the resource before it is fetched from the external server",
          "misconception": "Targets [encryption confusion]: Misunderstands the role of CORS in relation to encryption."
        },
        {
          "text": "It forces the browser to use a secure connection (HTTPS) for the resource",
          "misconception": "Targets [protocol confusion]: Confuses CORS with transport layer security requirements."
        },
        {
          "text": "It prevents the browser from caching the resource",
          "misconception": "Targets [caching confusion]: Mixes CORS with caching behavior."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>crossorigin=&quot;anonymous&quot;</code> attribute is necessary for SRI when loading resources from a different origin because it enables Cross-Origin Resource Sharing (CORS) checks, allowing the browser to fetch and verify the resource without violating same-origin policies.",
        "distractor_analysis": "The first distractor incorrectly associates CORS with encryption. The second confuses CORS with HTTPS enforcement. The third incorrectly links CORS to browser caching behavior.",
        "analogy": "Imagine you're asking a neighbor (different origin) for a tool. <code>crossorigin=&quot;anonymous&quot;</code> is like telling the neighbor it's okay to lend you the tool, and you'll use it appropriately, without them needing to know your personal details."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SRI_IMPLEMENTATION",
        "CORS_BASICS"
      ]
    },
    {
      "question_text": "What is a potential drawback of implementing Subresource Integrity (SRI)?",
      "correct_answer": "If a resource is updated by its provider (e.g., a CDN), the SRI hash must be updated on the website, or the resource will fail to load.",
      "distractors": [
        {
          "text": "It significantly increases server load by requiring re-encryption of all resources",
          "misconception": "Targets [performance confusion]: Overestimates the performance impact and misunderstands SRI's client-side verification."
        },
        {
          "text": "It prevents the use of any JavaScript libraries hosted on external domains",
          "misconception": "Targets [scope confusion]: Incorrectly assumes SRI prohibits all external resources, rather than ensuring their integrity."
        },
        {
          "text": "It requires the website owner to host all resources locally",
          "misconception": "Targets [implementation confusion]: Misunderstands that SRI is designed to secure external resources, not mandate local hosting."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI requires diligent maintenance because when a third-party resource is updated, its hash changes. The website's <code>integrity</code> attribute must be updated accordingly; otherwise, the browser will reject the new version because its hash won't match the old one.",
        "distractor_analysis": "The first distractor exaggerates performance impact and misunderstands SRI's client-side nature. The second incorrectly states SRI prevents external JS. The third wrongly suggests SRI mandates local hosting.",
        "analogy": "If you have a specific key to open a lock, and the lock's mechanism is changed, your old key won't work anymore. You need a new key (updated hash) for the new lock (updated resource)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SRI_IMPLEMENTATION",
        "WEB_SECURITY_BEST_PRACTICES"
      ]
    },
    {
      "question_text": "Which web security standard or framework is most directly related to ensuring the integrity of externally hosted web resources?",
      "correct_answer": "Subresource Integrity (SRI)",
      "distractors": [
        {
          "text": "Content Security Policy (CSP)",
          "misconception": "Targets [policy confusion]: CSP controls *what* resources can be loaded, not necessarily their integrity once loaded."
        },
        {
          "text": "HTTP Strict Transport Security (HSTS)",
          "misconception": "Targets [protocol confusion]: HSTS enforces secure (HTTPS) connections, not resource integrity."
        },
        {
          "text": "Cross-Origin Resource Sharing (CORS)",
          "misconception": "Targets [access control confusion]: CORS governs *if* a resource can be shared across origins, not its integrity."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI directly addresses dynamic content integrity by using cryptographic hashes to verify that fetched resources from any origin (including CDNs) have not been altered, thus complementing policies like CSP and transport security like HSTS.",
        "distractor_analysis": "CSP controls resource loading policies, HSTS enforces secure transport, and CORS manages cross-origin access. SRI is the specific mechanism for verifying the integrity of the content itself.",
        "analogy": "Imagine a security guard (SRI) checking IDs (hashes) of people entering a building (your webpage) from different groups (external origins). CSP might dictate which groups are allowed in, HSTS ensures they arrive safely, and CORS allows them to enter from specific groups."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "WEB_SECURITY_BASICS",
        "SRI_IMPLEMENTATION",
        "CSP_BASICS",
        "CORS_BASICS"
      ]
    },
    {
      "question_text": "Consider a scenario where a website includes a JavaScript file from a CDN. If an attacker compromises the CDN and injects malicious code into the JavaScript file, how does SRI prevent this malicious code from executing?",
      "correct_answer": "The browser calculates the hash of the fetched JavaScript file and compares it to the hash specified in the <code>integrity</code> attribute. If they don't match, the browser refuses to execute the script.",
      "distractors": [
        {
          "text": "The browser automatically sanitizes the JavaScript code before execution",
          "misconception": "Targets [sanitization confusion]: Confuses SRI's integrity check with input/output sanitization."
        },
        {
          "text": "The browser alerts the user that the CDN might be compromised",
          "misconception": "Targets [alerting confusion]: SRI's action is to block execution, not necessarily to alert the user directly about the CDN."
        },
        {
          "text": "The browser requests the JavaScript file again from a different source",
          "misconception": "Targets [fallback confusion]: SRI's mechanism is to block, not to retry from another source."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI's core function is to prevent execution of tampered resources. By comparing the fetched resource's hash against the expected hash, the browser acts as a verifier, ensuring that only unmodified, trusted code is run, thus mitigating attacks via compromised third-party hosts.",
        "distractor_analysis": "The first distractor suggests code sanitization, which is a different security mechanism. The second incorrectly states SRI's primary action is user alerting. The third proposes a fallback mechanism that SRI does not implement.",
        "analogy": "It's like a bouncer at a club checking everyone's pre-approved guest list (SRI hash). If someone's name isn't on the list (hash mismatch), they are denied entry (script not executed), regardless of how they look or claim to be."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "SRI_IMPLEMENTATION",
        "WEB_ATTACKS_XSS"
      ]
    },
    {
      "question_text": "Which of the following is NOT a direct benefit of implementing Subresource Integrity (SRI)?",
      "correct_answer": "Protection against vulnerabilities within the website's own backend code.",
      "distractors": [
        {
          "text": "Mitigation of risks from compromised third-party scripts",
          "misconception": "Targets [scope confusion]: This IS a direct benefit of SRI."
        },
        {
          "text": "Prevention of malicious code injection via CDNs",
          "misconception": "Targets [attack vector confusion]: This IS a direct benefit of SRI."
        },
        {
          "text": "Ensuring that loaded resources match the developer's intended versions",
          "misconception": "Targets [intent confusion]: This IS a direct benefit of SRI."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI specifically protects the integrity of *fetched* resources, primarily from external sources like CDNs. It does not inspect or protect against vulnerabilities within the website's own server-side code or internally hosted client-side code.",
        "distractor_analysis": "The distractors describe core benefits of SRI: protecting against compromised third parties, preventing CDN injection, and ensuring resource versions. The correct answer highlights what SRI *does not* cover.",
        "analogy": "SRI is like a security guard checking the authenticity of imported goods at the border. It doesn't inspect the manufacturing process of domestically produced goods."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SRI_IMPLEMENTATION",
        "WEB_SECURITY_PRINCIPLES"
      ]
    },
    {
      "question_text": "What is the relationship between Subresource Integrity (SRI) and Content Security Policy (CSP)?",
      "correct_answer": "SRI verifies the integrity of specific resources, while CSP defines which resources are allowed to be loaded in the first place.",
      "distractors": [
        {
          "text": "CSP enforces SRI by requiring all loaded resources to have integrity hashes",
          "misconception": "Targets [policy enforcement confusion]: CSP does not enforce SRI; they are complementary."
        },
        {
          "text": "SRI is a type of CSP directive used to specify allowed resource hashes",
          "misconception": "Targets [categorization confusion]: SRI is a separate mechanism, not a CSP directive type."
        },
        {
          "text": "They are redundant and serve the same purpose of preventing external resource loading",
          "misconception": "Targets [redundancy confusion]: They address different aspects of resource security."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CSP acts as a whitelist, controlling *what* resources can be loaded from which origins, thereby preventing unauthorized scripts. SRI then acts as a verification step for *allowed* resources, ensuring their integrity once fetched, providing defense-in-depth.",
        "distractor_analysis": "The first distractor incorrectly states CSP enforces SRI. The second miscategorizes SRI as a CSP directive. The third wrongly claims they are redundant and serve the same purpose.",
        "analogy": "CSP is like a guest list for a party, deciding who is allowed in. SRI is like checking the ID of each guest on the list to ensure they are who they claim to be and haven't been replaced."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "SRI_IMPLEMENTATION",
        "CSP_BASICS"
      ]
    },
    {
      "question_text": "When generating an SRI integrity hash, which of the following is a common practice regarding the choice of hash algorithm?",
      "correct_answer": "Use SHA-384 or SHA-512 for stronger security guarantees, as they are more resistant to collision attacks than SHA-256.",
      "distractors": [
        {
          "text": "Always use SHA-256 as it is the fastest and sufficient for most web applications",
          "misconception": "Targets [performance vs security trade-off]: Prioritizes speed over optimal security for integrity."
        },
        {
          "text": "Prefer MD5 or SHA-1 for compatibility with older browsers",
          "misconception": "Targets [outdated algorithm preference]: Recommends insecure algorithms for compatibility."
        },
        {
          "text": "Use a custom, proprietary hashing algorithm for enhanced security",
          "misconception": "Targets [security through obscurity]: Relies on non-standard algorithms which are often weaker and lack broad support/auditing."
        }
      ],
      "detailed_explanation": {
        "core_logic": "While SHA-256 is widely supported, SHA-384 and SHA-512 offer greater security margins against collision attacks, making them preferable for integrity checks, especially for critical resources. Older algorithms like MD5 and SHA-1 are cryptographically broken and must be avoided.",
        "distractor_analysis": "The first distractor prioritizes speed over security. The second recommends deprecated and insecure algorithms. The third suggests a non-standard approach that undermines security.",
        "analogy": "When choosing a lock for your house, you could use a basic padlock (SHA-256), a strong deadbolt (SHA-384), or a high-security vault lock (SHA-512). Using an old, easily picked lock (MD5) is not advisable."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "CRYPTO_HASHING",
        "SRI_IMPLEMENTATION"
      ]
    },
    {
      "question_text": "What is the primary mechanism by which Subresource Integrity (SRI) ensures that a fetched resource is trustworthy?",
      "correct_answer": "By comparing a cryptographic hash of the fetched resource against a pre-defined, trusted hash value.",
      "distractors": [
        {
          "text": "By verifying the digital signature of the resource's origin server",
          "misconception": "Targets [signature vs hash confusion]: Confuses integrity checking with authentication of the source."
        },
        {
          "text": "By analyzing the resource's content for known malicious patterns",
          "misconception": "Targets [content analysis confusion]: SRI does not inspect content; it verifies the entire file's integrity."
        },
        {
          "text": "By checking if the resource is served over a secure HTTPS connection",
          "misconception": "Targets [transport vs content confusion]: HTTPS ensures secure transit, but SRI ensures the content itself hasn't changed."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI functions by leveraging cryptographic hashes. The browser calculates a hash of the downloaded resource and compares it to the hash provided in the <code>integrity</code> attribute. A match confirms the resource has not been altered since the hash was generated, thus ensuring its integrity.",
        "distractor_analysis": "The first distractor confuses integrity hashes with digital signatures. The second suggests content analysis, which SRI does not perform. The third conflates transport security (HTTPS) with content integrity.",
        "analogy": "It's like checking if a downloaded file's checksum matches the one provided by the software vendor. If the checksums match, the file is likely intact; if not, it may be corrupted or tampered with."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_HASHING",
        "SRI_IMPLEMENTATION"
      ]
    },
    {
      "question_text": "In the context of dynamic content integrity, what is the main risk associated with loading JavaScript libraries from a Content Delivery Network (CDN)?",
      "correct_answer": "The CDN could be compromised, leading to the distribution of malicious JavaScript code to all websites using that library.",
      "distractors": [
        {
          "text": "The JavaScript library might be outdated and contain security vulnerabilities",
          "misconception": "Targets [outdated code vs compromised code confusion]: While outdated code is a risk, SRI specifically addresses *tampering* of current code."
        },
        {
          "text": "The CDN might block legitimate users from accessing the JavaScript file",
          "misconception": "Targets [availability vs integrity confusion]: This relates to availability, not the integrity of the content served."
        },
        {
          "text": "The JavaScript code might violate the website's Content Security Policy (CSP)",
          "misconception": "Targets [policy violation vs integrity confusion]: CSP governs *what* can load; SRI verifies *if* it's been tampered with."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CDNs are attractive targets because compromising one can allow attackers to inject malicious code into widely used libraries, affecting numerous websites. SRI directly counters this by ensuring the integrity of the code fetched from the CDN, preventing the execution of tampered versions.",
        "distractor_analysis": "The first distractor focuses on inherent vulnerabilities, not malicious modification. The second addresses availability, not integrity. The third confuses CSP violations with integrity breaches.",
        "analogy": "Imagine a popular bakery supplying bread to many restaurants. If the bakery's ingredients are secretly poisoned, all restaurants using that bread are affected. SRI is like each restaurant checking the bread's ingredients against a trusted recipe before serving it."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "WEB_ATTACKS_MALWARE_INJECTION",
        "SRI_IMPLEMENTATION"
      ]
    },
    {
      "question_text": "Which of the following best describes the role of cryptographic hashes in Subresource Integrity (SRI)?",
      "correct_answer": "They act as unique fingerprints for files, allowing browsers to detect any modification to the original file.",
      "distractors": [
        {
          "text": "They encrypt the file content to protect it from eavesdropping",
          "misconception": "Targets [encryption vs hashing confusion]: Hashes are not encryption; they are one-way functions."
        },
        {
          "text": "They digitally sign the file to authenticate the source",
          "misconception": "Targets [signing vs hashing confusion]: Digital signatures authenticate the source; hashes verify integrity."
        },
        {
          "text": "They compress the file to reduce bandwidth usage",
          "misconception": "Targets [compression confusion]: Hashing does not compress files."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Cryptographic hashes are fundamental to SRI because they provide a fixed-size, unique representation of a file's content. Since even a minor change to the file drastically alters its hash, browsers can reliably detect tampering by comparing the fetched file's hash to the expected one.",
        "distractor_analysis": "The first distractor incorrectly equates hashing with encryption. The second confuses hashing with digital signatures, which provide authentication. The third wrongly suggests hashing is a form of compression.",
        "analogy": "A hash is like a unique fingerprint for a document. If the document is altered even slightly, its fingerprint changes, making it easy to spot that it's not the original."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_HASHING",
        "SRI_IMPLEMENTATION"
      ]
    },
    {
      "question_text": "When implementing SRI, what is the recommended approach for obtaining the integrity hash for a resource?",
      "correct_answer": "Generate the hash from a trusted, known-good version of the resource file locally, or obtain it from the resource provider's official documentation.",
      "distractors": [
        {
          "text": "Calculate the hash directly from the resource as it is served by the CDN in real-time",
          "misconception": "Targets [real-time calculation confusion]: SRI requires a pre-calculated, trusted hash, not a live calculation."
        },
        {
          "text": "Use a generic hash value provided by a security forum",
          "misconception": "Targets [unverified source confusion]: Relying on unverified sources for hashes is insecure."
        },
        {
          "text": "Ask the CDN administrator to provide the hash dynamically upon request",
          "misconception": "Targets [dynamic hash confusion]: SRI hashes are static values embedded in the HTML, not dynamically provided."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The integrity of SRI relies on having a trusted, pre-determined hash. Generating this hash from a known-good local copy or obtaining it from official, reliable sources ensures that the hash value accurately represents the intended, untampered resource.",
        "distractor_analysis": "The first distractor suggests a real-time calculation which defeats the purpose of pre-verification. The second relies on untrusted sources. The third proposes a dynamic mechanism contrary to SRI's static attribute-based approach.",
        "analogy": "If you're buying a rare collectible, you'd get its certificate of authenticity (the hash) from the reputable dealer (provider) or verify it against your own trusted reference, not ask the seller to generate a new certificate on the spot."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "SRI_IMPLEMENTATION",
        "WEB_SECURITY_BEST_PRACTICES"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Dynamic Content Integrity 008_Application Security best practices",
    "latency_ms": 25142.398
  },
  "timestamp": "2026-01-18T12:06:44.850608"
}