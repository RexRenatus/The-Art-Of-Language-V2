{
  "topic_title": "External Resource Integrity",
  "category": "008_Application Security - Web 008_Application Security",
  "flashcards": [
    {
      "question_text": "What is the primary security goal of Subresource Integrity (SRI)?",
      "correct_answer": "To ensure that fetched resources (like scripts or stylesheets) have not been tampered with during transit or from the source.",
      "distractors": [
        {
          "text": "To encrypt all external resources to prevent eavesdropping.",
          "misconception": "Targets [confidentiality vs integrity confusion]: Confuses integrity checking with data encryption."
        },
        {
          "text": "To enforce Cross-Origin Resource Sharing (CORS) policies for all external assets.",
          "misconception": "Targets [scope confusion]: Misunderstands SRI's role as a security check, not a policy enforcement mechanism like CORS."
        },
        {
          "text": "To optimize the loading speed of external resources from Content Delivery Networks (CDNs).",
          "misconception": "Targets [performance vs security confusion]: Attributes a performance benefit to a security feature."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI works by comparing a cryptographic hash of the fetched resource against a known, trusted hash provided by the developer. This ensures integrity because if the resource is altered, the hashes will not match, preventing the browser from loading the compromised file.",
        "distractor_analysis": "The first distractor confuses integrity with confidentiality. The second misattributes CORS enforcement to SRI. The third incorrectly links SRI to performance optimization rather than its core security function.",
        "analogy": "SRI is like a tamper-evident seal on a package. If the seal is broken (hash doesn't match), you know the contents might have been altered and you shouldn't accept the package."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "APPSEC_WEB_BASICS",
        "CRYPTO_HASHING"
      ]
    },
    {
      "question_text": "How does Subresource Integrity (SRI) achieve its security goal?",
      "correct_answer": "By requiring the browser to compare a cryptographic hash of the fetched resource against a hash specified in the <code>integrity</code> attribute.",
      "distractors": [
        {
          "text": "By encrypting the resource using a key shared between the server and the browser.",
          "misconception": "Targets [encryption vs hashing confusion]: Incorrectly assumes SRI uses encryption for integrity checks."
        },
        {
          "text": "By verifying the digital signature of the resource provider.",
          "misconception": "Targets [signature vs hash confusion]: Confuses SRI's hash-based verification with digital signature verification."
        },
        {
          "text": "By checking the resource's file permissions on the external server.",
          "misconception": "Targets [access control vs integrity confusion]: Misunderstands that SRI verifies content, not server-side permissions."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI functions by embedding a cryptographic hash (e.g., SHA-384) within the HTML tag for an external resource. The browser calculates the hash of the downloaded resource and compares it to the provided hash. If they match, the resource is trusted; otherwise, it's blocked, thus ensuring content integrity.",
        "distractor_analysis": "The distractors incorrectly suggest encryption, digital signatures, or file permissions as the mechanism, rather than the core concept of hash comparison for integrity.",
        "analogy": "It's like checking the unique serial number on a product against the one listed on its warranty card. If they match, you're sure it's the genuine product."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "APPSEC_WEB_SRI_IMPLEMENTATION",
        "CRYPTO_HASHING"
      ]
    },
    {
      "question_text": "Which HTML attribute is used to specify the cryptographic hash for Subresource Integrity (SRI)?",
      "correct_answer": "<code>integrity</code>",
      "distractors": [
        {
          "text": "<code>sri-hash</code>",
          "misconception": "Targets [attribute naming confusion]: Invents a plausible but incorrect attribute name."
        },
        {
          "text": "<code>checksum</code>",
          "misconception": "Targets [terminology confusion]: Uses a related but not standard HTML attribute name for SRI."
        },
        {
          "text": "<code>resource-verify</code>",
          "misconception": "Targets [attribute naming confusion]: Creates a descriptive but non-existent attribute."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>integrity</code> attribute is the standard HTML mechanism for providing the cryptographic hash value that browsers use to verify the integrity of external resources. This attribute works in conjunction with the <code>src</code> or <code>href</code> attribute to ensure the loaded content matches the expected hash.",
        "distractor_analysis": "The distractors propose incorrect attribute names, testing whether the student knows the specific HTML attribute used for SRI.",
        "analogy": "The <code>integrity</code> attribute is like the label on a medicine bottle that lists the exact chemical formula. If the medicine inside doesn't match the formula, it's not the right one."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "APPSEC_WEB_SRI_IMPLEMENTATION"
      ]
    },
    {
      "question_text": "When using Subresource Integrity (SRI), what is the purpose of the <code>crossorigin</code> attribute?",
      "correct_answer": "To ensure that the browser performs CORS checks when fetching resources from a different origin, which is a prerequisite for SRI verification.",
      "distractors": [
        {
          "text": "To specify the encryption algorithm used for the resource.",
          "misconception": "Targets [attribute function confusion]: Confuses `crossorigin` with encryption-related attributes."
        },
        {
          "text": "To indicate that the resource is hosted on a Content Delivery Network (CDN).",
          "misconception": "Targets [attribute purpose confusion]: Misunderstands `crossorigin`'s role in security protocols, not just hosting location."
        },
        {
          "text": "To allow the browser to bypass SRI checks if the resource is from a trusted domain.",
          "misconception": "Targets [security bypass confusion]: Incorrectly suggests `crossorigin` weakens security checks."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>crossorigin</code> attribute, when set to <code>anonymous</code> or <code>use-credentials</code>, is required for SRI to function correctly with cross-origin resources. It enables the browser to perform necessary CORS checks, which are a prerequisite for SRI to verify the integrity of resources fetched from a different domain, thereby ensuring the resource can be safely shared.",
        "distractor_analysis": "The distractors incorrectly associate <code>crossorigin</code> with encryption, CDN identification, or bypassing security checks, rather than its role in enabling CORS for cross-origin SRI.",
        "analogy": "The <code>crossorigin</code> attribute is like a security guard checking your ID before you enter a building from a different neighborhood. It ensures the proper protocols are followed before allowing access, which is necessary for the integrity check (SRI) to be meaningful."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "APPSEC_WEB_SRI_IMPLEMENTATION",
        "WEB_CORS"
      ]
    },
    {
      "question_text": "What are the common cryptographic hash algorithms supported by Subresource Integrity (SRI)?",
      "correct_answer": "SHA-256, SHA-384, and SHA-512",
      "distractors": [
        {
          "text": "MD5, SHA-1, and SHA-256",
          "misconception": "Targets [outdated algorithms confusion]: Includes deprecated or weaker hashing algorithms not recommended for SRI."
        },
        {
          "text": "SHA-3, SHA-256, and AES-256",
          "misconception": "Targets [algorithm type confusion]: Mixes hashing algorithms with a symmetric encryption algorithm."
        },
        {
          "text": "SHA-512, RSA-2048, and SHA-384",
          "misconception": "Targets [algorithm type confusion]: Includes an asymmetric encryption algorithm alongside hashing algorithms."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI supports modern, cryptographically strong hash functions like SHA-256, SHA-384, and SHA-512. These algorithms are chosen because they are collision-resistant and suitable for integrity checking, unlike older or encryption-specific algorithms.",
        "distractor_analysis": "The distractors include outdated (MD5, SHA-1) or incorrect algorithm types (AES, RSA), testing knowledge of SRI's specific supported hashing standards.",
        "analogy": "Think of these algorithms as different types of 'fingerprint' generators. SRI uses robust, modern fingerprinting methods (SHA-256, SHA-384, SHA-512) to ensure the file's identity hasn't changed."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "APPSEC_WEB_SRI_IMPLEMENTATION",
        "CRYPTO_HASHING_STANDARDS"
      ]
    },
    {
      "question_text": "Why is it important to use SRI when loading JavaScript from a Content Delivery Network (CDN)?",
      "correct_answer": "To protect against a compromised CDN that might serve malicious JavaScript, which could then compromise the entire website.",
      "distractors": [
        {
          "text": "To ensure the CDN uses the latest version of the JavaScript library.",
          "misconception": "Targets [version control vs integrity confusion]: Confuses SRI's integrity check with version management."
        },
        {
          "text": "To improve the CDN's availability and reduce downtime.",
          "misconception": "Targets [performance vs security confusion]: Attributes availability benefits to a security feature."
        },
        {
          "text": "To comply with GDPR regulations regarding third-party data handling.",
          "misconception": "Targets [regulatory confusion]: Misapplies data privacy regulations to content integrity."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CDNs are attractive targets for attackers. If a CDN is compromised, malicious code can be injected into hosted files. SRI prevents this by ensuring the browser only loads the JavaScript if its hash matches the one specified, thereby protecting the website from attacks originating from a compromised CDN.",
        "distractor_analysis": "The distractors incorrectly link SRI to version control, CDN availability, or GDPR compliance, diverting from its primary function of preventing malicious code injection via compromised external resources.",
        "analogy": "Using SRI with a CDN is like hiring a security guard to check every delivery truck entering your premises. Even if the truck looks official, the guard verifies its contents against a manifest to ensure nothing dangerous is being brought in."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "analyze",
      "prerequisites": [
        "APPSEC_WEB_SRI_IMPLEMENTATION",
        "APPSEC_WEB_ATTACKS"
      ]
    },
    {
      "question_text": "What happens if a fetched resource's calculated hash does not match the hash specified in the <code>integrity</code> attribute?",
      "correct_answer": "The browser will refuse to load the resource and will typically log a console error.",
      "distractors": [
        {
          "text": "The browser will load the resource but flag it as potentially unsafe.",
          "misconception": "Targets [browser behavior confusion]: Assumes a warning instead of a block for integrity failures."
        },
        {
          "text": "The browser will attempt to fetch the resource from an alternative source.",
          "misconception": "Targets [fallback mechanism confusion]: Invents a fallback behavior not part of SRI."
        },
        {
          "text": "The browser will ignore the <code>integrity</code> attribute and load the resource anyway.",
          "misconception": "Targets [attribute enforcement confusion]: Assumes the integrity check can be bypassed."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When the hash mismatch occurs, the browser's security mechanism, as defined by SRI, blocks the resource from loading to prevent potential execution of malicious code. This is a critical defense mechanism, hence the strict blocking behavior rather than a warning or fallback.",
        "distractor_analysis": "The distractors suggest a warning, an alternative fetch, or ignoring the attribute, all of which contradict the strict security enforcement of SRI when an integrity check fails.",
        "analogy": "If the tamper-evident seal on a package is broken, the delivery person refuses to hand it over. They don't just give it to you with a warning; they reject it outright to prevent potential harm."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "APPSEC_WEB_SRI_IMPLEMENTATION"
      ]
    },
    {
      "question_text": "Which of the following is a potential drawback of using Subresource Integrity (SRI)?",
      "correct_answer": "Updating an external resource (e.g., a library) requires updating the <code>integrity</code> hash in the HTML, which can be cumbersome.",
      "distractors": [
        {
          "text": "SRI significantly slows down website loading times.",
          "misconception": "Targets [performance impact confusion]: Overstates the performance impact of SRI."
        },
        {
          "text": "SRI is not compatible with HTTPS connections.",
          "misconception": "Targets [compatibility confusion]: Incorrectly claims incompatibility with secure connections."
        },
        {
          "text": "SRI only works for JavaScript files, not CSS or other resources.",
          "misconception": "Targets [resource type limitation confusion]: Incorrectly limits SRI's applicability."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Because SRI relies on exact hash matches, any update to an external resource, even a minor one, necessitates recalculating and updating the hash in the <code>integrity</code> attribute. This maintenance overhead is a known drawback, requiring careful management of external dependencies.",
        "distractor_analysis": "The distractors present false drawbacks: SRI's performance impact is minimal, it's designed for HTTPS, and it applies to various resource types, not just JavaScript.",
        "analogy": "Imagine you have a specific key for your house. If you change the lock (update the resource), you need a new key (new hash) to match. Forgetting to get the new key means you can't get in (resource won't load)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "evaluate",
      "prerequisites": [
        "APPSEC_WEB_SRI_IMPLEMENTATION",
        "APPSEC_WEB_MAINTENANCE"
      ]
    },
    {
      "question_text": "How can developers generate the correct cryptographic hash for the <code>integrity</code> attribute?",
      "correct_answer": "By using command-line tools like <code>openssl</code> or online SRI hash generator tools after downloading the resource.",
      "distractors": [
        {
          "text": "By asking the CDN provider for the hash directly.",
          "misconception": "Targets [trust model confusion]: Relies solely on the CDN provider, which SRI aims to partially mitigate."
        },
        {
          "text": "By using a browser's developer console to inspect the resource.",
          "misconception": "Targets [tooling confusion]: Assumes browsers provide a direct SRI hash generation feature."
        },
        {
          "text": "By using a simple file size check.",
          "misconception": "Targets [hashing vs simple check confusion]: Proposes an inadequate method for integrity verification."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Generating SRI hashes involves downloading the specific version of the resource and then applying a cryptographic hash function (like SHA-384) using tools such as <code>openssl</code> or dedicated SRI generators. This process ensures the developer has the correct hash for the exact file they intend to link.",
        "distractor_analysis": "The distractors suggest unreliable methods like trusting the CDN implicitly, using non-existent browser features, or employing inadequate checks like file size.",
        "analogy": "To get the correct fingerprint for a document, you need to print it yourself and then use a special ink and scanner (hash function) to capture its unique pattern, rather than just asking someone else for it."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "APPSEC_WEB_SRI_IMPLEMENTATION",
        "CRYPTO_HASHING_TOOLS"
      ]
    },
    {
      "question_text": "Consider a scenario where a website loads a critical JavaScript file from a third-party CDN. If the CDN is compromised and the JavaScript file is replaced with a malicious version, what is the role of SRI in this attack?",
      "correct_answer": "SRI will detect the mismatch between the original hash and the malicious file's hash, causing the browser to block the malicious script from executing.",
      "distractors": [
        {
          "text": "SRI will encrypt the malicious script, rendering it harmless.",
          "misconception": "Targets [encryption vs integrity confusion]: Incorrectly assumes SRI provides encryption."
        },
        {
          "text": "SRI will automatically update the website's code to remove the malicious script.",
          "misconception": "Targets [automated remediation confusion]: Assumes SRI performs code modification."
        },
        {
          "text": "SRI will prevent the CDN compromise itself.",
          "misconception": "Targets [prevention vs detection confusion]: Misunderstands SRI as a preventative measure against the initial compromise."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI acts as a detection and blocking mechanism. When the CDN is compromised and the file altered, the hash of the new, malicious file will not match the hash specified in the <code>integrity</code> attribute. Because of this mismatch, the browser, following SRI rules, will refuse to load and execute the script, thereby protecting the website.",
        "distractor_analysis": "The distractors incorrectly suggest SRI encrypts, automatically remediates code, or prevents the initial compromise, rather than its actual function of detecting and blocking tampered resources.",
        "analogy": "If a delivery person tries to deliver a package with a broken seal (malicious script), SRI acts like the security guard who inspects the seal and refuses the delivery, preventing the potentially harmful contents from entering the premises."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "analyze",
      "prerequisites": [
        "APPSEC_WEB_SRI_IMPLEMENTATION",
        "APPSEC_WEB_ATTACKS"
      ]
    },
    {
      "question_text": "What is the relationship between Subresource Integrity (SRI) and Content Security Policy (CSP)?",
      "correct_answer": "SRI and CSP are complementary security mechanisms; CSP can restrict where resources are loaded from, while SRI verifies the integrity of those loaded resources.",
      "distractors": [
        {
          "text": "SRI is a type of CSP directive.",
          "misconception": "Targets [policy vs integrity confusion]: Confuses SRI as a directive within CSP."
        },
        {
          "text": "CSP is used to generate SRI hashes.",
          "misconception": "Targets [mechanism confusion]: Incorrectly links CSP to hash generation."
        },
        {
          "text": "SRI replaces the need for CSP when using external resources.",
          "misconception": "Targets [redundancy confusion]: Assumes SRI makes CSP unnecessary."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CSP controls *which* origins are allowed to load resources, providing a first layer of defense. SRI then verifies the *integrity* of the resources loaded from those allowed origins. They work together: CSP limits the attack surface, and SRI ensures the integrity of what's allowed through.",
        "distractor_analysis": "The distractors incorrectly define SRI as a CSP directive, link CSP to hash generation, or claim SRI makes CSP redundant, failing to recognize their complementary roles in web security.",
        "analogy": "CSP is like a bouncer at a club deciding who gets in (which domains are allowed). SRI is like a security check inside the club, ensuring that once someone is inside, they haven't brought anything dangerous with them (verifying resource integrity)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "APPSEC_WEB_SRI_IMPLEMENTATION",
        "WEB_CSP"
      ]
    },
    {
      "question_text": "Which of the following best describes the 'Subresource Integrity' concept in the context of web security?",
      "correct_answer": "A security mechanism that allows browsers to verify that fetched resources have not been tampered with by comparing cryptographic hashes.",
      "distractors": [
        {
          "text": "A protocol for encrypting all data transferred between a browser and a server.",
          "misconception": "Targets [encryption vs integrity confusion]: Confuses integrity checking with data encryption."
        },
        {
          "text": "A method for authenticating the origin of web servers.",
          "misconception": "Targets [authentication vs integrity confusion]: Misunderstands SRI's focus on content integrity, not server identity."
        },
        {
          "text": "A technique for optimizing resource loading times via CDNs.",
          "misconception": "Targets [performance vs security confusion]: Attributes a performance benefit to a security feature."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Subresource Integrity (SRI) is fundamentally about ensuring the integrity of external resources. It works by using cryptographic hashes embedded in HTML to verify that the fetched file matches the expected content, thereby preventing the execution of modified or malicious code.",
        "distractor_analysis": "The distractors incorrectly describe SRI as encryption, server authentication, or a performance optimization technique, missing its core purpose of content integrity verification.",
        "analogy": "SRI is like a notary public verifying that a document hasn't been altered since it was originally signed and sealed."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "APPSEC_WEB_BASICS",
        "CRYPTO_HASHING"
      ]
    },
    {
      "question_text": "What is the primary risk mitigated by implementing Subresource Integrity (SRI)?",
      "correct_answer": "The risk of a compromised third-party host (like a CDN) serving malicious code that gets executed by the user's browser.",
      "distractors": [
        {
          "text": "The risk of a user's browser being infected with malware.",
          "misconception": "Targets [attack vector confusion]: SRI mitigates a cause of malware infection, not the infection itself directly."
        },
        {
          "text": "The risk of sensitive data being leaked from the web server.",
          "misconception": "Targets [data leakage vs code execution confusion]: SRI primarily prevents malicious code execution, not direct data exfiltration from the server."
        },
        {
          "text": "The risk of denial-of-service (DoS) attacks against the website.",
          "misconception": "Targets [attack type confusion]: While compromised resources *could* lead to DoS, SRI's primary mitigation is against code injection."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI directly addresses the threat of supply chain attacks where external resources are compromised. By verifying the integrity of these resources, it prevents the execution of malicious code injected by an attacker into a trusted third-party file, thus protecting the end-user's browser and the website's integrity.",
        "distractor_analysis": "The distractors misidentify the primary risk, confusing SRI's role with general malware prevention, data leakage, or DoS attacks, rather than its specific function against compromised external resources.",
        "analogy": "It's like ensuring the ingredients you buy from a supplier haven't been tampered with before you use them in your recipe, preventing a bad dish (compromised website) from being served."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "APPSEC_WEB_SRI_IMPLEMENTATION",
        "APPSEC_WEB_ATTACKS"
      ]
    },
    {
      "question_text": "Can Subresource Integrity (SRI) be used to protect resources loaded over HTTP?",
      "correct_answer": "No, SRI requires resources to be loaded over HTTPS to ensure the integrity of the SRI mechanism itself and the resource.",
      "distractors": [
        {
          "text": "Yes, SRI works regardless of the connection protocol.",
          "misconception": "Targets [protocol compatibility confusion]: Incorrectly assumes SRI is protocol-agnostic."
        },
        {
          "text": "Yes, but only if the resource is also signed with a digital signature.",
          "misconception": "Targets [additional requirement confusion]: Invents a requirement not mandated by SRI for HTTP."
        },
        {
          "text": "No, SRI is designed specifically for HTTP connections to detect man-in-the-middle attacks.",
          "misconception": "Targets [protocol purpose confusion]: Reverses the security context, suggesting SRI is for HTTP's vulnerabilities."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI relies on the integrity of the connection and the resource itself. Loading resources over HTTP is insecure because the SRI hash itself could be tampered with in transit. Therefore, SRI is designed to work exclusively with HTTPS connections to ensure both the resource and its integrity check are protected.",
        "distractor_analysis": "The distractors incorrectly claim SRI works over HTTP, or invent additional requirements or reverse its protocol dependency, failing to grasp the necessity of HTTPS for SRI's security guarantees.",
        "analogy": "Trying to use SRI over HTTP is like trying to verify a signature on a document that's being passed through a public, unsecured mailbox. You can't trust the signature (or the hash) because the document itself could have been altered en route."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "APPSEC_WEB_SRI_IMPLEMENTATION",
        "WEB_HTTPS"
      ]
    },
    {
      "question_text": "What is the role of the <code>sha384-</code> prefix in an SRI <code>integrity</code> attribute value?",
      "correct_answer": "It specifies that the following base64-encoded string is a SHA-384 cryptographic hash.",
      "distractors": [
        {
          "text": "It indicates the encryption strength of the hash.",
          "misconception": "Targets [strength vs algorithm confusion]: Confuses algorithm type with encryption strength."
        },
        {
          "text": "It signifies that the resource is loaded from a secure server.",
          "misconception": "Targets [protocol indicator confusion]: Misinterprets the prefix as a connection security indicator."
        },
        {
          "text": "It denotes the version number of the hashing algorithm.",
          "misconception": "Targets [version vs algorithm confusion]: Incorrectly assumes the prefix indicates algorithm versioning."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The prefix (e.g., <code>sha384-</code>, <code>sha256-</code>, <code>sha512-</code>) in the <code>integrity</code> attribute explicitly tells the browser which hashing algorithm was used to generate the subsequent base64-encoded hash string. This allows the browser to correctly calculate the hash of the fetched resource using the specified algorithm for comparison.",
        "distractor_analysis": "The distractors incorrectly interpret the prefix as an indicator of encryption strength, server security, or algorithm version, rather than its actual function of specifying the hashing algorithm.",
        "analogy": "The prefix is like the label on a measuring cup that says '1 cup'. It tells you what unit of measurement (algorithm) to use for the quantity (hash) that follows."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "APPSEC_WEB_SRI_IMPLEMENTATION",
        "CRYPTO_HASHING_STANDARDS"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "External Resource Integrity 008_Application Security best practices",
    "latency_ms": 21951.08
  },
  "timestamp": "2026-01-18T12:06:42.094673"
}