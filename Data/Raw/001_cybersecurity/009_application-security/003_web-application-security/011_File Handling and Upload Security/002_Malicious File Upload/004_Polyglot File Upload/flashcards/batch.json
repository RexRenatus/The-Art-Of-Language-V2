{
  "topic_title": "Polyglot File Upload",
  "category": "008_Application Security - Web 008_Application Security",
  "flashcards": [
    {
      "question_text": "What is the primary security risk associated with polyglot file uploads?",
      "correct_answer": "The ability to bypass file type restrictions by embedding multiple file formats within a single file.",
      "distractors": [
        {
          "text": "Increased server storage requirements due to larger file sizes.",
          "misconception": "Targets [resource exhaustion]: Confuses file format manipulation with simple large file uploads."
        },
        {
          "text": "Difficulty in performing client-side validation of file content.",
          "misconception": "Targets [validation confusion]: Mixes client-side limitations with server-side bypass techniques."
        },
        {
          "text": "Potential for denial-of-service attacks through malformed file headers.",
          "misconception": "Targets [attack vector confusion]: Associates polyglot with DoS rather than code execution."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Polyglot files exploit parsers by presenting valid content for multiple formats, allowing attackers to bypass restrictions because the file can be interpreted as a safe type by one parser while executing malicious code via another.",
        "distractor_analysis": "The first distractor focuses on storage, ignoring the execution risk. The second incorrectly emphasizes client-side validation, while the third misattributes the primary risk to DoS rather than code execution.",
        "analogy": "Imagine a document that looks like a harmless PDF to a librarian but secretly contains executable commands for a hidden computer system."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "FILE_UPLOAD_BASICS",
        "MALICIOUS_FILE_UPLOAD"
      ]
    },
    {
      "question_text": "Which OWASP recommendation is crucial for mitigating polyglot file upload vulnerabilities?",
      "correct_answer": "Validate file content using magic bytes and specialized libraries, not just file extensions.",
      "distractors": [
        {
          "text": "Enforce strict file size limits to prevent large malicious uploads.",
          "misconception": "Targets [mitigation confusion]: Focuses on size, not content validation, which doesn't stop polyglot."
        },
        {
          "text": "Store all uploaded files outside the webroot to prevent direct execution.",
          "misconception": "Targets [defense layer confusion]: This is a good practice but doesn't prevent the upload itself."
        },
        {
          "text": "Implement CSRF protection on all file upload forms.",
          "misconception": "Targets [attack vector confusion]: CSRF protects against unauthorized uploads, not the content of legitimate uploads."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Polyglot files bypass extension checks because they can be named with a safe extension (e.g., .jpg) but contain executable code. Validating content via magic bytes and libraries ensures the file's actual type matches its declared type, preventing malicious interpretation.",
        "distractor_analysis": "File size limits don't address the content. Storing files outside the webroot is a secondary defense. CSRF protection is unrelated to the file's intrinsic maliciousness.",
        "analogy": "Instead of just checking the label on a package (file extension), you inspect the contents to ensure it's what it claims to be (magic bytes/content validation)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "FILE_UPLOAD_BASICS",
        "OWASP_FILE_UPLOAD_CHEATSHEET"
      ]
    },
    {
      "question_text": "A web application allows users to upload images. An attacker uploads a file named <code>photo.jpg</code> that, when processed by the server, executes a PHP script. What type of attack is this an example of?",
      "correct_answer": "Polyglot file upload leading to code execution.",
      "distractors": [
        {
          "text": "Cross-Site Scripting (XSS) attack.",
          "misconception": "Targets [injection type confusion]: XSS typically involves injecting scripts into web pages, not executing server-side scripts via file uploads."
        },
        {
          "text": "SQL Injection attack.",
          "misconception": "Targets [injection type confusion]: SQL injection targets database queries, not file execution."
        },
        {
          "text": "Server-Side Request Forgery (SSRF) attack.",
          "misconception": "Targets [attack vector confusion]: SSRF involves tricking the server into making requests to other systems, not executing uploaded code."
        }
      ],
      "detailed_explanation": {
        "core_logic": "This scenario demonstrates a polyglot file upload because the file, named as a safe image type, contains executable code (PHP). The server's file processing or web server configuration then interprets and executes this code, leading to a compromise.",
        "distractor_analysis": "XSS and SQLi are different injection types. SSRF involves making external requests, not executing uploaded code directly.",
        "analogy": "The attacker tricked the application into accepting a 'photo' (safe file type) that was actually a hidden 'executable program' (malicious code)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "analyze",
      "prerequisites": [
        "POLYGLOT_FILE_UPLOAD",
        "CODE_EXECUTION_VULNERABILITIES"
      ]
    },
    {
      "question_text": "Why is relying solely on the <code>Content-Type</code> header insufficient for validating uploaded files against polyglot attacks?",
      "correct_answer": "The <code>Content-Type</code> header is client-controlled and can be easily spoofed by an attacker.",
      "distractors": [
        {
          "text": "The <code>Content-Type</code> header only indicates file size, not format.",
          "misconception": "Targets [header function confusion]: Misunderstands the purpose of the Content-Type header."
        },
        {
          "text": "Server-side processing often ignores the <code>Content-Type</code> header for security.",
          "misconception": "Targets [server behavior confusion]: While servers *should* validate beyond Content-Type, they might not, and the header itself is the weak point."
        },
        {
          "text": "The <code>Content-Type</code> header is only used for static file serving.",
          "misconception": "Targets [header scope confusion]: Misunderstands the header's role in dynamic content and uploads."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>Content-Type</code> header is part of the HTTP request and can be manipulated by the client. Therefore, it cannot be trusted as a sole indicator of a file's true type, making it ineffective against attackers who craft polyglot files with a legitimate-looking header.",
        "distractor_analysis": "The first distractor misrepresents the header's function. The second incorrectly assumes servers always ignore it. The third limits its scope incorrectly.",
        "analogy": "It's like trusting a return address on a package without checking the sender's ID â€“ the address can be faked."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "HTTP_BASICS",
        "POLYGLOT_FILE_UPLOAD"
      ]
    },
    {
      "question_text": "What is a 'magic byte' in the context of file validation?",
      "correct_answer": "A sequence of bytes at the beginning of a file that identifies its specific file type.",
      "distractors": [
        {
          "text": "A cryptographic hash used to verify file integrity.",
          "misconception": "Targets [cryptography confusion]: Confuses file type identification with integrity checking mechanisms."
        },
        {
          "text": "A unique identifier assigned by the operating system to each file.",
          "misconception": "Targets [file system confusion]: Misunderstands file metadata versus file content signatures."
        },
        {
          "text": "A marker indicating the end of a file's data stream.",
          "misconception": "Targets [file structure confusion]: Confuses file type signatures with end-of-file markers."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Magic bytes are specific byte sequences found at the start of many file formats (e.g., <code>FF D8</code> for JPEG). They serve as a reliable signature for the file type, allowing servers to validate content beyond just the file extension or <code>Content-Type</code> header.",
        "distractor_analysis": "The first distractor confuses magic bytes with hashing. The second misattributes them to the OS. The third incorrectly defines them as end-of-file markers.",
        "analogy": "Think of magic bytes as the first few words of a book that immediately tell you if it's a novel, a textbook, or a comic book, regardless of its cover title."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "FILE_FORMATS",
        "FILE_VALIDATION"
      ]
    },
    {
      "question_text": "How can renaming a malicious file to have a seemingly safe extension (e.g., <code>.jpg</code>) still lead to execution in a vulnerable application?",
      "correct_answer": "If the application relies on the file extension rather than analyzing the file's actual content (magic bytes) or using a robust type-checking library.",
      "distractors": [
        {
          "text": "Because the web server automatically executes files with common image extensions.",
          "misconception": "Targets [server behavior confusion]: Misunderstands how web servers handle file types; they don't auto-execute based on extension alone."
        },
        {
          "text": "If the file is uploaded to a directory that is configured to execute all files.",
          "misconception": "Targets [configuration confusion]: While possible, this is a misconfiguration, not an inherent flaw in extension-based checking."
        },
        {
          "text": "Because most browsers will render any file as an image if the extension is <code>.jpg</code>.",
          "misconception": "Targets [client vs. server confusion]: Browser rendering is separate from server-side execution vulnerabilities."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When an application trusts the file extension, an attacker can name a malicious script (e.g., PHP) as <code>.jpg</code>. Since the application only checks the extension, it proceeds to process or serve the file as if it were a legitimate image, potentially leading to code execution if the server is misconfigured.",
        "distractor_analysis": "Web servers don't auto-execute based on extension alone. Executing all files in a directory is a specific misconfiguration, not the general problem. Browser behavior is irrelevant to server-side execution.",
        "analogy": "It's like a security guard only checking the 'fruit' label on a box, ignoring the fact that the box actually contains dangerous chemicals."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "POLYGLOT_FILE_UPLOAD",
        "FILE_EXTENSION_VALIDATION"
      ]
    },
    {
      "question_text": "Which of the following is a recommended practice for storing uploaded files to mitigate risks associated with polyglot uploads?",
      "correct_answer": "Store files in a location inaccessible from the webroot, served via a controlled application handler.",
      "distractors": [
        {
          "text": "Store files directly within the webroot for easy access.",
          "misconception": "Targets [storage security confusion]: Directly contradicts best practices for preventing direct execution."
        },
        {
          "text": "Store files on the same server but in a separate, publicly accessible directory.",
          "misconception": "Targets [access control confusion]: Public accessibility, even separate, increases risk if execution is possible."
        },
        {
          "text": "Encrypt all uploaded files using a symmetric key stored on the web server.",
          "misconception": "Targets [encryption scope confusion]: Encryption protects confidentiality but doesn't prevent execution if the file is decrypted or interpreted."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Storing files outside the webroot prevents direct URL-based execution. A dedicated application handler then retrieves and serves the files, allowing the application to enforce access controls and content type checks before delivery, thus mitigating risks from malicious uploads.",
        "distractor_analysis": "Storing in the webroot is insecure. Publicly accessible storage bypasses the protection. Encryption protects data but not execution if the file is processed.",
        "analogy": "Keep potentially dangerous items in a locked back room (outside webroot) and only bring them out when specifically requested and inspected (via handler)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "FILE_STORAGE_SECURITY",
        "POLYGLOT_FILE_UPLOAD"
      ]
    },
    {
      "question_text": "Consider a scenario where an application accepts PDF uploads. An attacker uploads a file that is a valid PDF but also contains embedded JavaScript that executes when the PDF is opened in a vulnerable viewer. What is this an example of?",
      "correct_answer": "A polyglot file exploiting a specific document parser vulnerability.",
      "distractors": [
        {
          "text": "A simple file extension spoofing attack.",
          "misconception": "Targets [attack complexity confusion]: Underestimates the sophistication; it's not just the extension but the embedded exploit."
        },
        {
          "text": "A Cross-Site Scripting (XSS) attack targeting the upload form.",
          "misconception": "Targets [attack vector confusion]: XSS targets the web interface, not the document viewer's internal parsing."
        },
        {
          "text": "A denial-of-service attack by uploading a malformed PDF.",
          "misconception": "Targets [attack goal confusion]: The goal here is execution/exploitation, not just resource exhaustion."
        }
      ],
      "detailed_explanation": {
        "core_logic": "This is a polyglot attack because the file is valid in one context (PDF) but contains malicious executable content (JavaScript) that exploits a specific parser (PDF viewer). The application accepts it as a PDF, but the viewer executes the script.",
        "distractor_analysis": "The first distractor simplifies the attack. The second confuses the attack vector (XSS vs. document parser exploit). The third misidentifies the primary goal.",
        "analogy": "It's like a Trojan horse disguised as a gift (PDF) that contains a hidden threat (JavaScript) meant to harm the recipient (viewer)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "analyze",
      "prerequisites": [
        "POLYGLOT_FILE_UPLOAD",
        "DOCUMENT_PARSER_VULNERABILITIES"
      ]
    },
    {
      "question_text": "What is the purpose of Content Disarm and Reconstruction (CDR) in the context of file uploads?",
      "correct_answer": "To proactively remove potentially malicious content from uploaded files by rebuilding them into a safe format.",
      "distractors": [
        {
          "text": "To encrypt uploaded files to protect their confidentiality.",
          "misconception": "Targets [security mechanism confusion]: Confuses CDR with encryption; CDR focuses on removing threats, not just confidentiality."
        },
        {
          "text": "To scan uploaded files for known malware signatures using antivirus.",
          "misconception": "Targets [detection vs. prevention confusion]: CDR is more proactive than signature-based scanning; it reconstructs rather than just detects."
        },
        {
          "text": "To validate the file extension against a predefined allowlist.",
          "misconception": "Targets [validation method confusion]: CDR goes beyond simple extension checks to analyze and rebuild content."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CDR works by deconstructing files into their basic components, sanitizing them, and then reconstructing them into a clean, safe version. This process effectively neutralizes embedded threats like macros or scripts that signature-based antivirus might miss, thus preventing polyglot attacks.",
        "distractor_analysis": "Encryption is for confidentiality. Antivirus is detection-based. Extension validation is a weak, easily bypassed method.",
        "analogy": "CDR is like taking apart a potentially dangerous toy, removing any harmful parts, and putting it back together in a safe, playable form."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "POLYGLOT_FILE_UPLOAD",
        "FILE_SANITIZATION"
      ]
    },
    {
      "question_text": "Which of the following file types are particularly susceptible to polyglot attacks due to their complex structure and ability to embed scripts?",
      "correct_answer": "PDF, DOCX, and SVG files.",
      "distractors": [
        {
          "text": "Plain text (.txt) and CSV files.",
          "misconception": "Targets [file type complexity confusion]: These formats are generally simple and lack robust scripting capabilities."
        },
        {
          "text": "Simple image formats like BMP and GIF.",
          "misconception": "Targets [file type complexity confusion]: While some image formats can be manipulated, they are less prone to embedding executable scripts compared to document formats."
        },
        {
          "text": "Executable files like .exe and .dll.",
          "misconception": "Targets [attack vector confusion]: These are already executable; the 'polyglot' aspect is about disguising malicious code as a different, safe type."
        }
      ],
      "detailed_explanation": {
        "core_logic": "PDFs can contain JavaScript, DOCX files can contain macros and embedded objects, and SVGs can contain embedded scripts (like JavaScript). These formats are designed for rich content, making them prime candidates for attackers to embed malicious code within a seemingly legitimate file structure.",
        "distractor_analysis": "Text and CSV files lack the complexity for embedding scripts. BMP and GIF are less common targets for script embedding. Executables are inherently malicious, not disguised as safe types.",
        "analogy": "Think of complex documents like PDF or DOCX as elaborate gift boxes that can hide more than just the intended gift; simple text files are just plain envelopes."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "POLYGLOT_FILE_UPLOAD",
        "FILE_FORMAT_FEATURES"
      ]
    },
    {
      "question_text": "What is the 'double extension' attack in the context of file uploads?",
      "correct_answer": "Naming a file with two extensions, such as <code>malicious.php.jpg</code>, hoping the server processes the first (PHP) while the client sees the second (JPG).",
      "distractors": [
        {
          "text": "Uploading two separate files, one malicious and one benign.",
          "misconception": "Targets [attack mechanism confusion]: Confuses multiple files with a single, multi-part file."
        },
        {
          "text": "Using a file name that includes a period followed by a valid extension, like <code>report.pdf</code>.",
          "misconception": "Targets [normal file naming confusion]: This is standard file naming, not an attack technique."
        },
        {
          "text": "Embedding a valid file extension within the file's content.",
          "misconception": "Targets [attack vector confusion]: Focuses on content manipulation, not file naming exploits."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The double extension attack exploits how some systems parse file names. If the server interprets <code>malicious.php.jpg</code> as <code>malicious.php</code> for execution but the client or another system sees it as <code>malicious.jpg</code>, it can bypass filters that block <code>.php</code> but allow <code>.jpg</code>.",
        "distractor_analysis": "The first distractor describes unrelated actions. The second describes normal file naming. The third focuses on content, not the naming trick.",
        "analogy": "It's like labeling a box 'Apples' on the outside, but inside it's actually filled with dangerous chemicals, and the delivery person only looks at the label."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "POLYGLOT_FILE_UPLOAD",
        "FILE_NAMING_VULNERABILITIES"
      ]
    },
    {
      "question_text": "How does changing the filename to a generated, random string help mitigate polyglot file upload risks?",
      "correct_answer": "It prevents attackers from predicting or relying on specific filenames that might be associated with malicious content or execution.",
      "distractors": [
        {
          "text": "It automatically sanitizes the file content, removing malicious code.",
          "misconception": "Targets [mechanism confusion]: Renaming doesn't alter the file's internal structure or content."
        },
        {
          "text": "It ensures that the file extension is always validated correctly.",
          "misconception": "Targets [validation confusion]: The filename change is separate from the validation logic itself."
        },
        {
          "text": "It makes it harder for attackers to overwrite existing system files.",
          "misconception": "Targets [attack goal confusion]: While related to preventing overwrites, the primary benefit for polyglot is obscuring the file's identity."
        }
      ],
      "detailed_explanation": {
        "core_logic": "By generating a random filename (e.g., <code>a3f7b9c1.pdf</code>), the application prevents attackers from using predictable names like <code>shell.php.jpg</code>. This obscures the file's true nature and prevents it from being easily referenced or executed based on its name, complementing content validation.",
        "distractor_analysis": "Renaming does not sanitize content. It doesn't guarantee correct extension validation. While it can help prevent overwrites, its main role against polyglot is obscuring the file's identity.",
        "analogy": "It's like giving a secret agent a new, unrecognizable alias; their original identity and potential threats are hidden."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "POLYGLOT_FILE_UPLOAD",
        "SECURE_FILE_HANDLING"
      ]
    },
    {
      "question_text": "What is the risk if an application allows uploading archives (like .zip) that contain polyglot files?",
      "correct_answer": "The archive's contents can bypass checks if the archive itself is validated but its internal files are not individually inspected.",
      "distractors": [
        {
          "text": "The archive format itself is inherently insecure and should always be blocked.",
          "misconception": "Targets [format generalization confusion]: Archive formats are not inherently insecure; the risk is in how their contents are handled."
        },
        {
          "text": "Decompressing the archive consumes excessive server resources, leading to DoS.",
          "misconception": "Targets [resource exhaustion]: While possible, this misses the primary security risk of embedded malicious files."
        },
        {
          "text": "The archive's metadata can be manipulated to execute code.",
          "misconception": "Targets [attack vector confusion]: The risk is from the *contents* of the archive, not typically its metadata."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Attackers can place a polyglot file inside a seemingly legitimate archive (e.g., a <code>.zip</code> file). If the application only validates the <code>.zip</code> file itself and doesn't inspect each file within it after decompression, the embedded malicious file can bypass security controls.",
        "distractor_analysis": "Archive formats are useful; the risk is in handling their contents. Resource exhaustion is a secondary concern. Metadata manipulation is less common than exploiting embedded file content.",
        "analogy": "It's like accepting a sealed box because the box looks safe, without checking the potentially dangerous items packed inside."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "POLYGLOT_FILE_UPLOAD",
        "ARCHIVE_SECURITY"
      ]
    },
    {
      "question_text": "Which security principle is most directly violated by allowing polyglot file uploads that lead to code execution?",
      "correct_answer": "Principle of Least Privilege, as the file processing component is granted the ability to execute arbitrary code.",
      "distractors": [
        {
          "text": "Defense in Depth, as only a single layer of security (file type check) is bypassed.",
          "misconception": "Targets [security principle confusion]: Least Privilege is more directly violated by the execution capability granted."
        },
        {
          "text": "Separation of Duties, as the user uploading the file also controls its execution.",
          "misconception": "Targets [role confusion]: The violation is more about the component's excessive permissions than user roles."
        },
        {
          "text": "Fail-Safe Defaults, as the system should deny access by default.",
          "misconception": "Targets [default state confusion]: While related, the core issue is the component's over-privilege, not the default state."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The Principle of Least Privilege dictates that a component should only have the permissions necessary to perform its function. When a file upload handler can execute arbitrary code from an uploaded file, it has been granted excessive privileges beyond its intended scope, enabling malicious execution.",
        "distractor_analysis": "Defense in Depth is about multiple layers, not just one. Separation of Duties relates to distinct roles. Fail-Safe Defaults is about denying by default, but the execution capability itself is the core privilege issue.",
        "analogy": "Giving a janitor the keys to the nuclear launch codes violates Least Privilege; they only need keys to the supply closet."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "evaluate",
      "prerequisites": [
        "SECURITY_PRINCIPLES",
        "POLYGLOT_FILE_UPLOAD"
      ]
    },
    {
      "question_text": "When implementing file upload security against polyglot attacks, why is it important to consider the specific libraries used for file parsing?",
      "correct_answer": "Vulnerabilities within the parsing libraries themselves can be exploited to interpret malicious content, even if the file appears valid.",
      "distractors": [
        {
          "text": "Libraries are often slow, and attackers exploit this for denial-of-service.",
          "misconception": "Targets [performance vs. security confusion]: Focuses on performance issues rather than inherent library vulnerabilities."
        },
        {
          "text": "Libraries typically handle file naming conventions, which can be exploited.",
          "misconception": "Targets [scope confusion]: Library vulnerabilities are usually in parsing logic, not file naming handling."
        },
        {
          "text": "Outdated libraries may not support modern encryption standards for uploaded files.",
          "misconception": "Targets [encryption confusion]: Relates library issues to encryption, not the core parsing and interpretation flaws."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Libraries used to parse file formats (like PDF or image libraries) can have their own vulnerabilities (e.g., buffer overflows, XXE). An attacker can craft a polyglot file that exploits these specific library flaws, leading to code execution or other compromises, regardless of other validation steps.",
        "distractor_analysis": "Performance issues are secondary to security flaws. File naming is usually handled separately. Encryption is irrelevant to parsing vulnerabilities.",
        "analogy": "Using an old, faulty tool (parsing library) to assemble a product (process file) can lead to the product being dangerously flawed, even if the design (file format) is sound."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "POLYGLOT_FILE_UPLOAD",
        "DEPENDENCY_MANAGEMENT"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Polyglot File Upload 008_Application Security best practices",
    "latency_ms": 27315.387000000002
  },
  "timestamp": "2026-01-18T12:10:54.353531"
}