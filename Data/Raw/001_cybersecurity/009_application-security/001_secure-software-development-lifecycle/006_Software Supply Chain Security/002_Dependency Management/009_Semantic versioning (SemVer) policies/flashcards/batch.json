{
  "topic_title": "Semantic versioning (SemVer) policies",
  "category": "008_Application Security - Secure Software Development Lifecycle",
  "flashcards": [
    {
      "question_text": "According to Semantic Versioning (SemVer) 2.0.0, when should the MAJOR version number be incremented?",
      "correct_answer": "When incompatible API changes are made.",
      "distractors": [
        {
          "text": "When backwards-compatible bug fixes are introduced.",
          "misconception": "Targets [patch version confusion]: Confuses MAJOR version increments with PATCH version increments for bug fixes."
        },
        {
          "text": "When new functionality is added in a backwards-compatible manner.",
          "misconception": "Targets [minor version confusion]: Confuses MAJOR version increments with MINOR version increments for new features."
        },
        {
          "text": "When any new feature or fix is released.",
          "misconception": "Targets [over-simplification]: Fails to differentiate between MAJOR, MINOR, and PATCH versioning rules."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The MAJOR version is incremented because incompatible API changes break existing functionality, requiring users to adapt. This aligns with SemVer's goal of managing dependencies and preventing 'dependency hell' by signaling significant, potentially breaking, changes.",
        "distractor_analysis": "The distractors incorrectly associate MAJOR version increments with PATCH (bug fixes) or MINOR (backwards-compatible features) versioning rules, or oversimplify the criteria for any release.",
        "analogy": "Think of MAJOR version updates like a major software overhaul (e.g., Windows 10 to Windows 11) where things might look and work differently, requiring users to learn new ways. MINOR updates are like adding new features to an existing version (e.g., a new tool in your word processor), and PATCH updates are like fixing a bug in that tool."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SEMVER_BASICS"
      ]
    },
    {
      "question_text": "In Semantic Versioning (SemVer), what does incrementing the MINOR version signify?",
      "correct_answer": "New functionality has been added in a backwards-compatible manner.",
      "distractors": [
        {
          "text": "Critical security vulnerabilities have been patched.",
          "misconception": "Targets [security focus confusion]: Associates MINOR versions with security patches, which are typically PATCH versions."
        },
        {
          "text": "Significant architectural changes have been implemented.",
          "misconception": "Targets [major change confusion]: Associates MINOR versions with major architectural shifts, which warrant MAJOR version increments."
        },
        {
          "text": "The software is now stable enough for production release.",
          "misconception": "Targets [stability misinterpretation]: Confuses versioning with release readiness; stability is implied by non-zero MAJOR versions, not MINOR increments."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The MINOR version is incremented because adding new functionality in a backwards-compatible way enhances the software without breaking existing integrations. This allows users to adopt new features without immediate refactoring, thus managing 'dependency hell'.",
        "distractor_analysis": "Distractors incorrectly link MINOR versions to security patches (PATCH), major architectural changes (MAJOR), or general stability, rather than the addition of compatible features.",
        "analogy": "A MINOR version update is like adding a new, optional feature to your smartphone's operating system that doesn't change how your existing apps work. You can choose to use the new feature or ignore it, and your current apps will continue to function."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SEMVER_BASICS"
      ]
    },
    {
      "question_text": "What is the primary purpose of Semantic Versioning (SemVer) in managing software dependencies?",
      "correct_answer": "To prevent 'dependency hell' by providing a clear contract for compatibility.",
      "distractors": [
        {
          "text": "To ensure all software is always running the absolute latest version.",
          "misconception": "Targets [version obsession]: Misunderstands SemVer's goal as forcing upgrades, rather than managing compatibility."
        },
        {
          "text": "To standardize the look and feel of all software interfaces.",
          "misconception": "Targets [UI/UX confusion]: Confuses versioning with user interface design principles."
        },
        {
          "text": "To automatically resolve all security vulnerabilities in code.",
          "misconception": "Targets [security automation misbelief]: Believes versioning itself fixes vulnerabilities, rather than signaling changes that might address them."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SemVer prevents 'dependency hell' because it establishes a clear, machine-readable contract for compatibility. By adhering to MAJOR.MINOR.PATCH rules, developers can specify dependency ranges that ensure stability while allowing for necessary updates, thus managing the complexity of interconnected software.",
        "distractor_analysis": "The distractors misrepresent SemVer's purpose as forcing latest versions, standardizing UI, or automatically fixing security issues, rather than managing compatibility and preventing conflicts.",
        "analogy": "SemVer is like a traffic light system for software updates. Red (MAJOR) means stop and be cautious, potential incompatibility. Yellow (MINOR) means proceed with caution, new features but compatible. Green (PATCH) means go, minor fixes, fully compatible."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SEMVER_BASICS",
        "DEPENDENCY_MANAGEMENT"
      ]
    },
    {
      "question_text": "When developing software, what does Semantic Versioning (SemVer) recommend for version <code>0.y.z</code>?",
      "correct_answer": "It is for initial development, and anything may change at any time; the artifact should not be considered stable.",
      "distractors": [
        {
          "text": "It indicates a stable release candidate ready for production.",
          "misconception": "Targets [stability misinterpretation]: Confuses initial development versions with release candidates."
        },
        {
          "text": "It signifies a fully tested and backwards-compatible version.",
          "misconception": "Targets [compatibility misbelief]: Assumes early versions are inherently stable and compatible."
        },
        {
          "text": "It requires strict adherence to MAJOR.MINOR.PATCH rules for all changes.",
          "misconception": "Targets [rule misapplication]: Applies strict SemVer rules to a phase where they are explicitly relaxed."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Version <code>0.y.z</code> is designated for initial development because it allows for rapid iteration and API experimentation without the strict backward compatibility constraints of later versions. This flexibility is crucial for early-stage projects before a stable public API is defined.",
        "distractor_analysis": "Distractors incorrectly assign stability or strict adherence to SemVer rules to the <code>0.y.z</code> initial development phase, which is explicitly defined as unstable and subject to frequent, breaking changes.",
        "analogy": "Think of <code>0.y.z</code> versions like a sculptor's initial clay model. It's rough, constantly being reshaped, and not yet the final piece. Once the sculptor is happy with the form, they might declare it 'version 1.0.0' – the first stable version."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SEMVER_BASICS"
      ]
    },
    {
      "question_text": "Consider a software library versioned as <code>1.2.3</code>. If a developer makes a backwards-compatible bug fix, which part of the version number should be incremented according to SemVer?",
      "correct_answer": "PATCH (Z)",
      "distractors": [
        {
          "text": "MAJOR (X)",
          "misconception": "Targets [major change confusion]: Associates bug fixes with major, breaking changes."
        },
        {
          "text": "MINOR (Y)",
          "misconception": "Targets [feature addition confusion]: Associates bug fixes with the addition of new features."
        },
        {
          "text": "Build Metadata",
          "misconception": "Targets [metadata confusion]: Confuses version number components with optional build metadata."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The PATCH version (Z) is incremented for backwards-compatible bug fixes because these changes improve the software's correctness without altering its public API. This ensures that existing integrations remain functional, adhering to SemVer's principle of managing compatibility.",
        "distractor_analysis": "Distractors incorrectly suggest incrementing MAJOR (for breaking changes), MINOR (for new features), or Build Metadata (for build-specific info) instead of PATCH for bug fixes.",
        "analogy": "If your car's radio occasionally glitches (a bug), the mechanic fixes it without changing the car's engine or adding new features. This is like a PATCH update – fixing a problem while keeping everything else the same."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "SEMVER_BASICS"
      ]
    },
    {
      "question_text": "A software project releases version <code>2.5.0</code>. Later, they add a new feature that does not break existing functionality. According to SemVer, what should the next version number be?",
      "correct_answer": "2.6.0",
      "distractors": [
        {
          "text": "3.0.0",
          "misconception": "Targets [major version misapplication]: Incorrectly increments MAJOR version for a non-breaking feature addition."
        },
        {
          "text": "2.5.1",
          "misconception": "Targets [patch version misapplication]: Incorrectly increments PATCH version for a feature addition, not a bug fix."
        },
        {
          "text": "2.5.0-beta",
          "misconception": "Targets [pre-release confusion]: Applies pre-release tags inappropriately when a stable MINOR release is warranted."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The MINOR version is incremented because a new, backwards-compatible feature was added. Since the previous version was <code>2.5.0</code>, incrementing the MINOR part results in <code>2.6.0</code>, following SemVer's rule for feature additions.",
        "distractor_analysis": "Distractors suggest incrementing MAJOR (incorrect for compatible features), PATCH (incorrect for features), or using a pre-release tag (unnecessary for a stable feature release).",
        "analogy": "Imagine a recipe book. Version <code>2.5.0</code> is the current edition. Adding a new, optional dessert recipe that doesn't change the main courses is like a MINOR update, making it version <code>2.6.0</code>."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "SEMVER_BASICS"
      ]
    },
    {
      "question_text": "What is the significance of the <code>+META</code> part in a SemVer string like <code>1.2.3+build456</code>?",
      "correct_answer": "It is build metadata and does not affect version precedence or compatibility.",
      "distractors": [
        {
          "text": "It indicates a pre-release version.",
          "misconception": "Targets [pre-release confusion]: Confuses build metadata with pre-release identifiers (e.g., `-alpha`)."
        },
        {
          "text": "It signifies a breaking change in the API.",
          "misconception": "Targets [breaking change misinterpretation]: Incorrectly associates build metadata with MAJOR version changes."
        },
        {
          "text": "It must be incremented before the PATCH version.",
          "misconception": "Targets [ordering confusion]: Believes build metadata has a defined ordering relative to version components."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Build metadata (<code>+META</code>) is ignored when determining version precedence because it provides information about the build itself (e.g., build number, commit hash) and does not alter the software's functional compatibility. Therefore, it doesn't affect how versions are compared or considered compatible.",
        "distractor_analysis": "Distractors incorrectly identify build metadata as pre-release information, a sign of breaking changes, or something that influences version ordering.",
        "analogy": "Think of <code>+build456</code> as a serial number stamped on a product. The serial number helps identify that specific unit but doesn't change the product's core functionality or how it compares to other units of the same model (e.g., <code>1.2.3</code>)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SEMVER_BASICS"
      ]
    },
    {
      "question_text": "When is it appropriate to use a pre-release version tag in SemVer, such as <code>1.0.0-alpha.1</code>?",
      "correct_answer": "To indicate that a version is unstable and may not satisfy the intended compatibility requirements of its associated normal version.",
      "distractors": [
        {
          "text": "After a stable release to provide additional bug fixes.",
          "misconception": "Targets [timing confusion]: Incorrectly applies pre-release tags to post-stable releases."
        },
        {
          "text": "For internal development builds that are never released publicly.",
          "misconception": "Targets [scope confusion]: Assumes pre-release tags are only for internal use, not for public testing phases."
        },
        {
          "text": "To denote a version with enhanced security features.",
          "misconception": "Targets [feature misclassification]: Associates pre-release tags with specific feature types like security enhancements."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Pre-release tags (<code>-alpha</code>, <code>-beta</code>, etc.) are used because they signal that a version is not yet stable and may contain bugs or breaking changes, even if it's intended to be part of a future stable release (e.g., <code>1.0.0</code>). This allows users to test upcoming versions while clearly distinguishing them from stable releases.",
        "distractor_analysis": "Distractors incorrectly suggest using pre-release tags for post-stable fixes, exclusively internal builds, or specific feature types, rather than for signaling instability before a stable release.",
        "analogy": "A pre-release version is like a movie trailer or a beta test for a video game. It gives you a preview of what's coming, but it's not the final, polished product and might have issues."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SEMVER_BASICS"
      ]
    },
    {
      "question_text": "According to the Open Source Project Security Baseline, what is a key requirement for CI/CD pipelines regarding input parameters?",
      "correct_answer": "Input parameters must be sanitized and validated prior to use.",
      "distractors": [
        {
          "text": "Input parameters should be encrypted during transit.",
          "misconception": "Targets [unknown]: Not specified"
        },
        {
          "text": "Input parameters must be limited to alphanumeric characters only.",
          "misconception": "Targets [overly restrictive validation]: Suggests a specific, potentially too-narrow validation rule, rather than the principle."
        },
        {
          "text": "Input parameters should be automatically approved if from a trusted source.",
          "misconception": "Targets [trust assumption]: Relies on source trust without proper validation, which can be bypassed."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Input parameters must be sanitized and validated because untrusted input can lead to various vulnerabilities, such as injection attacks (e.g., command injection, SQL injection) within the CI/CD pipeline. This control, found in the OSPS Baseline ([OSPS-BR-01.01]), ensures that the pipeline processes only safe and expected data.",
        "distractor_analysis": "Distractors suggest encryption (related but different security control), overly restrictive validation, or automatic approval based on source, none of which address the core risk of malicious or malformed input data.",
        "analogy": "Imagine a security guard at a building entrance. They don't just check where you came from; they inspect your ID and bag (sanitize and validate) to ensure you're not bringing anything dangerous inside, regardless of how you arrived."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "SEMVER_BASICS",
        "CI_CD_SECURITY",
        "OSPS_BASELINE"
      ]
    },
    {
      "question_text": "Which NIST Special Publication provides guidance on Cybersecurity Supply Chain Risk Management (C-SCRM) practices?",
      "correct_answer": "NIST SP 800-161r1",
      "distractors": [
        {
          "text": "NIST SP 800-53",
          "misconception": "Targets [control framework confusion]: Confuses C-SCRM guidance with general security and privacy controls."
        },
        {
          "text": "NIST SP 800-63",
          "misconception": "Targets [identity management confusion]: Confuses C-SCRM with digital identity guidelines."
        },
        {
          "text": "NIST SP 800-171",
          "misconception": "Targets [uncontrolled unclassified information confusion]: Confuses C-SCRM with protecting CUI in non-federal systems."
        }
      ],
      "detailed_explanation": {
        "core_logic": "NIST SP 800-161r1 provides comprehensive guidance on Cybersecurity Supply Chain Risk Management (C-SCRM) practices because managing risks associated with third-party software and hardware is critical for overall system security. It outlines policies and procedures to identify, assess, and mitigate these risks.",
        "distractor_analysis": "The distractors name other relevant NIST publications but misattribute the specific focus on C-SCRM to them, confusing it with broader security controls, digital identity, or CUI protection.",
        "analogy": "NIST SP 800-161r1 is like a detailed manual for vetting all the suppliers and components that go into building a secure house, ensuring no weak links exist in the construction chain."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "SEMVER_BASICS",
        "CSCRM_BASICS",
        "NIST_FRAMEWORKS"
      ]
    },
    {
      "question_text": "In SemVer, what is the rule for incrementing the MAJOR version when version <code>1.0.0</code> has already been released?",
      "correct_answer": "Increment MAJOR when you make backwards incompatible API changes.",
      "distractors": [
        {
          "text": "Increment MAJOR when you add any new functionality.",
          "misconception": "Targets [feature vs. breaking change confusion]: Incorrectly assumes all new functionality requires a MAJOR version bump."
        },
        {
          "text": "Increment MAJOR when you fix any bug.",
          "misconception": "Targets [bug fix vs. breaking change confusion]: Incorrectly associates bug fixes with MAJOR version increments."
        },
        {
          "text": "Increment MAJOR only when releasing version 2.0.0.",
          "misconception": "Targets [fixed versioning confusion]: Believes MAJOR versions are only incremented at specific milestones like 2.0.0, not based on API changes."
        }
      ],
      "detailed_explanation": {
        "core_logic": "After version <code>1.0.0</code>, the MAJOR version is incremented specifically for backwards incompatible API changes because this is the signal that existing consumers of the software will need to adapt their integrations. This adheres to SemVer's core principle of communicating compatibility.",
        "distractor_analysis": "Distractors incorrectly link MAJOR version increments to general new functionality, bug fixes, or arbitrary version milestones, rather than the specific criterion of breaking API changes.",
        "analogy": "If version <code>1.0.0</code> of a tool is like a hammer, and you change it into a screwdriver, that's a MAJOR change (<code>2.0.0</code>) because you can no longer use it as a hammer. If you just make the hammer handle more ergonomic, that's a MINOR or PATCH update."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "SEMVER_BASICS"
      ]
    },
    {
      "question_text": "What is the relationship between Semantic Versioning (SemVer) and preventing 'dependency hell'?",
      "correct_answer": "SemVer provides a standardized way to specify version compatibility, allowing tools to manage dependencies more intelligently and avoid conflicts.",
      "distractors": [
        {
          "text": "SemVer automatically resolves all dependency conflicts.",
          "misconception": "Targets [automation over specification]: Believes SemVer is an automated resolution system, not a specification for compatibility."
        },
        {
          "text": "SemVer enforces that all dependencies must be updated to the latest MAJOR version.",
          "misconception": "Targets [forced upgrade misinterpretation]: Misunderstands SemVer's goal as forcing upgrades, rather than managing safe updates."
        },
        {
          "text": "SemVer is only relevant for large, complex software projects.",
          "misconception": "Targets [scope limitation]: Believes SemVer's benefits are limited to large projects, ignoring its value in smaller ones."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SemVer prevents 'dependency hell' because it establishes a clear contract for compatibility. By defining MAJOR, MINOR, and PATCH increments, developers can specify dependency ranges (e.g., <code>^1.2.3</code> meaning <code>&gt;=1.2.3 &lt;2.0.0</code>) that allow for safe updates without introducing breaking changes, thus managing the complexity of interconnected software.",
        "distractor_analysis": "Distractors incorrectly claim SemVer automatically resolves conflicts, forces major upgrades, or is only for large projects, missing its core function as a compatibility signaling mechanism.",
        "analogy": "SemVer acts like a standardized labeling system on food ingredients. It tells you if a new version of an ingredient is compatible with your existing recipe (e.g., 'may contain nuts' vs. 'new flavor'). This helps you avoid ruining your dish (dependency hell)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SEMVER_BASICS",
        "DEPENDENCY_MANAGEMENT"
      ]
    },
    {
      "question_text": "According to SemVer 2.0.0, what is the rule for version precedence when comparing <code>1.0.0-alpha</code> and <code>1.0.0</code>?",
      "correct_answer": "<code>1.0.0-alpha</code> has lower precedence than <code>1.0.0</code>.",
      "distractors": [
        {
          "text": "<code>1.0.0-alpha</code> has higher precedence than <code>1.0.0</code>.",
          "misconception": "Targets [precedence order confusion]: Incorrectly assumes pre-release versions have higher precedence."
        },
        {
          "text": "They have equal precedence.",
          "misconception": "Targets [equality misinterpretation]: Believes pre-release and stable versions are equivalent in precedence."
        },
        {
          "text": "Precedence is determined by the build metadata, not the pre-release tag.",
          "misconception": "Targets [metadata vs. pre-release confusion]: Confuses the role of build metadata with pre-release identifiers in determining precedence."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Pre-release versions have lower precedence than their associated normal version because they are explicitly marked as unstable and potentially incompatible. This ensures that stable releases are always preferred over pre-release versions in dependency resolution, preventing accidental use of unstable code.",
        "distractor_analysis": "Distractors incorrectly assign higher precedence, equal precedence, or incorrectly attribute precedence determination to build metadata instead of the defined rule that pre-releases are lower precedence.",
        "analogy": "Think of <code>1.0.0</code> as the final, official product, and <code>1.0.0-alpha</code> as a beta version you can test. The official product always takes precedence over the beta version."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "SEMVER_BASICS"
      ]
    },
    {
      "question_text": "In the context of software supply chain security, how does Semantic Versioning (SemVer) aid in vulnerability management?",
      "correct_answer": "By allowing developers to specify dependency version ranges that exclude known vulnerable versions or only include patched versions.",
      "distractors": [
        {
          "text": "SemVer automatically scans code for vulnerabilities.",
          "misconception": "Targets [automation misbelief]: Confuses versioning with automated vulnerability scanning tools."
        },
        {
          "text": "SemVer guarantees that all released versions are vulnerability-free.",
          "misconception": "Targets [guarantee misinterpretation]: Assumes versioning itself eliminates all security flaws."
        },
        {
          "text": "SemVer requires all dependencies to be updated to the latest MAJOR version to patch vulnerabilities.",
          "misconception": "Targets [forced upgrade misapplication]: Incorrectly mandates MAJOR version upgrades for vulnerability patching, which might be handled by PATCH releases."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SemVer aids vulnerability management because it provides a structured way to declare compatibility. Developers can specify dependency constraints (e.g., <code>~1.2.3</code> for compatible patches, or <code>^1.2.3</code> for compatible minor/patches) that allow package managers to update to versions containing security fixes without introducing breaking changes, thus mitigating risks.",
        "distractor_analysis": "Distractors incorrectly attribute automated scanning, guaranteed vulnerability-free releases, or mandatory MAJOR version upgrades to SemVer, missing its role in enabling precise dependency management for security updates.",
        "analogy": "SemVer helps manage vulnerabilities like a recall notice for a specific batch of a product. You can identify and avoid that specific batch (vulnerable version) while still using other, safe batches (patched versions) of the same product."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "analyze",
      "prerequisites": [
        "SEMVER_BASICS",
        "VULNERABILITY_MANAGEMENT",
        "CSCRM_BASICS"
      ]
    },
    {
      "question_text": "What is the purpose of the <code>EXTRA</code> version component in SemVer, as mentioned in some specifications (e.g., v3.0.0 draft)?",
      "correct_answer": "To denote new prereleases or other extra versioning parameters.",
      "distractors": [
        {
          "text": "To indicate backwards incompatible changes.",
          "misconception": "Targets [breaking change confusion]: Associates EXTRA versions with MAJOR version changes."
        },
        {
          "text": "To represent backwards compatible bug fixes.",
          "misconception": "Targets [bug fix confusion]: Associates EXTRA versions with PATCH version changes."
        },
        {
          "text": "To provide build metadata that does not affect precedence.",
          "misconception": "Targets [metadata confusion]: Confuses EXTRA versioning with build metadata."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>EXTRA</code> version component, as seen in evolving SemVer drafts, serves to explicitly label versions that are not yet stable releases, such as prereleases (<code>-alpha</code>, <code>-beta</code>). This allows for more granular control and signaling of a version's readiness and compatibility status beyond the standard MAJOR.MINOR.PATCH.",
        "distractor_analysis": "Distractors incorrectly assign the roles of MAJOR (breaking changes), PATCH (bug fixes), or build metadata to the <code>EXTRA</code> component, which is intended for prerelease or similar non-standard versioning indicators.",
        "analogy": "Think of <code>EXTRA</code> versions like different stages of a movie production: <code>script</code> (pre-alpha), <code>rough cut</code> (alpha), <code>final cut</code> (beta), before the <code>premiere</code> (1.0.0). Each stage has a different level of polish and stability."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SEMVER_BASICS"
      ]
    },
    {
      "question_text": "Consider a scenario where a library's API is changed in a way that requires users to modify their code calling the library. According to SemVer, what is the minimum version increment required?",
      "correct_answer": "MAJOR",
      "distractors": [
        {
          "text": "MINOR",
          "misconception": "Targets [compatibility misinterpretation]: Assumes backwards compatibility is maintained despite API changes."
        },
        {
          "text": "PATCH",
          "misconception": "Targets [bug fix vs. breaking change confusion]: Incorrectly categorizes breaking API changes as simple bug fixes."
        },
        {
          "text": "No increment needed if the functionality is still available.",
          "misconception": "Targets [functional equivalence confusion]: Believes API changes are acceptable if the core function remains, ignoring breaking interface changes."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A MAJOR version increment is required because changing an API in a way that requires users to modify their code signifies a backwards incompatibility. SemVer mandates this MAJOR increment to clearly signal to consumers that their existing integrations will break and require updates.",
        "distractor_analysis": "Distractors incorrectly suggest MINOR or PATCH increments, or no increment, failing to recognize that breaking API changes necessitate a MAJOR version bump according to SemVer rules.",
        "analogy": "If you have a remote control (API) for your TV, and the button layout is completely changed so your old programming (code) no longer works with it, that's a MAJOR update to the remote. You need a new way to control the TV."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "SEMVER_BASICS",
        "API_DESIGN"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 16,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Semantic versioning (SemVer) policies 008_Application Security best practices",
    "latency_ms": 29569.32
  },
  "timestamp": "2026-01-18T11:47:17.263180"
}