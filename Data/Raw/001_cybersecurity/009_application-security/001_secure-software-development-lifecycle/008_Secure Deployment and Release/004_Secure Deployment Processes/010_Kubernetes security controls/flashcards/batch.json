{
  "topic_title": "Kubernetes security controls",
  "category": "008_Application Security - Secure Software Development Lifecycle",
  "flashcards": [
    {
      "question_text": "Which Kubernetes security control is primarily used to enforce network traffic policies between pods and namespaces?",
      "correct_answer": "Network Policies",
      "distractors": [
        {
          "text": "Pod Security Standards",
          "misconception": "Targets [scope confusion]: Confuses network segmentation with pod-level security hardening."
        },
        {
          "text": "Service Accounts",
          "misconception": "Targets [identity vs. network confusion]: Mixes identity management with network access control."
        },
        {
          "text": "Admission Controllers",
          "misconception": "Targets [function confusion]: Believes admission controllers manage network traffic, rather than request validation/mutation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Network Policies function by defining rules that govern how pods are allowed to communicate with each other and other network endpoints, thereby segmenting network traffic and enforcing security boundaries.",
        "distractor_analysis": "Pod Security Standards focus on container hardening, Service Accounts manage pod identity, and Admission Controllers intercept API requests, none of which directly control inter-pod network traffic like Network Policies do.",
        "analogy": "Network Policies are like the security guards at different doors within a building, controlling who can go from one room to another, while Pod Security Standards are like the rules for how each room must be furnished and secured internally."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "K8S_NETWORKING",
        "K8S_SECURITY_BASICS"
      ]
    },
    {
      "question_text": "According to Kubernetes best practices, what is the recommended approach for Service Accounts?",
      "correct_answer": "Create dedicated Service Accounts for each workload or microservice and set <code>automountServiceAccountToken</code> to <code>false</code> unless API access is required.",
      "distractors": [
        {
          "text": "Always use the <code>default</code> Service Account for all pods to simplify management.",
          "misconception": "Targets [least privilege violation]: Advocates for a broad, insecure default instead of specific accounts."
        },
        {
          "text": "Enable <code>automountServiceAccountToken: true</code> for all workloads to ensure API access is always available.",
          "misconception": "Targets [over-permissioning]: Recommends granting API access unnecessarily, increasing attack surface."
        },
        {
          "text": "Use a single, highly-privileged Service Account for all cluster-wide operations.",
          "misconception": "Targets [centralized risk]: Creates a single point of failure and broad compromise potential."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Dedicated Service Accounts and disabling automatic token mounting (unless needed) adhere to the principle of least privilege, because it limits the blast radius if a pod's credentials are compromised and reduces unnecessary access to the Kubernetes API.",
        "distractor_analysis": "Using the default Service Account, always enabling token mounting, or using a single privileged account all violate security best practices by increasing the attack surface and reducing granular control.",
        "analogy": "Using dedicated Service Accounts is like giving each employee a specific keycard for only the rooms they need to access, rather than a master key for the entire building."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "K8S_RBAC",
        "K8S_SERVICE_ACCOUNTS"
      ]
    },
    {
      "question_text": "What is the primary security benefit of setting <code>runAsNonRoot: true</code> in a pod's <code>securityContext</code>?",
      "correct_answer": "Prevents containers from running as the root user, reducing the impact of a potential compromise.",
      "distractors": [
        {
          "text": "Ensures that the container image itself is free of vulnerabilities.",
          "misconception": "Targets [vulnerability vs. privilege confusion]: Mixes runtime privilege with static image security."
        },
        {
          "text": "Automatically restricts network access for the container.",
          "misconception": "Targets [function confusion]: Attributes network control capabilities to a user privilege setting."
        },
        {
          "text": "Enforces read-only access to the container's root filesystem.",
          "misconception": "Targets [misattributed control]: Confuses user privilege with filesystem permissions."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Setting <code>runAsNonRoot: true</code> is crucial because it enforces the principle of least privilege by preventing the container process from running with elevated root permissions, thus limiting potential damage if the container is compromised.",
        "distractor_analysis": "The correct answer directly addresses the privilege reduction benefit. The distractors incorrectly link it to image scanning, network access control, or filesystem immutability, which are separate security concerns.",
        "analogy": "It's like ensuring a contractor working in your house doesn't have the master key to your entire property, only access to the specific areas they are working in."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "K8S_POD_SECURITY_CONTEXT",
        "LEAST_PRIVILEGE"
      ]
    },
    {
      "question_text": "In Kubernetes, what does the <code>allowPrivilegeEscalation: false</code> setting in a container's <code>securityContext</code> prevent?",
      "correct_answer": "Processes within the container from gaining more privileges than their parent process (e.g., via setuid binaries).",
      "distractors": [
        {
          "text": "The container from accessing the host's network namespace.",
          "misconception": "Targets [namespace confusion]: Attributes network isolation capabilities to privilege escalation settings."
        },
        {
          "text": "The container from being run as a non-root user.",
          "misconception": "Targets [opposite effect]: Describes the function of `runAsNonRoot` rather than privilege escalation."
        },
        {
          "text": "The container from mounting host volumes.",
          "misconception": "Targets [volume access confusion]: Links privilege escalation to volume mounting, which is a separate configuration."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Setting <code>allowPrivilegeEscalation: false</code> is important because it prevents processes from gaining elevated privileges, such as those that can occur when a process drops privileges and then regains them, thus maintaining a lower privilege level.",
        "distractor_analysis": "The correct answer accurately describes the prevention of privilege escalation. The distractors incorrectly associate this setting with network access, non-root execution, or volume mounting, which are controlled by other security context fields.",
        "analogy": "This is like ensuring that a temporary pass granted to an employee doesn't allow them to suddenly access the CEO's office; their access remains limited to what was initially permitted."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "K8S_POD_SECURITY_CONTEXT",
        "PRIVILEGE_ESCALATION"
      ]
    },
    {
      "question_text": "What is the purpose of Kubernetes Admission Controllers in securing applications?",
      "correct_answer": "To intercept and validate or mutate requests to the Kubernetes API server before objects are persisted.",
      "distractors": [
        {
          "text": "To encrypt data stored within the Kubernetes control plane.",
          "misconception": "Targets [encryption confusion]: Confuses request validation with data-at-rest encryption."
        },
        {
          "text": "To control network traffic flow between pods.",
          "misconception": "Targets [network control confusion]: Attributes network policy enforcement to API request interception."
        },
        {
          "text": "To authenticate users and services accessing the API server.",
          "misconception": "Targets [authentication confusion]: Mixes request validation with the process of verifying identity."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Admission Controllers are critical because they act as gatekeepers for API requests, ensuring that only valid and compliant configurations are applied to the cluster, thereby preventing misconfigurations and enforcing security policies.",
        "distractor_analysis": "The correct answer accurately describes the function of Admission Controllers. The distractors incorrectly assign them roles related to data encryption, network traffic control, or user authentication, which are handled by other Kubernetes mechanisms.",
        "analogy": "Admission Controllers are like the bouncers at a club's entrance, checking IDs and ensuring only authorized individuals with the correct attire get inside, before they can interact with anything within."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "K8S_API_SERVER",
        "K8S_ADMISSION_CONTROL"
      ]
    },
    {
      "question_text": "Which Kubernetes Pod Security Standard profile offers the most restrictive security posture?",
      "correct_answer": "Restricted",
      "distractors": [
        {
          "text": "Privileged",
          "misconception": "Targets [profile definition confusion]: Associates the most restrictive profile with the least restrictive one."
        },
        {
          "text": "Baseline",
          "misconception": "Targets [profile comparison error]: Confuses the intermediate 'Baseline' profile with the most restrictive 'Restricted' profile."
        },
        {
          "text": "Unrestricted",
          "misconception": "Targets [terminology confusion]: Uses a non-existent profile name that implies lack of restriction."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'Restricted' profile is the most secure because it enforces a heavily restricted policy, aligning with current Pod hardening best practices and minimizing potential attack vectors by disallowing many privileged operations.",
        "distractor_analysis": "The 'Restricted' profile is indeed the most secure. 'Privileged' is the least restrictive, and 'Baseline' is minimally restrictive. 'Unrestricted' is not a defined profile in the Pod Security Standards.",
        "analogy": "Think of the Pod Security Standards profiles like different levels of security clearance: 'Privileged' is like having access to everything, 'Baseline' is like having access to most areas, and 'Restricted' is like having access only to specific, essential rooms."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "K8S_POD_SECURITY_STANDARDS"
      ]
    },
    {
      "question_text": "What is the primary function of the Kubernetes Secret API?",
      "correct_answer": "To store and manage sensitive configuration data, such as passwords and API keys.",
      "distractors": [
        {
          "text": "To encrypt all data stored within the Kubernetes cluster.",
          "misconception": "Targets [scope confusion]: Overstates the function to include all cluster data encryption, not just secrets."
        },
        {
          "text": "To manage network access control lists for pods.",
          "misconception": "Targets [function confusion]: Attributes network policy functions to secret management."
        },
        {
          "text": "To provide identity and authentication for service accounts.",
          "misconception": "Targets [identity confusion]: Mixes secret storage with identity management."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The Secret API is designed to securely store and manage sensitive information because it provides a mechanism to decouple credentials and configuration from container images and deployment manifests, reducing the risk of exposure.",
        "distractor_analysis": "The correct answer accurately describes the purpose of Kubernetes Secrets. The distractors incorrectly assign it roles related to general data encryption, network access control, or service account authentication.",
        "analogy": "Kubernetes Secrets are like a secure vault within the cluster where you store critical documents (like passwords or API keys) that should not be left lying around in plain sight."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "K8S_SECRETS",
        "SENSITIVE_DATA_MANAGEMENT"
      ]
    },
    {
      "question_text": "Why is it recommended to avoid using the <code>default</code> ServiceAccount in Kubernetes?",
      "correct_answer": "It increases the attack surface because it's often granted broader permissions than necessary for specific workloads.",
      "distractors": [
        {
          "text": "The <code>default</code> ServiceAccount is not compatible with most Kubernetes applications.",
          "misconception": "Targets [compatibility error]: Incorrectly claims incompatibility rather than security risks."
        },
        {
          "text": "Using the <code>default</code> ServiceAccount prevents pods from accessing the Kubernetes API.",
          "misconception": "Targets [opposite effect]: Claims it blocks API access, when it often grants too much."
        },
        {
          "text": "The <code>default</code> ServiceAccount is deprecated and will be removed in future versions.",
          "misconception": "Targets [deprecation confusion]: Misattributes deprecation status to a security risk."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Avoiding the <code>default</code> ServiceAccount is a best practice because it often inherits broad permissions by default, violating the principle of least privilege and creating a larger potential impact if compromised.",
        "distractor_analysis": "The correct answer highlights the security risk of over-permissioning associated with the default Service Account. The distractors offer incorrect reasons like incompatibility, blocking API access, or deprecation.",
        "analogy": "It's like using a single master key for all employees in an office building; if that key is lost or stolen, the entire building is at risk, unlike individual keycards for specific departments."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "analyze",
      "prerequisites": [
        "K8S_SERVICE_ACCOUNTS",
        "LEAST_PRIVILEGE"
      ]
    },
    {
      "question_text": "What is the purpose of setting <code>readOnlyRootFilesystem: true</code> for a container in Kubernetes?",
      "correct_answer": "To prevent modifications to the container's root filesystem, enhancing security by limiting potential changes.",
      "distractors": [
        {
          "text": "To ensure that the container's root filesystem is always mounted as read-only by the host.",
          "misconception": "Targets [implementation detail confusion]: Focuses on the host's perspective rather than the container's security context."
        },
        {
          "text": "To automatically encrypt the container's root filesystem.",
          "misconception": "Targets [encryption confusion]: Attributes encryption capabilities to filesystem immutability."
        },
        {
          "text": "To disable the use of any persistent volumes by the container.",
          "misconception": "Targets [volume access confusion]: Incorrectly links root filesystem immutability to the prohibition of persistent volumes."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Setting <code>readOnlyRootFilesystem: true</code> is a security best practice because it prevents attackers from modifying critical system files or injecting malicious code into the container's filesystem after it has been deployed, thus reducing the attack surface.",
        "distractor_analysis": "The correct answer correctly identifies the security benefit of filesystem immutability. The distractors incorrectly relate it to host mounting specifics, encryption, or the prohibition of persistent volumes.",
        "analogy": "This is like ensuring that a temporary workspace is set up so that nothing can be permanently altered or damaged; any changes made are lost when the work is done."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "K8S_POD_SECURITY_CONTEXT",
        "FILESYSTEM_SECURITY"
      ]
    },
    {
      "question_text": "Which Kubernetes security mechanism is used to control network traffic between pods, similar to a firewall?",
      "correct_answer": "Network Policies",
      "distractors": [
        {
          "text": "Pod Security Admission",
          "misconception": "Targets [scope confusion]: Confuses network traffic control with pod security policy enforcement."
        },
        {
          "text": "Resource Quotas",
          "misconception": "Targets [resource management confusion]: Attributes network control to resource allocation limits."
        },
        {
          "text": "Security Context",
          "misconception": "Targets [privilege confusion]: Mixes container-level privilege settings with network segmentation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Network Policies function as a firewall for pods because they allow administrators to specify how groups of pods are allowed to communicate with each other and with other network endpoints, thereby enforcing network segmentation and security.",
        "distractor_analysis": "Network Policies are specifically designed for network traffic control between pods. Pod Security Admission enforces pod security standards, Resource Quotas manage resource consumption, and Security Context defines runtime privileges.",
        "analogy": "Network Policies are like setting up specific rules for which hallways and doors employees can use to move between different departments in a large office building."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "K8S_NETWORKING",
        "NETWORK_SEGMENTATION"
      ]
    },
    {
      "question_text": "What is the primary goal of enforcing Pod Security Standards in Kubernetes?",
      "correct_answer": "To ensure that pods and their containers are isolated appropriately and adhere to security best practices.",
      "distractors": [
        {
          "text": "To automatically encrypt all container images used in the cluster.",
          "misconception": "Targets [encryption confusion]: Attributes image encryption to pod security standards."
        },
        {
          "text": "To manage the lifecycle and scaling of application pods.",
          "misconception": "Targets [orchestration confusion]: Confuses security policy enforcement with workload management."
        },
        {
          "text": "To provide a centralized logging and auditing solution for all cluster activities.",
          "misconception": "Targets [logging confusion]: Mixes security posture enforcement with monitoring and auditing."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Pod Security Standards are essential because they provide a baseline for container security, ensuring proper isolation and adherence to hardening practices, thereby reducing the attack surface and preventing common security misconfigurations.",
        "distractor_analysis": "The correct answer accurately describes the goal of Pod Security Standards. The distractors incorrectly associate them with image encryption, workload orchestration, or centralized logging.",
        "analogy": "Pod Security Standards are like setting minimum safety requirements for all vehicles operating on a road â€“ ensuring they have essential safety features like brakes and airbags, regardless of their specific purpose."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "K8S_POD_SECURITY_STANDARDS",
        "CONTAINER_ISOLATION"
      ]
    },
    {
      "question_text": "Which Kubernetes security control helps protect sensitive configuration values that require confidentiality?",
      "correct_answer": "Secrets",
      "distractors": [
        {
          "text": "ConfigMaps",
          "misconception": "Targets [data sensitivity confusion]: Confuses non-sensitive configuration with sensitive data storage."
        },
        {
          "text": "Persistent Volumes",
          "misconception": "Targets [storage type confusion]: Attributes secret management to general data storage."
        },
        {
          "text": "Network Policies",
          "misconception": "Targets [network vs. data confusion]: Mixes network traffic control with sensitive data protection."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Kubernetes Secrets are specifically designed to store sensitive data like passwords and API keys because they provide a more secure method than ConfigMaps, often integrating with encryption at rest features for enhanced protection.",
        "distractor_analysis": "Secrets are the dedicated Kubernetes resource for sensitive data. ConfigMaps are for non-sensitive configuration, Persistent Volumes are for storage, and Network Policies manage network traffic.",
        "analogy": "ConfigMaps are like public notice boards for general information, while Secrets are like locked filing cabinets for highly confidential documents."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "K8S_SECRETS",
        "SENSITIVE_DATA_MANAGEMENT"
      ]
    },
    {
      "question_text": "What is the role of <code>automountServiceAccountToken: false</code> in a pod's specification?",
      "correct_answer": "It prevents the pod's Service Account token from being automatically mounted into the pod, reducing the risk of unauthorized API access.",
      "distractors": [
        {
          "text": "It ensures that the pod cannot access the Kubernetes API at all.",
          "misconception": "Targets [absolute restriction confusion]: Claims complete API denial rather than token mounting prevention."
        },
        {
          "text": "It automatically assigns a new Service Account to the pod.",
          "misconception": "Targets [assignment confusion]: Attributes account assignment to token mounting control."
        },
        {
          "text": "It encrypts the Service Account token before mounting.",
          "misconception": "Targets [encryption confusion]: Confuses token mounting control with token encryption."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Setting <code>automountServiceAccountToken: false</code> is a security measure because it adheres to the principle of least privilege by ensuring that pods only have access to the Kubernetes API if explicitly granted and configured, thereby minimizing the attack surface.",
        "distractor_analysis": "The correct answer accurately describes the function of disabling automatic token mounting. The distractors incorrectly suggest it completely blocks API access, assigns new accounts, or encrypts the token.",
        "analogy": "This is like ensuring that a guest in your house doesn't automatically receive a key to your private office; they only get one if you specifically give it to them for a particular reason."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "K8S_SERVICE_ACCOUNTS",
        "K8S_POD_SPEC",
        "LEAST_PRIVILEGE"
      ]
    },
    {
      "question_text": "Which Kubernetes security concept involves intercepting API requests to validate or modify them before they are processed?",
      "correct_answer": "Admission Controllers",
      "distractors": [
        {
          "text": "API Server",
          "misconception": "Targets [component confusion]: Identifies the server itself rather than the intercepting plugins."
        },
        {
          "text": "Webhooks",
          "misconception": "Targets [implementation detail confusion]: While webhooks are often used, 'Admission Controllers' is the broader concept."
        },
        {
          "text": "RBAC (Role-Based Access Control)",
          "misconception": "Targets [authorization confusion]: Mixes request validation with permission checking."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Admission Controllers are the mechanism for intercepting and validating/mutating API requests because they act as policy enforcement points, ensuring that only compliant resources are created or modified within the Kubernetes cluster.",
        "distractor_analysis": "Admission Controllers are the correct term for this function. The API Server is the endpoint, Webhooks are an implementation detail, and RBAC handles authorization, not request validation/mutation.",
        "analogy": "Admission Controllers are like the security checkpoint at an airport, inspecting baggage (API requests) before allowing passengers (data) to proceed to the gate (storage)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "analyze",
      "prerequisites": [
        "K8S_API_SERVER",
        "K8S_ADMISSION_CONTROL"
      ]
    },
    {
      "question_text": "In the context of Kubernetes Pod Security Standards, what does the 'Privileged' profile allow?",
      "correct_answer": "Unrestricted access and the ability to bypass typical container isolation mechanisms.",
      "distractors": [
        {
          "text": "Only minimal privilege escalation capabilities.",
          "misconception": "Targets [level confusion]: Associates 'Privileged' with limited escalation, not full bypass."
        },
        {
          "text": "Access to host network and host PID namespaces, but no other host resources.",
          "misconception": "Targets [scope limitation]: Incorrectly limits the broad access granted by the Privileged profile."
        },
        {
          "text": "Secure communication between pods using TLS encryption.",
          "misconception": "Targets [function confusion]: Attributes network security features to a privilege profile."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'Privileged' profile is designed to be unrestricted because it intentionally bypasses most security mechanisms, allowing pods to have broad access, including to the node's host network and devices, for specific system-level workloads.",
        "distractor_analysis": "The correct answer accurately reflects the unrestricted nature of the 'Privileged' profile. The distractors incorrectly limit its scope or assign it unrelated security functions.",
        "analogy": "The 'Privileged' profile is like giving a system administrator a master key to the entire building, allowing them to access any room and perform any maintenance, bypassing normal access controls."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "K8S_POD_SECURITY_STANDARDS",
        "CONTAINER_ISOLATION"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Kubernetes security controls 008_Application Security best practices",
    "latency_ms": 24140.642
  },
  "timestamp": "2026-01-18T11:51:46.263211"
}