{
  "topic_title": "Zombie API Identification",
  "category": "008_Application Security - 006_API Security",
  "flashcards": [
    {
      "question_text": "What is the primary characteristic of a 'zombie API' in the context of application security?",
      "correct_answer": "An API that is no longer actively maintained or supported but remains accessible and potentially exploitable.",
      "distractors": [
        {
          "text": "An API that is intentionally designed to be a honeypot for attackers.",
          "misconception": "Targets [honeypot confusion]: Confuses zombie APIs with security decoys designed to attract attackers."
        },
        {
          "text": "An API that is only accessible to internal development teams for testing purposes.",
          "misconception": "Targets [access control confusion]: Mistakenly associates 'zombie' with restricted internal access rather than neglect."
        },
        {
          "text": "An API that has been deprecated but is still in active use by legacy systems.",
          "misconception": "Targets [deprecation vs. neglect confusion]: While related, 'zombie' implies a lack of maintenance beyond simple deprecation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Zombie APIs are a security risk because they are forgotten, unpatched, and still exposed, making them easy targets. They function by remaining active without oversight, unlike intentionally secured or deprecated APIs.",
        "distractor_analysis": "The distractors confuse zombie APIs with honeypots, internal-only APIs, or simply deprecated APIs, failing to capture the core concept of unmaintained but accessible and vulnerable services.",
        "analogy": "A zombie API is like an abandoned house with unlocked doors and broken windows; it's still standing but neglected, making it an easy target for intruders."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "API_BASICS",
        "APPSEC_RISKS"
      ]
    },
    {
      "question_text": "Which of the following is a significant security risk associated with zombie APIs?",
      "correct_answer": "They may contain unpatched vulnerabilities that attackers can exploit.",
      "distractors": [
        {
          "text": "They can cause excessive load on production servers due to high traffic.",
          "misconception": "Targets [performance vs. security confusion]: Focuses on performance impact rather than direct security exploits."
        },
        {
          "text": "They increase the complexity of API documentation management.",
          "misconception": "Targets [documentation vs. security confusion]: Addresses a management issue, not a direct security vulnerability."
        },
        {
          "text": "They require frequent updates to comply with new industry standards.",
          "misconception": "Targets [compliance vs. neglect confusion]: Assumes active maintenance for compliance, contrary to the 'zombie' nature."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Zombie APIs are dangerous because they are often forgotten and thus unpatched, leaving known or unknown vulnerabilities open for exploitation. This occurs because the lack of maintenance means security updates are not applied.",
        "distractor_analysis": "The distractors focus on operational overhead (load, documentation, updates) rather than the direct security threat of unpatched, exploitable code.",
        "analogy": "A zombie API is like a forgotten weapon left lying around; it's dangerous because it's still functional but no one is guarding it or ensuring it's safe."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "APPSEC_VULNERABILITIES",
        "API_SECURITY_RISKS"
      ]
    },
    {
      "question_text": "According to OWASP, what is a key challenge in managing API inventory, which contributes to zombie APIs?",
      "correct_answer": "Lack of a centralized, up-to-date inventory of all deployed APIs.",
      "distractors": [
        {
          "text": "Over-reliance on third-party API management solutions.",
          "misconception": "Targets [tooling vs. process confusion]: Blames external tools rather than internal process failures."
        },
        {
          "text": "Insufficient developer training on API security best practices.",
          "misconception": "Targets [training vs. inventory confusion]: While important, it's not the primary inventory management challenge leading to zombie APIs."
        },
        {
          "text": "The rapid adoption of microservices architecture.",
          "misconception": "Targets [architectural pattern confusion]: Microservices can exacerbate the problem but aren't the root cause of inventory failure."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A centralized and accurate API inventory is crucial for governance and security. Without it, APIs can be deployed and forgotten, becoming zombie APIs. This lack of visibility is a core issue identified by OWASP.",
        "distractor_analysis": "The distractors misattribute the cause to external solutions, training, or architectural patterns, rather than the fundamental lack of a proper API inventory process.",
        "analogy": "Managing APIs without an inventory is like trying to manage a library without a catalog; you don't know what books you have, where they are, or if they're still relevant."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "API_GOVERNANCE",
        "OWASP_API_SECURITY"
      ]
    },
    {
      "question_text": "Which of the following is a recommended best practice for preventing zombie APIs?",
      "correct_answer": "Implement a robust API lifecycle management process with clear ownership and retirement policies.",
      "distractors": [
        {
          "text": "Disable all unused APIs immediately without review.",
          "misconception": "Targets [overly aggressive policy confusion]: Recommends a drastic measure that could break critical legacy integrations."
        },
        {
          "text": "Only deploy APIs that have been thoroughly documented by external vendors.",
          "misconception": "Targets [external dependency confusion]: Relies on external parties for internal API management and security."
        },
        {
          "text": "Use a single, monolithic API for all application functionalities.",
          "misconception": "Targets [architectural simplification confusion]: Suggests an architectural change that doesn't directly address lifecycle management of multiple APIs."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A well-defined API lifecycle management process ensures that APIs are tracked, maintained, and retired appropriately. This proactive approach prevents APIs from becoming forgotten and vulnerable 'zombies' because ownership and status are clear.",
        "distractor_analysis": "The distractors suggest overly aggressive disabling, external dependency, or architectural simplification, none of which address the core need for internal lifecycle management and clear retirement policies.",
        "analogy": "Preventing zombie APIs is like managing a garden: you need to regularly tend to all plants, know which ones are thriving, which need pruning, and which should be removed, rather than letting them overgrow and become a mess."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "API_LIFECYCLE_MANAGEMENT",
        "API_GOVERNANCE"
      ]
    },
    {
      "question_text": "What is the role of API discovery in identifying potential zombie APIs?",
      "correct_answer": "It helps uncover undocumented or forgotten APIs that might otherwise go unnoticed.",
      "distractors": [
        {
          "text": "It automatically patches all discovered APIs to secure them.",
          "misconception": "Targets [discovery vs. remediation confusion]: Confuses the act of finding with the act of fixing."
        },
        {
          "text": "It generates comprehensive documentation for all APIs found.",
          "misconception": "Targets [discovery vs. documentation confusion]: Discovery tools identify existence, not necessarily create full documentation."
        },
        {
          "text": "It enforces strict access controls on all newly identified endpoints.",
          "misconception": "Targets [discovery vs. access control confusion]: Discovery is about identification, not immediate enforcement of access policies."
        }
      ],
      "detailed_explanation": {
        "core_logic": "API discovery tools scan networks and systems to identify active API endpoints, including those that are undocumented or forgotten. This process is crucial because it brings these potentially 'zombie' APIs into visibility, allowing them to be assessed and managed.",
        "distractor_analysis": "The distractors incorrectly attribute remediation, documentation generation, or access control enforcement to the API discovery process itself, rather than its primary function of identification.",
        "analogy": "API discovery is like a sonar ping in the ocean; it helps you find hidden objects (APIs) that you didn't know were there, so you can then decide what to do with them."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "API_DISCOVERY",
        "API_INVENTORY"
      ]
    },
    {
      "question_text": "Which NIST publication provides guidance relevant to API protection, indirectly aiding in the identification and management of zombie APIs?",
      "correct_answer": "NIST SP 800-228, Guidelines for API Protection for Cloud-Native Systems",
      "distractors": [
        {
          "text": "NIST SP 800-53, Security and Privacy Controls for Information Systems and Organizations",
          "misconception": "Targets [control framework confusion]: While relevant to security, SP 800-53 is broader and not API-specific like SP 800-228."
        },
        {
          "text": "NIST SP 800-63, Digital Identity Guidelines",
          "misconception": "Targets [identity vs. API protection confusion]: Focuses on digital identity, not the broader protection of API systems."
        },
        {
          "text": "NIST SP 800-171, Protecting Controlled Unclassified Information in Nonfederal Information Systems and Organizations",
          "misconception": "Targets [data protection vs. API protection confusion]: Focuses on protecting CUI, not the specific mechanisms for API security."
        }
      ],
      "detailed_explanation": {
        "core_logic": "NIST SP 800-228 specifically addresses API protection in cloud-native systems, covering risk factors and controls throughout the API lifecycle. By providing guidance on secure deployment and management, it helps organizations avoid creating or neglecting APIs, thus preventing zombie APIs.",
        "distractor_analysis": "The distractors name other important NIST publications, but they are either too general (SP 800-53), focused on a specific aspect (SP 800-63, SP 800-171), or not directly focused on API protection as SP 800-228 is.",
        "analogy": "NIST SP 800-228 is like a specialized manual for securing your house's doors and windows (APIs), whereas other NIST documents might be general home security guides or focus on specific rooms (identity, data)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "NIST_FRAMEWORK",
        "API_PROTECTION"
      ]
    },
    {
      "question_text": "What is the relationship between API deprecation and zombie APIs?",
      "correct_answer": "Deprecation is a formal process to retire an API, while a zombie API is an API that has been neglected and forgotten, often after deprecation.",
      "distractors": [
        {
          "text": "Deprecation is the primary cause of zombie APIs.",
          "misconception": "Targets [causation confusion]: Deprecation is a step towards retirement; zombie APIs arise from neglect, not the deprecation itself."
        },
        {
          "text": "Zombie APIs are always intentionally kept active after deprecation.",
          "misconception": "Targets [intent confusion]: Zombie APIs are forgotten, not intentionally kept active."
        },
        {
          "text": "Deprecation automatically removes an API from the network.",
          "misconception": "Targets [deprecation process confusion]: Deprecation is a notification; removal requires a separate action."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Deprecation is a formal process where an API is marked for retirement, with clear timelines for its eventual shutdown. A zombie API, however, is one that has been neglected, often *after* or *without* a proper deprecation process, and remains active and unmanaged, posing a security risk because it's forgotten.",
        "distractor_analysis": "The distractors confuse the cause-and-effect, intent, and process of deprecation versus the state of a zombie API.",
        "analogy": "Deprecating an API is like announcing a store is closing next month and offering discounts; a zombie API is like a store that just quietly stopped operating but the doors are still unlocked and the lights are on, attracting trouble."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "API_LIFECYCLE",
        "API_SECURITY_RISKS"
      ]
    },
    {
      "question_text": "Consider an API that was developed for a specific project, which has since been completed and decommissioned. The API itself was never formally retired or removed. What is this API most likely classified as?",
      "correct_answer": "A zombie API.",
      "distractors": [
        {
          "text": "A deprecated API.",
          "misconception": "Targets [deprecation vs. neglect confusion]: While it might be deprecated, the key is it's forgotten and unmanaged, fitting the 'zombie' definition."
        },
        {
          "text": "A legacy API.",
          "misconception": "Targets [legacy vs. zombie confusion]: 'Legacy' implies it's old but potentially still supported or managed; 'zombie' implies neglect."
        },
        {
          "text": "A shadow API.",
          "misconception": "Targets [shadow vs. zombie confusion]: Shadow APIs are often unknown to IT but actively used; zombie APIs are known but unmanaged."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Since the project is decommissioned and the API was never formally retired or removed, it likely remains active but unmanaged and forgotten. This state perfectly aligns with the definition of a zombie API, posing a security risk due to lack of oversight and potential unpatched vulnerabilities.",
        "distractor_analysis": "The distractors use related terms but miss the core characteristic of a zombie API: being forgotten and unmanaged after its intended purpose has ended.",
        "analogy": "This is like finding an old tool left in a workshop after the project it was for is finished; it's still there, potentially useful, but forgotten and not put away safely, making it a hazard."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "API_LIFECYCLE",
        "APPSEC_RISKS"
      ]
    },
    {
      "question_text": "What is the primary goal of implementing an API gateway in relation to managing API lifecycles and preventing zombie APIs?",
      "correct_answer": "To provide a single point of entry and control for all APIs, enabling better visibility, management, and enforcement of policies.",
      "distractors": [
        {
          "text": "To automatically generate API documentation for all connected services.",
          "misconception": "Targets [gateway function confusion]: Gateways manage traffic and policies, not primarily documentation generation."
        },
        {
          "text": "To encrypt all data transmitted between clients and APIs.",
          "misconception": "Targets [gateway function confusion]: While gateways can enforce TLS, encryption of data payload is often handled by the API itself or other layers."
        },
        {
          "text": "To replace the need for individual API authentication mechanisms.",
          "misconception": "Targets [gateway function confusion]: Gateways often centralize authentication but don't necessarily replace underlying mechanisms entirely."
        }
      ],
      "detailed_explanation": {
        "core_logic": "An API gateway acts as a central control point, offering a unified view and management interface for all APIs. This visibility is crucial for tracking API lifecycles, identifying inactive or forgotten (zombie) APIs, and enforcing security policies consistently, thereby preventing them from becoming a risk.",
        "distractor_analysis": "The distractors misrepresent the primary function of an API gateway, attributing documentation generation, universal payload encryption, or complete replacement of authentication mechanisms, which are not its core purposes in lifecycle management.",
        "analogy": "An API gateway is like the main entrance and security checkpoint for a large building complex; it controls who enters, monitors traffic, and ensures all visitors (API requests) adhere to building rules, making it easier to manage all the individual offices (APIs) within."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "API_GATEWAY",
        "API_LIFECYCLE_MANAGEMENT"
      ]
    },
    {
      "question_text": "How can security testing, specifically penetration testing, help identify zombie APIs?",
      "correct_answer": "By actively probing all accessible endpoints, including those that are undocumented or thought to be inactive.",
      "distractors": [
        {
          "text": "By reviewing code repositories for commented-out API endpoints.",
          "misconception": "Targets [testing method confusion]: Code review is static analysis; penetration testing is dynamic and focuses on live endpoints."
        },
        {
          "text": "By analyzing network traffic logs for unusual API calls.",
          "misconception": "Targets [testing method confusion]: Log analysis is part of monitoring, not active probing for unknown endpoints."
        },
        {
          "text": "By performing vulnerability scans on known API documentation.",
          "misconception": "Targets [testing scope confusion]: This only tests documented APIs, missing the 'zombie' aspect of undocumented ones."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Penetration testing involves actively attempting to interact with and exploit systems. By systematically probing all network-accessible endpoints, including those not listed in official documentation or thought to be inactive, testers can uncover zombie APIs that might otherwise remain hidden and vulnerable.",
        "distractor_analysis": "The distractors suggest methods (code review, log analysis, documented scans) that are either static, passive, or limited in scope, failing to capture the active, broad-ranging probing characteristic of penetration testing for zombie API discovery.",
        "analogy": "Penetration testing for zombie APIs is like a detective searching every room in a house, including closets and attics, not just the main living areas, to find any hidden or forgotten dangers."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "PENETRATION_TESTING",
        "API_DISCOVERY"
      ]
    },
    {
      "question_text": "What is the primary security concern when an API is considered 'shadow' versus 'zombie'?",
      "correct_answer": "Shadow APIs are typically unknown to IT/security but actively used, while zombie APIs are known but unmanaged and forgotten.",
      "distractors": [
        {
          "text": "Shadow APIs are always more vulnerable than zombie APIs.",
          "misconception": "Targets [vulnerability comparison confusion]: Vulnerability depends on specific flaws, not just the 'shadow' or 'zombie' classification."
        },
        {
          "text": "Zombie APIs are intentionally created for malicious purposes.",
          "misconception": "Targets [intent confusion]: Zombie APIs are a result of neglect, not malicious intent."
        },
        {
          "text": "Shadow APIs are always officially deprecated, while zombie APIs are not.",
          "misconception": "Targets [deprecation status confusion]: Neither classification inherently implies a formal deprecation status."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The key distinction lies in visibility and management. Shadow APIs bypass official channels and are unknown to IT, creating blind spots. Zombie APIs, while potentially known, are unmanaged and forgotten, often due to a lack of lifecycle governance, leading to unpatched vulnerabilities.",
        "distractor_analysis": "The distractors incorrectly compare vulnerability levels, assign malicious intent to zombie APIs, or misstate the deprecation status associated with these terms.",
        "analogy": "A shadow API is like a secret passage in a castle that even the guards don't know about, while a zombie API is like a guard tower that's fallen into disrepair and is no longer manned, even though everyone knows it's there."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "API_SECURITY_RISKS",
        "API_GOVERNANCE"
      ]
    },
    {
      "question_text": "Which of the following is an example of a 'security misconfiguration' that could lead to an API becoming a zombie API?",
      "correct_answer": "Failure to implement automated monitoring and alerting for API endpoint status and usage.",
      "distractors": [
        {
          "text": "Using strong, unique API keys for all client authentications.",
          "misconception": "Targets [best practice vs. misconfiguration confusion]: This is a security best practice, not a misconfiguration."
        },
        {
          "text": "Implementing rate limiting to prevent abuse.",
          "misconception": "Targets [best practice vs. misconfiguration confusion]: This is a security control, not a misconfiguration."
        },
        {
          "text": "Enforcing HTTPS for all API communication.",
          "misconception": "Targets [best practice vs. misconfiguration confusion]: This is a fundamental security requirement, not a misconfiguration."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A security misconfiguration is an insecure default setting or a failure to implement proper security controls. Failing to monitor API endpoints means that an API could become inactive or compromised without detection, eventually turning into a zombie API. The other options are security best practices.",
        "distractor_analysis": "The distractors describe security best practices (strong keys, rate limiting, HTTPS) rather than misconfigurations that would allow an API to be neglected and become a zombie.",
        "analogy": "Failing to monitor API status is like not having a smoke detector in your house; it's a lack of a crucial safety feature that allows a problem (a fire, or a zombie API) to go unnoticed until it's too late."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "API_SECURITY_MISCONFIGURATION",
        "API_MONITORING"
      ]
    },
    {
      "question_text": "What is the primary benefit of establishing clear API ownership and accountability within an organization?",
      "correct_answer": "Ensures that each API has a designated owner responsible for its maintenance, security, and eventual retirement.",
      "distractors": [
        {
          "text": "Guarantees that all APIs will be profitable for the business.",
          "misconception": "Targets [business value vs. ownership confusion]: Ownership is about responsibility, not direct profit generation."
        },
        {
          "text": "Automates the process of API version control.",
          "misconception": "Targets [ownership vs. version control confusion]: Ownership is a human/process responsibility; version control is a technical process."
        },
        {
          "text": "Reduces the need for API security testing.",
          "misconception": "Targets [ownership vs. testing confusion]: Ownership ensures maintenance, but security testing remains essential."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Assigning clear ownership ensures that someone is responsible for an API's entire lifecycle, from development to retirement. This accountability is critical because it prevents APIs from being forgotten and becoming zombie APIs, as the owner is tasked with maintenance and security oversight.",
        "distractor_analysis": "The distractors misrepresent the purpose of ownership, linking it to profitability, version control automation, or reducing testing needs, rather than its core function of ensuring lifecycle responsibility.",
        "analogy": "Assigning API ownership is like assigning a parent to a child; the parent is responsible for the child's well-being, development, and ensuring they grow up safely, preventing them from becoming a neglected 'problem'."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "API_GOVERNANCE",
        "API_OWNERSHIP"
      ]
    },
    {
      "question_text": "How can integrating API management tools with CI/CD pipelines help prevent zombie APIs?",
      "correct_answer": "By automating the registration, monitoring, and retirement of APIs as part of the development and deployment process.",
      "distractors": [
        {
          "text": "By automatically generating complex API security policies.",
          "misconception": "Targets [automation scope confusion]: While policies can be applied, full generation is complex and often requires human input."
        },
        {
          "text": "By ensuring all code is written in a single, secure programming language.",
          "misconception": "Targets [language vs. process confusion]: Pipeline integration focuses on process and management, not language enforcement."
        },
        {
          "text": "By exclusively allowing the deployment of APIs with extensive documentation.",
          "misconception": "Targets [documentation requirement confusion]: Pipelines can enforce registration and monitoring, but strict documentation mandates can hinder agility."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Integrating API management with CI/CD pipelines automates key lifecycle tasks. This means APIs are registered, monitored for usage, and can be automatically flagged for retirement if they become unused, directly preventing them from becoming forgotten zombie APIs. This automation embeds lifecycle management into the development workflow.",
        "distractor_analysis": "The distractors focus on policy generation, language enforcement, or documentation mandates, which are not the primary benefits of integrating API management with CI/CD for zombie API prevention.",
        "analogy": "Integrating API management with CI/CD is like having an automated assembly line for cars that also tracks each car's VIN, maintenance schedule, and flags it for recall if it's never driven, ensuring no car is forgotten."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "CI_CD",
        "API_LIFECYCLE_MANAGEMENT"
      ]
    },
    {
      "question_text": "What is the primary risk of a zombie API having outdated authentication or authorization mechanisms?",
      "correct_answer": "Attackers can exploit known weaknesses in the old mechanisms to gain unauthorized access.",
      "distractors": [
        {
          "text": "It may cause compatibility issues with modern client applications.",
          "misconception": "Targets [functional vs. security risk confusion]: Compatibility is a functional issue, not a direct security exploit."
        },
        {
          "text": "It can lead to excessive logging, impacting system performance.",
          "misconception": "Targets [performance vs. security risk confusion]: Outdated mechanisms are more likely to be bypassed than to cause performance issues through excessive logging."
        },
        {
          "text": "It might prevent the API from being discovered by legitimate users.",
          "misconception": "Targets [discovery vs. access confusion]: Outdated auth/authz affects access control, not discovery."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Outdated authentication and authorization mechanisms often contain known vulnerabilities that have been patched in newer versions or protocols. Because zombie APIs are unmanaged, these patches are not applied, leaving them susceptible to exploitation by attackers who are aware of these specific weaknesses.",
        "distractor_analysis": "The distractors focus on functional compatibility, performance impacts, or discovery issues, rather than the direct security risk of unauthorized access through exploitable, outdated security controls.",
        "analogy": "An outdated authentication mechanism on a zombie API is like using an old, easily picked lock on a forgotten storage unit; it's a known weak point that anyone with the right knowledge can exploit to get inside."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "attack",
      "bloom_level": "apply",
      "prerequisites": [
        "API_AUTHENTICATION",
        "API_AUTHORIZATION",
        "APPSEC_VULNERABILITIES"
      ]
    },
    {
      "question_text": "Which of the following actions is MOST crucial for decommissioning an API and preventing it from becoming a zombie API?",
      "correct_answer": "Removing or disabling the API endpoint and all associated infrastructure and access credentials.",
      "distractors": [
        {
          "text": "Updating the API's documentation to reflect its retirement.",
          "misconception": "Targets [documentation vs. removal confusion]: Documentation updates are important but do not remove the active threat."
        },
        {
          "text": "Archiving the API's source code in a secure repository.",
          "misconception": "Targets [archiving vs. removal confusion]: Archiving code is good practice but doesn't disable the live, running API."
        },
        {
          "text": "Notifying all known users about the upcoming deprecation.",
          "misconception": "Targets [notification vs. removal confusion]: Notification is part of deprecation, but the API must still be removed to prevent it from becoming a zombie."
        }
      ],
      "detailed_explanation": {
        "core_logic": "To truly decommission an API and prevent it from becoming a zombie, it must be rendered inaccessible. This involves removing the live endpoint and any underlying infrastructure that keeps it running, as well as revoking associated access credentials. Simply documenting or archiving does not eliminate the active security risk.",
        "distractor_analysis": "The distractors focus on documentation, code archiving, or user notification, which are supporting activities but do not achieve the critical step of disabling the live API service.",
        "analogy": "Decommissioning an API is like demolishing an old building; you can't just put up a 'closed' sign or take photos of it. You must physically remove the structure to ensure it's no longer a hazard."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "API_DECOMMISSIONING",
        "API_LIFECYCLE_MANAGEMENT"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 16,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Zombie API Identification 008_Application Security best practices",
    "latency_ms": 24133.046
  },
  "timestamp": "2026-01-18T12:40:10.825687"
}