{
  "topic_title": "API Hiding",
  "category": "008_Application Security - Mobile 008_Application Security",
  "flashcards": [
    {
      "question_text": "According to NIST SP 800-228, what is a primary goal of API protection in cloud-native systems?",
      "correct_answer": "To identify and mitigate risks throughout the API lifecycle.",
      "distractors": [
        {
          "text": "To ensure all APIs use the latest TLS versions exclusively.",
          "misconception": "Targets [scope confusion]: Focuses on a single control rather than the lifecycle risk management."
        },
        {
          "text": "To eliminate the need for API authentication entirely.",
          "misconception": "Targets [fundamental security principle violation]: API authentication is critical, not to be eliminated."
        },
        {
          "text": "To mandate the use of specific proprietary API gateways.",
          "misconception": "Targets [vendor lock-in misconception]: NIST provides guidelines, not mandates specific vendor products."
        }
      ],
      "detailed_explanation": {
        "core_logic": "NIST SP 800-228 emphasizes identifying and analyzing risks across the API lifecycle and developing controls, because secure API deployment is critical for enterprise security.",
        "distractor_analysis": "The first distractor narrows the focus to a single technical control, the second suggests removing a core security mechanism, and the third implies a vendor-specific mandate, all misrepresenting NIST's lifecycle risk-based approach.",
        "analogy": "Think of NIST SP 800-228 as a comprehensive health check for your APIs, looking for potential issues from development to runtime, rather than just prescribing a single medicine."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "API_SECURITY_BASICS",
        "NIST_SP_800_228"
      ]
    },
    {
      "question_text": "What is the primary risk associated with exposing sensitive business flows via APIs, as highlighted by the OWASP API Security Top 10 (2023)?",
      "correct_answer": "Unrestricted Access to Sensitive Business Flows (API6:2023), leading to potential business harm if used excessively.",
      "distractors": [
        {
          "text": "Broken Object Level Authorization (API1:2023) due to improper ID handling.",
          "misconception": "Targets [misplaced risk identification]: While a critical API risk, it's distinct from business flow abuse."
        },
        {
          "text": "Security Misconfiguration (API8:2023) in the API gateway settings.",
          "misconception": "Targets [incorrect risk category]: Misconfiguration is a broad category, not specific to business flow abuse."
        },
        {
          "text": "Server-Side Request Forgery (API7:2023) by manipulating resource URIs.",
          "misconception": "Targets [unrelated vulnerability]: SSRF involves fetching remote resources, not abusing business logic."
        }
      ],
      "detailed_explanation": {
        "core_logic": "APIs vulnerable to API6:2023 can be abused through excessive automated use of business functions, causing harm, because the API lacks compensating controls for such usage patterns.",
        "distractor_analysis": "Each distractor points to a different OWASP API Security Top 10 risk, but API6 specifically addresses the abuse of legitimate business processes through excessive or automated calls, not authorization, configuration, or SSRF vulnerabilities.",
        "analogy": "It's like having a turnstile at an event that only checks if you have a ticket, but doesn't stop someone from running through it hundreds of times, potentially disrupting the event."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "OWASP_API_SECURITY_TOP_10",
        "API_BUSINESS_LOGIC"
      ]
    },
    {
      "question_text": "In the context of securing HTTP-based APIs, what is the fundamental difference between API authentication and API authorization?",
      "correct_answer": "Authentication verifies the identity of the requester, while authorization determines what actions they are permitted to perform.",
      "distractors": [
        {
          "text": "Authentication grants access to resources, while authorization logs user activity.",
          "misconception": "Targets [role confusion]: Reverses the primary functions of authentication and authorization."
        },
        {
          "text": "Authentication is performed by the API gateway, while authorization is handled by the backend service.",
          "misconception": "Targets [implementation detail vs. concept]: Both can be handled at various layers, not strictly defined by location."
        },
        {
          "text": "Authentication ensures data confidentiality, while authorization ensures data integrity.",
          "misconception": "Targets [security property confusion]: Mixes identity/access control with data security properties."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Authentication confirms 'who you are' (identity verification), often using credentials or tokens. Authorization then checks 'what you can do' based on that verified identity, because access control policies are applied after identity is established.",
        "distractor_analysis": "The first distractor swaps the core functions. The second incorrectly assigns strict, universal locations for these processes. The third conflates identity/access control with data security goals like confidentiality and integrity.",
        "analogy": "Authentication is like showing your ID at a club entrance to prove you're old enough. Authorization is like the bouncer then deciding if you can go into the VIP section based on your membership status."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "API_SECURITY_BASICS",
        "AUTHENTICATION_VS_AUTHORIZATION"
      ]
    },
    {
      "question_text": "Which NIST SP 800-228 recommendation directly addresses the risk of attackers manipulating API requests by altering user-supplied URIs?",
      "correct_answer": "Implementing controls to validate user-supplied URIs in API requests.",
      "distractors": [
        {
          "text": "Enforcing strict rate limiting on all API endpoints.",
          "misconception": "Targets [unrelated control]: Rate limiting addresses resource consumption, not URI manipulation."
        },
        {
          "text": "Using strong encryption for all API data in transit.",
          "misconception": "Targets [misapplied solution]: Encryption protects data confidentiality, not the validity of request targets."
        },
        {
          "text": "Implementing robust input validation for all API parameters.",
          "misconception": "Targets [insufficient control]: While important, 'input validation' is broad; URI validation is a specific, critical subset for SSRF-like risks."
        }
      ],
      "detailed_explanation": {
        "core_logic": "NIST SP 800-228, in line with OWASP API7:2023 (SSRF), recommends validating user-supplied URIs because this directly prevents attackers from coercing the API to make unintended requests to external or internal resources.",
        "distractor_analysis": "Rate limiting and encryption are important API security measures but do not directly prevent SSRF-like attacks. Broad input validation is necessary but insufficient without specific URI validation.",
        "analogy": "This is like ensuring the address on a package you're sending is correctly formatted and points to a valid location, rather than just checking if the package is sealed or if the sender is known."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "NIST_SP_800_228",
        "OWASP_API_SECURITY_TOP_10",
        "SSRF_VULNERABILITIES"
      ]
    },
    {
      "question_text": "What is the core principle behind 'API Hiding' in the context of code obfuscation and resilience against reverse engineering?",
      "correct_answer": "Making the API's internal logic and implementation details difficult to understand or reconstruct.",
      "distractors": [
        {
          "text": "Completely removing all API endpoints to prevent access.",
          "misconception": "Targets [misunderstanding of 'hiding']: Hiding refers to obfuscation, not complete removal of functionality."
        },
        {
          "text": "Encrypting all API requests and responses with strong algorithms.",
          "misconception": "Targets [confusion with data protection]: Encryption protects data confidentiality, while hiding protects implementation logic."
        },
        {
          "text": "Implementing strict authentication and authorization checks.",
          "misconception": "Targets [confusion with access control]: These controls manage access, not the difficulty of reverse-engineering the code."
        }
      ],
      "detailed_explanation": {
        "core_logic": "API Hiding, through techniques like code obfuscation, aims to deter reverse engineering by making the underlying code complex and unintelligible, because understanding the implementation is often the first step in finding vulnerabilities.",
        "distractor_analysis": "The distractors confuse API hiding with complete functional removal, data encryption, or access control mechanisms, none of which directly address the goal of making the code itself difficult to reverse-engineer.",
        "analogy": "It's like scrambling a recipe's instructions with confusing language and symbols, making it hard for someone to figure out exactly how to bake the cake, even if they can see the ingredients."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CODE_OBFUSCATION",
        "REVERSE_ENGINEERING_DEFENSE"
      ]
    },
    {
      "question_text": "Which OWASP API Security Top 10 risk (2023) directly relates to issues where APIs expose object identifiers, leading to unauthorized access to specific data objects?",
      "correct_answer": "API1:2023 - Broken Object Level Authorization",
      "distractors": [
        {
          "text": "API2:2023 - Broken Authentication",
          "misconception": "Targets [related but distinct risk]: Authentication is about verifying identity, not controlling access to specific objects."
        },
        {
          "text": "API5:2023 - Broken Function Level Authorization",
          "misconception": "Targets [incorrect scope]: This concerns access to functions/actions, not specific data objects."
        },
        {
          "text": "API8:2023 - Security Misconfiguration",
          "misconception": "Targets [general category]: While misconfiguration can cause this, the specific risk is object-level authorization."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Broken Object Level Authorization (API1:2023) occurs because APIs often handle object identifiers, and without proper checks, attackers can manipulate these IDs to access data they shouldn't, since authorization must be enforced at the individual object level.",
        "distractor_analysis": "The distractors represent other critical OWASP API security risks. Broken Authentication deals with identity verification, Broken Function Level Authorization deals with permissions for actions, and Security Misconfiguration is a broader category.",
        "analogy": "Imagine a library where each book has a unique ID. Broken Object Level Authorization is like being able to use the ID of a restricted book (e.g., a rare manuscript) to check it out, even if you don't have special permission."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "OWASP_API_SECURITY_TOP_10",
        "OBJECT_LEVEL_AUTHORIZATION"
      ]
    },
    {
      "question_text": "How does code obfuscation contribute to 'API Hiding' and resilience against reverse engineering?",
      "correct_answer": "It transforms the code into a complex, difficult-to-understand format, hindering analysis.",
      "distractors": [
        {
          "text": "It removes all comments and variable names from the source code.",
          "misconception": "Targets [incomplete obfuscation]: This is a minor part of obfuscation, not the core mechanism."
        },
        {
          "text": "It encrypts the API's communication channels.",
          "misconception": "Targets [confusion with data protection]: Encryption protects data in transit, not the code's understandability."
        },
        {
          "text": "It automatically patches known vulnerabilities in the API.",
          "misconception": "Targets [misunderstanding of purpose]: Obfuscation is about hiding logic, not vulnerability patching."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Code obfuscation makes the API's implementation harder to reverse-engineer by applying transformations like renaming, control flow flattening, and dead code insertion, because the goal is to obscure the original logic and make analysis time-consuming and error-prone.",
        "distractor_analysis": "The distractors describe unrelated security measures (encryption, patching) or a superficial aspect of obfuscation (removing comments/names) rather than the core mechanism of making code complex and unintelligible.",
        "analogy": "It's like taking a clear instruction manual and rewriting it using a mix of different languages, complex jargon, and deliberately confusing sentence structures, making it very hard to follow the steps."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "CODE_OBFUSCATION",
        "REVERSE_ENGINEERING_DEFENSE"
      ]
    },
    {
      "question_text": "According to NIST SP 800-228, what is a key consideration for API protection in cloud-native environments regarding the API lifecycle?",
      "correct_answer": "Identifying and analyzing risks during both the development (pre-runtime) and operational (runtime) phases.",
      "distractors": [
        {
          "text": "Focusing solely on runtime security controls after deployment.",
          "misconception": "Targets [incomplete lifecycle view]: Neglects crucial pre-runtime (development) security considerations."
        },
        {
          "text": "Implementing basic authentication for all internal APIs.",
          "misconception": "Targets [insufficient control]: Basic authentication is often inadequate, and the focus is broader risk management."
        },
        {
          "text": "Ensuring APIs are only accessible from within the corporate network.",
          "misconception": "Targets [outdated security model]: Cloud-native APIs often require external access, necessitating different security paradigms."
        }
      ],
      "detailed_explanation": {
        "core_logic": "NIST SP 800-228 emphasizes a comprehensive approach to API protection that spans the entire lifecycle, from design and development (pre-runtime) through deployment and operation (runtime), because vulnerabilities can be introduced and exploited at any stage.",
        "distractor_analysis": "The distractors represent incomplete or incorrect security strategies: focusing only on runtime ignores development risks, basic authentication is often insufficient, and restricting access solely to internal networks is not always feasible or secure for cloud-native architectures.",
        "analogy": "It's like building a house: you need to consider the foundation (pre-runtime) as much as the locks on the doors (runtime) to ensure overall safety and security."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "NIST_SP_800_228",
        "API_LIFECYCLE_SECURITY"
      ]
    },
    {
      "question_text": "What is the primary security concern addressed by API3:2023 (Broken Object Property Level Authorization) in the OWASP API Security Top 10?",
      "correct_answer": "Unauthorized access to or modification of specific properties within an API object.",
      "distractors": [
        {
          "text": "Exposure of entire sensitive objects due to improper ID handling.",
          "misconception": "Targets [confusing with API1]: API1 deals with entire object access, while API3 focuses on specific properties within objects."
        },
        {
          "text": "Incorrectly assigned permissions for API functions or operations.",
          "misconception": "Targets [confusing with API5]: API5 addresses function-level authorization, not property-level access control."
        },
        {
          "text": "Lack of proper input validation for API request parameters.",
          "misconception": "Targets [unrelated vulnerability]: Input validation is crucial but distinct from authorization checks on object properties."
        }
      ],
      "detailed_explanation": {
        "core_logic": "API3:2023 addresses scenarios where an API might allow a user to read or write specific fields (properties) of an object they shouldn't have access to, even if they can access the object itself, because authorization checks are not granular enough.",
        "distractor_analysis": "The distractors confuse API3 with API1 (object-level access), API5 (function-level access), or general input validation, failing to recognize the specific focus on granular property-level authorization within an object.",
        "analogy": "Imagine a user profile object. API3 is like allowing a user to change their 'email address' property but not their 'account balance' property, even though they can view the whole profile."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "OWASP_API_SECURITY_TOP_10",
        "PROPERTY_LEVEL_AUTHORIZATION"
      ]
    },
    {
      "question_text": "Which technique is commonly used for 'API Hiding' to make code harder to reverse-engineer, as discussed in the context of resilience against reverse engineering?",
      "correct_answer": "Control flow obfuscation",
      "distractors": [
        {
          "text": "Data encryption",
          "misconception": "Targets [confusion with data protection]: Encrypts data in transit/rest, not the code's logic structure."
        },
        {
          "text": "Input validation",
          "misconception": "Targets [confusion with input sanitization]: Prevents injection attacks, does not obscure code logic."
        },
        {
          "text": "Rate limiting",
          "misconception": "Targets [confusion with resource management]: Controls request frequency, not code understandability."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Control flow obfuscation restructures the code's execution path, making it non-linear and difficult to follow, which is a key technique for 'API Hiding' because it significantly increases the effort required for reverse engineering.",
        "distractor_analysis": "Data encryption, input validation, and rate limiting are important security practices but serve different purposes than obscuring code logic for reverse engineering resilience.",
        "analogy": "It's like taking a straight road and replacing it with a maze of confusing turns, dead ends, and loops, making it extremely difficult to navigate from start to finish."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "CODE_OBFUSCATION",
        "REVERSE_ENGINEERING_DEFENSE"
      ]
    },
    {
      "question_text": "According to the NCSC guidance on securing HTTP-based APIs, what is a best practice for API authentication?",
      "correct_answer": "Use tokens issued by an identity provider for applications interacting on behalf of users.",
      "distractors": [
        {
          "text": "Share user credentials directly between the application and the API.",
          "misconception": "Targets [insecure credential handling]: Sharing user credentials directly is a major security risk."
        },
        {
          "text": "Implement authentication solely through API keys.",
          "misconception": "Targets [limited scope]: API keys are one method, but often insufficient, especially for user-delegated access."
        },
        {
          "text": "Rely on IP address whitelisting for all access.",
          "misconception": "Targets [outdated/weak control]: IP whitelisting is easily bypassed and not a robust authentication method."
        }
      ],
      "detailed_explanation": {
        "core_logic": "For applications acting on behalf of users, using tokens generated via an identity provider is a secure practice because it avoids direct credential sharing and allows for temporary, scoped access, aligning with modern authentication patterns.",
        "distractor_analysis": "Sharing credentials directly is insecure. Relying solely on API keys or IP whitelisting are often insufficient or easily bypassed methods for robust authentication, especially in complex scenarios.",
        "analogy": "Instead of giving your house key to a friend to pick up mail for you, you give them a temporary access code for the mailbox only, which is safer and easier to revoke."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "NCSC_API_SECURITY",
        "API_AUTHENTICATION"
      ]
    },
    {
      "question_text": "What does NIST SP 800-228 suggest regarding the implementation of API protection controls?",
      "correct_answer": "Adopt an incremental, risk-based approach to adopting controls.",
      "distractors": [
        {
          "text": "Implement all recommended controls simultaneously.",
          "misconception": "Targets [unrealistic implementation]: Ignores the practical challenges and cost of immediate, full implementation."
        },
        {
          "text": "Prioritize advanced controls over basic ones.",
          "misconception": "Targets [incorrect prioritization]: Basic controls are foundational and often must be in place first."
        },
        {
          "text": "Only implement controls that are mandated by regulations.",
          "misconception": "Targets [compliance vs. security]: Focuses solely on minimum compliance rather than comprehensive risk reduction."
        }
      ],
      "detailed_explanation": {
        "core_logic": "NIST SP 800-228 advocates for an incremental, risk-based approach because it allows organizations to prioritize and implement controls based on their specific threat landscape and resources, making security adoption more manageable and effective.",
        "distractor_analysis": "Implementing all controls at once is often impractical. Prioritizing advanced over basic controls can leave foundational gaps. Focusing only on regulations might miss critical risks not covered by compliance mandates.",
        "analogy": "It's like renovating a house: you tackle the most critical issues first (like structural problems) and gradually upgrade other areas based on budget and priority, rather than trying to do everything at once."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "NIST_SP_800_228",
        "RISK_BASED_SECURITY"
      ]
    },
    {
      "question_text": "Which OWASP API Security Top 10 risk (2023) is most closely related to the concept of 'API Hiding' through code obfuscation?",
      "correct_answer": "API8:2023 - Security Misconfiguration",
      "distractors": [
        {
          "text": "API1:2023 - Broken Object Level Authorization",
          "misconception": "Targets [unrelated risk]: This concerns access control to data objects, not code protection."
        },
        {
          "text": "API2:2023 - Broken Authentication",
          "misconception": "Targets [unrelated risk]: This concerns identity verification, not code obfuscation."
        },
        {
          "text": "API7:2023 - Server Side Request Forgery",
          "misconception": "Targets [unrelated risk]: This concerns manipulating server requests, not hiding implementation details."
        }
      ],
      "detailed_explanation": {
        "core_logic": "While not a direct match, 'API Hiding' through code obfuscation can be considered a form of security misconfiguration if it's improperly implemented or relies on weak obfuscation techniques, as it's a configuration choice that impacts security posture against reverse engineering.",
        "distractor_analysis": "The other distractors represent distinct, critical API security risks that are not directly related to the concept of hiding or obfuscating the API's underlying code.",
        "analogy": "It's like choosing to leave a valuable item in plain sight but locking the room it's in. The item (API logic) is still visible, but the 'configuration' (obfuscation) makes it harder to access or understand."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "OWASP_API_SECURITY_TOP_10",
        "CODE_OBFUSCATION",
        "SECURITY_MISCONFIGURATION"
      ]
    },
    {
      "question_text": "What is the purpose of implementing 'API Hiding' techniques like code obfuscation in mobile applications?",
      "correct_answer": "To deter attackers from understanding the API's logic and finding vulnerabilities.",
      "distractors": [
        {
          "text": "To improve the API's performance and reduce latency.",
          "misconception": "Targets [unrelated benefit]: Obfuscation typically adds overhead, not performance improvements."
        },
        {
          "text": "To ensure the confidentiality of data transmitted by the API.",
          "misconception": "Targets [confusion with encryption]: Data confidentiality is achieved through encryption, not code hiding."
        },
        {
          "text": "To automatically patch security vulnerabilities in the API.",
          "misconception": "Targets [misunderstanding of function]: Obfuscation does not fix vulnerabilities; it hides the code."
        }
      ],
      "detailed_explanation": {
        "core_logic": "API Hiding through code obfuscation serves to make the API's internal workings opaque, thereby increasing the difficulty and cost for attackers to reverse-engineer the code and discover exploitable vulnerabilities, because understanding the logic is a prerequisite for many attacks.",
        "distractor_analysis": "The distractors incorrectly attribute performance improvements, data confidentiality (which is encryption's role), or vulnerability patching to code obfuscation, missing its primary purpose of hindering reverse engineering.",
        "analogy": "It's like writing a secret message in a complex code that requires a special decoder ring to read, making it hard for anyone without the decoder to understand the message's content."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "CODE_OBFUSCATION",
        "REVERSE_ENGINEERING_DEFENSE"
      ]
    },
    {
      "question_text": "According to the NCSC guidance, when applications interact with APIs on behalf of users, what is a recommended secure approach for authentication?",
      "correct_answer": "The user authenticates through an identity provider, generating temporary credentials for the application.",
      "distractors": [
        {
          "text": "The application directly requests and stores the user's primary login credentials.",
          "misconception": "Targets [insecure credential management]: Storing and using primary user credentials directly is highly insecure."
        },
        {
          "text": "A static, shared API key is used for all user-initiated requests.",
          "misconception": "Targets [weak authentication mechanism]: Static keys lack user context and are prone to compromise."
        },
        {
          "text": "The API relies solely on the client's IP address for authentication.",
          "misconception": "Targets [insufficient authentication factor]: IP addresses are unreliable and easily spoofed for authentication."
        }
      ],
      "detailed_explanation": {
        "core_logic": "This approach, often involving protocols like OAuth 2.0, allows the application to obtain temporary tokens (e.g., access tokens) after the user securely authenticates with an identity provider, because it avoids exposing the user's main credentials to the application.",
        "distractor_analysis": "Directly handling user credentials, using static shared keys, or relying solely on IP addresses are all insecure methods that fail to provide proper user context or protection against credential theft and impersonation.",
        "analogy": "It's like using a valet key for your car: you give the valet a special key that only allows them to drive the car, not access your trunk or glove compartment, and you can easily get it back."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "NCSC_API_SECURITY",
        "API_AUTHENTICATION",
        "IDENTITY_PROVIDERS"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "API Hiding 008_Application Security best practices",
    "latency_ms": 23989.358
  },
  "timestamp": "2026-01-18T12:30:15.866849",
  "_av_safe_encoded": true,
  "_encoding_note": "Educational content encoded with HTML entities to prevent antivirus false positives. Content renders normally in Anki."
}