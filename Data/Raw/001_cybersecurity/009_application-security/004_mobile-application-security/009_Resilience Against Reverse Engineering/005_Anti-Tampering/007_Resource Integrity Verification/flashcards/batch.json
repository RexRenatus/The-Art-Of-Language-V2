{
  "topic_title": "Resource Integrity Verification",
  "category": "008_Application Security - Mobile 008_Application Security",
  "flashcards": [
    {
      "question_text": "What is the primary security goal of Subresource Integrity (SRI)?",
      "correct_answer": "To ensure that fetched resources (like scripts or stylesheets) have not been tampered with during transit or from compromised third-party hosts.",
      "distractors": [
        {
          "text": "To encrypt all resources loaded by a web page to protect confidentiality.",
          "misconception": "Targets [confidentiality vs integrity confusion]: Confuses the purpose of encryption with integrity checking."
        },
        {
          "text": "To verify the identity of the server hosting the resources using digital certificates.",
          "misconception": "Targets [identity vs integrity confusion]: Mixes SRI with TLS/SSL certificate validation."
        },
        {
          "text": "To enforce access control policies for external resources loaded by a web page.",
          "misconception": "Targets [access control vs integrity confusion]: Confuses integrity checking with authorization mechanisms."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI works by comparing a cryptographic hash of a fetched resource against a known, trusted hash provided by the developer. This ensures integrity because if the resource is altered, the hash will not match, preventing its execution.",
        "distractor_analysis": "The distractors incorrectly suggest SRI's purpose is confidentiality, server identity verification, or access control, rather than ensuring the resource's content hasn't changed.",
        "analogy": "SRI is like a tamper-evident seal on a package; it doesn't hide what's inside, but it tells you if someone has opened or altered the package before you received it."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_HASH_BASICS",
        "WEB_SECURITY_FUNDAMENTALS"
      ]
    },
    {
      "question_text": "How does Subresource Integrity (SRI) achieve its security goal?",
      "correct_answer": "By embedding a cryptographic hash (e.g., SHA-384, SHA-512) of the resource within the HTML tag (e.g., &lt;script&gt;, &lt;link&gt;) using the <code>integrity</code> attribute.",
      "distractors": [
        {
          "text": "By requiring all external resources to be served over HTTPS.",
          "misconception": "Targets [protocol vs mechanism confusion]: Confuses SRI with the general security of HTTPS."
        },
        {
          "text": "By using digital signatures embedded in the resource's metadata.",
          "misconception": "Targets [signature vs hash confusion]: Mixes SRI's hash-based approach with signature verification."
        },
        {
          "text": "By implementing a Content Security Policy (CSP) that whitelists specific resource URLs.",
          "misconception": "Targets [policy vs integrity confusion]: Confuses SRI with CSP, which controls resource origins, not content integrity."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI functions by embedding a base64-encoded cryptographic hash of the resource's content into the <code>integrity</code> attribute of the HTML tag. The browser calculates the hash of the fetched resource and compares it to the provided hash; a mismatch prevents loading.",
        "distractor_analysis": "Distractors incorrectly attribute SRI's mechanism to HTTPS, digital signatures, or CSP, which are related but distinct security measures.",
        "analogy": "It's like providing a unique fingerprint for a document. If the document you receive doesn't match the fingerprint you were given, you know it's been altered."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "SRI_BASICS",
        "WEB_SECURITY_FUNDAMENTALS"
      ]
    },
    {
      "question_text": "Which cryptographic hash algorithms are commonly supported for Subresource Integrity (SRI)?",
      "correct_answer": "SHA-256, SHA-384, and SHA-512.",
      "distractors": [
        {
          "text": "MD5 and SHA-1",
          "misconception": "Targets [outdated algorithms]: Uses algorithms known to be cryptographically weak and unsuitable for integrity checks."
        },
        {
          "text": "AES and RSA",
          "misconception": "Targets [encryption vs hashing confusion]: Lists symmetric and asymmetric encryption algorithms, not hashing algorithms."
        },
        {
          "text": "SHA-3 and BLAKE2",
          "misconception": "Targets [algorithm support confusion]: Lists newer, less commonly supported (for SRI) hash functions."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI relies on strong, collision-resistant hash functions to ensure integrity. SHA-256, SHA-384, and SHA-512 are widely supported and considered secure for this purpose, providing robust checks against tampering.",
        "distractor_analysis": "The distractors propose cryptographically weak algorithms (MD5, SHA-1) or algorithms used for encryption (AES, RSA) instead of appropriate hashing algorithms, or newer hashes not yet widely adopted for SRI.",
        "analogy": "These are like different types of locks you can use to secure a box. SHA-256, SHA-384, and SHA-512 are the strong, modern locks that SRI uses, while MD5/SHA-1 are old, easily picked locks."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CRYPTO_HASH_BASICS",
        "SRI_BASICS"
      ]
    },
    {
      "question_text": "Consider a scenario where a website loads a JavaScript file from a Content Delivery Network (CDN). If the CDN is compromised and the JavaScript file is replaced with malicious code, how does SRI help mitigate this attack?",
      "correct_answer": "The browser will calculate the hash of the compromised JavaScript file and find that it does not match the hash specified in the <code>integrity</code> attribute, causing the browser to refuse to load the malicious script.",
      "distractors": [
        {
          "text": "The browser will detect the malicious code through signature analysis and block it.",
          "misconception": "Targets [signature vs hash confusion]: Misunderstands SRI as a signature-based malware scanner."
        },
        {
          "text": "The HTTPS connection will prevent the CDN from serving the modified file.",
          "misconception": "Targets [HTTPS vs integrity confusion]: Assumes HTTPS alone prevents content modification, which is incorrect for compromised servers."
        },
        {
          "text": "The browser will prompt the user to confirm loading the potentially modified script.",
          "misconception": "Targets [user interaction vs automated check confusion]: Incorrectly assumes SRI involves user intervention rather than automated blocking."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI provides a critical defense against compromised CDNs because it verifies the *content* of the resource, not just its origin or transport security. Since the hash won't match, the browser's built-in security mechanism prevents the malicious script from executing.",
        "distractor_analysis": "The distractors misrepresent SRI's mechanism, suggesting it uses signature analysis, relies solely on HTTPS (which doesn't protect against compromised servers), or involves user interaction.",
        "analogy": "It's like having a unique serial number for a specific edition of a book. If you receive a book with a different serial number, you know it's not the correct edition, even if it looks similar."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "analyze",
      "prerequisites": [
        "SRI_BASICS",
        "WEB_ATTACKS_CDN_COMPROMISE"
      ]
    },
    {
      "question_text": "What is the role of the <code>crossorigin</code> attribute when using Subresource Integrity (SRI)?",
      "correct_answer": "It is required when loading resources from a different origin (domain) to ensure the browser performs CORS checks, which is a prerequisite for SRI verification.",
      "distractors": [
        {
          "text": "It encrypts the resource before it is fetched by the browser.",
          "misconception": "Targets [encryption vs CORS confusion]: Confuses the purpose of `crossorigin` with encryption."
        },
        {
          "text": "It specifies the cryptographic algorithm used for the integrity hash.",
          "misconception": "Targets [attribute confusion]: Mixes the function of `crossorigin` with the `integrity` attribute's algorithm prefix."
        },
        {
          "text": "It allows the browser to cache the resource for faster loading.",
          "misconception": "Targets [caching vs security confusion]: Attributes a caching function to a security-related attribute."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>crossorigin</code> attribute, when set to <code>anonymous</code> or <code>use-credentials</code>, is essential for SRI because it signals to the browser that the resource is from a different origin. This triggers Cross-Origin Resource Sharing (CORS) checks, which are necessary for the browser to securely verify the integrity of cross-origin resources.",
        "distractor_analysis": "Distractors incorrectly associate <code>crossorigin</code> with encryption, algorithm specification, or caching, rather than its role in enabling CORS checks for cross-origin SRI.",
        "analogy": "Think of <code>crossorigin</code> as showing your ID at a border crossing. It's a necessary step to prove you're allowed to bring goods (resources) from another country (domain) into yours, before they check if the goods themselves are legitimate (integrity)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SRI_BASICS",
        "CORS_BASICS"
      ]
    },
    {
      "question_text": "What is a potential drawback of implementing Subresource Integrity (SRI)?",
      "correct_answer": "Updating a resource on a CDN requires updating the hash in the HTML, which can be cumbersome if not automated, potentially leading to broken sites if hashes are not synchronized.",
      "distractors": [
        {
          "text": "SRI significantly increases the latency of loading web pages.",
          "misconception": "Targets [performance impact confusion]: Overstates the performance impact, as hash calculation is generally fast."
        },
        {
          "text": "SRI is not compatible with modern JavaScript frameworks.",
          "misconception": "Targets [compatibility confusion]: Incorrectly claims incompatibility with modern web development practices."
        },
        {
          "text": "SRI only protects against accidental corruption, not malicious attacks.",
          "misconception": "Targets [scope of protection confusion]: Misunderstands that SRI is effective against both accidental and malicious tampering."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The primary challenge with SRI is managing hash updates. Since SRI locks a resource to a specific hash, any update to that resource (even a legitimate security patch) requires updating the hash in the HTML. Failure to do so breaks the site because the browser rejects the new version.",
        "distractor_analysis": "The distractors incorrectly claim significant performance degradation, incompatibility with modern frameworks, or that SRI only protects against accidental corruption.",
        "analogy": "It's like having a specific key for a specific lock. If you change the lock, you need a new key. If you forget to update the key (hash) when you change the lock (resource), the old key won't work anymore."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SRI_BASICS",
        "CDN_MANAGEMENT"
      ]
    },
    {
      "question_text": "Which of the following is NOT a recommended practice when implementing Subresource Integrity (SRI)?",
      "correct_answer": "Using outdated and cryptographically weak hash algorithms like MD5 or SHA-1.",
      "distractors": [
        {
          "text": "Loading resources from a CDN using HTTPS.",
          "misconception": "Targets [best practice confusion]: Suggests a secure transport protocol is not recommended, which is false."
        },
        {
          "text": "Specifying multiple hashes for a single resource in the <code>integrity</code> attribute.",
          "misconception": "Targets [feature misuse confusion]: Implies a valid feature (fallback hashes) is not recommended."
        },
        {
          "text": "Using the <code>crossorigin=&quot;anonymous&quot;</code> attribute for cross-origin resources.",
          "misconception": "Targets [prerequisite confusion]: Suggests a necessary attribute for cross-origin SRI is not recommended."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI relies on strong cryptographic hashes to ensure integrity. Using weak algorithms like MD5 or SHA-1 defeats the purpose because they are susceptible to collision attacks, making them unreliable for detecting tampering. Therefore, using them is a critical anti-pattern.",
        "distractor_analysis": "The distractors present valid SRI practices (HTTPS, multiple hashes, <code>crossorigin</code>) as not recommended, while the correct answer identifies a clear security anti-pattern.",
        "analogy": "It's like recommending you use a flimsy, easily breakable lock (MD5/SHA-1) to secure your valuables instead of a strong, modern one."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "evaluate",
      "prerequisites": [
        "SRI_BASICS",
        "CRYPTO_HASH_STRENGTH"
      ]
    },
    {
      "question_text": "What is the purpose of the <code>integrity</code> attribute in a &lt;script&gt; tag when using SRI?",
      "correct_answer": "It holds the cryptographic hash(es) of the script file that the browser must match for the script to be considered trustworthy and executed.",
      "distractors": [
        {
          "text": "It specifies the URL from which the script should be loaded.",
          "misconception": "Targets [attribute confusion]: Confuses the `integrity` attribute with the `src` attribute."
        },
        {
          "text": "It defines the execution environment for the script.",
          "misconception": "Targets [execution context confusion]: Attributes a role related to sandboxing or execution context to the integrity attribute."
        },
        {
          "text": "It indicates the script's compatibility with different browsers.",
          "misconception": "Targets [compatibility vs integrity confusion]: Mixes integrity checking with browser compatibility information."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>integrity</code> attribute is the core of SRI. It contains the cryptographic fingerprint of the expected resource. Because the browser calculates the hash of the fetched resource and compares it, this attribute directly enforces the integrity verification mechanism.",
        "distractor_analysis": "The distractors incorrectly assign the functions of the <code>src</code> attribute, execution environment controls, or browser compatibility checks to the <code>integrity</code> attribute.",
        "analogy": "The <code>integrity</code> attribute is like a unique serial number printed on a product's packaging. The <code>src</code> attribute is the address where you get the product, and the <code>integrity</code> attribute is the check to ensure the product inside matches the one you expected."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SRI_BASICS",
        "HTML_TAGS"
      ]
    },
    {
      "question_text": "How can a developer generate the necessary hash for the <code>integrity</code> attribute?",
      "correct_answer": "Using command-line tools like <code>openssl</code> or <code>shasum</code> to calculate the hash of the resource file, and then base64-encoding the result.",
      "distractors": [
        {
          "text": "By inspecting the network traffic logs of the CDN.",
          "misconception": "Targets [information source confusion]: Suggests hashes can be reliably obtained from network logs, which is not how SRI hashes are generated."
        },
        {
          "text": "By using a browser's developer console to read the file's properties.",
          "misconception": "Targets [tool misuse confusion]: Incorrectly assumes browser developer tools can directly provide SRI-compatible hashes."
        },
        {
          "text": "By asking the CDN provider to send the hash via email.",
          "misconception": "Targets [process simplification confusion]: Over-simplifies the process and ignores the need for programmatic generation or verification."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Generating SRI hashes involves using standard cryptographic tools to compute the hash of the resource file (e.g., <code>openssl dgst -sha384 -binary &lt;file&gt; | openssl base64 -A</code>). This process ensures the developer has the correct, verifiable hash for the <code>integrity</code> attribute.",
        "distractor_analysis": "The distractors propose unreliable or incorrect methods for obtaining SRI hashes, such as relying on network logs, browser tools, or manual requests, instead of programmatic generation.",
        "analogy": "It's like creating a unique wax seal impression for a document. You use a specific tool (openssl/shasum) and process (base64 encoding) to create the official seal (hash) that others can use to verify the document's authenticity."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "SRI_BASICS",
        "COMMAND_LINE_TOOLS"
      ]
    },
    {
      "question_text": "What is the relationship between Subresource Integrity (SRI) and Content Security Policy (CSP)?",
      "correct_answer": "SRI and CSP are complementary security mechanisms; CSP controls *where* resources can be loaded from, while SRI ensures the *integrity* of those loaded resources.",
      "distractors": [
        {
          "text": "CSP replaces the need for SRI by enforcing strict origin policies.",
          "misconception": "Targets [redundancy confusion]: Incorrectly assumes CSP makes SRI obsolete."
        },
        {
          "text": "SRI is a directive within CSP that specifies allowed hashes.",
          "misconception": "Targets [integration confusion]: Misunderstands how SRI and CSP function as separate, albeit related, security controls."
        },
        {
          "text": "They are mutually exclusive; a site can implement either SRI or CSP, but not both.",
          "misconception": "Targets [exclusivity confusion]: Incorrectly claims that SRI and CSP cannot be used together."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CSP directives like <code>script-src</code> control the allowed sources for scripts, preventing loading from untrusted domains. SRI, applied to resources loaded from allowed sources, then verifies that the content of those resources has not been tampered with. They work together to provide layered security.",
        "distractor_analysis": "The distractors incorrectly suggest redundancy, integration, or exclusivity between SRI and CSP, rather than their complementary roles in web security.",
        "analogy": "CSP is like a bouncer at a club deciding who is allowed in (which domains). SRI is like a security check at the door for those allowed in, ensuring they aren't carrying anything dangerous (tampered content)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "SRI_BASICS",
        "CSP_BASICS"
      ]
    },
    {
      "question_text": "What does it mean for a resource to be 'tampered with' in the context of Subresource Integrity (SRI)?",
      "correct_answer": "The content of the resource has been altered in any way from its original, trusted state, whether maliciously or accidentally.",
      "distractors": [
        {
          "text": "The resource has been encrypted by an unauthorized party.",
          "misconception": "Targets [encryption vs modification confusion]: Confuses tampering with unauthorized encryption."
        },
        {
          "text": "The resource's file permissions have been changed.",
          "misconception": "Targets [scope of tampering confusion]: Focuses on file system metadata rather than content alteration."
        },
        {
          "text": "The resource has been moved to a different server.",
          "misconception": "Targets [location vs content confusion]: Confuses changing the resource's location with changing its content."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Tampering, in the context of SRI, refers specifically to any modification of the resource's actual bytes or content. This is detected because the cryptographic hash of the altered content will differ from the expected hash, thus failing the integrity check.",
        "distractor_analysis": "The distractors broaden the definition of 'tampering' to include encryption, file permission changes, or relocation, which are not the primary focus of SRI's content integrity verification.",
        "analogy": "Tampering is like changing the words in a printed contract after it's been signed. SRI ensures the contract you receive has the exact same words as the original signed version."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SRI_BASICS",
        "SECURITY_TERMINOLOGY"
      ]
    },
    {
      "question_text": "Why is it important for SRI hashes to be base64-encoded?",
      "correct_answer": "Base64 encoding ensures that the hash value can be safely represented and transmitted within HTML attributes, which have specific character set limitations.",
      "distractors": [
        {
          "text": "Base64 encoding encrypts the hash value for added security.",
          "misconception": "Targets [encoding vs encryption confusion]: Confuses encoding, which is for representation, with encryption, which is for confidentiality."
        },
        {
          "text": "Base64 encoding reduces the size of the hash for faster loading.",
          "misconception": "Targets [encoding efficiency confusion]: Incorrectly assumes base64 significantly reduces hash size; it actually increases it slightly."
        },
        {
          "text": "Base64 encoding is required by the W3C specification for all hash algorithms.",
          "misconception": "Targets [specification detail confusion]: Overgeneralizes a specific requirement for representation into a universal rule for all algorithms."
        }
      ],
      "detailed_explanation": {
        "core_logic": "HTML attributes can only reliably contain a limited set of characters. Base64 encoding converts the binary hash data into a string of ASCII characters (A-Z, a-z, 0-9, +, /), making it safe to embed directly into the <code>integrity</code> attribute without issues.",
        "distractor_analysis": "The distractors incorrectly claim base64 provides encryption, reduces size, or is universally required for all hash algorithms, rather than its role in safe representation within HTML.",
        "analogy": "It's like translating a message into a common language (like English) so that anyone can read it, regardless of their native tongue. Base64 translates the binary hash into a format (ASCII characters) that HTML can easily handle."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SRI_BASICS",
        "ENCODING_BASICS"
      ]
    },
    {
      "question_text": "What is the potential risk if a CDN provider updates a resource (e.g., a JavaScript library) without notifying the website owner, and the website owner has SRI enabled?",
      "correct_answer": "The website will break because the browser will refuse to load the updated resource, as its hash will not match the old hash specified in the <code>integrity</code> attribute.",
      "distractors": [
        {
          "text": "The browser will automatically update the <code>integrity</code> attribute to match the new resource.",
          "misconception": "Targets [automation confusion]: Incorrectly assumes browsers automatically update SRI hashes."
        },
        {
          "text": "The CDN will serve the old version of the resource alongside the new one.",
          "misconception": "Targets [serving mechanism confusion]: Misunderstands how CDNs serve files and how SRI interacts with this."
        },
        {
          "text": "The browser will ignore SRI for that resource and load it anyway.",
          "misconception": "Targets [SRI enforcement confusion]: Incorrectly assumes browsers will bypass SRI checks under certain conditions."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI's strength is its strictness. When a resource is updated on the CDN, its hash changes. Since the <code>integrity</code> attribute in the HTML still holds the old hash, the browser's integrity check fails, preventing the resource from loading and thus breaking the website's functionality.",
        "distractor_analysis": "The distractors propose scenarios where the browser or CDN magically handles the update, or where SRI is bypassed, contrary to its designed behavior.",
        "analogy": "It's like having a specific key for your house. If the locksmith changes the lock but gives you the old key, you won't be able to get in anymore. The website breaks because the 'key' (hash) no longer fits the 'lock' (resource)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "analyze",
      "prerequisites": [
        "SRI_BASICS",
        "CDN_MANAGEMENT",
        "WEB_BREAKAGE_SCENARIOS"
      ]
    },
    {
      "question_text": "What is the concept of 'supply chain integrity' in relation to Subresource Integrity (SRI)?",
      "correct_answer": "It refers to ensuring the trustworthiness and integrity of all components and resources used in the development and delivery of a web application, including third-party libraries and CDNs.",
      "distractors": [
        {
          "text": "It means encrypting the entire software supply chain to prevent eavesdropping.",
          "misconception": "Targets [confidentiality vs integrity confusion]: Equates supply chain integrity solely with confidentiality."
        },
        {
          "text": "It involves verifying the physical security of the servers hosting the supply chain components.",
          "misconception": "Targets [physical vs logical security confusion]: Focuses on physical security rather than the integrity of the code/data itself."
        },
        {
          "text": "It guarantees that all developers in the supply chain have passed background checks.",
          "misconception": "Targets [personnel vs code integrity confusion]: Focuses on developer vetting rather than the integrity of the delivered code."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI directly addresses supply chain integrity by allowing developers to verify that third-party resources (like scripts from CDNs) haven't been compromised. This prevents malicious code injection through the supply chain, ensuring the integrity of the application's components from their source to the user's browser.",
        "distractor_analysis": "The distractors misinterpret 'supply chain integrity' as focusing only on encryption, physical security, or personnel vetting, rather than the integrity of the code and data flowing through the chain.",
        "analogy": "Supply chain integrity is like ensuring every ingredient sourced for a meal is fresh and untainted, from the farm to the kitchen, so the final dish is safe and as intended."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SRI_BASICS",
        "SOFTWARE_SUPPLY_CHAIN_SECURITY"
      ]
    },
    {
      "question_text": "Can Subresource Integrity (SRI) protect against a compromised build server that injects malicious code into a self-hosted resource before it's deployed?",
      "correct_answer": "No, SRI primarily protects resources fetched from external origins (like CDNs). It does not inherently protect against tampering that occurs before deployment on resources hosted on the same origin.",
      "distractors": [
        {
          "text": "Yes, SRI verifies all resources regardless of their origin.",
          "misconception": "Targets [origin scope confusion]: Incorrectly assumes SRI applies universally to all resources, including self-hosted ones post-deployment."
        },
        {
          "text": "Yes, if the build server is also secured with HTTPS.",
          "misconception": "Targets [transport security vs content integrity confusion]: Confuses transport security (HTTPS) with content integrity verification."
        },
        {
          "text": "Yes, by using SRI on the HTML file itself, which references the compromised resource.",
          "misconception": "Targets [mechanism misunderstanding]: Incorrectly believes SRI on the HTML can detect tampering within the referenced resource itself if hosted locally."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI's core function is to verify resources fetched from a *different* origin than the document. If a resource is hosted on the same origin and compromised during the build process, SRI applied to that resource won't prevent its execution because the browser assumes same-origin resources are trusted by default in this context.",
        "distractor_analysis": "The distractors incorrectly extend SRI's scope to self-hosted resources compromised pre-deployment, or wrongly link its effectiveness to HTTPS or the integrity of the referencing HTML.",
        "analogy": "SRI is like checking the seal on a package delivered by a courier. It doesn't help if someone tampered with the contents *before* the courier even picked it up from your own workshop."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "evaluate",
      "prerequisites": [
        "SRI_BASICS",
        "APPLICATION_DEPLOYMENT_SECURITY"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Resource Integrity Verification 008_Application Security best practices",
    "latency_ms": 26489.155
  },
  "timestamp": "2026-01-18T12:29:45.668868"
}