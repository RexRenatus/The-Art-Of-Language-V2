{
  "topic_title": "IPC Permission Enforcement",
  "category": "008_Application Security - Mobile 008_Application Security",
  "flashcards": [
    {
      "question_text": "In Android, what is the primary mechanism for controlling access to sensitive data or actions when one app communicates with another via Inter-Process Communication (IPC)?",
      "correct_answer": "Defining and enforcing custom or system-defined permissions.",
      "distractors": [
        {
          "text": "Using only implicit intents with app choosers.",
          "misconception": "Targets [scope confusion]: Confuses intent mechanisms with permission enforcement for IPC."
        },
        {
          "text": "Relying solely on signature-based permissions between apps.",
          "misconception": "Targets [granularity error]: Signature permissions are one type, but not the sole or always appropriate mechanism for all IPC."
        },
        {
          "text": "Ensuring components are not exported by default.",
          "misconception": "Targets [prevention vs. control confusion]: Non-exported components prevent access, but permission enforcement controls access to exported components."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Android permissions are fundamental for IPC security because they act as gatekeepers, allowing apps to request and grant access to specific functionalities or data, thereby enforcing the principle of least privilege.",
        "distractor_analysis": "The first distractor focuses on intents, which are communication channels, not access control. The second limits it to signature permissions, which are specific. The third discusses preventing access rather than controlling it.",
        "analogy": "Think of Android permissions like security badges for different departments in a building. Each badge (permission) grants access to specific areas (data/actions) for authorized personnel (apps) communicating via internal phone lines (IPC)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "ANDROID_IPC",
        "ANDROID_PERMISSIONS"
      ]
    },
    {
      "question_text": "When an Android app defines a custom permission for its exported components, what is the recommended protection level to ensure only apps signed with the same certificate can use it?",
      "correct_answer": "signature",
      "distractors": [
        {
          "text": "normal",
          "misconception": "Targets [protection level confusion]: 'normal' permissions are granted automatically and don't restrict based on signing certificate."
        },
        {
          "text": "dangerous",
          "misconception": "Targets [risk assessment error]: 'dangerous' permissions require runtime user approval and are not suitable for same-developer IPC."
        },
        {
          "text": "signatureOrSystem",
          "misconception": "Targets [specificity error]: This level allows system apps or apps with the same signature, which is broader than intended for same-developer IPC."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'signature' protection level is used because it ensures that only apps signed with the exact same certificate as the app defining the permission can be granted it, thereby enforcing strict control between related applications.",
        "distractor_analysis": "The distractors represent common misunderstandings of Android permission protection levels: 'normal' is too permissive, 'dangerous' requires user consent, and 'signatureOrSystem' is too broad.",
        "analogy": "Using a 'signature' protection level for a custom permission is like having a unique, company-issued keycard that only works for specific doors within your own building, ensuring only authorized employees can access sensitive areas."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "apply",
      "prerequisites": [
        "ANDROID_PERMISSIONS",
        "ANDROID_SIGNATURE_PROTECTION"
      ]
    },
    {
      "question_text": "A vulnerability exists where an exported Android component performs a sensitive task, has a corresponding permission, but fails to check for that permission on incoming requests. What is the most likely impact?",
      "correct_answer": "A malicious app can abuse the vulnerable component's privileges.",
      "distractors": [
        {
          "text": "The Android system will automatically block all IPC to the component.",
          "misconception": "Targets [system automation error]: Android doesn't automatically block; it relies on developer implementation for checks."
        },
        {
          "text": "The app will crash due to an unhandled permission exception.",
          "misconception": "Targets [error handling confusion]: Crashes might occur, but the primary risk is unauthorized access, not just a crash."
        },
        {
          "text": "The user will be prompted to grant a new permission at runtime.",
          "misconception": "Targets [runtime permission confusion]: This applies to 'dangerous' permissions, not necessarily to IPC component access control vulnerabilities."
        }
      ],
      "detailed_explanation": {
        "core_logic": "This scenario describes a classic access control vulnerability because the component is exported and sensitive, yet lacks manifest or code-level permission checks, allowing any app to proxy its privileges.",
        "distractor_analysis": "The distractors suggest automatic system intervention, a simple crash, or runtime user prompts, none of which accurately describe the consequence of a missing IPC permission check.",
        "analogy": "This is like a secure vault door (exported component) that's supposed to require a specific keycard (permission) to open, but it's left ajar, allowing anyone (malicious app) to walk in and access the valuables (sensitive data/actions)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "analyze",
      "prerequisites": [
        "ANDROID_EXPORTED_COMPONENTS",
        "ANDROID_PERMISSION_CHECKS"
      ]
    },
    {
      "question_text": "Which OWASP Mobile Security Project category directly addresses vulnerabilities related to improper access control for exported components in Android IPC?",
      "correct_answer": "MASVS-PLATFORM: Platform Interaction",
      "distractors": [
        {
          "text": "MASVS-CODE: Secure Coding",
          "misconception": "Targets [scope confusion]: While related, this category is broader than specific platform interaction vulnerabilities."
        },
        {
          "text": "MASVS-AUTH: Authentication and Authorization",
          "misconception": "Targets [granularity error]: This category covers broader auth/authz, not specifically platform interaction flaws in IPC."
        },
        {
          "text": "MASVS-CRYPTO: Cryptography",
          "misconception": "Targets [domain confusion]: This category deals with encryption and data protection, not IPC access control."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The MASVS-PLATFORM: Platform Interaction category specifically targets how applications interact with the underlying operating system and its components, including IPC mechanisms and their access controls.",
        "distractor_analysis": "The distractors represent other OWASP MASVS categories that are related but do not precisely pinpoint the vulnerability type described.",
        "analogy": "If the mobile app security is a house, MASVS-PLATFORM: Platform Interaction is like checking the security of the doors, windows, and intercom system (IPC) that connect different rooms (apps/components) within the house."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "OWASP_MASVS",
        "ANDROID_IPC"
      ]
    },
    {
      "question_text": "Consider two Android apps, App A (a banking app) and App B (a malicious app). App A has an exported Content Provider that exposes sensitive user data. App A fails to implement any <code>android:permission</code> checks on this provider. What is the MOST effective mitigation for App A?",
      "correct_answer": "Declare and enforce a <code>signature</code> or <code>dangerous</code> permission on the Content Provider.",
      "distractors": [
        {
          "text": "Make the Content Provider non-exported.",
          "misconception": "Targets [prevention vs. control confusion]: While effective, this prevents *any* external access, not controlled access via permissions."
        },
        {
          "text": "Implement input validation on all data queried from the provider.",
          "misconception": "Targets [input validation vs. authorization confusion]: Input validation checks data format, not *who* is allowed to access it."
        },
        {
          "text": "Encrypt the sensitive data stored by the Content Provider.",
          "misconception": "Targets [data protection vs. access control confusion]: Encryption protects data if accessed, but doesn't prevent unauthorized access attempts."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Enforcing a permission on the Content Provider is the direct mitigation because it establishes an authorization check, ensuring only apps with the granted permission can access the sensitive data, thus preventing unauthorized access by malicious apps.",
        "distractor_analysis": "Making the provider non-exported is too restrictive if other apps need access. Input validation doesn't authorize access. Encryption protects data but doesn't stop unauthorized queries.",
        "analogy": "The Content Provider is like a filing cabinet with sensitive documents. Making it non-exported is locking the room. Input validation is checking if the request form is filled correctly. Encryption is putting documents in a locked folder inside the cabinet. Enforcing a permission is requiring a specific keycard to even approach the cabinet."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "ANDROID_CONTENT_PROVIDERS",
        "ANDROID_PERMISSIONS",
        "ANDROID_EXPORTED_COMPONENTS"
      ]
    },
    {
      "question_text": "What is the fundamental difference between 'normal' and 'dangerous' permissions in Android regarding user interaction?",
      "correct_answer": "Normal permissions are granted automatically at install time, while dangerous permissions require explicit user approval at runtime.",
      "distractors": [
        {
          "text": "Normal permissions are for system apps only, dangerous for third-party apps.",
          "misconception": "Targets [app type confusion]: Both normal and dangerous permissions can be used by any app type."
        },
        {
          "text": "Dangerous permissions are always enforced via signature checks, normal are not.",
          "misconception": "Targets [protection level confusion]: Signature protection is separate from normal/dangerous classification."
        },
        {
          "text": "Normal permissions are requested in the manifest, dangerous permissions via code.",
          "misconception": "Targets [manifest vs. code confusion]: Both types are declared in the manifest."
        }
      ],
      "detailed_explanation": {
        "core_logic": "This distinction is crucial because 'dangerous' permissions involve sensitive user data or device functions, necessitating runtime user consent to uphold privacy and control, unlike 'normal' permissions which pose minimal risk.",
        "distractor_analysis": "The distractors incorrectly associate permission types with app types, protection levels, or declaration methods, missing the core difference in user interaction and risk.",
        "analogy": "'Normal' permissions are like a library card automatically given when you join - you can access basic services. 'Dangerous' permissions are like needing a special key to access a restricted archive, requiring you to ask permission each time."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "ANDROID_PERMISSIONS"
      ]
    },
    {
      "question_text": "When developing an Android app that needs to communicate with a system service via IPC, and the system service has specific security requirements, what is a common approach for the app to gain the necessary privileges?",
      "correct_answer": "Requesting a specific system-defined permission that the system service enforces.",
      "distractors": [
        {
          "text": "Granting the app 'root' privileges on the device.",
          "misconception": "Targets [privilege escalation confusion]: Root access is a security anti-pattern for regular apps and bypasses intended IPC controls."
        },
        {
          "text": "Using generic Binder IPC calls without any permission checks.",
          "misconception": "Targets [security bypass error]: This would leave the IPC vulnerable to unauthorized access."
        },
        {
          "text": "Modifying the system service to accept any app's requests.",
          "misconception": "Targets [system modification error]: Tampering with system services is insecure and impractical for app developers."
        }
      ],
      "detailed_explanation": {
        "core_logic": "System services often define specific permissions to control which apps can interact with them, ensuring that only authorized applications can invoke sensitive operations via IPC, thereby maintaining system integrity.",
        "distractor_analysis": "The distractors suggest dangerous privilege escalation, insecure IPC practices, or system modification, none of which align with secure Android development principles for interacting with system services.",
        "analogy": "Interacting with a system service is like accessing a government building. You don't get 'root' access (full control). You don't just walk in (generic calls). You don't break down the doors (modify service). Instead, you present a specific, authorized government-issued pass (system permission)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "ANDROID_IPC",
        "ANDROID_SYSTEM_SERVICES",
        "ANDROID_PERMISSIONS"
      ]
    },
    {
      "question_text": "What is the purpose of the <code>signatureOrSystem</code> protection level for Android permissions?",
      "correct_answer": "To allow permissions to be granted to apps signed with the same certificate OR to system applications.",
      "distractors": [
        {
          "text": "To allow permissions to be granted to any app that requests them.",
          "misconception": "Targets [permissiveness error]: This describes a lack of protection, not a specific level."
        },
        {
          "text": "To allow permissions to be granted only to apps installed from the system image.",
          "misconception": "Targets [installation source confusion]: It includes same-signature apps, not just system image apps."
        },
        {
          "text": "To allow permissions to be granted to apps that have been granted 'dangerous' permissions.",
          "misconception": "Targets [permission type confusion]: This level is independent of the 'dangerous' classification."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>signatureOrSystem</code> protection level is designed for scenarios where either apps from the same developer (same signature) or core system applications need access, providing a balance between developer control and system integration.",
        "distractor_analysis": "The distractors misinterpret the conditions under which <code>signatureOrSystem</code> permissions are granted, confusing it with automatic grants, installation sources, or other permission types.",
        "analogy": "A <code>signatureOrSystem</code> permission is like a VIP pass that works for both employees of a specific company (same signature) and for official government delegates (system apps) entering a secure facility."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "ANDROID_PERMISSIONS",
        "ANDROID_PROTECTION_LEVELS"
      ]
    },
    {
      "question_text": "In Android, when an app's component (activity, receiver, service, content provider) is exported, what is the critical security check that must be performed to prevent unauthorized access?",
      "correct_answer": "A permission check, either declared in the manifest or implemented in code.",
      "distractors": [
        {
          "text": "A check for the app's package name.",
          "misconception": "Targets [identification vs. authorization confusion]: Package name identifies the app, but doesn't inherently grant authorization."
        },
        {
          "text": "A check for the calling app's UID.",
          "misconception": "Targets [UID vs. permission confusion]: UID identifies the app process, but permissions define what it's allowed to do."
        },
        {
          "text": "A check for the Android version the calling app is running.",
          "misconception": "Targets [versioning vs. authorization confusion]: App version is irrelevant to authorization for accessing a component."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Exported components are accessible by other apps, therefore, a permission check acts as the authorization gatekeeper, ensuring that only apps possessing the required permission can invoke the component's sensitive functionality.",
        "distractor_analysis": "The distractors suggest checks that identify the caller (package name, UID) or its environment (version) but do not establish authorization, which is the core security requirement.",
        "analogy": "An exported component is like a public phone booth. Without a permission check, anyone can use it. A permission check is like requiring a specific coin or access card to make a call, ensuring only authorized users can utilize the service."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "ANDROID_EXPORTED_COMPONENTS",
        "ANDROID_PERMISSIONS"
      ]
    },
    {
      "question_text": "What is the primary risk associated with exporting an Android Service that performs sensitive operations without requiring any permissions?",
      "correct_answer": "Any malicious application can bind to and control the service, potentially performing sensitive actions.",
      "distractors": [
        {
          "text": "The service will consume excessive system resources.",
          "misconception": "Targets [resource management vs. security confusion]: Resource consumption is a performance issue, not a direct security risk of unauthorized control."
        },
        {
          "text": "The app will be flagged by Google Play Protect for insecure practices.",
          "misconception": "Targets [detection vs. root cause confusion]: While it might be flagged, the core risk is the actual unauthorized control."
        },
        {
          "text": "The service's internal state will become corrupted.",
          "misconception": "Targets [data integrity vs. access control confusion]: Corruption might occur, but the primary risk is unauthorized *actions* by another app."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Exporting a service without permission checks means it's open to any app, allowing a malicious app to bind to it and trigger its sensitive operations, effectively hijacking its functionality and privileges.",
        "distractor_analysis": "The distractors focus on secondary effects like resource usage, detection, or data corruption, rather than the direct security implication of unauthorized control over sensitive operations.",
        "analogy": "An exported, unprotected service is like a remote-controlled car with no security code. Anyone with a compatible remote (malicious app) can take control and drive it wherever they want, potentially causing damage."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "ANDROID_SERVICES",
        "ANDROID_EXPORTED_COMPONENTS",
        "ANDROID_PERMISSIONS"
      ]
    },
    {
      "question_text": "Which of the following is NOT a recommended mitigation strategy for securing Inter-Process Communication (IPC) in Android applications?",
      "correct_answer": "Disabling all forms of IPC to prevent potential vulnerabilities.",
      "distractors": [
        {
          "text": "Implementing robust permission checks for exported components.",
          "misconception": "Targets [completeness error]: This is a primary and recommended mitigation."
        },
        {
          "text": "Using signature-level permissions for communication between apps from the same developer.",
          "misconception": "Targets [completeness error]: This is a specific and recommended mitigation for intra-developer communication."
        },
        {
          "text": "Validating the identity and permissions of the calling application.",
          "misconception": "Targets [completeness error]: This is a fundamental aspect of secure IPC."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Disabling all IPC is an overly restrictive approach that cripples app functionality and is not a practical or recommended security strategy; instead, secure IPC relies on controlled access and validation.",
        "distractor_analysis": "The distractors represent valid and recommended security practices for Android IPC, making the correct answer the only option that is NOT a recommended mitigation.",
        "analogy": "Trying to secure a house by boarding up all the doors and windows (disabling IPC) is not a strategy; it makes the house unusable. Secure IPC is like installing strong locks, security cameras, and a doorman (permissions, validation) on the doors that are necessary."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "evaluate",
      "prerequisites": [
        "ANDROID_IPC",
        "ANDROID_PERMISSIONS"
      ]
    },
    {
      "question_text": "What does the <code>android:exported</code> attribute in an Android component's manifest declaration signify regarding IPC?",
      "correct_answer": "It determines whether the component can be invoked by components from other applications.",
      "distractors": [
        {
          "text": "It indicates whether the component requires internet access.",
          "misconception": "Targets [attribute confusion]: Internet access is controlled by the INTERNET permission, not the exported attribute."
        },
        {
          "text": "It specifies the minimum Android version required for the component.",
          "misconception": "Targets [versioning confusion]: Minimum SDK version is declared elsewhere in the manifest."
        },
        {
          "text": "It defines the permission level required to launch the component.",
          "misconception": "Targets [attribute vs. permission confusion]: The attribute determines *if* it can be invoked externally, not *which* permission is needed."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>android:exported</code> attribute is critical because it explicitly controls the component's visibility and accessibility to external applications, directly impacting the security surface for IPC.",
        "distractor_analysis": "The distractors incorrectly associate the <code>exported</code> attribute with internet access, minimum SDK version, or the permission level itself, rather than its function of controlling external invocation.",
        "analogy": "The <code>android:exported</code> attribute is like a 'Public Access' sign on a building entrance. If it's 'true' (exported), the public (other apps) can enter. If it's 'false', only internal staff (same app) can access it."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "ANDROID_MANIFEST",
        "ANDROID_EXPORTED_COMPONENTS"
      ]
    },
    {
      "question_text": "When a 'dangerous' permission is requested by an Android app, what is the typical user interaction required for granting it?",
      "correct_answer": "The user is presented with a system dialog asking for their explicit consent.",
      "distractors": [
        {
          "text": "The permission is automatically granted upon app installation.",
          "misconception": "Targets [permission type confusion]: This describes 'normal' permissions, not 'dangerous' ones."
        },
        {
          "text": "The user must manually edit system configuration files.",
          "misconception": "Targets [user interaction error]: This is an overly technical and incorrect user interaction for dangerous permissions."
        },
        {
          "text": "The app developer must sign the permission request with a special key.",
          "misconception": "Targets [developer vs. user role confusion]: Permission granting is a user action, not a developer signing process."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Runtime permission requests for 'dangerous' permissions are designed to give users direct control over sensitive data access, hence the need for an explicit, user-facing dialog to confirm consent.",
        "distractor_analysis": "The distractors describe scenarios applicable to 'normal' permissions, system-level configurations, or developer actions, none of which accurately reflect the user interaction for granting 'dangerous' permissions.",
        "analogy": "Requesting a 'dangerous' permission is like asking to borrow a valuable item. The system (like a librarian) shows you a form (dialog) and asks 'Are you sure you want to grant this access?' before letting you proceed."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "ANDROID_PERMISSIONS",
        "ANDROID_RUNTIME_PERMISSIONS"
      ]
    },
    {
      "question_text": "What is the primary security benefit of using non-exported Content Providers for sharing data between apps within the same Android application?",
      "correct_answer": "It prevents other applications on the device from accessing the data, enforcing data isolation.",
      "distractors": [
        {
          "text": "It automatically encrypts the data stored in the provider.",
          "misconception": "Targets [security mechanism confusion]: Non-exporting is an access control mechanism, not an encryption method."
        },
        {
          "text": "It reduces the overall memory footprint of the application.",
          "misconception": "Targets [performance vs. security confusion]: Export status primarily affects security, not memory usage."
        },
        {
          "text": "It allows the provider to be accessed by any app with internet connectivity.",
          "misconception": "Targets [access control reversal]: Non-exporting explicitly restricts access, it doesn't enable internet-based access."
        }
      ],
      "detailed_explanation": {
        "core_logic": "By setting <code>android:exported=&quot;false&quot;</code>, the Content Provider is only accessible by components within the same application, effectively creating a secure boundary that prevents unauthorized external access to sensitive data.",
        "distractor_analysis": "The distractors incorrectly attribute encryption, performance benefits, or internet-based access to the non-exported status, missing its core function of restricting inter-app access.",
        "analogy": "A non-exported Content Provider is like a private diary kept within your own room. Only you (components within the same app) can access it. Anyone from outside the room (other apps) cannot reach it, ensuring privacy."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "ANDROID_CONTENT_PROVIDERS",
        "ANDROID_EXPORTED_COMPONENTS"
      ]
    },
    {
      "question_text": "Which of the following best describes the role of Binder in Android's IPC mechanism concerning security?",
      "correct_answer": "Binder provides the underlying framework for IPC, but security is enforced through Android's permission system on top of it.",
      "distractors": [
        {
          "text": "Binder itself handles all permission checks for IPC calls.",
          "misconception": "Targets [framework vs. security layer confusion]: Binder is the transport layer; permissions are the security enforcement."
        },
        {
          "text": "Binder automatically encrypts all data transmitted between processes.",
          "misconception": "Targets [encryption confusion]: Binder does not provide encryption; that's handled by other mechanisms if needed."
        },
        {
          "text": "Binder only allows IPC between apps signed with the same certificate.",
          "misconception": "Targets [signature restriction error]: Binder is a general IPC mechanism; signature checks are part of the permission system."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Binder acts as the RPC mechanism, enabling communication, but the Android framework layers permission checks on top of Binder calls to ensure that only authorized processes can invoke specific services or access data.",
        "distractor_analysis": "The distractors incorrectly attribute permission enforcement, encryption, or strict signature-based restrictions directly to the Binder IPC mechanism itself, rather than the surrounding Android security model.",
        "analogy": "Binder is like the postal service delivering letters between two offices. It ensures the letter gets there (IPC). The security (permissions) is like requiring a specific ID or authorization code to send or receive certain types of mail, which the postal service doesn't inherently enforce but relies on sender/receiver protocols for."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "ANDROID_IPC",
        "ANDROID_BINDER",
        "ANDROID_PERMISSIONS"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "IPC Permission Enforcement 008_Application Security best practices",
    "latency_ms": 23451.467
  },
  "timestamp": "2026-01-18T12:28:10.835790"
}