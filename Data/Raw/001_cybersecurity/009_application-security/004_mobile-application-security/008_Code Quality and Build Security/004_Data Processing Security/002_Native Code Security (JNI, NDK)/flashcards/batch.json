{
  "topic_title": "Native Code Security (JNI, NDK)",
  "category": "008_Application Security - Mobile 008_Application Security",
  "flashcards": [
    {
      "question_text": "What is the primary security concern when using the Java Native Interface (JNI) to bridge Java/Kotlin code with native C/C++ code in Android applications?",
      "correct_answer": "The native code can bypass Android's security model and access sensitive data or perform unauthorized operations.",
      "distractors": [
        {
          "text": "JNI calls are inherently slower than pure Java/Kotlin calls, impacting performance.",
          "misconception": "Targets [performance vs security confusion]: Students focus on performance overhead rather than security vulnerabilities."
        },
        {
          "text": "The JNI layer introduces memory leaks that are difficult to debug in managed code.",
          "misconception": "Targets [memory management confusion]: Students conflate JNI's potential for native memory issues with general memory leak concerns."
        },
        {
          "text": "Android's runtime environment (ART) cannot effectively monitor native code execution.",
          "misconception": "Targets [runtime monitoring confusion]: Students misunderstand ART's capabilities and the security implications of native code."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Native code, written in C/C++, operates outside the managed runtime's direct control, meaning it can bypass Android's security sandbox and access system resources or sensitive data if not carefully secured.",
        "distractor_analysis": "The distractors focus on performance, general memory leaks, and runtime monitoring misunderstandings, rather than the core security risk of native code bypassing the sandbox.",
        "analogy": "Think of JNI as a secret tunnel between your secure house (Android app) and a less secure external area (native code). If the tunnel isn't properly secured, unwanted visitors (malicious code) can enter your house."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "ANDROID_SECURITY_MODEL",
        "JNI_FUNDAMENTALS"
      ]
    },
    {
      "question_text": "According to Android developer best practices, what is a key strategy to minimize security risks when passing data between Java/Kotlin and native code via JNI?",
      "correct_answer": "Minimize the amount and frequency of data marshalled across the JNI layer.",
      "distractors": [
        {
          "text": "Always encrypt sensitive data before passing it through JNI.",
          "misconception": "Targets [over-reliance on encryption]: Students assume encryption is always the primary solution, neglecting data minimization."
        },
        {
          "text": "Use global JNI references exclusively for all data transfers.",
          "misconception": "Targets [misunderstanding JNI references]: Students confuse reference types or their security implications."
        },
        {
          "text": "Perform all complex data transformations within the native code.",
          "misconception": "Targets [data processing location confusion]: Students don't consider where data processing occurs in relation to security boundaries."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Marshaling data across the JNI layer incurs overhead and increases the attack surface. Minimizing data transfer reduces the potential for vulnerabilities and improves performance, as recommended by [developer.android.com/training/articles/perf-jni].",
        "distractor_analysis": "The distractors suggest encryption as a universal fix, misuse JNI references, or misplace data processing, rather than focusing on the fundamental principle of minimizing data exposure.",
        "analogy": "Imagine sending packages through a checkpoint. It's safer and faster to send fewer, smaller packages than many large ones, as each package requires inspection."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "JNI_FUNDAMENTALS",
        "DATA_MINIMIZATION"
      ]
    },
    {
      "question_text": "Which of the following is a critical security consideration when implementing JNI functions that handle user input or sensitive data?",
      "correct_answer": "Thoroughly validate and sanitize all input received from the managed code before processing it in native code.",
      "distractors": [
        {
          "text": "Assume that all data passed from Java/Kotlin is already sanitized.",
          "misconception": "Targets [trust boundary violation]: Students incorrectly assume the managed layer perfectly sanitizes input."
        },
        {
          "text": "Use obfuscation techniques on native code to hide input handling logic.",
          "misconception": "Targets [security through obscurity]: Students rely on hiding code rather than secure coding practices."
        },
        {
          "text": "Log all JNI calls with detailed parameter values for auditing.",
          "misconception": "Targets [logging vs validation confusion]: Students confuse the purpose of logging with the necessity of input validation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Native code must treat data from the managed layer as untrusted input. Input validation and sanitization are crucial because the managed layer might be compromised or contain vulnerabilities, allowing malicious data to reach the native code, as emphasized in secure coding guides like [www.jssec.org/dl/android_securecoding_en/index.html].",
        "distractor_analysis": "The distractors suggest blind trust in the managed layer, ineffective obscurity, or misinterpreting the role of logging, instead of the essential practice of input validation.",
        "analogy": "When receiving a package, you don't assume it's safe just because the sender looks trustworthy; you inspect its contents before bringing it inside."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "INPUT_VALIDATION",
        "JNI_FUNDAMENTALS"
      ]
    },
    {
      "question_text": "What is the primary security risk associated with using the Android NDK (Native Development Kit) for computationally intensive tasks?",
      "correct_answer": "Native code can more easily exploit vulnerabilities like buffer overflows or use-after-free errors, bypassing managed code protections.",
      "distractors": [
        {
          "text": "The NDK increases the application's overall memory footprint significantly.",
          "misconception": "Targets [memory footprint vs vulnerability confusion]: Students conflate resource usage with exploitable security flaws."
        },
        {
          "text": "Native libraries are not subject to Android's permission model.",
          "misconception": "Targets [permission model misunderstanding]: Students incorrectly believe native code is entirely outside the permission system."
        },
        {
          "text": "NDK-compiled code is more susceptible to reverse engineering than Java/Kotlin code.",
          "misconception": "Targets [reverse engineering confusion]: Students focus on code visibility rather than direct exploitability."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The NDK allows developers to write performance-critical parts of an app in C/C++. However, this native code is more prone to memory corruption vulnerabilities (e.g., buffer overflows) that are harder to manage and can lead to arbitrary code execution, bypassing the safety nets of managed code, as noted in general Android security best practices [source.android.google.cn/docs/security/best-practices].",
        "distractor_analysis": "The distractors focus on memory footprint, permission models, and reverse engineering, which are secondary concerns compared to the direct exploitability of memory corruption vulnerabilities in native code.",
        "analogy": "Using the NDK is like building a high-performance engine for your car. While it offers great power, it requires meticulous engineering to prevent catastrophic failures (like engine blowouts) that wouldn't occur in a standard, less powerful engine."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "NDK_FUNDAMENTALS",
        "MEMORY_CORRUPTION_VULNERABILITIES"
      ]
    },
    {
      "question_text": "When designing JNI interfaces, what is the recommended approach to prevent unintended data exposure or modification by other applications?",
      "correct_answer": "Use signature-based permissions or non-exported Content Providers for inter-process communication.",
      "distractors": [
        {
          "text": "Rely solely on the default export settings for all JNI-accessible components.",
          "misconception": "Targets [default settings risk]: Students assume default configurations are secure."
        },
        {
          "text": "Implement custom authentication mechanisms within the native code itself.",
          "misconception": "Targets [reinventing security wheels]: Students try to build custom security solutions instead of using platform features."
        },
        {
          "text": "Pass all sensitive data through public, unencrypted JNI methods.",
          "misconception": "Targets [data exposure]: Students ignore the need for secure communication channels."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Android provides mechanisms like signature-based permissions and non-exported Content Providers to control access to components, including those exposed via JNI. These ensure that only trusted applications can interact with sensitive native code, aligning with secure inter-app communication principles [developer.android.com/privacy-and-security/security-best-practices].",
        "distractor_analysis": "The distractors suggest relying on insecure defaults, building custom and potentially flawed security, or exposing data openly, rather than using established Android security features.",
        "analogy": "It's like having a secure mailbox (Content Provider) with a specific key (signature permission) that only authorized people can use, rather than leaving your front door wide open."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "ANDROID_IPC",
        "JNI_FUNDAMENTALS"
      ]
    },
    {
      "question_text": "What is the security implication of asynchronous communication between managed code and native code via JNI?",
      "correct_answer": "It can complicate state management and increase the difficulty of reasoning about security vulnerabilities.",
      "distractors": [
        {
          "text": "Asynchronous calls are inherently more secure because they are non-blocking.",
          "misconception": "Targets [async vs security confusion]: Students incorrectly equate non-blocking operations with enhanced security."
        },
        {
          "text": "Asynchronous JNI calls always lead to performance degradation.",
          "misconception": "Targets [performance focus]: Students prioritize performance over security implications of asynchronous operations."
        },
        {
          "text": "Android's runtime cannot handle asynchronous JNI calls effectively.",
          "misconception": "Targets [runtime capability misunderstanding]: Students underestimate the runtime's ability to manage async operations."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Asynchronous communication between managed and native code via JNI can lead to complex race conditions and make it harder to track the state of data and operations, thereby increasing the potential for security vulnerabilities. It's generally recommended to keep async operations within the same language domain where possible [developer.android.com/training/articles/perf-jni].",
        "distractor_analysis": "The distractors incorrectly link asynchronous operations to inherent security, performance issues, or runtime limitations, rather than the complexity and state management challenges they introduce.",
        "analogy": "Trying to coordinate two people working on the same document asynchronously (one sends edits, the other receives later) is harder to manage and more prone to conflicts than if they were working side-by-side."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "JNI_FUNDAMENTALS",
        "ASYNC_PROGRAMMING"
      ]
    },
    {
      "question_text": "Which of the following is a common vulnerability class in native code (C/C++) that is less prevalent in managed languages like Java/Kotlin?",
      "correct_answer": "Buffer overflows and related memory corruption vulnerabilities.",
      "distractors": [
        {
          "text": "Cross-Site Scripting (XSS) attacks.",
          "misconception": "Targets [attack vector confusion]: Students confuse client-side web vulnerabilities with native code issues."
        },
        {
          "text": "SQL Injection attacks.",
          "misconception": "Targets [data manipulation confusion]: Students confuse input validation issues in data access with memory safety."
        },
        {
          "text": "Insecure Direct Object References (IDOR).",
          "misconception": "Targets [access control confusion]: Students confuse authorization flaws with memory management vulnerabilities."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Managed languages like Java and Kotlin have built-in memory safety features that prevent common C/C++ vulnerabilities such as buffer overflows, use-after-free, and null pointer dereferences. Native code requires manual memory management, making it susceptible to these low-level exploits [wiki.sei.cmu.edu/confluence/display/android/Android+Secure+Coding+Standard].",
        "distractor_analysis": "The distractors list common web application vulnerabilities (XSS, SQLi) or access control issues (IDOR), which are distinct from the memory corruption vulnerabilities inherent in manual memory management in native code.",
        "analogy": "Managed languages are like driving an automatic car with safety features that prevent you from accidentally putting it in the wrong gear. Native code is like driving a manual car where you have more control but can easily make a mistake that damages the engine (memory)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "MEMORY_SAFETY",
        "NATIVE_CODE_VULNERABILITIES"
      ]
    },
    {
      "question_text": "What security principle should guide the design of JNI interfaces, especially when native code interacts with sensitive system resources?",
      "correct_answer": "Principle of Least Privilege.",
      "distractors": [
        {
          "text": "Defense in Depth.",
          "misconception": "Targets [principle confusion]: Students confuse different security principles, applying defense-in-depth incorrectly."
        },
        {
          "text": "Separation of Concerns.",
          "misconception": "Targets [principle confusion]: Students confuse modular design with access control."
        },
        {
          "text": "Fail-Safe Defaults.",
          "misconception": "Targets [principle confusion]: Students confuse default states with necessary permissions."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The Principle of Least Privilege dictates that native code should only have the minimum permissions necessary to perform its intended function. This limits the potential damage if the native code is compromised or behaves unexpectedly, aligning with general secure design practices [wiki.sei.cmu.edu/confluence/display/android/Android+Secure+Coding+Standard].",
        "distractor_analysis": "While Defense in Depth and Separation of Concerns are important, Least Privilege is the most direct principle for controlling native code's access to resources. Fail-Safe Defaults relate more to initial states.",
        "analogy": "A janitor (native code) should only have keys to the rooms they need to clean (least privilege), not the entire building (excessive privilege)."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SECURITY_PRINCIPLES",
        "JNI_FUNDAMENTALS"
      ]
    },
    {
      "question_text": "Consider a scenario where a native library used by an Android app is found to have a critical vulnerability. What is the most effective immediate mitigation strategy?",
      "correct_answer": "Disable or remove the functionality that relies on the vulnerable native library.",
      "distractors": [
        {
          "text": "Immediately update the Android application to the latest version.",
          "misconception": "Targets [update vs disable confusion]: Students assume updating the app automatically fixes the native library issue."
        },
        {
          "text": "Implement runtime checks within the Java/Kotlin code to monitor native library behavior.",
          "misconception": "Targets [monitoring vs mitigation confusion]: Students focus on detection rather than immediate risk reduction."
        },
        {
          "text": "Rely on Android's built-in security features to isolate the native library.",
          "misconception": "Targets [over-reliance on platform]: Students assume the platform can automatically protect against all known native library flaws."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When a critical vulnerability is discovered in a native library, the most immediate and effective mitigation is to disable the feature using that library or remove it entirely. This prevents the vulnerability from being exploited while a proper fix is developed and deployed, following incident response best practices.",
        "distractor_analysis": "Updating the app is a solution, but not always immediate. Runtime monitoring detects issues but doesn't stop them. Relying solely on platform isolation might not be sufficient for critical vulnerabilities.",
        "analogy": "If you discover a dangerous gas leak in one room of your house, the immediate action is to close the door to that room and evacuate, not just to monitor the gas levels or hope the house's ventilation system handles it."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "INCIDENT_RESPONSE",
        "NATIVE_CODE_VULNERABILITIES"
      ]
    },
    {
      "question_text": "What is the purpose of using <code>PackageManager.MATCH_ALL</code> when querying for activities that can handle an implicit intent in Android, as mentioned in security best practices?",
      "correct_answer": "To ensure that all potential handlers are considered, allowing the app to present an app chooser if multiple handlers exist.",
      "distractors": [
        {
          "text": "To restrict the intent resolution only to system-level applications.",
          "misconception": "Targets [permission scope confusion]: Students misunderstand the flag's purpose regarding app permissions."
        },
        {
          "text": "To prioritize native code handlers over Java/Kotlin handlers.",
          "misconception": "Targets [handler type confusion]: Students incorrectly believe the flag differentiates between native and managed code handlers."
        },
        {
          "text": "To ensure the intent is only sent if exactly one application can handle it.",
          "misconception": "Targets [intent resolution logic confusion]: Students misunderstand how `MATCH_ALL` relates to single vs. multiple handlers."
        }
      ],
      "detailed_explanation": {
        "core_logic": "<code>PackageManager.MATCH_ALL</code> is used to retrieve all activities that can handle an intent, regardless of their priority or specific filters. This is crucial for security best practices like showing an app chooser when multiple apps can respond, preventing implicit intents from being hijacked [developer.android.com/privacy-and-security/security-best-practices].",
        "distractor_analysis": "The distractors misinterpret <code>MATCH_ALL</code> as a restriction, a handler type differentiator, or a condition for single handler resolution, rather than its actual function of gathering all potential handlers.",
        "analogy": "It's like asking 'Who can deliver this package?' and getting a list of all available couriers, so you can choose the most trustworthy one, rather than just accepting the first one you find."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "ANDROID_INTENTS",
        "APP_CHOOSER_SECURITY"
      ]
    },
    {
      "question_text": "Why is it important to avoid asynchronous communication between Java/Kotlin and native code when possible, according to JNI performance and security tips?",
      "correct_answer": "It simplifies state management and reasoning about potential race conditions and security flaws.",
      "distractors": [
        {
          "text": "Asynchronous communication is always less performant than synchronous calls.",
          "misconception": "Targets [performance generalization]: Students make a blanket statement about performance without considering context."
        },
        {
          "text": "Android's ART runtime cannot effectively manage asynchronous JNI callbacks.",
          "misconception": "Targets [runtime limitation misunderstanding]: Students incorrectly assume the runtime is incapable of handling async JNI."
        },
        {
          "text": "Native code cannot initiate asynchronous callbacks to managed code.",
          "misconception": "Targets [JNI capability misunderstanding]: Students misunderstand the directionality and capabilities of JNI callbacks."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Synchronous communication between managed and native code simplifies the flow of control and data, making it easier to reason about the application's state and identify potential security vulnerabilities like race conditions. Asynchronous communication adds complexity that can obscure these issues [developer.android.com/training/articles/perf-jni].",
        "distractor_analysis": "The distractors make incorrect generalizations about performance, misunderstand the ART runtime's capabilities, or misstate JNI's ability to handle callbacks.",
        "analogy": "It's easier to follow a conversation where one person speaks at a time (synchronous) than one where multiple people interrupt each other unpredictably (asynchronous)."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "JNI_FUNDAMENTALS",
        "CONCURRENCY_CONTROL"
      ]
    },
    {
      "question_text": "What is the primary security benefit of using signature-based permissions for inter-app communication involving native code?",
      "correct_answer": "It ensures that only applications signed with a specific certificate can communicate with the native component.",
      "distractors": [
        {
          "text": "It allows any application to communicate as long as it requests the permission.",
          "misconception": "Targets [permission type confusion]: Students confuse signature permissions with normal runtime permissions."
        },
        {
          "text": "It encrypts the data exchanged between applications automatically.",
          "misconception": "Targets [encryption vs authentication confusion]: Students conflate authentication mechanisms with data confidentiality."
        },
        {
          "text": "It prevents the native code from being reverse-engineered.",
          "misconception": "Targets [obfuscation vs access control confusion]: Students confuse access control with code protection."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Signature-based permissions verify the identity of the calling application based on its signing certificate, not just a runtime request. This provides a strong guarantee that only applications from the same developer (or those sharing the same signing key) can access the protected native component, enhancing security for inter-process communication [developer.android.com/privacy-and-security/security-best-practices].",
        "distractor_analysis": "The distractors incorrectly describe signature permissions as open, conflate them with encryption, or associate them with reverse engineering prevention, missing the core authentication aspect.",
        "analogy": "It's like a VIP club that only allows members with a specific, verified membership card (signature) to enter, rather than just anyone who asks nicely."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "ANDROID_PERMISSIONS",
        "SIGNATURE_PROTECTION"
      ]
    },
    {
      "question_text": "When using the Android NDK, what is a critical security practice related to the management of native libraries?",
      "correct_answer": "Ensure native libraries are properly signed and their integrity is verified before execution.",
      "distractors": [
        {
          "text": "Always load native libraries from external storage for easier updates.",
          "misconception": "Targets [storage security confusion]: Students misunderstand the security risks of loading code from less trusted locations."
        },
        {
          "text": "Assume that all libraries downloaded from trusted sources are inherently secure.",
          "misconception": "Targets [trusting external sources]: Students fail to account for potential supply chain attacks or vulnerabilities in third-party libraries."
        },
        {
          "text": "Use the simplest possible native library API to reduce complexity.",
          "misconception": "Targets [simplicity vs security confusion]: Students prioritize API simplicity over integrity checks."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Native libraries are a prime target for tampering. Verifying their integrity (e.g., through digital signatures) ensures that the code being executed is the authentic, unmodified version intended by the developer, preventing the introduction of malicious code via supply chain attacks [source.android.google.cn/docs/security/best-practices].",
        "distractor_analysis": "The distractors suggest insecure loading locations, blind trust in sources, or prioritizing API simplicity over integrity verification, all of which undermine the security of native libraries.",
        "analogy": "Before using a tool from a toolbox, you check if it's the correct tool and hasn't been damaged or altered, ensuring it will work as intended and safely."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "NDK_FUNDAMENTALS",
        "CODE_INTEGRITY"
      ]
    },
    {
      "question_text": "What is the security risk of using global JNI references extensively without proper management?",
      "correct_answer": "It can lead to memory leaks in the native heap, potentially causing application instability or denial-of-service.",
      "distractors": [
        {
          "text": "It exposes sensitive data to other applications running on the device.",
          "misconception": "Targets [reference vs data exposure confusion]: Students confuse the management of references with data leakage."
        },
        {
          "text": "It violates Android's security sandbox, allowing native code to access any app's data.",
          "misconception": "Targets [sandbox violation misunderstanding]: Students overestimate the impact of JNI references on the overall sandbox."
        },
        {
          "text": "It significantly slows down JNI calls, impacting user experience.",
          "misconception": "Targets [performance vs memory leak confusion]: Students conflate memory management issues with direct performance degradation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Global JNI references must be explicitly deleted when no longer needed. Failure to do so results in memory leaks within the native environment, consuming resources and potentially leading to crashes or denial-of-service conditions. Tools like the Memory Profiler can help identify these leaks [developer.android.com/training/articles/perf-jni].",
        "distractor_analysis": "The distractors incorrectly link global references to data exposure, sandbox violations, or direct performance impacts, rather than the specific issue of native memory leaks.",
        "analogy": "Leaving lights on in every room of a house indefinitely (global references) will eventually drain the power supply (memory), even if you're not actively using those rooms."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "JNI_FUNDAMENTALS",
        "MEMORY_MANAGEMENT"
      ]
    },
    {
      "question_text": "Which Android security best practice is most relevant when deciding whether to use JNI for a specific functionality?",
      "correct_answer": "Only use native code when absolutely necessary for performance or access to platform features not available in Java/Kotlin.",
      "distractors": [
        {
          "text": "Always use JNI for any code that handles sensitive user data.",
          "misconception": "Targets [misapplication of security]: Students incorrectly assume native code is inherently more secure for sensitive data."
        },
        {
          "text": "Prefer JNI for all cryptographic operations to ensure maximum security.",
          "misconception": "Targets [performance over security]: Students prioritize perceived security of native code over potential vulnerabilities."
        },
        {
          "text": "Use JNI whenever a third-party library is available in native code.",
          "misconception": "Targets [dependency risk]: Students overlook the security implications of integrating third-party native libraries."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Native code introduces significant security risks due to manual memory management and bypassing the managed runtime's safety features. Therefore, it should only be employed when the benefits (performance, specific APIs) clearly outweigh the increased security burden [source.android.google.cn/docs/security/best-practices].",
        "distractor_analysis": "The distractors suggest using JNI inappropriately for sensitive data, cryptography, or third-party libraries without considering the associated risks.",
        "analogy": "You wouldn't use a complex, high-powered tool for a simple task if a safer, easier tool is available; you choose the right tool for the job based on necessity and risk."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "JNI_FUNDAMENTALS",
        "SECURITY_RISK_ASSESSMENT"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Native Code Security (JNI, NDK) 008_Application Security best practices",
    "latency_ms": 25345.014
  },
  "timestamp": "2026-01-18T12:29:55.749116"
}