{
  "topic_title": "Pod Security Policy Validation",
  "category": "008_Application Security - 008_006_Application Security Testing Tools",
  "flashcards": [
    {
      "question_text": "What is the primary function of Kubernetes Pod Security Admission (PSA)?",
      "correct_answer": "To enforce Pod Security Standards (PSS) at the namespace level by rejecting or warning about non-compliant pods.",
      "distractors": [
        {
          "text": "To automatically upgrade all pods to the most secure configuration.",
          "misconception": "Targets [automation over enforcement]: Confuses PSA's role as a policy enforcer with an automated remediation tool."
        },
        {
          "text": "To provide detailed security audit logs for all pod activities.",
          "misconception": "Targets [logging vs. admission control]: Mixes PSA's admission control function with the separate audit logging mechanism."
        },
        {
          "text": "To define network policies for pod-to-pod communication.",
          "misconception": "Targets [scope confusion]: Associates PSA with network security (NetworkPolicies) rather than pod security contexts."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Pod Security Admission (PSA) functions as a built-in Kubernetes admission controller that enforces the Pod Security Standards (PSS) by evaluating pod configurations against defined security levels (privileged, baseline, restricted) at the namespace level, thereby preventing or warning about non-compliant deployments.",
        "distractor_analysis": "The first distractor overstates PSA's capabilities by suggesting automatic upgrades. The second conflates admission control with audit logging. The third incorrectly assigns network policy responsibilities to PSA.",
        "analogy": "Think of Pod Security Admission as a security guard at a building's entrance. The guard checks if each person (pod) meets the building's security requirements (PSS) before allowing them in, rather than automatically upgrading everyone or just logging who enters."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "KUBERNETES_PODS",
        "KUBERNETES_NAMESPACES",
        "SECURITY_ADMISSION_CONTROLLERS"
      ]
    },
    {
      "question_text": "Which Kubernetes Pod Security Standard profile is the most restrictive and enforces current Pod hardening best practices?",
      "correct_answer": "Restricted",
      "distractors": [
        {
          "text": "Baseline",
          "misconception": "Targets [level confusion]: Associates 'Baseline' with high security instead of minimal restrictions."
        },
        {
          "text": "Privileged",
          "misconception": "Targets [level confusion]: Mistakenly believes 'Privileged' offers the most security controls."
        },
        {
          "text": "Enforced",
          "misconception": "Targets [mode vs. profile confusion]: Confuses an admission control mode ('enforce') with a security profile."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'Restricted' profile within Kubernetes Pod Security Standards is designed to be heavily restricted, enforcing current Pod hardening best practices by disallowing many capabilities and configurations that could lead to privilege escalation or security vulnerabilities.",
        "distractor_analysis": "The 'Baseline' profile is minimally restrictive, 'Privileged' is unrestricted, and 'Enforced' is an admission control mode, not a security profile level.",
        "analogy": "Imagine security levels for a building: 'Privileged' is like an open-door policy, 'Baseline' is like basic ID check, and 'Restricted' is like full TSA screening – the most secure and limiting."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "KUBERNETES_POD_SECURITY_STANDARDS"
      ]
    },
    {
      "question_text": "In Kubernetes Pod Security Admission, what is the effect of setting the <code>pod-security.kubernetes.io/enforce</code> label to <code>restricted</code> on a namespace?",
      "correct_answer": "Pods violating the 'restricted' policy will be rejected.",
      "distractors": [
        {
          "text": "Pods violating the 'restricted' policy will trigger an audit log entry but will be allowed.",
          "misconception": "Targets [mode confusion]: Confuses the 'enforce' mode with the 'audit' mode."
        },
        {
          "text": "Pods violating the 'restricted' policy will display a warning message but will be allowed.",
          "misconception": "Targets [mode confusion]: Confuses the 'enforce' mode with the 'warn' mode."
        },
        {
          "text": "Pods violating the 'restricted' policy will be automatically remediated.",
          "misconception": "Targets [admission vs. remediation]: Assumes the admission controller performs automatic fixes rather than rejection."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When the <code>pod-security.kubernetes.io/enforce</code> label is set to <code>restricted</code> for a namespace, Kubernetes' Pod Security Admission controller will reject any new pods that do not comply with the 'restricted' Pod Security Standard profile, thereby enforcing strict security controls.",
        "distractor_analysis": "The 'audit' mode logs violations, 'warn' mode issues warnings, and admission controllers typically reject non-compliant resources rather than remediating them automatically.",
        "analogy": "Setting <code>enforce: restricted</code> is like a strict bouncer at a club door. If you don't meet the dress code ('restricted' policy), you're denied entry (rejected), not just noted ('audit') or warned ('warn')."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "KUBERNETES_POD_SECURITY_ADMISSION",
        "KUBERNETES_NAMESPACES"
      ]
    },
    {
      "question_text": "What is the purpose of the 'Privileged' Pod Security Standard profile?",
      "correct_answer": "To provide an unrestricted policy, allowing pods to bypass typical container isolation mechanisms and known privilege escalations.",
      "distractors": [
        {
          "text": "To enforce the most stringent security controls and disallow all privilege escalation.",
          "misconception": "Targets [profile definition confusion]: Reverses the definition of 'Privileged' with 'Restricted'."
        },
        {
          "text": "To enforce minimal security controls, preventing known privilege escalations for common workloads.",
          "misconception": "Targets [profile definition confusion]: Describes the 'Baseline' profile, not 'Privileged'."
        },
        {
          "text": "To allow pods to access host network interfaces but disallow host PID namespace sharing.",
          "misconception": "Targets [partial understanding]: Mixes specific allowed 'Privileged' features with restrictions from other profiles."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'Privileged' Pod Security Standard profile is intentionally open and unrestricted, designed for system-level workloads where bypassing standard container isolation is necessary, and it permits known privilege escalations.",
        "distractor_analysis": "The first distractor describes 'Restricted', the second describes 'Baseline', and the third lists specific controls that are not universally applicable or defining characteristics of the 'Privileged' profile.",
        "analogy": "The 'Privileged' profile is like giving a master key to a trusted administrator for system maintenance – it grants broad access and bypasses normal security checks, unlike a standard user's limited access."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "KUBERNETES_POD_SECURITY_STANDARDS",
        "CONTAINER_ISOLATION"
      ]
    },
    {
      "question_text": "Which of the following security contexts is typically disallowed in the Kubernetes 'Baseline' Pod Security Standard profile?",
      "correct_answer": "Running pods as HostProcess containers on Windows.",
      "distractors": [
        {
          "text": "Using hostNetwork to share the host's network namespace.",
          "misconception": "Targets [specific control confusion]: While hostNetwork is restricted, HostProcess is a more specific and critical disallowed feature for Windows."
        },
        {
          "text": "Running privileged containers.",
          "misconception": "Targets [level confusion]: 'Privileged containers' are disallowed in 'Baseline', but 'HostProcess' is a more specific example relevant to Windows."
        },
        {
          "text": "Allowing hostPath volumes.",
          "misconception": "Targets [volume type confusion]: HostPath volumes are restricted in 'Restricted' but allowed in 'Baseline' with certain limitations."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'Baseline' Pod Security Standard profile aims to prevent known privilege escalations. On Windows, running HostProcess containers grants privileged access to the host machine, which is explicitly disallowed in the Baseline profile.",
        "distractor_analysis": "While <code>hostNetwork</code> and <code>privileged</code> containers are also restricted, <code>HostProcess</code> on Windows is a key specific control disallowed in Baseline. <code>hostPath</code> volumes are restricted in 'Restricted', not 'Baseline'.",
        "analogy": "The 'Baseline' profile is like a security guard checking for obvious threats. Allowing 'HostProcess' on Windows is like letting someone bring a dangerous tool into a secure area – it's a known risk that must be prevented."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "KUBERNETES_POD_SECURITY_STANDARDS",
        "WINDOWS_CONTAINERS"
      ]
    },
    {
      "question_text": "How does Kubernetes Pod Security Admission (PSA) handle policy violations when configured in <code>audit</code> mode?",
      "correct_answer": "Violations are recorded in the audit log, but the pod is allowed to run.",
      "distractors": [
        {
          "text": "Violations cause the pod to be rejected immediately.",
          "misconception": "Targets [mode confusion]: Describes the 'enforce' mode, not 'audit'."
        },
        {
          "text": "Violations trigger a user-facing warning message.",
          "misconception": "Targets [mode confusion]: Describes the 'warn' mode, not 'audit'."
        },
        {
          "text": "Violations are ignored, and the pod runs without any notification.",
          "misconception": "Targets [logging function confusion]: Assumes audit mode does not record violations."
        }
      ],
      "detailed_explanation": {
        "core_logic": "In 'audit' mode, Pod Security Admission does not prevent pods from being created. Instead, it adds an audit annotation to the event recorded in the Kubernetes audit log, providing visibility into policy violations without blocking execution.",
        "distractor_analysis": "The 'enforce' mode rejects pods, and the 'warn' mode issues warnings. Audit mode's primary function is logging, not blocking or warning.",
        "analogy": "Setting PSA to 'audit' mode is like having a security camera that records suspicious activity but doesn't stop anyone from entering. The footage (audit log) is reviewed later."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "KUBERNETES_POD_SECURITY_ADMISSION",
        "KUBERNETES_AUDIT_LOGS"
      ]
    },
    {
      "question_text": "What is the recommended approach for enforcing Pod Security Standards in modern Kubernetes versions (v1.25+)?",
      "correct_answer": "Using the built-in Pod Security Admission controller.",
      "distractors": [
        {
          "text": "Using the deprecated PodSecurityPolicy (PSP) API.",
          "misconception": "Targets [deprecated technology]: Recommends a feature that has been removed from Kubernetes."
        },
        {
          "text": "Implementing custom network policies to restrict pod behavior.",
          "misconception": "Targets [tool confusion]: Suggests NetworkPolicies, which control network traffic, not pod security contexts."
        },
        {
          "text": "Relying solely on container runtime security features.",
          "misconception": "Targets [scope confusion]: Overlooks Kubernetes-native policy enforcement in favor of lower-level controls."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Since Kubernetes v1.25, the built-in Pod Security Admission controller is the recommended method for enforcing Pod Security Standards, having replaced the deprecated PodSecurityPolicy (PSP) API. It provides a native, namespace-scoped mechanism for policy enforcement.",
        "distractor_analysis": "PodSecurityPolicy (PSP) is removed. Network Policies address network segmentation, not pod security contexts. Container runtime features are important but don't replace Kubernetes-level policy enforcement.",
        "analogy": "In modern Kubernetes, Pod Security Admission is the official, built-in security guard for your building's entrances (namespaces). PodSecurityPolicy was an older, now removed, security system."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "analyze",
      "prerequisites": [
        "KUBERNETES_POD_SECURITY_ADMISSION",
        "KUBERNETES_POD_SECURITY_POLICY"
      ]
    },
    {
      "question_text": "Which Pod Security Standard profile is designed for common containerized workloads and aims to prevent known privilege escalations?",
      "correct_answer": "Baseline",
      "distractors": [
        {
          "text": "Restricted",
          "misconception": "Targets [level confusion]: Associates 'Restricted' with common workloads instead of maximum security."
        },
        {
          "text": "Privileged",
          "misconception": "Targets [level confusion]: Mistakenly believes 'Privileged' is for common, less sensitive workloads."
        },
        {
          "text": "Standard",
          "misconception": "Targets [non-existent profile]: Refers to a profile name that is not part of the Pod Security Standards."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'Baseline' Pod Security Standard profile is specifically tailored for ease of adoption by common containerized workloads, focusing on preventing known privilege escalations without imposing overly strict restrictions.",
        "distractor_analysis": "'Restricted' is the most secure, 'Privileged' is unrestricted, and 'Standard' is not a defined PSS profile.",
        "analogy": "The 'Baseline' profile is like a standard security check at an airport for most passengers – it catches common threats but isn't as intensive as the checks for high-security personnel ('Restricted')."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "KUBERNETES_POD_SECURITY_STANDARDS"
      ]
    },
    {
      "question_text": "In the context of Pod Security Standards, what does the <code>seLinux.rule</code> of <code>MustRunAs</code> with specific options imply for the 'Restricted' profile?",
      "correct_answer": "It requires SELinux to be configured with specific user, role, type, and level settings that align with container security best practices.",
      "distractors": [
        {
          "text": "It allows any SELinux configuration as long as the container runs.",
          "misconception": "Targets [restriction level confusion]: Assumes 'MustRunAs' implies broad allowance rather than specific constraints."
        },
        {
          "text": "It mandates that SELinux be completely disabled for restricted pods.",
          "misconception": "Targets [security feature confusion]: Reverses the intent of SELinux enforcement."
        },
        {
          "text": "It requires SELinux to use a custom policy defined by the user.",
          "misconception": "Targets [policy definition confusion]: Assumes 'MustRunAs' requires user-defined custom policies, not specific predefined options."
        }
      ],
      "detailed_explanation": {
        "core_logic": "For the 'Restricted' profile, <code>seLinux.rule: MustRunAs</code> dictates specific SELinux options for user, role, type, and level that align with hardening best practices, ensuring containers run with least privilege and defined security contexts.",
        "distractor_analysis": "The 'Restricted' profile imposes specific SELinux configurations, not arbitrary allowance, disabling, or user-defined custom policies.",
        "analogy": "Setting <code>seLinux.rule: MustRunAs</code> for 'Restricted' is like requiring a specific uniform (SELinux configuration) for all employees in a secure facility – it ensures everyone adheres to a defined security standard."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "KUBERNETES_POD_SECURITY_STANDARDS",
        "SELINUX"
      ]
    },
    {
      "question_text": "What is the primary difference in volume type restrictions between the 'Baseline' and 'Restricted' Pod Security Standard profiles?",
      "correct_answer": "'Restricted' allows a subset of volume types (e.g., configMap, persistentVolumeClaim), while 'Baseline' disallows only <code>hostPath</code> and wildcard volumes.",
      "distractors": [
        {
          "text": "'Baseline' disallows all volume types except <code>hostPath</code>, while 'Restricted' allows all.",
          "misconception": "Targets [volume type allowance confusion]: Reverses the allowances and restrictions for both profiles."
        },
        {
          "text": "Both profiles disallow <code>hostPath</code> volumes and only allow <code>emptyDir</code>.",
          "misconception": "Targets [profile similarity confusion]: Assumes both profiles have identical, highly restrictive volume policies."
        },
        {
          "text": "'Baseline' allows all volume types, while 'Restricted' only allows <code>emptyDir</code> and <code>secret</code>.",
          "misconception": "Targets [restriction level confusion]: Misrepresents the scope of allowed volumes for both profiles."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'Baseline' profile restricts <code>hostPath</code> and wildcard volumes to prevent direct host access, while the 'Restricted' profile further limits allowed volume types to a curated subset like <code>configMap</code>, <code>csi</code>, <code>persistentVolumeClaim</code>, and <code>secret</code>, enhancing security by minimizing potential attack surfaces.",
        "distractor_analysis": "The correct answer accurately reflects the differing levels of volume type restrictions between 'Baseline' and 'Restricted' profiles. Distractors incorrectly swap allowances, assume identical restrictions, or misrepresent the allowed types.",
        "analogy": "Imagine securing a warehouse: 'Baseline' prevents using dangerous, direct-access tools (<code>hostPath</code>), while 'Restricted' only allows specific, pre-approved equipment (<code>configMap</code>, <code>pvc</code>, etc.) for maximum safety."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "KUBERNETES_POD_SECURITY_STANDARDS",
        "KUBERNETES_VOLUMES"
      ]
    },
    {
      "question_text": "Consider a scenario where a developer needs to deploy a stateless web application that should not be able to escalate privileges. Which Pod Security Standard profile should be enforced on the namespace?",
      "correct_answer": "Restricted",
      "distractors": [
        {
          "text": "Privileged",
          "misconception": "Targets [risk assessment error]: Recommends the least secure profile for a sensitive application."
        },
        {
          "text": "Baseline",
          "misconception": "Targets [inadequate security level]: Suggests a profile that might not prevent all necessary privilege escalations for a web app."
        },
        {
          "text": "Audit",
          "misconception": "Targets [mode vs. profile confusion]: Confuses an admission control mode with a security profile level."
        }
      ],
      "detailed_explanation": {
        "core_logic": "For a stateless web application requiring no privilege escalation, the 'Restricted' Pod Security Standard profile is the most appropriate choice because it enforces current hardening best practices and heavily restricts capabilities, thereby preventing privilege escalation.",
        "distractor_analysis": "'Privileged' is too permissive, 'Baseline' might not be restrictive enough for sensitive applications, and 'Audit' is an enforcement mode, not a security profile.",
        "analogy": "Deploying a web application without privilege escalation needs is like sending a sensitive package via a secure courier ('Restricted'). Using 'Privileged' would be like sending it via an open truck, and 'Baseline' might be a standard mail service with basic checks."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "KUBERNETES_POD_SECURITY_STANDARDS",
        "APPLICATION_SECURITY_PRINCIPLES"
      ]
    },
    {
      "question_text": "What is the role of <code>requiredDropCapabilities</code> in the Pod Security Standards, particularly for the 'Restricted' profile?",
      "correct_answer": "It mandates that all Linux capabilities must be dropped, ensuring containers run with the absolute minimum privileges.",
      "distractors": [
        {
          "text": "It allows specific capabilities to be dropped, with no opinion on others.",
          "misconception": "Targets [scope confusion]: Assumes 'Restricted' has a flexible approach to dropping capabilities."
        },
        {
          "text": "It requires specific capabilities to be added, not dropped.",
          "misconception": "Targets [function confusion]: Reverses the purpose of `requiredDropCapabilities`."
        },
        {
          "text": "It has no opinion for the 'Restricted' profile, allowing all capabilities.",
          "misconception": "Targets [restriction level confusion]: Incorrectly states that 'Restricted' allows all capabilities."
        }
      ],
      "detailed_explanation": {
        "core_logic": "For the 'Restricted' Pod Security Standard profile, <code>requiredDropCapabilities</code> must include <code>ALL</code>, meaning all Linux capabilities are dropped by default. This enforces the principle of least privilege by removing any potentially dangerous capabilities from the container's runtime environment.",
        "distractor_analysis": "The 'Restricted' profile mandates dropping ALL capabilities. Distractors incorrectly suggest flexibility, adding capabilities, or no restrictions.",
        "analogy": "Setting <code>requiredDropCapabilities</code> to <code>ALL</code> for 'Restricted' is like stripping a tool down to its bare minimum components before giving it to someone in a high-security area – you remove anything that could be misused."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "KUBERNETES_POD_SECURITY_STANDARDS",
        "LINUX_CAPABILITIES"
      ]
    },
    {
      "question_text": "Which Kubernetes API object was used to enforce pod security configurations before Pod Security Admission became the standard?",
      "correct_answer": "PodSecurityPolicy (PSP)",
      "distractors": [
        {
          "text": "NetworkPolicy",
          "misconception": "Targets [tool confusion]: Associates network security controls with pod security policy enforcement."
        },
        {
          "text": "PodSecurityContext",
          "misconception": "Targets [object confusion]: Confuses the object defining pod security settings with the policy enforcement API."
        },
        {
          "text": "AdmissionConfiguration",
          "misconception": "Targets [configuration vs. object confusion]: Refers to the configuration for admission controllers, not the deprecated policy object itself."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The PodSecurityPolicy (PSP) API was the primary mechanism in older Kubernetes versions for defining and enforcing security constraints on pods. However, PSP was deprecated in v1.21 and removed in v1.25, being replaced by the more integrated Pod Security Admission controller.",
        "distractor_analysis": "NetworkPolicy controls network access, PodSecurityContext defines settings within a pod spec, and AdmissionConfiguration configures admission controllers, none of which were the direct PSP replacement.",
        "analogy": "PodSecurityPolicy (PSP) was like an old, complex security system for a building that required separate installation and management. Pod Security Admission is the new, integrated security system built directly into the building's management."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "KUBERNETES_POD_SECURITY_POLICY",
        "KUBERNETES_ADMISSION_CONTROLLERS"
      ]
    },
    {
      "question_text": "What is the purpose of the <code>runAsUser</code> field within the Pod Security Standards, specifically for the 'Restricted' profile?",
      "correct_answer": "It mandates that pods must run as a non-root user, enforcing the principle of least privilege.",
      "distractors": [
        {
          "text": "It allows pods to run as any user, including root.",
          "misconception": "Targets [restriction level confusion]: Assumes 'Restricted' allows root execution."
        },
        {
          "text": "It requires pods to run as a specific, predefined user ID.",
          "misconception": "Targets [granularity confusion]: Confuses 'run as non-root' with specifying an exact UID."
        },
        {
          "text": "It has no opinion on the user ID, allowing any value.",
          "misconception": "Targets [profile definition confusion]: Assumes the 'Restricted' profile does not enforce user ID constraints."
        }
      ],
      "detailed_explanation": {
        "core_logic": "For the 'Restricted' Pod Security Standard profile, the <code>runAsUser</code> setting typically enforces a <code>MustRunAsNonRoot</code> rule. This is a critical security measure because running containers as non-root significantly reduces the potential impact of a container compromise.",
        "distractor_analysis": "The 'Restricted' profile explicitly aims to prevent root execution. Distractors incorrectly suggest allowing root, requiring a specific UID, or having no opinion.",
        "analogy": "The <code>runAsUser</code> rule for 'Restricted' is like requiring all workers in a sensitive area to wear non-uniform clothing ('non-root') to avoid confusion with management ('root') and limit their potential authority if compromised."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "KUBERNETES_POD_SECURITY_STANDARDS",
        "PRINCIPLE_OF_LEAST_PRIVILEGE"
      ]
    },
    {
      "question_text": "How can Kubernetes namespaces be configured to define the Pod Security Admission control mode (enforce, audit, warn)?",
      "correct_answer": "By applying specific labels like <code>pod-security.kubernetes.io/&lt;MODE&gt;:&lt;LEVEL&gt;</code> to the namespace.",
      "distractors": [
        {
          "text": "By modifying the kube-apiserver configuration file.",
          "misconception": "Targets [configuration scope confusion]: Confuses cluster-wide defaults with namespace-specific settings."
        },
        {
          "text": "By creating NetworkPolicy resources within the namespace.",
          "misconception": "Targets [resource type confusion]: Associates network policy resources with pod security admission modes."
        },
        {
          "text": "By setting annotations on individual pod definitions.",
          "misconception": "Targets [scope confusion]: Assumes policy is set per-pod rather than per-namespace."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Kubernetes namespaces can be configured to use specific Pod Security Admission control modes (<code>enforce</code>, <code>audit</code>, <code>warn</code>) and levels (<code>privileged</code>, <code>baseline</code>, <code>restricted</code>) by applying corresponding labels, such as <code>pod-security.kubernetes.io/enforce: restricted</code>, directly to the namespace resource.",
        "distractor_analysis": "Namespace labels are the mechanism for per-namespace PSA configuration. The kube-apiserver config sets defaults, NetworkPolicies handle network rules, and pod annotations are for pod-specific settings, not namespace-level admission policies.",
        "analogy": "Configuring PSA modes via namespace labels is like assigning different security clearance levels to different departments (namespaces) within a company using ID badges (<code>labels</code>). The central security office (<code>kube-apiserver</code>) sets overall rules, but department badges define specific access."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "KUBERNETES_POD_SECURITY_ADMISSION",
        "KUBERNETES_NAMESPACES",
        "KUBERNETES_LABELS"
      ]
    },
    {
      "question_text": "What is the primary security benefit of enforcing the 'Restricted' Pod Security Standard profile?",
      "correct_answer": "It significantly reduces the attack surface by disallowing unnecessary capabilities, host access, and privilege escalation.",
      "distractors": [
        {
          "text": "It ensures all pods are encrypted at rest.",
          "misconception": "Targets [scope confusion]: Confuses pod security policy with data-at-rest encryption."
        },
        {
          "text": "It guarantees network segmentation between all pods.",
          "misconception": "Targets [scope confusion]: Associates pod security policy with network segmentation (NetworkPolicies)."
        },
        {
          "text": "It automatically patches vulnerabilities within container images.",
          "misconception": "Targets [remediation confusion]: Assumes admission control performs vulnerability patching."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'Restricted' Pod Security Standard profile enhances security by enforcing strict controls, such as disallowing host namespaces, privileged containers, and excessive Linux capabilities. This minimizes the potential impact of a container compromise and reduces the overall attack surface.",
        "distractor_analysis": "The 'Restricted' profile focuses on pod configuration and runtime security, not data encryption, network segmentation, or automated vulnerability patching.",
        "analogy": "The 'Restricted' profile is like a highly secure vault for your applications. It limits what tools (<code>capabilities</code>) and access (<code>host access</code>) are allowed inside, drastically reducing the risk of a breach, unlike data encryption or network firewalls."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "analyze",
      "prerequisites": [
        "KUBERNETES_POD_SECURITY_STANDARDS",
        "ATTACK_SURFACE_REDUCTION"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 16,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Pod Security Policy Validation 008_Application Security best practices",
    "latency_ms": 27993.739
  },
  "timestamp": "2026-01-18T12:46:30.581161"
}