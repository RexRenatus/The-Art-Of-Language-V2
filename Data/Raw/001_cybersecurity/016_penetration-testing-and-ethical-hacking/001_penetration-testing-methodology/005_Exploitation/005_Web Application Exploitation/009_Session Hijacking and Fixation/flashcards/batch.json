{
  "topic_title": "Session Hijacking and Fixation",
  "category": "Cybersecurity - Penetration Testing And Ethical Hacking - Penetration Testing Methodology",
  "flashcards": [
    {
      "question_text": "What is the primary goal of a session hijacking attack?",
      "correct_answer": "To gain unauthorized access to a user's session by stealing or predicting their session token.",
      "distractors": [
        {
          "text": "To prevent users from logging into their accounts.",
          "misconception": "Targets [denial of service confusion]: Confuses hijacking with DoS attacks."
        },
        {
          "text": "To modify the application's source code.",
          "misconception": "Targets [scope confusion]: Misunderstands the target of the attack, conflating it with code injection."
        },
        {
          "text": "To force a user to accept a new, attacker-controlled session ID.",
          "misconception": "Targets [fixation vs. hijacking confusion]: Confuses the goal of session fixation with the outcome of hijacking."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Session hijacking aims to impersonate a legitimate user by obtaining their active session token, because the token represents authenticated user state. This allows the attacker to bypass authentication and access resources as if they were the user.",
        "distractor_analysis": "The first distractor describes a denial-of-service attack. The second misattributes the goal to code modification. The third describes session fixation, a related but distinct attack.",
        "analogy": "Imagine an attacker stealing your house key while you're inside, allowing them to enter and act as you."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SESSION_MANAGEMENT_BASICS",
        "AUTHENTICATION_TOKENS"
      ]
    },
    {
      "question_text": "Which of the following is a common method for session hijacking?",
      "correct_answer": "Session sniffing by capturing session tokens over an unencrypted channel.",
      "distractors": [
        {
          "text": "Brute-forcing the user's password.",
          "misconception": "Targets [authentication method confusion]: Confuses session hijacking with password brute-forcing."
        },
        {
          "text": "Exploiting SQL injection vulnerabilities to gain administrative access.",
          "misconception": "Targets [vulnerability type confusion]: Mixes session hijacking with SQL injection, a different attack vector."
        },
        {
          "text": "Performing a denial-of-service attack on the authentication server.",
          "misconception": "Targets [attack objective confusion]: Confuses session hijacking with DoS, which aims to disrupt service."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Session sniffing is a direct method for session hijacking because it allows an attacker to capture a valid session token transmitted over an insecure network. Once captured, the token can be used to impersonate the user.",
        "distractor_analysis": "The distractors describe unrelated attacks: password brute-forcing, SQL injection, and DoS, none of which directly involve stealing an active session token.",
        "analogy": "It's like listening in on a phone call to get someone's private access code."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "attack",
      "bloom_level": "apply",
      "prerequisites": [
        "SESSION_SNIFFING",
        "NETWORK_SECURITY_BASICS"
      ]
    },
    {
      "question_text": "What is the core vulnerability exploited in a session fixation attack?",
      "correct_answer": "The web application allows a user to authenticate without regenerating or invalidating the existing session token.",
      "distractors": [
        {
          "text": "The session token is too short and easily guessable.",
          "misconception": "Targets [token predictability confusion]: Attributes fixation to token weakness, not regeneration failure."
        },
        {
          "text": "The server does not properly validate the origin of the session token.",
          "misconception": "Targets [validation confusion]: Focuses on token origin validation, not session regeneration."
        },
        {
          "text": "Cross-site scripting (XSS) vulnerabilities allow token theft.",
          "misconception": "Targets [attack vector confusion]: Confuses session fixation with XSS, which is a method for hijacking, not fixation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Session fixation occurs because the application fails to issue a new session token upon successful authentication. Therefore, an attacker can pre-set a session ID, and if the user logs in with that ID, the attacker can then use it to hijack the session.",
        "distractor_analysis": "The first distractor describes a weakness that aids hijacking, not fixation. The second is a general security flaw. The third describes a method for hijacking, not the core fixation vulnerability.",
        "analogy": "It's like an attacker giving you a pre-numbered lottery ticket and telling you to use it to buy a prize; if you win, they already have the winning ticket."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SESSION_MANAGEMENT_BASICS",
        "AUTHENTICATION_PROCESS"
      ]
    },
    {
      "question_text": "According to the OWASP Web Security Testing Guide (WSTG), what is a key test for session fixation?",
      "correct_answer": "Attempting to authenticate after an attacker has provided a known session ID and checking if the session ID changes.",
      "distractors": [
        {
          "text": "Injecting malicious scripts to steal the session cookie.",
          "misconception": "Targets [hijacking vs. fixation test confusion]: Describes a session hijacking test, not fixation."
        },
        {
          "text": "Analyzing the session token's entropy to determine its randomness.",
          "misconception": "Targets [token strength vs. fixation confusion]: Focuses on token strength, not the regeneration mechanism."
        },
        {
          "text": "Testing for weak cookie attributes like 'HttpOnly' and 'Secure'.",
          "misconception": "Targets [cookie attribute vs. fixation confusion]: Addresses cookie security, not the session fixation vulnerability."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The WSTG recommends testing session fixation by observing if the session ID changes post-authentication. If it remains the same, it indicates the application is vulnerable because the attacker's pre-set session ID is still valid.",
        "distractor_analysis": "The first distractor is a session hijacking test. The second tests token strength, not fixation. The third tests cookie security, which is related but distinct from fixation.",
        "analogy": "It's like checking if the hotel re-keys your room after you check in with a key the concierge gave you."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "WSTG",
        "SESSION_FIXATION_TESTING"
      ]
    },
    {
      "question_text": "How can an attacker leverage Cross-Site Scripting (XSS) to facilitate session hijacking?",
      "correct_answer": "By injecting JavaScript code that steals the user's session cookie and sends it to the attacker.",
      "distractors": [
        {
          "text": "By redirecting the user to a malicious website that mimics the login page.",
          "misconception": "Targets [phishing vs. XSS confusion]: Describes phishing, not how XSS directly steals tokens."
        },
        {
          "text": "By exploiting a vulnerability to directly modify the user's session data on the server.",
          "misconception": "Targets [server-side vs. client-side confusion]: XSS primarily targets the client-side browser."
        },
        {
          "text": "By forcing the browser to send requests with an attacker-controlled session ID.",
          "misconception": "Targets [XSS vs. fixation confusion]: Describes session fixation, not the mechanism of XSS token theft."
        }
      ],
      "detailed_explanation": {
        "core_logic": "XSS allows an attacker to execute arbitrary JavaScript in the victim's browser, because the browser trusts the script as if it came from the legitimate website. This script can then access <code>document.cookie</code> to retrieve the session token and transmit it to the attacker.",
        "distractor_analysis": "The first distractor describes phishing. The second misattributes the attack's scope to server-side modification. The third describes session fixation, not XSS token theft.",
        "analogy": "It's like tricking a trusted messenger (the browser) into reading a secret note (the cookie) and writing it down for you."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "XSS_BASICS",
        "SESSION_HIJACKING_METHODS"
      ]
    },
    {
      "question_text": "What is the recommended defense against session fixation attacks?",
      "correct_answer": "Regenerate the session identifier upon successful user authentication.",
      "distractors": [
        {
          "text": "Implement strong password policies for all users.",
          "misconception": "Targets [defense mechanism confusion]: Password policies protect against credential theft, not session fixation."
        },
        {
          "text": "Encrypt all session cookies using TLS/SSL.",
          "misconception": "Targets [encryption vs. regeneration confusion]: Encryption protects token confidentiality, but doesn't prevent fixation if the token isn't refreshed."
        },
        {
          "text": "Use shorter, more frequent session timeouts.",
          "misconception": "Targets [timeout vs. fixation confusion]: Shorter timeouts reduce the window of opportunity for hijacking, but don't fix the fixation vulnerability itself."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Regenerating the session identifier upon authentication is the primary defense because it invalidates any pre-set session ID the attacker might have provided. This ensures that the user is assigned a new, unique session token, breaking the fixation chain.",
        "distractor_analysis": "Password policies are for authentication strength. Encryption protects the token in transit. Shorter timeouts mitigate hijacking risk but don't solve the root cause of fixation.",
        "analogy": "It's like getting a new room key every time you check into a hotel, even if you're staying longer."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "SESSION_MANAGEMENT_BEST_PRACTICES",
        "AUTHENTICATION_SECURITY"
      ]
    },
    {
      "question_text": "Which of the following best describes 'Session Sniffing' in the context of session hijacking?",
      "correct_answer": "Capturing session tokens transmitted over an unencrypted network connection.",
      "distractors": [
        {
          "text": "Predicting a valid session token through mathematical algorithms.",
          "misconception": "Targets [sniffing vs. prediction confusion]: Describes token prediction, a different hijacking method."
        },
        {
          "text": "Exploiting a vulnerability to force a user to accept a specific session ID.",
          "misconception": "Targets [sniffing vs. fixation confusion]: Describes session fixation, not sniffing."
        },
        {
          "text": "Using malware on the client-side to steal session cookies.",
          "misconception": "Targets [sniffing vs. client-side attack confusion]: Describes client-side attacks like XSS or Trojans, not network sniffing."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Session sniffing involves intercepting network traffic to capture session tokens, because these tokens are often transmitted in plain text over HTTP. By capturing these tokens, an attacker can then use them to impersonate the user.",
        "distractor_analysis": "The distractors describe token prediction, session fixation, and client-side attacks, which are distinct methods of compromising session tokens.",
        "analogy": "It's like eavesdropping on a conversation to hear someone's secret code word."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "NETWORK_PROTOCOLS",
        "ENCRYPTION_BASICS"
      ]
    },
    {
      "question_text": "What is the risk associated with predictable session tokens?",
      "correct_answer": "Attackers can easily guess or generate valid session tokens, leading to session hijacking.",
      "distractors": [
        {
          "text": "The application may crash due to invalid token formats.",
          "misconception": "Targets [risk type confusion]: Predictable tokens don't typically cause crashes, but rather unauthorized access."
        },
        {
          "text": "Users may be locked out of their accounts due to token collisions.",
          "misconception": "Targets [risk type confusion]: Token collisions are rare and usually handled; the main risk is hijacking."
        },
        {
          "text": "The server may become overloaded processing too many valid tokens.",
          "misconception": "Targets [risk type confusion]: Predictability doesn't inherently increase the number of valid tokens, just the ease of guessing them."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Predictable session tokens are a major security risk because attackers can systematically generate or guess valid tokens, thereby bypassing the need to steal an active token. This directly enables session hijacking.",
        "distractor_analysis": "The distractors describe potential side effects or unrelated risks, rather than the primary security implication of predictable tokens.",
        "analogy": "It's like using a combination lock where the combination is always 1-2-3; anyone can open it."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SESSION_TOKEN_GENERATION",
        "RANDOMNESS_IN_SECURITY"
      ]
    },
    {
      "question_text": "In the context of web security testing, what does 'Testing for Exposed Session Variables' (WSTG-SESS-04) aim to identify?",
      "correct_answer": "Session identifiers or sensitive user data being exposed in URLs, hidden form fields, or client-side scripts.",
      "distractors": [
        {
          "text": "Weaknesses in the application's authentication mechanism.",
          "misconception": "Targets [scope confusion]: Focuses on authentication, not the exposure of session-related data."
        },
        {
          "text": "Vulnerabilities that allow for cross-site request forgery (CSRF).",
          "misconception": "Targets [vulnerability type confusion]: CSRF is a different attack vector related to state-changing requests."
        },
        {
          "text": "Insecure direct object references (IDOR) in API endpoints.",
          "misconception": "Targets [vulnerability type confusion]: IDOR relates to accessing resources directly via identifiers, not session variable exposure."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Testing for exposed session variables is crucial because session identifiers or sensitive data embedded in URLs or client-side code can be easily intercepted or accessed by attackers, facilitating session hijacking or information disclosure.",
        "distractor_analysis": "The distractors describe other types of web vulnerabilities (authentication weaknesses, CSRF, IDOR) that are distinct from the specific issue of session variable exposure.",
        "analogy": "It's like leaving your user ID and password written on a public notice board instead of keeping them private."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "WSTG",
        "SESSION_MANAGEMENT_SECURITY"
      ]
    },
    {
      "question_text": "What is the primary difference between session hijacking and session fixation?",
      "correct_answer": "Session hijacking involves stealing an *active* session token, while session fixation involves an attacker *forcing* a user to use a known, pre-determined session token.",
      "distractors": [
        {
          "text": "Session hijacking targets the server, while session fixation targets the client.",
          "misconception": "Targets [attack target confusion]: Both attacks primarily target the session management mechanism, often involving client-side interaction."
        },
        {
          "text": "Session hijacking uses encryption, while session fixation uses obfuscation.",
          "misconception": "Targets [technique confusion]: Neither attack inherently relies on encryption or obfuscation as their core mechanism."
        },
        {
          "text": "Session hijacking is an active attack, while session fixation is a passive attack.",
          "misconception": "Targets [attack type confusion]: Both can involve active and passive elements, but fixation is more about manipulation before authentication."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The key distinction lies in the attacker's action: hijacking steals an existing, valid token from an active session, whereas fixation involves the attacker providing a token *before* the user authenticates, and the vulnerability is the server accepting that pre-set token.",
        "distractor_analysis": "The distractors misrepresent the targets, techniques, or attack types of these related but distinct session vulnerabilities.",
        "analogy": "Hijacking is like stealing someone's car keys while they're driving. Fixation is like giving someone a specific key and telling them to use it to start their car, then you already have a copy of that key."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "SESSION_HIJACKING",
        "SESSION_FIXATION"
      ]
    },
    {
      "question_text": "How does the 'Secure' flag on a cookie help mitigate session hijacking risks?",
      "correct_answer": "It ensures the cookie is only transmitted over an encrypted HTTPS connection, preventing sniffing.",
      "distractors": [
        {
          "text": "It prevents the cookie from being accessed by client-side JavaScript.",
          "misconception": "Targets [flag function confusion]: This is the function of the 'HttpOnly' flag, not 'Secure'."
        },
        {
          "text": "It forces the browser to discard the cookie after a certain period.",
          "misconception": "Targets [flag function confusion]: This relates to cookie expiration, not the 'Secure' flag."
        },
        {
          "text": "It prevents the cookie from being stored in the browser's cache.",
          "misconception": "Targets [flag function confusion]: The 'Secure' flag does not control caching behavior."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'Secure' flag instructs the browser to only send the cookie over HTTPS (encrypted) connections. This is crucial because it prevents attackers from sniffing the session token if they are positioned to intercept network traffic on an unencrypted channel.",
        "distractor_analysis": "The distractors incorrectly describe the functions of the 'HttpOnly' flag, cookie expiration, or caching, rather than the specific purpose of the 'Secure' flag.",
        "analogy": "It's like putting a letter in a tamper-proof, secure envelope that can only be sent via a trusted courier, preventing anyone from reading it along the way."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "HTTP_COOKIES",
        "HTTPS_BASICS"
      ]
    },
    {
      "question_text": "What is the purpose of the 'HttpOnly' flag on a session cookie?",
      "correct_answer": "To prevent client-side scripts (like JavaScript) from accessing the cookie, thereby mitigating XSS-based session hijacking.",
      "distractors": [
        {
          "text": "To ensure the cookie is only sent over HTTPS connections.",
          "misconception": "Targets [flag confusion]: This is the function of the 'Secure' flag."
        },
        {
          "text": "To automatically expire the cookie after a set duration.",
          "misconception": "Targets [flag confusion]: This relates to cookie expiration settings, not the 'HttpOnly' flag."
        },
        {
          "text": "To prevent the cookie from being stored in browser history.",
          "misconception": "Targets [flag confusion]: The 'HttpOnly' flag does not affect browser history."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'HttpOnly' flag restricts cookie access to the HTTP protocol only, meaning JavaScript running in the browser cannot read it. This is a vital defense because it prevents XSS attacks from stealing the session cookie.",
        "distractor_analysis": "The distractors incorrectly attribute the functions of the 'Secure' flag, cookie expiration, or browser history management to the 'HttpOnly' flag.",
        "analogy": "It's like putting a document in a locked filing cabinet that only the main office (the web server) can access, preventing unauthorized employees (client-side scripts) from reading it."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "HTTP_COOKIES",
        "XSS_MITIGATION"
      ]
    },
    {
      "question_text": "Consider a scenario: An attacker performs session fixation by sending a user a link containing a specific session ID. The user clicks the link, logs in, and the application uses the attacker-provided session ID. What is the most critical next step for the attacker?",
      "correct_answer": "Use the known session ID to access the application as the authenticated user.",
      "distractors": [
        {
          "text": "Attempt to inject SQL commands into the login form.",
          "misconception": "Targets [attack vector confusion]: The user is already authenticated; SQL injection is a different attack."
        },
        {
          "text": "Try to change the user's password to lock them out.",
          "misconception": "Targets [attack objective confusion]: While possible, the primary goal is to impersonate, not just deny access."
        },
        {
          "text": "Scan the application for other vulnerabilities like XSS.",
          "misconception": "Targets [prioritization confusion]: The immediate goal is to leverage the established session, not search for new vulnerabilities."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Once a user authenticates with an attacker-controlled session ID (session fixation), the attacker's immediate goal is to leverage that established session. Therefore, they use the known session ID to access the application and impersonate the user.",
        "distractor_analysis": "The distractors describe unrelated attacks (SQL injection, lockout) or secondary objectives (scanning for other vulns) that are not the most critical immediate action after successful fixation.",
        "analogy": "The attacker has successfully planted their key in your car's ignition; their next step is to drive the car away."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "SESSION_FIXATION",
        "SESSION_HIJACKING"
      ]
    },
    {
      "question_text": "What is the role of JSON Web Tokens (JWT) in session management, and what are common security concerns?",
      "correct_answer": "JWTs are used to transmit user identity and authorization information, but can be vulnerable if not properly signed, validated, or if sensitive data is included.",
      "distractors": [
        {
          "text": "JWTs are primarily used for encrypting sensitive user data, making them a replacement for traditional encryption.",
          "misconception": "Targets [token purpose confusion]: JWTs are for transmitting claims, not primary encryption."
        },
        {
          "text": "JWTs are inherently secure and do not require additional validation beyond checking the signature.",
          "misconception": "Targets [security assumption error]: JWTs require robust validation, including signature verification and checking claims."
        },
        {
          "text": "JWTs are only used for stateless authentication and cannot be used for session fixation or hijacking.",
          "misconception": "Targets [statelessness vs. vulnerability confusion]: Statelessness doesn't prevent fixation/hijacking if tokens are weak or mishandled."
        }
      ],
      "detailed_explanation": {
        "core_logic": "JWTs provide a compact and self-contained way to transmit information between parties, often used for session management. However, their security relies heavily on proper implementation: using strong signing algorithms (like RS256), validating signatures, checking claims (like expiration), and avoiding sensitive data in the payload.",
        "distractor_analysis": "The distractors misrepresent JWTs as a primary encryption method, falsely claim inherent security, or incorrectly state they are immune to session-related attacks.",
        "analogy": "A JWT is like a passport: it contains identifying information and can be used for travel (authentication), but it needs to be valid (signed/validated) and checked carefully to ensure it's not forged or expired."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "JWT_BASICS",
        "SESSION_MANAGEMENT_PATTERNS"
      ]
    },
    {
      "question_text": "Which of the following is NOT a common technique used in session hijacking?",
      "correct_answer": "Man-in-the-browser (MitB) attack",
      "distractors": [
        {
          "text": "Session sniffing",
          "misconception": "Targets [technique identification error]: Session sniffing is a common hijacking technique."
        },
        {
          "text": "Cross-site scripting (XSS)",
          "misconception": "Targets [technique identification error]: XSS is frequently used to steal session cookies."
        },
        {
          "text": "Predictable session token generation",
          "misconception": "Targets [technique identification error]: Predictable tokens directly enable hijacking."
        }
      ],
      "detailed_explanation": {
        "core_logic": "While Man-in-the-Browser (MitB) attacks can compromise user sessions, they are distinct from typical session hijacking methods like sniffing, XSS, or exploiting predictable tokens. MitB involves malware on the user's machine that can intercept or manipulate browser activity, including session data, but it's a specific type of client-side compromise.",
        "distractor_analysis": "Session sniffing, XSS, and predictable tokens are all direct methods or enablers of session hijacking. MitB is a related but more specific client-side attack vector.",
        "analogy": "If session hijacking is like pickpocketing a wallet, sniffing/XSS/predictable tokens are like using a distraction or a fake wallet. MitB is more like having a spy inside the person's own house."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "SESSION_HIJACKING_TECHNIQUES",
        "MITB_ATTACKS"
      ]
    },
    {
      "question_text": "What is the primary security benefit of using SameSite cookies (e.g., Lax or Strict) in preventing session hijacking and fixation?",
      "correct_answer": "They restrict when cookies are sent with cross-site requests, limiting the ability of external sites to trigger authentication or steal session tokens.",
      "distractors": [
        {
          "text": "They encrypt the cookie data to protect it from sniffing.",
          "misconception": "Targets [encryption confusion]: SameSite is about request context, not data encryption."
        },
        {
          "text": "They force the browser to regenerate the session ID upon login.",
          "misconception": "Targets [regeneration confusion]: SameSite does not directly control session ID regeneration."
        },
        {
          "text": "They ensure that session tokens are always transmitted over HTTPS.",
          "misconception": "Targets [protocol confusion]: SameSite is independent of the transport protocol (HTTP/HTTPS)."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SameSite cookie attributes control whether cookies are sent with cross-site requests. 'Strict' prevents cookies from being sent with any cross-site request, and 'Lax' allows them only with top-level navigation GET requests. This significantly hinders attacks like session fixation and hijacking that rely on cross-site interactions.",
        "distractor_analysis": "The distractors incorrectly describe SameSite cookies as performing encryption, forcing session ID regeneration, or enforcing HTTPS transmission.",
        "analogy": "SameSite cookies are like security guards at a building's entrance, deciding who gets in based on where the visitor is coming from (same site vs. cross-site request)."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "defense",
      "bloom_level": "evaluate",
      "prerequisites": [
        "HTTP_COOKIES",
        "BROWSER_SECURITY_FEATURES"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 16,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Session Hijacking and Fixation Penetration Testing And Ethical Hacking best practices",
    "latency_ms": 24639.385000000002
  },
  "timestamp": "2026-01-18T14:21:43.326300",
  "_av_safe_encoded": true,
  "_encoding_note": "Educational content encoded with HTML entities to prevent antivirus false positives. Content renders normally in Anki."
}