{
  "topic_title": "Boolean-based SQL Injection Tools",
  "category": "Cybersecurity - Penetration Testing And Ethical Hacking - Penetration Testing Tools",
  "flashcards": [
    {
      "question_text": "Which of the following best describes the core mechanism of a boolean-based blind SQL injection attack?",
      "correct_answer": "Injecting conditional SQL statements that result in different HTTP responses based on true/false outcomes.",
      "distractors": [
        {
          "text": "Injecting SQL statements that cause database errors to reveal data.",
          "misconception": "Targets [technique confusion]: Confuses boolean-based injection with error-based SQL injection."
        },
        {
          "text": "Injecting SQL statements that cause time delays in the database response.",
          "misconception": "Targets [technique confusion]: Confuses boolean-based injection with time-based blind SQL injection."
        },
        {
          "text": "Injecting SQL statements that directly extract data into the HTTP response.",
          "misconception": "Targets [technique confusion]: Confuses blind injection with in-band SQL injection."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Boolean-based blind SQL injection works by injecting conditional SQL statements (e.g., AND 1=1, AND 1=2) and observing differences in the application's HTTP response. This allows an attacker to infer data character by character because each true/false condition yields a distinct response.",
        "distractor_analysis": "The distractors incorrectly describe error-based, time-based, and in-band SQL injection techniques, failing to identify the conditional response mechanism specific to boolean-based blind SQL injection.",
        "analogy": "It's like asking a series of yes/no questions to a person who can only respond by either smiling (true) or frowning (false), gradually piecing together information."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SQLI_BASICS",
        "SQLI_BLIND_TYPES"
      ]
    },
    {
      "question_text": "What is the primary advantage of using a tool like sqlmap for boolean-based SQL injection compared to manual testing?",
      "correct_answer": "Automation of repetitive requests and response analysis, significantly speeding up the process.",
      "distractors": [
        {
          "text": "It guarantees exploitation of all SQL injection vulnerabilities.",
          "misconception": "Targets [overestimation of capability]: Assumes tools are foolproof and can always succeed."
        },
        {
          "text": "It bypasses the need for understanding SQL syntax and database structures.",
          "misconception": "Targets [skill overestimation]: Believes tools eliminate the need for foundational knowledge."
        },
        {
          "text": "It can only detect boolean-based blind SQL injection, making it highly specialized.",
          "misconception": "Targets [tool scope misunderstanding]: Incorrectly limits the tool's detection capabilities."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Tools like sqlmap automate the process of sending numerous conditional queries and analyzing HTTP responses, which is crucial for boolean-based blind SQL injection. This automation is far more efficient than manual testing because it systematically covers many possibilities.",
        "distractor_analysis": "The distractors overstate tool capabilities, downplay the need for user knowledge, and misrepresent the tool's scope, failing to acknowledge the efficiency gains from automation as the primary advantage.",
        "analogy": "It's like using a power drill instead of a hand screwdriver for a large project; the drill automates the repetitive action, saving significant time and effort."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SQLI_TOOLS",
        "SQLI_AUTOMATION"
      ]
    },
    {
      "question_text": "When using a tool for boolean-based SQL injection, what is the significance of analyzing HTTP response differences?",
      "correct_answer": "Subtle variations in response content or timing indicate whether an injected condition is true or false.",
      "distractors": [
        {
          "text": "They confirm the server is running a vulnerable version of the database.",
          "misconception": "Targets [vulnerability correlation]: Assumes response differences directly identify vulnerable software versions."
        },
        {
          "text": "They indicate the presence of other types of web vulnerabilities.",
          "misconception": "Targets [cross-vulnerability confusion]: Believes SQL injection indicators point to unrelated vulnerabilities."
        },
        {
          "text": "They are used to identify the specific SQL injection payload that was successful.",
          "misconception": "Targets [payload identification confusion]: Assumes response differences directly reveal the exact payload, rather than its effect."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The core of boolean-based blind SQL injection relies on observing how the application's HTTP response changes based on the truthiness of an injected SQL condition. Therefore, analyzing these differences is fundamental to inferring data, because each variation signifies a true or false outcome.",
        "distractor_analysis": "The distractors misattribute the significance of response differences, linking them to server versions, unrelated vulnerabilities, or direct payload identification, rather than their role in determining the truth value of injected conditions.",
        "analogy": "It's like a game of 'hot or cold' where the subtle changes in the response (e.g., a slightly longer page, a different word appearing) tell you if you're getting closer (true) or further away (false) from the hidden information."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SQLI_BLIND_TYPES",
        "HTTP_BASICS"
      ]
    },
    {
      "question_text": "Which of the following is a common technique used by tools to automate boolean-based blind SQL injection?",
      "correct_answer": "Employing a bisection algorithm to efficiently guess characters of the target data.",
      "distractors": [
        {
          "text": "Performing brute-force attacks on database credentials.",
          "misconception": "Targets [technique confusion]: Confuses SQL injection with credential stuffing or brute-force attacks."
        },
        {
          "text": "Analyzing server-side log files for injection attempts.",
          "misconception": "Targets [data source confusion]: Assumes tools analyze server logs for injection success, rather than HTTP responses."
        },
        {
          "text": "Exploiting known vulnerabilities in the web server software.",
          "misconception": "Targets [vulnerability type confusion]: Confuses SQL injection with exploiting web server software flaws."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Tools like sqlmap often use a bisection algorithm, similar to binary search, to efficiently determine characters for boolean-based blind SQL injection. This works by repeatedly narrowing down the possible range of characters, significantly reducing the number of requests needed compared to a linear guess.",
        "distractor_analysis": "The distractors describe unrelated attack vectors (credential brute-force, log analysis, web server exploits) instead of the efficient character-guessing algorithm characteristic of boolean-based blind SQL injection automation.",
        "analogy": "It's like finding a word in a dictionary. Instead of checking every word from A to Z, you open to the middle, see if your word comes before or after, and then focus on that half, repeating the process."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "SQLI_AUTOMATION",
        "ALGORITHMS"
      ]
    },
    {
      "question_text": "What is the primary goal when using a tool to perform boolean-based SQL injection?",
      "correct_answer": "To infer sensitive data from the database by making the application reveal information through true/false responses.",
      "distractors": [
        {
          "text": "To directly download the entire database file from the server.",
          "misconception": "Targets [exploitation method confusion]: Assumes direct file access is the typical outcome of blind SQLi."
        },
        {
          "text": "To execute arbitrary operating system commands on the server.",
          "misconception": "Targets [vulnerability type confusion]: Confuses SQL injection with command injection vulnerabilities."
        },
        {
          "text": "To crash the database server through malformed queries.",
          "misconception": "Targets [attack objective confusion]: Assumes the goal is denial of service rather than data exfiltration."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The primary objective of boolean-based blind SQL injection is data exfiltration. Since direct data retrieval isn't possible, attackers use conditional logic to infer data character by character, because each true/false outcome provides a piece of the puzzle.",
        "distractor_analysis": "The distractors describe outcomes associated with different types of vulnerabilities (direct database access, OS command injection, denial of service) rather than the specific data inference goal of boolean-based blind SQL injection.",
        "analogy": "The goal is to extract secrets from a locked vault by asking questions like 'Is the first digit of the code a 5?' and observing if the guard nods (true) or shakes their head (false)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SQLI_BLIND_TYPES",
        "DATA_EXFILTRATION"
      ]
    },
    {
      "question_text": "Which of the following is a key consideration when configuring a tool for boolean-based SQL injection against a target?",
      "correct_answer": "Identifying the correct parameter to test and understanding how the application handles different HTTP response codes.",
      "distractors": [
        {
          "text": "Ensuring the target server has a public IP address.",
          "misconception": "Targets [environmental assumption]: Assumes only publicly accessible servers are vulnerable."
        },
        {
          "text": "Verifying the target database is running the latest version.",
          "misconception": "Targets [vulnerability assumption]: Believes only outdated software is vulnerable."
        },
        {
          "text": "Confirming the target application uses a specific programming language.",
          "misconception": "Targets [language specificity]: Assumes SQL injection is tied to a particular backend language."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Effective boolean-based SQL injection requires identifying the vulnerable input parameter and understanding how the application's responses (including HTTP status codes) vary based on injected conditions. This allows the tool to correctly interpret true/false outcomes, because the application's behavior is the signal.",
        "distractor_analysis": "The distractors focus on irrelevant or incorrect prerequisites, such as server accessibility, software versioning, or programming language, instead of the critical aspects of parameter identification and response code analysis.",
        "analogy": "When trying to pick a lock, you need to know which keyhole to use (the parameter) and how the tumblers react when you insert a pick (response codes)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "SQLI_TARGETING",
        "HTTP_BASICS"
      ]
    },
    {
      "question_text": "How does a tool differentiate between a 'true' and 'false' response in boolean-based blind SQL injection?",
      "correct_answer": "By comparing HTTP responses for consistent differences in content, length, or status codes based on injected conditions.",
      "distractors": [
        {
          "text": "By analyzing the server's system logs for specific error messages.",
          "misconception": "Targets [data source confusion]: Assumes tools analyze server logs instead of HTTP responses."
        },
        {
          "text": "By checking if the database server returns a specific SQL error.",
          "misconception": "Targets [technique confusion]: Confuses blind injection with error-based SQL injection."
        },
        {
          "text": "By measuring the exact time difference between request and response.",
          "misconception": "Targets [technique confusion]: Confuses boolean-based injection with time-based blind SQL injection."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Tools differentiate true/false responses by detecting consistent variations in the HTTP response generated by the web application. These variations can be in the page content, response length, or HTTP status codes, because these elements change based on whether the injected SQL condition evaluates to true or false.",
        "distractor_analysis": "The distractors incorrectly suggest that differentiation relies on server logs, SQL errors, or time delays, which are characteristic of other attack types or data sources, not the response comparison central to boolean-based blind SQL injection.",
        "analogy": "It's like a game where one person says 'Open Sesame&#33;' and the other person observes if the cave entrance opens (true) or stays shut (false), looking for any subtle change."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "SQLI_BLIND_TYPES",
        "HTTP_ANALYSIS"
      ]
    },
    {
      "question_text": "What is the role of the 'payload' in a boolean-based SQL injection attack executed by a tool?",
      "correct_answer": "The payload is the crafted SQL statement injected into the application's input to test conditions.",
      "distractors": [
        {
          "text": "It is the database schema definition that the tool aims to retrieve.",
          "misconception": "Targets [objective confusion]: Confuses the injected code with the target data structure."
        },
        {
          "text": "It is the tool's configuration file that dictates the attack strategy.",
          "misconception": "Targets [component confusion]: Mistakes the attack vector for the tool's settings."
        },
        {
          "text": "It is the final extracted data that the attacker obtains.",
          "misconception": "Targets [result confusion]: Confuses the input used for attack with the final output."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The payload in SQL injection is the malicious SQL code snippet that an attacker injects into an application's input field. For boolean-based attacks, these payloads are designed as conditional statements (e.g., ' OR 1=1 -- ') to elicit different responses, thereby revealing information.",
        "distractor_analysis": "The distractors misidentify the payload as the database schema, the tool's configuration, or the extracted data, failing to recognize it as the actual SQL code being injected to test conditions.",
        "analogy": "The payload is like a specific question you ask someone to gauge their reaction, such as 'Is your name John?' to see if they confirm or deny it."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SQLI_BASICS",
        "SQLI_PAYLOADS"
      ]
    },
    {
      "question_text": "Which OWASP Web Security Testing Guide (WSTG) category most directly covers testing for SQL injection vulnerabilities, including boolean-based types?",
      "correct_answer": "WSTG-INPV-05: Testing for SQL Injection",
      "distractors": [
        {
          "text": "WSTG-ATHP-02: Testing for Business Logic Flaws",
          "misconception": "Targets [category confusion]: Incorrectly associates SQL injection with business logic testing."
        },
        {
          "text": "WSTG-ERRH-01: Testing for Improper Error Handling",
          "misconception": "Targets [technique confusion]: Links SQL injection solely to error handling, ignoring other types."
        },
        {
          "text": "WSTG-SESS-01: Testing for Session Management Flaws",
          "misconception": "Targets [category confusion]: Associates SQL injection with session management vulnerabilities."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The OWASP Web Security Testing Guide (WSTG) explicitly categorizes SQL injection testing under 'WSTG-INPV-05: Testing for SQL Injection'. This section details various SQL injection techniques, including blind types, because it's a critical input validation vulnerability.",
        "distractor_analysis": "The distractors point to unrelated WSTG categories, such as business logic flaws, error handling, or session management, failing to identify the specific category dedicated to SQL injection testing.",
        "analogy": "It's like looking for a specific tool in a toolbox; you wouldn't search the screwdriver drawer for a wrench, you'd go to the SQL injection section."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "OWASP_WSTG",
        "SQLI_BASICS"
      ]
    },
    {
      "question_text": "What is a potential risk if a tool incorrectly identifies a 'true' response during boolean-based SQL injection?",
      "correct_answer": "The tool might proceed down an incorrect path, leading to wasted time and inaccurate data inference.",
      "distractors": [
        {
          "text": "It could trigger an immediate security alert on the target system.",
          "misconception": "Targets [detection assumption]: Assumes incorrect analysis always leads to detection."
        },
        {
          "text": "It might cause the database to corrupt its own data.",
          "misconception": "Targets [impact overestimation]: Assumes minor analysis errors cause catastrophic data corruption."
        },
        {
          "text": "It could lead to the tool automatically patching the vulnerability.",
          "misconception": "Targets [tool capability misunderstanding]: Assumes penetration testing tools also perform remediation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "An incorrect 'true' response during boolean-based SQL injection can lead the tool to make flawed assumptions about the data being inferred. This causes the subsequent requests to be based on incorrect premises, resulting in wasted effort and ultimately, inaccurate or incomplete data exfiltration, because the entire inference chain is compromised.",
        "distractor_analysis": "The distractors suggest unlikely outcomes like immediate detection, data corruption, or automatic patching, rather than the more probable consequence of inefficient or incorrect data inference due to a flawed analysis of the response.",
        "analogy": "It's like following a faulty GPS signal; you might end up driving in circles or going the wrong way, wasting time and fuel because the initial direction was wrong."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SQLI_BLIND_TYPES",
        "ERROR_HANDLING"
      ]
    },
    {
      "question_text": "Which of the following best describes the 'blind' aspect of boolean-based blind SQL injection?",
      "correct_answer": "The attacker does not receive direct data output from the database in the HTTP response.",
      "distractors": [
        {
          "text": "The database server is hidden behind a firewall.",
          "misconception": "Targets [network topology confusion]: Confuses the nature of the injection with network architecture."
        },
        {
          "text": "The web application's source code is not accessible.",
          "misconception": "Targets [information access confusion]: Equates lack of direct data output with lack of source code access."
        },
        {
          "text": "The injection technique itself is intentionally obscured.",
          "misconception": "Targets [technique definition confusion]: Misinterprets 'blind' as referring to the obscurity of the method, not the output."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'blind' nature of this attack means that the vulnerable application does not directly display the results of the injected SQL query in its response. Instead, the attacker must infer the data indirectly, often by observing differences in the application's behavior based on true/false conditions, because direct feedback is absent.",
        "distractor_analysis": "The distractors misinterpret 'blind' as relating to network security, source code access, or the obscurity of the technique itself, rather than the lack of direct data output in the HTTP response.",
        "analogy": "It's like trying to guess the contents of a locked box by asking questions and observing if the person holding the box nods (true) or shakes their head (false), rather than being able to see inside."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SQLI_BLIND_TYPES",
        "HTTP_RESPONSE"
      ]
    },
    {
      "question_text": "What is the primary difference between boolean-based blind SQL injection and error-based SQL injection?",
      "correct_answer": "Boolean-based relies on observing HTTP response variations, while error-based relies on database error messages.",
      "distractors": [
        {
          "text": "Boolean-based extracts data directly, while error-based uses conditional logic.",
          "misconception": "Targets [technique confusion]: Reverses the directness of data extraction and the logic used."
        },
        {
          "text": "Boolean-based is used for time-based attacks, while error-based is for data retrieval.",
          "misconception": "Targets [technique association confusion]: Incorrectly links boolean-based to time-based and error-based to data retrieval."
        },
        {
          "text": "Boolean-based requires a vulnerable database, while error-based does not.",
          "misconception": "Targets [vulnerability requirement confusion]: Assumes error messages are independent of database vulnerability."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The fundamental difference lies in how information is extracted: boolean-based blind SQL injection infers data by observing HTTP response differences caused by true/false conditions, whereas error-based SQL injection exploits database error messages that reveal information, because these messages contain query execution details.",
        "distractor_analysis": "The distractors incorrectly describe the data extraction methods, associate boolean-based with time-based attacks, and misstate the database requirements for each technique.",
        "analogy": "Boolean-based is like getting clues from someone's facial expressions (nod/shake head), while error-based is like getting clues from them accidentally dropping a note with the answer."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "SQLI_BLIND_TYPES",
        "SQLI_ERROR_BASED"
      ]
    },
    {
      "question_text": "When using a tool like sqlmap for boolean-based SQL injection, what does the '--level' parameter typically control?",
      "correct_answer": "The depth of tests to perform, including the types of payloads and data to check.",
      "distractors": [
        {
          "text": "The maximum number of SQL injection attempts allowed.",
          "misconception": "Targets [parameter function confusion]: Confuses test depth with attempt limits."
        },
        {
          "text": "The specific database management system being targeted.",
          "misconception": "Targets [parameter function confusion]: Assumes the parameter identifies the DBMS, not test thoroughness."
        },
        {
          "text": "The network timeout duration for each request.",
          "misconception": "Targets [parameter function confusion]: Confuses test depth with network timing settings."
        }
      ],
      "detailed_explanation": {
        "core_logic": "In sqlmap, the '--level' parameter dictates how thorough the tests are, influencing the variety of SQL injection payloads and the depth of checks performed. Higher levels generally mean more comprehensive testing, because they explore a wider range of potential injection points and techniques.",
        "distractor_analysis": "The distractors incorrectly assign functions to the '--level' parameter, associating it with attempt limits, DBMS identification, or network timeouts, rather than its actual role in controlling the depth and scope of security tests.",
        "analogy": "It's like choosing how thoroughly you want to search a room: level 1 might be a quick glance, while level 5 involves checking under furniture and inside drawers."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SQLI_TOOLS",
        "SQLI_CONFIG"
      ]
    },
    {
      "question_text": "What is the primary challenge in automating boolean-based blind SQL injection detection with tools?",
      "correct_answer": "Distinguishing genuine 'true' responses from false positives caused by application logic or network issues.",
      "distractors": [
        {
          "text": "The sheer number of possible SQL injection payloads.",
          "misconception": "Targets [complexity oversimplification]: Focuses on payload variety rather than response interpretation."
        },
        {
          "text": "The inability to directly query the database schema.",
          "misconception": "Targets [blindness misunderstanding]: Confuses the lack of direct output with an inability to query schema at all."
        },
        {
          "text": "The requirement for administrator privileges on the target server.",
          "misconception": "Targets [privilege assumption]: Assumes elevated privileges are needed for blind SQLi detection."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The main difficulty in automating boolean-based blind SQL injection is accurately interpreting the application's responses. Tools must reliably differentiate between a response indicating a 'true' condition and one that mimics it due to normal application behavior or network anomalies, because subtle response variations are the only indicators.",
        "distractor_analysis": "The distractors focus on the number of payloads, the nature of blind injection, or incorrect privilege requirements, rather than the core challenge of distinguishing true signals from noise in the HTTP responses.",
        "analogy": "It's like trying to hear a whisper in a noisy room; the challenge isn't just hearing sounds, but discerning the specific whisper from all the other background noise."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "evaluate",
      "prerequisites": [
        "SQLI_AUTOMATION",
        "FALSE_POSITIVES"
      ]
    },
    {
      "question_text": "Which of the following best describes the output of a successful boolean-based blind SQL injection attack?",
      "correct_answer": "Inferred data, often extracted character by character, that was not directly displayed by the application.",
      "distractors": [
        {
          "text": "A direct dump of the entire database table.",
          "misconception": "Targets [exploitation method confusion]: Assumes direct data retrieval is possible in blind scenarios."
        },
        {
          "text": "A list of database error messages.",
          "misconception": "Targets [technique confusion]: Associates blind injection with error-based output."
        },
        {
          "text": "A confirmation that the server is vulnerable to SQL injection.",
          "misconception": "Targets [objective confusion]: Confuses the detection of vulnerability with the exfiltration of data."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The output of a successful boolean-based blind SQL injection is typically inferred data, such as usernames, passwords, or sensitive information, which the application does not directly show. This data is painstakingly reconstructed character by character because the attack relies on conditional logic rather than direct data exposure.",
        "distractor_analysis": "The distractors describe outcomes of other attack types (direct table dump, error messages) or a preliminary finding (vulnerability confirmation), failing to represent the actual, inferred data output characteristic of successful blind SQL injection.",
        "analogy": "It's like solving a jigsaw puzzle where you only get feedback on whether each piece fits correctly (true/false), and you gradually assemble the whole picture (data) without seeing the final image upfront."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SQLI_BLIND_TYPES",
        "DATA_EXFILTRATION"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Boolean-based SQL Injection Tools Penetration Testing And Ethical Hacking best practices",
    "latency_ms": 24450.447
  },
  "timestamp": "2026-01-18T15:13:33.564631",
  "_av_safe_encoded": true,
  "_encoding_note": "Educational content encoded with HTML entities to prevent antivirus false positives. Content renders normally in Anki."
}