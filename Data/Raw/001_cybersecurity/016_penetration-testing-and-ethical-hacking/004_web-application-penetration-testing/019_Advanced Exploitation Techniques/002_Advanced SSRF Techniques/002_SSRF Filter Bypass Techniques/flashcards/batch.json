{
  "topic_title": "SSRF Filter Bypass Techniques",
  "category": "Cybersecurity - Penetration Testing And Ethical Hacking - Web Application Penetration Testing",
  "flashcards": [
    {
      "question_text": "Which of the following is a common technique used to bypass SSRF filters that block direct access to localhost or 127.0.0.1?",
      "correct_answer": "Using IPv6 notation for localhost (e.g., ::1)",
      "distractors": [
        {
          "text": "Encoding the IP address using Base64",
          "misconception": "Targets [encoding confusion]: Assumes all encoding bypasses filters, but Base64 is not typically used for IP addresses in this context."
        },
        {
          "text": "Using a DNS rebinding attack",
          "misconception": "Targets [technique mismatch]: DNS rebinding is for bypassing DNS-based restrictions, not direct IP blocking."
        },
        {
          "text": "Leveraging the 'file://' protocol",
          "misconception": "Targets [protocol misuse]: 'file://' is for local file access, not for bypassing network access restrictions to localhost."
        }
      ],
      "detailed_explanation": {
        "core_logic": "IPv6 notation for localhost (::1) can bypass filters that specifically block IPv4 localhost (127.0.0.1) because the filter may not be configured to recognize or block the IPv6 equivalent.",
        "distractor_analysis": "Base64 encoding is not a standard IP address bypass. DNS rebinding is for DNS-level bypasses. 'file://' is for file access, not network bypasses.",
        "analogy": "It's like trying to get into a house by saying 'I'm not John Smith' (blocking 127.0.0.1), but then trying to get in by saying 'I'm not John Smith from the UK' (using ::1), if the guard only checks for 'John Smith'."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "attack",
      "bloom_level": "apply",
      "prerequisites": [
        "SSRF_BASICS",
        "NETWORKING_IPV4_IPV6"
      ]
    },
    {
      "question_text": "What is the primary goal when attempting to bypass SSRF filters using URL schema or wrapper manipulation?",
      "correct_answer": "To force the server to interpret and process data using a different protocol than initially intended, potentially accessing restricted resources.",
      "distractors": [
        {
          "text": "To increase the server's processing speed",
          "misconception": "Targets [performance confusion]: Assumes bypass techniques are for optimization, not exploitation."
        },
        {
          "text": "To encrypt the data being transmitted",
          "misconception": "Targets [security function confusion]: Confuses bypass techniques with encryption mechanisms."
        },
        {
          "text": "To de-obfuscate client-side JavaScript code",
          "misconception": "Targets [domain mismatch]: Relates to client-side code analysis, not server-side request manipulation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "By manipulating URL schemas (e.g., using 'dict://' or 'gopher://' instead of 'http://'), an attacker can trick the server into using different underlying protocols, which might not be subject to the same filtering rules.",
        "distractor_analysis": "The distractors suggest unrelated goals like performance enhancement, encryption, or client-side code analysis, none of which align with the purpose of SSRF filter bypass via protocol manipulation.",
        "analogy": "It's like giving a postal worker a package labeled 'Books' but inside it's actually 'Fragile Glassware', hoping they handle it differently because the label doesn't match the contents."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SSRF_BASICS",
        "NETWORK_PROTOCOLS"
      ]
    },
    {
      "question_text": "When a web application allows users to specify a URL to fetch content, and the server processes this URL, what is the fundamental risk if input validation is insufficient?",
      "correct_answer": "Server-Side Request Forgery (SSRF), allowing the attacker to force the server to make requests on their behalf.",
      "distractors": [
        {
          "text": "Cross-Site Scripting (XSS), enabling arbitrary script execution in the user's browser",
          "misconception": "Targets [vulnerability type confusion]: XSS affects the client-side, while SSRF affects the server-side."
        },
        {
          "text": "SQL Injection (SQLi), allowing manipulation of database queries",
          "misconception": "Targets [vulnerability type confusion]: SQLi targets database interaction, not server network requests."
        },
        {
          "text": "Denial of Service (DoS), overwhelming the server with legitimate requests",
          "misconception": "Targets [attack vector confusion]: While SSRF can lead to DoS, the primary risk of insufficient validation here is unauthorized server-initiated requests."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Insufficient validation of user-supplied URLs allows an attacker to control the destination and protocol of requests initiated by the server, leading to SSRF because the server trusts the input.",
        "distractor_analysis": "XSS and SQLi are distinct vulnerabilities targeting different components. DoS is a potential outcome but not the fundamental risk of the insufficient validation itself.",
        "analogy": "It's like giving a trusted employee a blank check and telling them to 'get supplies', without specifying where or what kind; they could go anywhere and buy anything, potentially causing harm."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SSRF_BASICS",
        "INPUT_VALIDATION"
      ]
    },
    {
      "question_text": "Which of the following bypass techniques is most effective against SSRF filters that block access to common localhost IP addresses like 127.0.0.1 and 127.0.0.1?",
      "correct_answer": "Using alternative IP representations or redirects, such as <code>http://[::1]/</code> or <code>http://169.254.169.254/</code>.",
      "distractors": [
        {
          "text": "Using URL encoding for the IP address",
          "misconception": "Targets [encoding specificity]: Standard URL encoding typically doesn't alter the IP address's fundamental representation for network routing."
        },
        {
          "text": "Employing a DNS rebinding attack",
          "misconception": "Targets [technique mismatch]: DNS rebinding is primarily for bypassing DNS-based access controls, not direct IP address blocks."
        },
        {
          "text": "Using the <code>data://</code> URI scheme",
          "misconception": "Targets [protocol misuse]: The `data://` scheme embeds data directly and is not typically used to circumvent network access restrictions to specific IPs."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Filters often target specific IPv4 localhost addresses. Using IPv6 localhost (<code>::1</code>) or special IP ranges like the link-local address (<code>169.254.x.x</code>) can bypass these specific blocks because the filter may not be configured to recognize or block them.",
        "distractor_analysis": "URL encoding doesn't change the IP's network meaning. DNS rebinding bypasses DNS, not direct IP blocks. <code>data://</code> is for embedding data, not network redirection.",
        "analogy": "If a security guard only checks IDs for 'John Smith' and 'Jane Doe', you might get past by using a different name like 'Peter Jones' (alternative IP) or by having someone else (redirect) vouch for you."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "attack",
      "bloom_level": "apply",
      "prerequisites": [
        "SSRF_BASICS",
        "NETWORKING_IP_ADDRESSING"
      ]
    },
    {
      "question_text": "What is the primary purpose of using the <code>gopher://</code> protocol in SSRF attacks?",
      "correct_answer": "To send arbitrary TCP packets, enabling interaction with various backend services beyond simple HTTP requests.",
      "distractors": [
        {
          "text": "To securely transfer files between servers",
          "misconception": "Targets [protocol function confusion]: Gopher is not designed for secure file transfer; it's for arbitrary data transmission."
        },
        {
          "text": "To perform DNS lookups for domain resolution",
          "misconception": "Targets [protocol function confusion]: DNS lookups use specific protocols (like DNS), not Gopher."
        },
        {
          "text": "To execute commands on the remote server via SSH",
          "misconception": "Targets [protocol function confusion]: SSH is used for remote command execution, Gopher is for raw TCP data."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>gopher://</code> protocol allows an attacker to craft and send raw TCP packets to a target port, enabling them to simulate requests for various protocols (HTTP, Redis, SMTP, etc.) and potentially achieve Remote Code Execution (RCE).",
        "distractor_analysis": "The distractors incorrectly associate Gopher with secure file transfer, DNS lookups, or SSH command execution, which are functions of different protocols.",
        "analogy": "Imagine Gopher is like a universal remote control for network devices; you can send specific button presses (TCP packets) to make different devices (services) do things, not just the TV (HTTP)."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "attack",
      "bloom_level": "apply",
      "prerequisites": [
        "SSRF_BASICS",
        "NETWORK_PROTOCOLS",
        "TCP_IP"
      ]
    },
    {
      "question_text": "When testing for SSRF, what is the significance of a trust relationship where internal systems are accessible only from the application server?",
      "correct_answer": "It creates a critical attack vector, as the server's access privileges can be leveraged to reach internal services lacking robust security controls.",
      "distractors": [
        {
          "text": "It indicates strong network segmentation, preventing external access",
          "misconception": "Targets [security assumption error]: While segmented, the server's access makes it a pivot point, not a secure barrier."
        },
        {
          "text": "It suggests the internal systems are highly secure due to limited exposure",
          "misconception": "Targets [security assumption error]: Limited exposure often means weaker security controls, assuming internal trust."
        },
        {
          "text": "It requires the use of specific encryption protocols for communication",
          "misconception": "Targets [solution mismatch]: Encryption is a defense, not an inherent characteristic of the trust relationship itself."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SSRF exploits trust relationships. When an application server can reach internal systems (e.g., on private IPs) that are not directly accessible externally, an attacker can use the server as a proxy to attack these less-protected internal resources.",
        "distractor_analysis": "The distractors incorrectly assume strong security or segmentation, or misattribute the need for encryption as a consequence of the trust relationship, rather than a potential defense.",
        "analogy": "It's like a guard at a secure facility who can access a restricted area. If an attacker compromises the guard, they gain access to that restricted area, even if the area itself has no external door."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SSRF_BASICS",
        "NETWORK_SEGMENTATION"
      ]
    },
    {
      "question_text": "Which of the following is a common defense strategy against SSRF vulnerabilities, as recommended by OWASP?",
      "correct_answer": "Implementing strict input validation and an allow-list of permitted URLs or domains.",
      "distractors": [
        {
          "text": "Disabling all external network access for the web server",
          "misconception": "Targets [overly restrictive defense]: Impractical for most web applications that need to fetch external resources."
        },
        {
          "text": "Relying solely on client-side JavaScript validation",
          "misconception": "Targets [defense layer error]: Client-side validation can be easily bypassed; server-side validation is crucial."
        },
        {
          "text": "Using a Web Application Firewall (WAF) without specific SSRF rules",
          "misconception": "Targets [defense effectiveness error]: A generic WAF may not catch all SSRF attempts without specific configurations."
        }
      ],
      "detailed_explanation": {
        "core_logic": "OWASP recommends validating user input rigorously, ideally using an allow-list approach, to ensure the server only makes requests to explicitly permitted destinations, thereby preventing SSRF.",
        "distractor_analysis": "Disabling all external access is often infeasible. Client-side validation is insufficient. A generic WAF might not be enough without specific SSRF rules.",
        "analogy": "It's like a bouncer at a club who checks everyone's ID against a pre-approved guest list, rather than just letting anyone in or relying on the person outside to check."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "SSRF_BASICS",
        "INPUT_VALIDATION",
        "OWASP_WSTG"
      ]
    },
    {
      "question_text": "What is the primary risk associated with using the <code>file://</code> URI scheme in an SSRF vulnerability?",
      "correct_answer": "It allows an attacker to read arbitrary local files on the server's file system.",
      "distractors": [
        {
          "text": "It enables the attacker to execute arbitrary code on the server",
          "misconception": "Targets [vulnerability capability confusion]: `file://` typically allows reading, not direct execution, unless combined with other vulnerabilities."
        },
        {
          "text": "It facilitates network reconnaissance of internal services",
          "misconception": "Targets [protocol function confusion]: `file://` is for file access, not network scanning."
        },
        {
          "text": "It causes a denial-of-service by overwhelming the file system",
          "misconception": "Targets [attack outcome confusion]: While excessive file access could impact performance, the primary risk is data leakage."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>file://</code> URI scheme instructs the server to access local files. If an SSRF vulnerability allows this scheme, an attacker can read sensitive files like configuration files or credentials.",
        "distractor_analysis": "The distractors incorrectly attribute code execution, network reconnaissance, or DoS as the primary risk of <code>file://</code> usage in SSRF, which is data exfiltration.",
        "analogy": "It's like giving someone a key to your filing cabinet and asking them to 'get a document'; they could potentially read any document inside, not just the one you intended."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "attack",
      "bloom_level": "apply",
      "prerequisites": [
        "SSRF_BASICS",
        "FILE_SYSTEM_ACCESS"
      ]
    },
    {
      "question_text": "How can DNS rebinding be used to bypass SSRF filters that block access to internal IP addresses?",
      "correct_answer": "By tricking the victim server into resolving a malicious domain to an internal IP address after initial validation, then resolving it to a different IP.",
      "distractors": [
        {
          "text": "By exploiting vulnerabilities in the DNS server itself",
          "misconception": "Targets [target confusion]: DNS rebinding exploits the client's trust in DNS resolution, not the DNS server's security."
        },
        {
          "text": "By using encoded IP addresses that the DNS server interprets differently",
          "misconception": "Targets [mechanism confusion]: Encoding is a separate bypass technique, not directly related to DNS rebinding's core mechanism."
        },
        {
          "text": "By forcing the server to use a specific DNS server known to be vulnerable",
          "misconception": "Targets [target confusion]: The attack relies on the victim's DNS resolution, not necessarily a vulnerable DNS server."
        }
      ],
      "detailed_explanation": {
        "core_logic": "DNS rebinding involves a malicious domain initially resolving to a public IP, passing validation. Then, the domain quickly re-resolves to a private/internal IP, allowing the SSRF vulnerable server to connect to internal resources.",
        "distractor_analysis": "The distractors misattribute the target of the attack (DNS server vs. victim's resolution) or confuse the mechanism with other bypass techniques like encoding.",
        "analogy": "It's like telling a guard 'I'm visiting the public park' (initial DNS resolution), then quickly changing the sign on the park entrance to 'Restricted Military Zone' (re-resolved internal IP) while the guard is looking."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "SSRF_BASICS",
        "DNS_BASICS",
        "NETWORK_REBINDING"
      ]
    },
    {
      "question_text": "What is the purpose of using Cloud metadata services (e.g., <code>http://169.254.169.254/</code>) in SSRF attacks?",
      "correct_answer": "To access sensitive instance metadata, credentials, and configuration information from cloud environments.",
      "distractors": [
        {
          "text": "To perform network scans of the cloud provider's infrastructure",
          "misconception": "Targets [scope confusion]: Metadata services provide instance-specific info, not general network scanning capabilities."
        },
        {
          "text": "To deploy malicious code onto cloud instances",
          "misconception": "Targets [action confusion]: Metadata services provide information, not direct deployment capabilities."
        },
        {
          "text": "To bypass firewalls by using a reserved IP address",
          "misconception": "Targets [mechanism confusion]: While it uses a reserved IP, the primary goal is data exfiltration, not firewall bypass itself."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Cloud metadata services are accessible via specific IP addresses (like <code>169.254.169.254</code>) from within the instance. SSRF allows an attacker to query these endpoints to retrieve sensitive data, including temporary credentials.",
        "distractor_analysis": "The distractors suggest network scanning, code deployment, or firewall bypass as the primary goal, whereas accessing sensitive instance metadata is the key objective.",
        "analogy": "It's like finding a secret internal phone number within a company building that lets you access employee records and security codes, rather than using it to call outside or deploy new software."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "attack",
      "bloom_level": "apply",
      "prerequisites": [
        "SSRF_BASICS",
        "CLOUD_COMPUTING_BASICS"
      ]
    },
    {
      "question_text": "Which of the following is a critical defense against SSRF, particularly when dealing with user-supplied URLs?",
      "correct_answer": "Implementing server-side validation to ensure the requested URL belongs to an approved domain or IP range.",
      "distractors": [
        {
          "text": "Sanitizing user input to remove special characters",
          "misconception": "Targets [insufficient defense]: While good practice, sanitization alone is often insufficient for complex SSRF bypasses."
        },
        {
          "text": "Using a Content Security Policy (CSP) to restrict resource loading",
          "misconception": "Targets [defense layer confusion]: CSP primarily controls client-side resource loading, not server-side requests."
        },
        {
          "text": "Encrypting all outgoing requests from the server",
          "misconception": "Targets [defense mismatch]: Encryption secures data in transit but doesn't prevent the server from making unauthorized requests."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Server-side validation, especially using an allow-list (whitelisting) of destinations, is crucial because it directly prevents the server from initiating requests to unauthorized or malicious locations, thus mitigating SSRF.",
        "distractor_analysis": "Input sanitization is a basic step, CSP affects the client, and encryption doesn't stop the server from making the request. Only server-side validation directly addresses the SSRF vector.",
        "analogy": "It's like having a security guard at a gate who checks the destination address on every delivery truck before letting it pass, rather than just checking if the truck looks clean or is locked."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "SSRF_BASICS",
        "INPUT_VALIDATION"
      ]
    },
    {
      "question_text": "What is the primary difference between SSRF and a typical Cross-Site Scripting (XSS) attack?",
      "correct_answer": "SSRF targets the server to make requests, while XSS targets the user's browser to execute scripts.",
      "distractors": [
        {
          "text": "SSRF exploits vulnerabilities in the database, while XSS exploits vulnerabilities in the web server",
          "misconception": "Targets [vulnerability target confusion]: SSRF targets server network requests, XSS targets browser execution; neither primarily targets DB/web server directly in this way."
        },
        {
          "text": "SSRF involves injecting malicious code, while XSS involves sending forged requests",
          "misconception": "Targets [attack vector confusion]: XSS involves injecting scripts, SSRF involves making forged/unintended server requests."
        },
        {
          "text": "SSRF can only be exploited over HTTP, while XSS can be exploited over any protocol",
          "misconception": "Targets [protocol scope confusion]: SSRF can leverage various protocols, and XSS is primarily web-based (HTTP/S)."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SSRF leverages the server's ability to make network requests, forcing it to target internal or external resources. XSS injects scripts into a webpage, which are then executed by the victim's browser, targeting the user's session or data.",
        "distractor_analysis": "The distractors incorrectly assign targets (DB/server), confuse the core actions (code injection vs. forged requests), and misstate protocol limitations.",
        "analogy": "SSRF is like tricking a company's mailroom into sending packages to addresses *you* choose, using the company's official postage. XSS is like slipping a fake message into a company memo that gets delivered to employees, causing them to do something harmful."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "SSRF_BASICS",
        "XSS_BASICS"
      ]
    },
    {
      "question_text": "Consider a web application that fetches an image from a user-provided URL. If the application uses a whitelist of allowed domains, which bypass technique would be MOST LIKELY to fail?",
      "correct_answer": "Using a URL that redirects to a non-whitelisted domain.",
      "distractors": [
        {
          "text": "Using an IP address in a different format (e.g., octal or hexadecimal)",
          "misconception": "Targets [encoding specificity]: While some formats might bypass naive parsers, robust validation often normalizes IPs before checking against the whitelist."
        },
        {
          "text": "Using a different URL schema (e.g., <code>dict://</code> instead of <code>http://</code>)",
          "misconception": "Targets [protocol specificity]: The whitelist typically applies to domains/IPs, not necessarily the protocol itself, though some filters might block non-HTTP/S."
        },
        {
          "text": "Using a subdomain of a whitelisted domain",
          "misconception": "Targets [whitelist granularity]: If the whitelist is broad (e.g., `example.com`), subdomains (`sub.example.com`) might be implicitly allowed or explicitly included."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A strict whitelist checks the final destination domain/IP. If a URL redirects to a domain not on the whitelist, the bypass fails because the server ultimately attempts to connect to an unauthorized location.",
        "distractor_analysis": "Alternative IP formats might bypass naive parsers. Different schemas might be allowed if the domain is whitelisted. Subdomains are often covered by broader whitelist entries.",
        "analogy": "If the whitelist is 'Approved Stores: Walmart, Target', trying to use a coupon for 'Best Buy' (redirect to non-whitelisted) will fail, even if you initially went to Walmart (whitelisted) to get the coupon."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "analyze",
      "prerequisites": [
        "SSRF_BASICS",
        "INPUT_VALIDATION",
        "URL_REDIRECTION"
      ]
    },
    {
      "question_text": "What is the primary risk of SSRF when targeting internal services that lack robust authentication or authorization?",
      "correct_answer": "Unauthorized access to sensitive data or functionality, potentially leading to Remote Code Execution (RCE).",
      "distractors": [
        {
          "text": "Increased latency for legitimate users",
          "misconception": "Targets [impact confusion]: While possible, data/functionality compromise is the primary risk, not just performance degradation."
        },
        {
          "text": "Exposure of the server's source code",
          "misconception": "Targets [specific outcome confusion]: Source code exposure is a possible outcome but not the universal primary risk; sensitive data or RCE are more direct consequences."
        },
        {
          "text": "Accidental data corruption on the target service",
          "misconception": "Targets [intent confusion]: Attackers aim for unauthorized access/control, not accidental corruption, though it can be a side effect."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SSRF allows an attacker to interact with internal services as if they were the server. If these services lack proper security, the attacker can exploit them to read data, execute commands, or gain further access, often leading to RCE.",
        "distractor_analysis": "The distractors focus on secondary effects (latency, code exposure) or unintended outcomes (corruption) rather than the core risk of unauthorized access and control.",
        "analogy": "It's like using a janitor's key card to access a restricted lab. The primary risk isn't that the janitor might accidentally spill chemicals, but that you can now steal research data or tamper with experiments."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SSRF_BASICS",
        "NETWORK_SECURITY"
      ]
    },
    {
      "question_text": "Which technique involves manipulating how a URL is parsed by different components (e.g., front-end proxy vs. back-end server) to bypass SSRF filters?",
      "correct_answer": "Abusing URL parsing discrepancies.",
      "distractors": [
        {
          "text": "Using DNS tunneling",
          "misconception": "Targets [technique mismatch]: DNS tunneling hides data within DNS queries, unrelated to URL parsing discrepancies."
        },
        {
          "text": "Leveraging HTTP Parameter Pollution (HPP)",
          "misconception": "Targets [vulnerability type confusion]: HPP exploits how multiple parameters with the same name are handled, not URL structure parsing."
        },
        {
          "text": "Employing port scanning techniques",
          "misconception": "Targets [goal confusion]: Port scanning is an objective, not a method for bypassing filters via parsing differences."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Different software components might interpret URL structures (like special characters, encoding, or protocol handlers) differently. An attacker crafts a URL that one component accepts but another, further down the chain, processes in a way that bypasses filters.",
        "distractor_analysis": "DNS tunneling, HPP, and port scanning are distinct techniques with different goals and mechanisms, not related to exploiting differences in URL parsing logic.",
        "analogy": "It's like giving instructions to two people: one understands 'turn left at the big tree' literally, while the other interprets it as 'head towards the general direction of the large tree'. You exploit this difference to get one person to go somewhere the other wouldn't."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "attack",
      "bloom_level": "apply",
      "prerequisites": [
        "SSRF_BASICS",
        "URL_PARSING",
        "WEB_APPLICATION_SECURITY"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "SSRF Filter Bypass Techniques Penetration Testing And Ethical Hacking best practices",
    "latency_ms": 24098.199
  },
  "timestamp": "2026-01-18T15:09:24.903873",
  "_av_safe_encoded": true,
  "_encoding_note": "Educational content encoded with HTML entities to prevent antivirus false positives. Content renders normally in Anki."
}