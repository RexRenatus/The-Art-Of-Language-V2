{
  "topic_title": "Client-side Cache Poisoning",
  "category": "Penetration Testing And Ethical Hacking - Web Application Penetration Testing",
  "flashcards": [
    {
      "question_text": "What is the primary goal of a client-side cache poisoning attack?",
      "correct_answer": "To trick a user's browser into caching a malicious response that is then served to the user.",
      "distractors": [
        {
          "text": "To poison the web server's cache with malicious content.",
          "misconception": "Targets [scope confusion]: Confuses client-side (browser) cache with server-side or proxy cache."
        },
        {
          "text": "To exploit vulnerabilities in the browser's JavaScript engine.",
          "misconception": "Targets [mechanism confusion]: Associates cache poisoning solely with client-side script execution, ignoring HTTP response manipulation."
        },
        {
          "text": "To intercept and modify network traffic between the client and server.",
          "misconception": "Targets [attack vector confusion]: Overlaps with Man-in-the-Middle (MitM) attacks, but cache poisoning specifically targets cached content."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Client-side cache poisoning works by manipulating how a user's browser caches HTTP responses, causing it to store a malicious payload instead of legitimate content.",
        "distractor_analysis": "The first distractor incorrectly focuses on server-side caching. The second misattributes the attack mechanism to JavaScript engine flaws. The third conflates it with general network interception attacks.",
        "analogy": "It's like tricking a librarian into filing a fake book in the 'new arrivals' section, so everyone who looks for new books gets the fake one."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "HTTP_BASICS",
        "BROWSER_CACHING"
      ]
    },
    {
      "question_text": "Which HTTP header is most commonly manipulated in client-side cache poisoning attacks to influence caching behavior?",
      "correct_answer": "Cache-Control",
      "distractors": [
        {
          "text": "Content-Type",
          "misconception": "Targets [header function confusion]: This header defines the media type of the resource, not its caching directives."
        },
        {
          "text": "Authorization",
          "misconception": "Targets [header function confusion]: This header is for authentication credentials, not cache management."
        },
        {
          "text": "User-Agent",
          "misconception": "Targets [header function confusion]: This header identifies the client software, not caching policies."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The Cache-Control header directly dictates how and for how long a resource should be cached by intermediaries and clients, making it a prime target for poisoning attacks.",
        "distractor_analysis": "Content-Type, Authorization, and User-Agent headers serve entirely different purposes and do not control caching directives, making them incorrect choices.",
        "analogy": "Think of Cache-Control as the 'do not disturb' sign for the browser's memory, telling it whether to keep a copy of a webpage or fetch a fresh one."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "HTTP_HEADERS",
        "BROWSER_CACHING"
      ]
    },
    {
      "question_text": "A web application fails to properly validate user-supplied input used in constructing cache keys. What type of attack could this lead to?",
      "correct_answer": "Client-side cache poisoning",
      "distractors": [
        {
          "text": "Cross-Site Scripting (XSS)",
          "misconception": "Targets [vulnerability type confusion]: XSS exploits script execution, not cache manipulation."
        },
        {
          "text": "SQL Injection",
          "misconception": "Targets [vulnerability type confusion]: SQLi targets database integrity, not caching mechanisms."
        },
        {
          "text": "Cross-Site Request Forgery (CSRF)",
          "misconception": "Targets [vulnerability type confusion]: CSRF forces unwanted actions, not cache poisoning."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When user input improperly influences cache keys, an attacker can craft requests that cause the server to cache a malicious response under a key that will be used by other users.",
        "distractor_analysis": "XSS, SQLi, and CSRF are distinct web vulnerabilities that exploit different application weaknesses and do not directly cause cache poisoning.",
        "analogy": "It's like letting anyone write the filing system for a library; an attacker could label a shelf 'Fiction' but put 'Technical Manuals' there, confusing patrons."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "analyze",
      "prerequisites": [
        "INPUT_VALIDATION",
        "CACHE_KEY_MANAGEMENT"
      ]
    },
    {
      "question_text": "What is the main difference between web cache poisoning and a standard denial-of-service (DoS) attack?",
      "correct_answer": "Web cache poisoning aims to deliver malicious content to users, while DoS aims to make a service unavailable.",
      "distractors": [
        {
          "text": "Web cache poisoning targets the client's cache, while DoS targets the server.",
          "misconception": "Targets [attack scope confusion]: While cache poisoning can involve client cache, the initial attack often targets shared caches or server behavior."
        },
        {
          "text": "Web cache poisoning is a form of DoS attack.",
          "misconception": "Targets [attack classification confusion]: Cache poisoning is a content injection attack, not primarily an availability attack."
        },
        {
          "text": "DoS attacks are easier to perform than web cache poisoning.",
          "misconception": "Targets [difficulty assessment error]: Both can be complex, and difficulty varies greatly by specific implementation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Cache poisoning leverages caching mechanisms to inject harmful content, whereas DoS attacks focus on overwhelming resources to disrupt service availability.",
        "distractor_analysis": "The first distractor oversimplifies the target scope. The second incorrectly categorizes cache poisoning as a DoS. The third makes a subjective and often incorrect claim about attack difficulty.",
        "analogy": "DoS is like blocking the road to a store, preventing anyone from getting in. Cache poisoning is like replacing the store's advertised specials with misleading offers."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "WEB_CACHE_BASICS",
        "DOS_BASICS"
      ]
    },
    {
      "question_text": "According to OWASP, what is a critical prerequisite for a successful cache poisoning attack?",
      "correct_answer": "The application must allow for the manipulation of HTTP header fields in a way that can be cached.",
      "distractors": [
        {
          "text": "The attacker must have administrative access to the web server.",
          "misconception": "Targets [privilege requirement confusion]: Administrative access is not typically required; exploiting caching logic is key."
        },
        {
          "text": "The target must be using a specific, outdated browser version.",
          "misconception": "Targets [dependency confusion]: While browser behavior can vary, the core vulnerability lies in the web application/cache logic, not a specific browser version."
        },
        {
          "text": "The application must be vulnerable to Cross-Site Scripting (XSS).",
          "misconception": "Targets [vulnerability correlation confusion]: XSS is a separate vulnerability; cache poisoning exploits caching mechanisms, not script execution directly."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Cache poisoning relies on the web server or cache server misinterpreting or improperly caching a response generated from manipulated headers, thus OWASP emphasizes header manipulation as a prerequisite.",
        "distractor_analysis": "Administrative access is usually unnecessary. While browser behavior matters, the primary vulnerability is in the caching logic. XSS is a different attack vector.",
        "analogy": "To poison a shared water cooler, you first need a way to tamper with the water supply itself, not just hope someone drinks from it."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "HTTP_HEADERS",
        "WEB_CACHE_BASICS",
        "OWASP_TOP_10"
      ]
    },
    {
      "question_text": "Which of the following best describes the 'two phases' of a web cache poisoning attack as described by PortSwigger?",
      "correct_answer": "Phase 1: Elicit a dangerous payload in a response; Phase 2: Exploit the cache to serve this payload to other users.",
      "distractors": [
        {
          "text": "Phase 1: Gain access to the cache server; Phase 2: Inject malicious data.",
          "misconception": "Targets [attack phase confusion]: Focuses on direct cache server access, which isn't always required, and misses the payload generation step."
        },
        {
          "text": "Phase 1: Identify user browsing habits; Phase 2: Craft targeted phishing emails.",
          "misconception": "Targets [attack objective confusion]: Describes reconnaissance and phishing, not the core mechanism of cache poisoning."
        },
        {
          "text": "Phase 1: Exploit a vulnerability in the web application; Phase 2: Perform a denial-of-service attack.",
          "misconception": "Targets [attack outcome confusion]: Links application vulnerability to DoS, ignoring the specific cache poisoning outcome."
        }
      ],
      "detailed_explanation": {
        "core_logic": "PortSwigger outlines cache poisoning as a two-phase process: first, causing the back-end server to generate a response with a dangerous payload, and second, ensuring this response is cached and served to victims.",
        "distractor_analysis": "The first distractor incorrectly assumes direct cache server access is always needed. The second describes unrelated attack types. The third incorrectly pairs application exploits with DoS instead of cache poisoning.",
        "analogy": "It's like a two-step process: first, you sneak a faulty ingredient into the main kitchen's recipe book (eliciting payload), then you make sure that recipe book is the one everyone uses for the daily special (caching)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "WEB_CACHE_BASICS",
        "ATTACK_PHASES"
      ]
    },
    {
      "question_text": "What is the role of the <code>Pragma: no-cache</code> or <code>Cache-Control: no-cache</code> headers in the context of cache poisoning attempts?",
      "correct_answer": "To attempt to purge existing malicious entries from the cache before injecting a new payload.",
      "distractors": [
        {
          "text": "To instruct the browser to immediately cache the malicious response.",
          "misconception": "Targets [header directive confusion]: These headers instruct caches NOT to serve stale content, not to force caching."
        },
        {
          "text": "To bypass authentication mechanisms on the web server.",
          "misconception": "Targets [header function confusion]: These headers are related to caching, not authentication."
        },
        {
          "text": "To increase the TTL (Time To Live) of cached resources.",
          "misconception": "Targets [header directive confusion]: These headers typically reduce or eliminate caching, effectively setting TTL to zero or near-zero."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Headers like <code>Pragma: no-cache</code> and <code>Cache-Control: no-cache</code> are used to prevent caches from serving stale or previously stored content, which attackers might use to clear out old cache entries before injecting their own malicious ones.",
        "distractor_analysis": "The distractors incorrectly suggest these headers force caching, bypass authentication, or increase TTL, all of which are contrary to their actual function in cache management.",
        "analogy": "It's like telling a filing clerk to 'clear out the old files' before you give them new ones to file, ensuring your new (malicious) document isn't mixed with outdated ones."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "HTTP_HEADERS",
        "WEB_CACHE_BASICS"
      ]
    },
    {
      "question_text": "How can a web application mitigate the risk of client-side cache poisoning?",
      "correct_answer": "By strictly validating all user-supplied input used in cache keys and ensuring sensitive data is not cacheable.",
      "distractors": [
        {
          "text": "By disabling all caching mechanisms on the server.",
          "misconception": "Targets [overly broad defense]: Disabling all caching severely impacts performance and is often impractical."
        },
        {
          "text": "By implementing strong encryption for all user sessions.",
          "misconception": "Targets [defense mechanism confusion]: Encryption protects data in transit/rest, but doesn't prevent cache poisoning if the cache itself is compromised."
        },
        {
          "text": "By relying solely on client-side JavaScript to manage cache validity.",
          "misconception": "Targets [client-side over-reliance]: Client-side controls can be bypassed; server-side validation and cache control are crucial."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Mitigation involves robust input validation for cache keys and careful configuration of cache directives (e.g., <code>Cache-Control: no-store</code>) for sensitive resources, preventing attackers from injecting malicious content.",
        "distractor_analysis": "Disabling all caching is impractical. Encryption doesn't stop cache poisoning. Relying solely on client-side controls is insecure because they can be manipulated.",
        "analogy": "To prevent a library from having fake books, you ensure the librarian meticulously checks every book's title and content before shelving it, and doesn't shelve anything marked 'confidential'."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "INPUT_VALIDATION",
        "WEB_CACHE_BASICS",
        "HTTP_HEADERS"
      ]
    },
    {
      "question_text": "What is the potential impact of a successful client-side cache poisoning attack on a single user?",
      "correct_answer": "The user may be redirected to a malicious website, have malicious scripts executed in their browser, or be served deceptive content.",
      "distractors": [
        {
          "text": "The user's system will be immediately infected with ransomware.",
          "misconception": "Targets [impact overstatement]: While severe, direct ransomware infection isn't the guaranteed outcome; it's often a step towards it."
        },
        {
          "text": "The user's account credentials will be stolen directly from their browser cache.",
          "misconception": "Targets [mechanism confusion]: Credentials might be captured if the poisoned response facilitates it, but the cache itself isn't the direct theft vector."
        },
        {
          "text": "The user's entire hard drive will be wiped.",
          "misconception": "Targets [impact overstatement]: This is an extreme outcome, far beyond the typical scope of cache poisoning."
        }
      ],
      "detailed_explanation": {
        "core_logic": "By poisoning the client's cache, an attacker can control what content the browser loads, leading to redirects, script execution (like XSS), or display of fake information, all aimed at compromising the user.",
        "distractor_analysis": "The distractors exaggerate the immediate impact (ransomware, drive wipe) or misrepresent the direct mechanism of credential theft.",
        "analogy": "Imagine your browser's cache is like your personal notepad. If someone poisons it, they could write down fake phone numbers (malicious redirects) or instructions (malicious scripts) that you'll follow later."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "WEB_CACHE_BASICS",
        "CLIENT_SIDE_ATTACKS"
      ]
    },
    {
      "question_text": "Which of the following is an example of a cache poisoning technique that exploits how a web server prioritizes headers?",
      "correct_answer": "Vary header poisoning",
      "distractors": [
        {
          "text": "DNS cache poisoning",
          "misconception": "Targets [domain confusion]: DNS cache poisoning affects DNS resolution, not HTTP caching of web content."
        },
        {
          "text": "Browser history manipulation",
          "misconception": "Targets [mechanism confusion]: History is separate from cache; this relates to user navigation tracking."
        },
        {
          "text": "Cross-User Defacement",
          "misconception": "Targets [attack type confusion]: This is a different type of web attack, often related to content management systems."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Vary header poisoning exploits scenarios where a cache uses the <code>Vary</code> header to differentiate cached responses based on request headers (like <code>Accept-Encoding</code>). An attacker can manipulate this to poison the cache for specific header combinations.",
        "distractor_analysis": "DNS cache poisoning targets the Domain Name System. Browser history manipulation is distinct from cache. Cross-User Defacement is a different attack category.",
        "analogy": "It's like having multiple mailboxes for different recipients (based on <code>Vary</code> header). If an attacker can trick the mail sorter into putting the wrong mail in the 'Mr. Smith' mailbox, everyone expecting mail for Mr. Smith gets the wrong thing."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "HTTP_HEADERS",
        "WEB_CACHE_BASICS",
        "VARY_HEADER"
      ]
    },
    {
      "question_text": "What is the primary risk associated with caching sensitive user data (e.g., PII) on the client-side?",
      "correct_answer": "The data can be exposed if the client's cache is accessed by an unauthorized party.",
      "distractors": [
        {
          "text": "It significantly slows down the user's browsing experience.",
          "misconception": "Targets [performance impact confusion]: Caching generally improves performance; the risk is data exposure, not slowdown."
        },
        {
          "text": "It increases the likelihood of Cross-Site Scripting (XSS) attacks.",
          "misconception": "Targets [vulnerability correlation confusion]: While related to client-side security, caching sensitive data doesn't directly increase XSS vulnerability."
        },
        {
          "text": "It requires the use of complex encryption algorithms.",
          "misconception": "Targets [mitigation confusion]: The risk is exposure, not the complexity of encryption needed for caching."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Caching sensitive Personally Identifiable Information (PII) on the client-side creates a risk because this data, if stored unencrypted or improperly secured in the cache, can be accessed by anyone who gains access to the client's device or cache files.",
        "distractor_analysis": "Caching sensitive data does not inherently slow down browsing; it improves it. It's not a direct cause of XSS, and the risk is exposure, not the complexity of encryption.",
        "analogy": "Leaving your personal diary on a public park bench is risky because anyone could pick it up and read it, regardless of how well you write."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "PII_BASICS",
        "CLIENT_SIDE_SECURITY",
        "BROWSER_CACHING"
      ]
    },
    {
      "question_text": "How does HTTP Response Splitting relate to cache poisoning attacks?",
      "correct_answer": "HTTP Response Splitting can be used to inject additional, malicious headers or content into a response, which can then be cached.",
      "distractors": [
        {
          "text": "It is a method to bypass client-side JavaScript security.",
          "misconception": "Targets [vulnerability type confusion]: Response splitting exploits HTTP protocol handling, not client-side scripts."
        },
        {
          "text": "It is primarily used to perform denial-of-service attacks.",
          "misconception": "Targets [attack outcome confusion]: While response splitting can have DoS implications, its direct use in cache poisoning is for content injection."
        },
        {
          "text": "It is a technique to encrypt sensitive data before it is cached.",
          "misconception": "Targets [function confusion]: Response splitting is about manipulating response structure, not encryption."
        }
      ],
      "detailed_explanation": {
        "core_logic": "HTTP Response Splitting allows an attacker to inject CRLF characters to create additional headers or lines in a response. If this manipulated response is cached, the injected content can be served to subsequent users.",
        "distractor_analysis": "Response splitting does not bypass JavaScript security, nor is its primary use DoS. It is fundamentally about manipulating response structure, not encryption.",
        "analogy": "It's like using a faulty printer that adds extra lines to your document. If that document is then copied and distributed (cached), the extra lines (malicious content) go with it."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "HTTP_BASICS",
        "WEB_CACHE_BASICS",
        "HTTP_RESPONSE_SPLITTING"
      ]
    },
    {
      "question_text": "Which of the following is a common indicator that a website might be vulnerable to client-side cache poisoning?",
      "correct_answer": "The website serves different content based on subtle variations in request headers (e.g., <code>Accept-Encoding</code>, <code>User-Agent</code>) without proper cache key management.",
      "distractors": [
        {
          "text": "The website uses HTTPS for all connections.",
          "misconception": "Targets [security feature confusion]: HTTPS encrypts traffic but does not inherently prevent cache poisoning vulnerabilities in the application logic."
        },
        {
          "text": "The website requires users to log in before accessing content.",
          "misconception": "Targets [authentication vs. caching confusion]: Authentication is separate from caching logic; logged-in users can still be affected."
        },
        {
          "text": "The website frequently updates its content.",
          "misconception": "Targets [irrelevant factor]: Content update frequency is unrelated to cache poisoning vulnerability."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Vulnerabilities arise when caches cannot correctly distinguish between different user requests (e.g., based on <code>Accept-Encoding</code> for compression) and cache a single response for all users, leading to poisoning.",
        "distractor_analysis": "HTTPS is a security measure, not a vulnerability indicator for cache poisoning. Login requirements don't prevent cache issues. Content update frequency is irrelevant.",
        "analogy": "If a restaurant serves different specials based on the day of the week, but the waiter always brings the same dish regardless of the day, customers might get the wrong meal."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "WEB_CACHE_BASICS",
        "HTTP_HEADERS",
        "CACHE_KEY_MANAGEMENT"
      ]
    },
    {
      "question_text": "What is the primary difference between a shared proxy cache and a browser cache in the context of poisoning attacks?",
      "correct_answer": "A shared proxy cache, if poisoned, affects multiple users, whereas a poisoned browser cache primarily affects the individual user.",
      "distractors": [
        {
          "text": "Proxy caches are always more vulnerable than browser caches.",
          "misconception": "Targets [vulnerability assessment error]: Vulnerability depends on implementation, not just cache type."
        },
        {
          "text": "Browser caches are controlled by the server, while proxy caches are controlled by the client.",
          "misconception": "Targets [control mechanism confusion]: Both are influenced by server directives, but browser cache is local to the client device."
        },
        {
          "text": "Proxy caches store dynamic content, while browser caches store static content.",
          "misconception": "Targets [content type confusion]: Both types of caches can store both static and dynamic content depending on configuration."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Shared proxy caches serve multiple users, so poisoning them has a wider impact. Browser caches are local to a single user's machine, limiting the scope of a poisoning attack to that user.",
        "distractor_analysis": "Vulnerability is implementation-dependent. Control is complex and influenced by server headers. Both cache types can store dynamic or static content.",
        "analogy": "Poisoning a public water fountain (proxy cache) affects everyone who drinks from it. Poisoning your personal water bottle (browser cache) only affects you."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "WEB_CACHE_BASICS",
        "PROXY_CACHING",
        "BROWSER_CACHING"
      ]
    },
    {
      "question_text": "Which security standard or framework provides guidance relevant to mitigating web cache poisoning vulnerabilities?",
      "correct_answer": "OWASP Web Security Testing Guide (WSTG)",
      "distractors": [
        {
          "text": "NIST Cybersecurity Framework (CSF)",
          "misconception": "Targets [framework scope confusion]: CSF is a high-level framework for managing cybersecurity risk, not specific testing guidance for web vulnerabilities."
        },
        {
          "text": "ISO 27001",
          "misconception": "Targets [standard scope confusion]: ISO 27001 focuses on Information Security Management Systems (ISMS), not detailed web application testing techniques."
        },
        {
          "text": "PCI DSS (Payment Card Industry Data Security Standard)",
          "misconception": "Targets [standard scope confusion]: PCI DSS focuses on protecting cardholder data, with some overlap but not specific guidance on cache poisoning testing."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The OWASP Web Security Testing Guide (WSTG) specifically includes sections on testing for browser cache weaknesses (WSTG-ATHN-06) and related web cache vulnerabilities, providing practical testing methodologies.",
        "distractor_analysis": "NIST CSF is a strategic framework, ISO 27001 is for ISMS, and PCI DSS is for cardholder data protection. None offer the specific, detailed web vulnerability testing guidance found in OWASP WSTG.",
        "analogy": "If you need instructions on how to fix a specific car engine part, you'd consult the car's repair manual (OWASP WSTG), not a general guide on car maintenance (NIST CSF) or road safety regulations (ISO 27001)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "OWASP_WSTG",
        "WEB_SECURITY_STANDARDS"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Client-side Cache Poisoning Penetration Testing And Ethical Hacking best practices",
    "latency_ms": 24822.623
  },
  "timestamp": "2026-01-18T15:09:30.676663",
  "_av_safe_encoded": true,
  "_encoding_note": "Educational content encoded with HTML entities to prevent antivirus false positives. Content renders normally in Anki."
}