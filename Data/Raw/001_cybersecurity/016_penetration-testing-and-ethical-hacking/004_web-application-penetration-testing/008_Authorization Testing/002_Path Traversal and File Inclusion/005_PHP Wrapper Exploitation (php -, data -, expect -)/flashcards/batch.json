{
  "topic_title": "PHP Wrapper 005_Exploitation (php://, data://, expect://)",
  "category": "Penetration Testing And Ethical Hacking - Web Application Penetration Testing",
  "flashcards": [
    {
      "question_text": "In PHP, which wrapper is commonly exploited to execute arbitrary code by embedding serialized objects or commands within a data stream?",
      "correct_answer": "expect://",
      "distractors": [
        {
          "text": "php://input",
          "misconception": "Targets [protocol confusion]: Misunderstands that php://input reads raw POST data, not executes code directly."
        },
        {
          "text": "data://",
          "misconception": "Targets [data stream misuse]: Believes data:// can execute arbitrary code, when it primarily handles inline data."
        },
        {
          "text": "file://",
          "misconception": "Targets [filesystem vs execution]: Confuses file system access with code execution capabilities."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The expect:// wrapper allows for the execution of arbitrary PHP code by leveraging PHP's object serialization and deserialization features, enabling attackers to inject malicious payloads.",
        "distractor_analysis": "php://input reads raw POST data, data:// handles inline data streams, and file:// accesses the filesystem, none of which directly execute arbitrary code like expect://.",
        "analogy": "Think of expect:// as a backdoor that allows you to send a set of instructions disguised as data, which the server then executes."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PHP_WRAPPERS",
        "PHP_SERIALIZATION"
      ]
    },
    {
      "question_text": "What is a primary security risk associated with the <code>php://input</code> wrapper when used in file upload functionalities?",
      "correct_answer": "It can be manipulated to overwrite or execute arbitrary code if not properly sanitized, especially when combined with insecure file handling.",
      "distractors": [
        {
          "text": "It leads to denial-of-service attacks by consuming excessive memory.",
          "misconception": "Targets [DoS vs RCE confusion]: Attributes a denial-of-service impact to a wrapper primarily exploited for remote code execution."
        },
        {
          "text": "It exposes sensitive database credentials through direct database connections.",
          "misconception": "Targets [protocol scope confusion]: Incorrectly associates the wrapper with direct database connection vulnerabilities."
        },
        {
          "text": "It allows for cross-site scripting (XSS) by injecting malicious JavaScript.",
          "misconception": "Targets [XSS vs RCE confusion]: Confuses the wrapper's capability for remote code execution with client-side XSS vulnerabilities."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When <code>php://input</code> is used to read raw POST data and this data is then processed insecurely (e.g., saved with a dangerous extension or executed), it can lead to remote code execution (RCE) because the wrapper bypasses typical file upload validation.",
        "distractor_analysis": "The correct answer highlights the RCE risk. The first distractor wrongly focuses on DoS. The second incorrectly links it to database credentials. The third confuses it with XSS.",
        "analogy": "Using <code>php://input</code> insecurely is like letting someone hand-deliver a package without checking its contents, which could contain anything from a harmless gift to a bomb."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "analyze",
      "prerequisites": [
        "PHP_WRAPPERS",
        "FILE_INCLUSION",
        "RCE_BASICS"
      ]
    },
    {
      "question_text": "Which PHP stream wrapper is often used to embed small amounts of data directly into scripts or configuration files, and can be a vector for code injection if user-controlled?",
      "correct_answer": "data://",
      "distractors": [
        {
          "text": "php://filter",
          "misconception": "Targets [filter vs data confusion]: Confuses the data embedding capability with the data filtering/transformation functions."
        },
        {
          "text": "expect://",
          "misconception": "Targets [execution vs embedding confusion]: Mistakenly believes data://'s primary function is code execution, not data embedding."
        },
        {
          "text": "zip://",
          "misconception": "Targets [archive vs data confusion]: Associates data embedding with archive manipulation rather than inline data streams."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>data://</code> wrapper allows embedding data directly within a URI. If user input is not sanitized and used with this wrapper, it can lead to code injection, especially if the data is interpreted as executable code.",
        "distractor_analysis": "php://filter is for transformations, expect:// is for code execution, and zip:// is for archive handling, distinguishing them from data://'s inline data embedding.",
        "analogy": "The <code>data://</code> wrapper is like writing a note directly on a letter instead of attaching a separate document; it's convenient but can be risky if the note contains instructions."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PHP_WRAPPERS",
        "CODE_INJECTION"
      ]
    },
    {
      "question_text": "When a PHP application uses <code>include</code> or <code>require</code> with a user-controlled URL that includes a PHP wrapper like <code>php://filter/convert.base64-encode/resource=</code>, what type of vulnerability is being exploited?",
      "correct_answer": "Local File Inclusion (LFI) to read sensitive files.",
      "distractors": [
        {
          "text": "Remote Code Execution (RCE) via command injection.",
          "misconception": "Targets [LFI vs RCE confusion]: Assumes reading a file directly translates to executing arbitrary commands."
        },
        {
          "text": "Cross-Site Scripting (XSS) via reflected input.",
          "misconception": "Targets [client-side vs server-side confusion]: Confuses server-side file reading with client-side script injection."
        },
        {
          "text": "SQL Injection via database query manipulation.",
          "misconception": "Targets [web attack vector confusion]: Incorrectly links file inclusion vulnerabilities to database manipulation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>php://filter</code> wrapper, when chained with <code>convert.base64-encode</code> and <code>resource=</code>, allows an attacker to read the content of local files (like configuration files or source code) by encoding them, thus exploiting LFI.",
        "distractor_analysis": "The correct answer identifies LFI for file reading. RCE requires code execution, XSS is client-side, and SQLi targets databases, all distinct from this LFI exploitation.",
        "analogy": "This is like using a special lens (<code>php://filter</code>) to read a document (<code>resource=</code>) that's normally hidden, allowing you to see its contents (encoded)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "attack",
      "bloom_level": "apply",
      "prerequisites": [
        "PHP_WRAPPERS",
        "LFI_BASICS",
        "BASE64_ENCODING"
      ]
    },
    {
      "question_text": "What is the primary function of the <code>php://memory</code> wrapper in PHP?",
      "correct_answer": "To provide a temporary, in-memory stream for reading and writing data, which is faster but volatile.",
      "distractors": [
        {
          "text": "To securely store sensitive data persistently across requests.",
          "misconception": "Targets [persistence vs volatility confusion]: Believes in-memory storage is persistent, ignoring its temporary nature."
        },
        {
          "text": "To execute arbitrary PHP code from a remote source.",
          "misconception": "Targets [execution vs data handling confusion]: Confuses data stream handling with code execution capabilities."
        },
        {
          "text": "To encrypt and decrypt data streams on the fly.",
          "misconception": "Targets [encryption vs data handling confusion]: Attributes encryption functionality to a data stream wrapper."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>php://memory</code> wrapper functions as a read/write stream that resides entirely in RAM. This offers performance benefits for temporary data manipulation but means the data is lost when the script finishes execution.",
        "distractor_analysis": "The correct answer describes the temporary, in-memory nature. The distractors incorrectly suggest persistence, code execution, or encryption.",
        "analogy": "Using <code>php://memory</code> is like using a whiteboard: you can write and erase quickly, but once the session ends, everything is gone."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PHP_WRAPPERS",
        "DATA_STREAMS"
      ]
    },
    {
      "question_text": "Consider a scenario where a PHP application uses <code>file_get_contents()</code> with a user-supplied URL. If the server allows wrappers like <code>php://expect</code>, what is the most severe potential impact?",
      "correct_answer": "Remote Code Execution (RCE) allowing an attacker to run commands on the server.",
      "distractors": [
        {
          "text": "Information Disclosure of sensitive files on the server.",
          "misconception": "Targets [impact severity confusion]: Underestimates the impact, confusing file disclosure with full system control."
        },
        {
          "text": "Cross-Site Scripting (XSS) reflected in the user's browser.",
          "misconception": "Targets [client-side vs server-side confusion]: Attributes a client-side vulnerability to a server-side wrapper exploitation."
        },
        {
          "text": "Denial of Service (DoS) by exhausting server resources.",
          "misconception": "Targets [impact type confusion]: Focuses on resource exhaustion rather than direct code execution."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>php://expect</code> wrapper is designed to interact with external commands and can be exploited to execute arbitrary code on the server, leading to Remote Code Execution (RCE), which is the most severe impact.",
        "distractor_analysis": "RCE is the most critical outcome. Information disclosure, XSS, and DoS are less severe or different types of vulnerabilities.",
        "analogy": "Allowing <code>php://expect</code> with user input is like giving a stranger the keys to your house and asking them to 'manage' your mail; they could do anything."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "scenario",
      "bloom_level": "analyze",
      "prerequisites": [
        "PHP_WRAPPERS",
        "RCE_BASICS",
        "FILE_INCLUSION"
      ]
    },
    {
      "question_text": "Which PHP wrapper is specifically designed to allow PHP to treat network protocols like HTTP, FTP, and other streams as if they were files?",
      "correct_answer": "php://",
      "distractors": [
        {
          "text": "data://",
          "misconception": "Targets [protocol scope confusion]: Believes data:// handles network protocols, when it's for inline data."
        },
        {
          "text": "expect://",
          "misconception": "Targets [execution vs network confusion]: Confuses network stream handling with code execution capabilities."
        },
        {
          "text": "stream://",
          "misconception": "Targets [non-existent wrapper confusion]: Assumes a generic 'stream' wrapper exists for this purpose."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The base <code>php://</code> protocol is a meta-wrapper that provides access to various other wrappers, including those for network protocols, allowing PHP functions like <code>fopen</code> to interact with remote resources as files.",
        "distractor_analysis": "While <code>php://</code> is a meta-wrapper, it's the entry point for accessing network protocol streams. <code>data://</code> is for inline data, <code>expect://</code> for execution, and <code>stream://</code> is not a standard PHP wrapper for this function.",
        "analogy": "The <code>php://</code> wrapper acts like a universal adapter, allowing PHP to connect to and read from different types of 'sockets' (network protocols) as if they were simple files."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PHP_WRAPPERS",
        "NETWORK_PROTOCOLS"
      ]
    },
    {
      "question_text": "What is the primary security concern when a PHP application allows user input to directly control the <code>resource</code> parameter in a <code>php://filter</code> chain?",
      "correct_answer": "Local File Inclusion (LFI) to read sensitive files or source code.",
      "distractors": [
        {
          "text": "Remote Code Execution (RCE) through command injection.",
          "misconception": "Targets [LFI vs RCE confusion]: Assumes reading files directly enables command execution."
        },
        {
          "text": "Cross-Site Scripting (XSS) by injecting malicious scripts.",
          "misconception": "Targets [server-side vs client-side confusion]: Confuses server-side file reading with client-side script injection."
        },
        {
          "text": "SQL Injection by manipulating database queries.",
          "misconception": "Targets [attack vector confusion]: Incorrectly links file inclusion to database manipulation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "By controlling the <code>resource</code> parameter, an attacker can specify arbitrary local files (e.g., <code>/etc/passwd</code>, <code>config.php</code>) to be read and potentially transformed (e.g., base64 encoded) via <code>php://filter</code>, leading to LFI.",
        "distractor_analysis": "The core risk is LFI for reading files. RCE, XSS, and SQLi are distinct vulnerabilities that do not directly result from this specific <code>php://filter</code> manipulation.",
        "analogy": "It's like giving someone a key to any filing cabinet (<code>resource</code>) and a method to copy documents (<code>php://filter</code>), allowing them to steal any information."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "attack",
      "bloom_level": "apply",
      "prerequisites": [
        "PHP_WRAPPERS",
        "LFI_BASICS"
      ]
    },
    {
      "question_text": "Which PHP wrapper is designed to allow PHP to execute external commands and interact with the system's shell, making it highly dangerous if exposed to user input?",
      "correct_answer": "expect://",
      "distractors": [
        {
          "text": "proc://",
          "misconception": "Targets [similar name confusion]: Assumes a wrapper named 'proc' exists for process execution."
        },
        {
          "text": "exec://",
          "misconception": "Targets [function vs wrapper confusion]: Confuses the `exec()` function with a stream wrapper."
        },
        {
          "text": "shell://",
          "misconception": "Targets [non-existent wrapper confusion]: Assumes a generic 'shell' wrapper exists for this purpose."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>expect://</code> wrapper is specifically built to execute external commands and interact with the system's shell, making it a potent tool for Remote Code Execution (RCE) when exploited through user-controlled input.",
        "distractor_analysis": "While other mechanisms exist for command execution in PHP, <code>expect://</code> is the specific stream wrapper designed for this dangerous capability.",
        "analogy": "The <code>expect://</code> wrapper is like giving a user direct access to the server's command line, allowing them to run any command they wish."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PHP_WRAPPERS",
        "RCE_BASICS"
      ]
    },
    {
      "question_text": "When using the <code>data://</code> wrapper in PHP, what is the typical format for embedding base64 encoded data?",
      "correct_answer": "data://text/plain;base64,SGVsbG8gV29ybGQ=",
      "distractors": [
        {
          "text": "data://base64/SGVsbG8gV29ybGQ=",
          "misconception": "Targets [format simplification]: Omits the MIME type and encoding declaration, assuming a simpler format."
        },
        {
          "text": "data://SGVsbG8gV29ybGQ=;base64",
          "misconception": "Targets [order confusion]: Places the encoding type after the data, contrary to the standard format."
        },
        {
          "text": "data://text/plain,SGVsbG8gV29ybGQ=",
          "misconception": "Targets [encoding omission]: Fails to specify 'base64' encoding, implying plain text."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>data://</code> wrapper follows a specific URI format: <code>data://&lt;MIME-type&gt;;&lt;encoding&gt;,&lt;data&gt;</code>. For base64 encoded data, it's typically <code>data://text/plain;base64,</code> followed by the encoded string.",
        "distractor_analysis": "The correct format includes the MIME type (<code>text/plain</code>), the encoding (<code>base64</code>), and the data. Distractors omit parts or misorder them.",
        "analogy": "It's like addressing a package: you need the recipient (<code>data</code>), the type of content (<code>text/plain</code>), and the method of packing (<code>base64</code>)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "PHP_WRAPPERS",
        "BASE64_ENCODING",
        "URI_FORMAT"
      ]
    },
    {
      "question_text": "What is the primary risk of using <code>php://input</code> to read POST data and then saving it to a file with a user-controlled filename and extension?",
      "correct_answer": "Remote Code Execution (RCE) if the attacker can control the extension to be <code>.php</code> and the server executes it.",
      "distractors": [
        {
          "text": "Cross-Site Scripting (XSS) if the data contains malicious JavaScript.",
          "misconception": "Targets [client-side vs server-side confusion]: Focuses on XSS, which is a client-side issue, rather than the server-side RCE risk."
        },
        {
          "text": "Information Disclosure if the attacker reads sensitive files.",
          "misconception": "Targets [read vs write/execute confusion]: Assumes the vulnerability is only for reading files, not for writing and executing code."
        },
        {
          "text": "Denial of Service (DoS) by uploading excessively large files.",
          "misconception": "Targets [resource exhaustion vs RCE confusion]: Attributes the vulnerability to resource limits rather than code execution."
        }
      ],
      "detailed_explanation": {
        "core_logic": "By controlling the filename and extension saved from <code>php://input</code>, an attacker can save malicious PHP code with a <code>.php</code> extension. If the web server is configured to execute <code>.php</code> files, this leads to RCE.",
        "distractor_analysis": "The primary risk is RCE via controlled file saving and execution. XSS, Info Disclosure, and DoS are less direct or severe outcomes.",
        "analogy": "It's like allowing someone to name and store documents in your office; if they name a document <code>malicious_script.php</code> and store it where it can be run, they can execute commands."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "attack",
      "bloom_level": "apply",
      "prerequisites": [
        "PHP_WRAPPERS",
        "RCE_BASICS",
        "FILE_UPLOAD_VULNS"
      ]
    },
    {
      "question_text": "Which PHP wrapper is often used in conjunction with file inclusion vulnerabilities to bypass restrictions and read source code or configuration files, even if direct file access is blocked?",
      "correct_answer": "php://filter",
      "distractors": [
        {
          "text": "php://input",
          "misconception": "Targets [input vs filter confusion]: Believes reading raw input data is equivalent to filtering/transforming file contents."
        },
        {
          "text": "data://",
          "misconception": "Targets [data embedding vs filtering confusion]: Confuses embedding inline data with filtering/transforming existing file content."
        },
        {
          "text": "expect://",
          "misconception": "Targets [execution vs filtering confusion]: Mistakenly associates code execution capabilities with file content reading."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>php://filter</code> wrapper allows PHP to process streams (like files) through various filters. This is commonly exploited in LFI scenarios to read source code or sensitive configuration files by encoding them (e.g., base64) or applying other transformations.",
        "distractor_analysis": "php://filter is specifically designed for stream manipulation. php://input reads POST data, data:// embeds data, and expect:// executes commands.",
        "analogy": "Think of <code>php://filter</code> as a special magnifying glass that can not only view a document but also translate it or make it invisible to normal sight, helping you read restricted files."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PHP_WRAPPERS",
        "LFI_BASICS",
        "STREAM_FILTERS"
      ]
    },
    {
      "question_text": "What is the fundamental difference between <code>php://input</code> and <code>php://stdin</code>?",
      "correct_answer": "<code>php://input</code> reads raw POST data, while <code>php://stdin</code> reads from the standard input stream, typically used in CLI environments.",
      "distractors": [
        {
          "text": "<code>php://input</code> is for reading files, <code>php://stdin</code> is for network streams.",
          "misconception": "Targets [stream type confusion]: Incorrectly assigns file reading to input and network streams to stdin."
        },
        {
          "text": "<code>php://input</code> is used for writing data, <code>php://stdin</code> is for reading data.",
          "misconception": "Targets [read/write confusion]: Reverses the primary purpose of one or both streams."
        },
        {
          "text": "<code>php://input</code> is for remote file inclusion, <code>php://stdin</code> is for local file inclusion.",
          "misconception": "Targets [inclusion type confusion]: Misapplies the concepts of RFI/LFI to these specific stream wrappers."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>php://input</code> wrapper allows reading raw data from the request body (typically POST requests), bypassing <code>magic_quotes</code> and <code>GPC</code>. <code>php://stdin</code> reads from the standard input, which is common in command-line interfaces (CLI) but less so in web contexts.",
        "distractor_analysis": "The correct answer accurately distinguishes between POST data reading and standard input reading. The distractors confuse their purposes, associated protocols, or read/write capabilities.",
        "analogy": "<code>php://input</code> is like reading the contents of a package delivered by mail (POST request), while <code>php://stdin</code> is like reading what someone types directly into a terminal."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "PHP_WRAPPERS",
        "HTTP_REQUESTS",
        "CLI_BASICS"
      ]
    },
    {
      "question_text": "In the context of PHP wrappers, what does the <code>php://fd</code> wrapper allow?",
      "correct_answer": "Accessing file descriptors, which are low-level handles to open files or I/O streams.",
      "distractors": [
        {
          "text": "Executing arbitrary commands on the server.",
          "misconception": "Targets [execution vs file descriptor confusion]: Confuses low-level I/O handles with command execution capabilities."
        },
        {
          "text": "Reading data from standard input.",
          "misconception": "Targets [specific descriptor vs general access confusion]: Mistakenly assumes it only provides access to stdin."
        },
        {
          "text": "Embedding small amounts of data directly into scripts.",
          "misconception": "Targets [data embedding vs descriptor confusion]: Confuses file descriptor access with the `data://` wrapper's functionality."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>php://fd</code> wrapper provides access to PHP's file descriptor numbers (0 for stdin, 1 for stdout, 2 for stderr, etc.), allowing interaction with these low-level I/O streams.",
        "distractor_analysis": "The correct answer defines <code>php://fd</code>'s purpose. The distractors incorrectly associate it with command execution, stdin specifically, or data embedding.",
        "analogy": "File descriptors are like numbered ports on a machine; <code>php://fd</code> lets you interact with specific ports (like port 1 for output) directly."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PHP_WRAPPERS",
        "FILE_DESCRIPTORS",
        "LOW_LEVEL_IO"
      ]
    },
    {
      "question_text": "What is a common defense mechanism against vulnerabilities involving PHP wrappers like <code>php://input</code> or <code>php://filter</code>?",
      "correct_answer": "Strict input validation and sanitization, ensuring user-controlled data is never treated as executable code or sensitive file paths.",
      "distractors": [
        {
          "text": "Disabling all PHP wrappers in the <code>php.ini</code> configuration.",
          "misconception": "Targets [overly broad defense confusion]: Suggests disabling all wrappers, which breaks legitimate functionality."
        },
        {
          "text": "Implementing rate limiting on all file access functions.",
          "misconception": "Targets [wrong defense mechanism confusion]: Proposes rate limiting, which doesn't prevent the core vulnerability."
        },
        {
          "text": "Using only <code>file://</code> wrapper for all file operations.",
          "misconception": "Targets [wrapper restriction confusion]: Believes restricting to `file://` inherently prevents exploitation, ignoring other vectors."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The most effective defense is robust input validation and sanitization. This prevents user-controlled data from being interpreted as a dangerous wrapper protocol, file path, or executable code, thereby mitigating LFI and RCE risks.",
        "distractor_analysis": "Input validation is the primary defense. Disabling all wrappers is impractical, rate limiting is ineffective, and restricting to <code>file://</code> doesn't solve all wrapper-related issues.",
        "analogy": "It's like having a strict security guard at the entrance (input validation) who checks everyone's ID and purpose before letting them access sensitive areas (code execution/file paths)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "PHP_WRAPPERS",
        "INPUT_VALIDATION",
        "SECURE_CODING"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "PHP Wrapper 005_Exploitation (php://, data://, expect://) Penetration Testing And Ethical Hacking best practices",
    "latency_ms": 35567.831
  },
  "timestamp": "2026-01-18T14:53:11.405765",
  "_av_safe_encoded": true,
  "_encoding_note": "Educational content encoded with HTML entities to prevent antivirus false positives. Content renders normally in Anki."
}