{
  "topic_title": "Expired Certificate Detection",
  "category": "Penetration Testing And Ethical Hacking - Web Application Penetration Testing",
  "flashcards": [
    {
      "question_text": "During a penetration test, what is the primary risk associated with a web server presenting an expired SSL/TLS certificate?",
      "correct_answer": "It can lead to a trust failure, potentially causing browsers to display security warnings or block access, and may indicate a lack of proper certificate lifecycle management.",
      "distractors": [
        {
          "text": "It automatically triggers a denial-of-service (DoS) attack.",
          "misconception": "Targets [causation error]: Confuses certificate expiration with active attack vectors."
        },
        {
          "text": "It guarantees that the server's private key has been compromised.",
          "misconception": "Targets [implication error]: Assumes expiration directly implies key compromise, which is not necessarily true."
        },
        {
          "text": "It forces the client to use a weaker encryption cipher.",
          "misconception": "Targets [mechanism confusion]: Incorrectly links certificate expiration to cipher negotiation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Expired certificates fail validation because their trust anchor has passed its validity period, signaling a potential security risk to clients and indicating poor operational hygiene.",
        "distractor_analysis": "The first distractor incorrectly equates expiration with a DoS attack. The second wrongly assumes expiration means key compromise. The third misattributes the cause of weaker cipher use.",
        "analogy": "It's like a driver's license expiring; the person is still the same, but official systems won't trust their identity for certain activities, and it suggests they haven't kept their documents current."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "SSL_TLS_BASICS",
        "CERTIFICATE_LIFECYCLE"
      ]
    },
    {
      "question_text": "Which of the following automated checks is MOST effective for detecting expired certificates on a target web server during a penetration test?",
      "correct_answer": "Using a network scanner or specialized tool (e.g., Nmap with SSL scripts, Qualys SSL Labs) to query the server's certificate validity period.",
      "distractors": [
        {
          "text": "Manually inspecting the certificate details in a web browser after connecting.",
          "misconception": "Targets [efficiency error]: Overlooks the need for automated, scalable detection in pentesting."
        },
        {
          "text": "Monitoring server logs for 'certificate expired' error messages.",
          "misconception": "Targets [log coverage error]: Assumes logs will always capture this specific event, which isn't guaranteed."
        },
        {
          "text": "Performing a brute-force attack on the server's private key.",
          "misconception": "Targets [irrelevant action]: Attempts an unrelated, high-risk attack instead of certificate validation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Automated tools are crucial for efficiency and coverage in penetration testing because they can systematically query certificate validity periods directly from the server, bypassing manual steps and log analysis limitations.",
        "distractor_analysis": "Manual browser inspection is inefficient. Server logs might not always record expiration events clearly. Brute-forcing private keys is irrelevant to detecting expired certificates.",
        "analogy": "Instead of checking each car's registration sticker by hand, you use a scanner that reads the expiration date directly from the sticker."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "NETWORK_SCANNING_TOOLS",
        "SSL_TLS_BASICS"
      ]
    },
    {
      "question_text": "What is the significance of the 'Not Before' and 'Not After' fields within an X.509 certificate during a penetration test?",
      "correct_answer": "They define the period during which the certificate is considered valid; 'Not After' indicates the expiration date.",
      "distractors": [
        {
          "text": "They specify the cryptographic algorithm strength used for encryption.",
          "misconception": "Targets [field confusion]: Mixes certificate validity dates with cipher suite information."
        },
        {
          "text": "They indicate the revocation status and reason code.",
          "misconception": "Targets [field confusion]: Confuses validity dates with certificate revocation list (CRL) or OCSP data."
        },
        {
          "text": "They represent the public key exponent and modulus values.",
          "misconception": "Targets [cryptographic component confusion]: Relates dates to the mathematical components of the public key."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'Not Before' and 'Not After' fields are fundamental to a certificate's lifecycle, defining its trust window. 'Not After' specifically marks the expiration, which clients check to ensure the certificate is still trusted.",
        "distractor_analysis": "The distractors incorrectly associate these date fields with encryption algorithms, revocation status, or public key components, demonstrating a misunderstanding of certificate structure.",
        "analogy": "These fields are like the 'valid from' and 'expires on' dates printed on a credit card, defining when it can be used."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "X509_CERTIFICATE_STRUCTURE",
        "CERTIFICATE_VALIDATION"
      ]
    },
    {
      "question_text": "A penetration tester discovers a web application that uses an expired certificate. What is a common attack vector that exploits this situation?",
      "correct_answer": "Man-in-the-Middle (MitM) attack, where the attacker intercepts traffic and presents their own certificate or exploits the client's trust failure.",
      "distractors": [
        {
          "text": "SQL Injection, by leveraging the expired certificate to bypass input validation.",
          "misconception": "Targets [attack vector confusion]: Links certificate expiration to a completely unrelated web vulnerability."
        },
        {
          "text": "Cross-Site Scripting (XSS), by injecting malicious scripts through the certificate error page.",
          "misconception": "Targets [attack vector confusion]: Incorrectly assumes expired certificates enable XSS injection."
        },
        {
          "text": "Buffer Overflow, by sending malformed data that exploits the certificate handling mechanism.",
          "misconception": "Targets [vulnerability type confusion]: Equates certificate expiration with memory corruption vulnerabilities."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Expired certificates create trust gaps that attackers exploit for MitM attacks because clients often ignore or bypass warnings, allowing the attacker to intercept and potentially modify traffic, impersonating the legitimate server.",
        "distractor_analysis": "SQL Injection and XSS are distinct vulnerabilities unrelated to certificate expiration. Buffer overflows exploit memory management flaws, not trust validation issues.",
        "analogy": "It's like a security guard whose ID badge has expired; a scammer could potentially walk past them by pretending to be an authorized official, intercepting communications."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "MITM_ATTACKS",
        "CERTIFICATE_VALIDATION",
        "WEB_APP_VULNERABILITIES"
      ]
    },
    {
      "question_text": "When using OpenSSL to check a certificate's expiration date, which command-line option is typically used?",
      "correct_answer": "The <code>openssl s_client -connect host:port</code> command, followed by inspecting the certificate details output.",
      "distractors": [
        {
          "text": "<code>openssl x509 -in certificate.pem -dates</code>",
          "misconception": "Targets [command usage error]: Assumes direct file inspection is the primary method for live server checks."
        },
        {
          "text": "<code>openssl req -text -noout -verify</code>",
          "misconception": "Targets [command purpose error]: This command is for certificate signing requests, not live server validation."
        },
        {
          "text": "<code>openssl dhparam -genparam 2048</code>",
          "misconception": "Targets [command purpose error]: This command generates Diffie-Hellman parameters, unrelated to certificate expiration."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>openssl s_client</code> command establishes a connection to a remote server and retrieves its certificate, allowing direct inspection of its validity period, which is essential for detecting expired certificates in real-time.",
        "distractor_analysis": "The first distractor is for local files. The second is for CSR generation. The third is for DH parameter generation, none of which directly check a live server's certificate expiration.",
        "analogy": "It's like using a phone call to ask someone their age ('connect') rather than looking at their expired ID card ('x509 -dates')."
      },
      "code_snippets": [
        {
          "language": "text",
          "code": "<pre><code class=\"language-bash\">openssl s_client -connect example.com:443 &lt;/code&gt;&lt;/pre&gt;",
          "context": "explanation"
        }
      ],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "OPENSSL_USAGE",
        "SSL_TLS_BASICS"
      ],
      "_code_snippets_html": "<div class=\"code-snippet code-explanation\">\n<span class=\"code-label\">Code Example</span>\n<pre><code class=\"language-text\">&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;openssl s_client -connect example.com:443 &amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;</code></pre>\n</div>"
    },
    {
      "question_text": "What is the role of Certificate Revocation Lists (CRLs) and Online Certificate Status Protocol (OCSP) in detecting potentially expired or compromised certificates?",
      "correct_answer": "They provide mechanisms for clients to check if a certificate has been revoked before its expiration date, complementing expiration checks.",
      "distractors": [
        {
          "text": "They are used to issue new certificates with extended validity periods.",
          "misconception": "Targets [function confusion]: Mixes revocation checking with certificate issuance."
        },
        {
          "text": "They encrypt the communication channel between client and server.",
          "misconception": "Targets [function confusion]: Confuses certificate status checking with the encryption function of TLS/SSL."
        },
        {
          "text": "They are primarily used to verify the identity of the Certificate Authority (CA).",
          "misconception": "Targets [scope confusion]: Focuses on CA validation rather than end-entity certificate status."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CRLs and OCSP are vital because certificates can be compromised or mis-issued before their 'Not After' date; these protocols allow clients to query the CA for the current status, ensuring they don't trust revoked certificates.",
        "distractor_analysis": "The distractors incorrectly describe CRLs/OCSP as tools for issuance, encryption, or CA verification, rather than for checking the revocation status of specific certificates.",
        "analogy": "CRLs/OCSP are like a 'hotlist' of credit cards that have been reported stolen; even if the card hasn't expired, it's no longer valid for transactions."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CERTIFICATE_REVOCATION",
        "PKI_BASICS"
      ]
    },
    {
      "question_text": "During a penetration test, if a client application fails to connect to a server due to an expired certificate, what is the MOST likely underlying reason for the failure?",
      "correct_answer": "The client's certificate validation logic correctly identifies the certificate's 'Not After' date as being in the past.",
      "distractors": [
        {
          "text": "The server's network firewall is blocking the connection based on certificate status.",
          "misconception": "Targets [component confusion]: Attributes connection failure to network infrastructure rather than certificate validation."
        },
        {
          "text": "The client's system clock is significantly out of sync with the server's clock.",
          "misconception": "Targets [secondary cause confusion]: While clock skew can cause issues, direct expiration is the primary reason for failure if the date is truly past."
        },
        {
          "text": "The server has disabled TLS/SSL protocol support entirely.",
          "misconception": "Targets [protocol confusion]: Assumes a complete protocol disablement rather than a specific certificate validation failure."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Certificate validation inherently checks the 'Not After' date; if this date has passed, the certificate is considered invalid by design, causing the client's security checks to fail and block the connection.",
        "distractor_analysis": "Firewalls don't typically block based on certificate expiration directly. Clock skew is a potential issue but secondary to the actual expiration date. Protocol disablement is a different failure mode.",
        "analogy": "The application is like a bouncer checking IDs; if the ID (certificate) has passed its expiry date, the bouncer denies entry, regardless of other factors like the venue's power supply."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "CERTIFICATE_VALIDATION",
        "TLS_HANDSHAKE"
      ]
    },
    {
      "question_text": "What is the potential impact of an expired certificate on a web application's Search Engine Optimization (SEO) ranking?",
      "correct_answer": "Search engines may penalize sites with security warnings or trust issues, potentially lowering their rankings.",
      "distractors": [
        {
          "text": "It directly improves SEO rankings due to perceived 'urgency'.",
          "misconception": "Targets [misinterpretation of impact]: Incorrectly assumes security warnings benefit SEO."
        },
        {
          "text": "It has no impact on SEO, as search engines only consider content quality.",
          "misconception": "Targets [oversimplification]: Ignores the role of user experience and security signals in SEO."
        },
        {
          "text": "It forces search engine bots to use HTTP instead of HTTPS.",
          "misconception": "Targets [protocol confusion]: Incorrectly assumes expiration forces a protocol downgrade."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Search engines prioritize secure and trustworthy user experiences; expired certificates trigger browser warnings, which deter users and signal a lack of maintenance, leading search engines to de-prioritize such sites.",
        "distractor_analysis": "The distractors incorrectly suggest expired certificates improve SEO, have no impact, or force protocol downgrades, failing to recognize the negative security and user experience implications.",
        "analogy": "It's like a shop with a broken 'Open' sign; customers might assume it's closed or untrustworthy, leading fewer people to visit, thus affecting its 'popularity' (ranking)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "HTTPS_BASICS",
        "SEO_FUNDAMENTALS",
        "WEBSITE_SECURITY"
      ]
    },
    {
      "question_text": "Consider a scenario where a penetration tester finds a server using a self-signed certificate that has expired. What is the primary challenge in assessing this?",
      "correct_answer": "Self-signed certificates are inherently untrusted by default; expiration adds another layer of invalidity, but the initial trust issue remains the primary concern.",
      "distractors": [
        {
          "text": "Self-signed certificates cannot be expired; they are valid indefinitely.",
          "misconception": "Targets [fundamental misunderstanding]: Believes self-signed certificates bypass validity periods."
        },
        {
          "text": "The expiration date is irrelevant because the certificate is self-signed.",
          "misconception": "Targets [trust model confusion]: Assumes self-signing negates all validation checks, including expiration."
        },
        {
          "text": "Only Certificate Authorities (CAs) can issue certificates that can expire.",
          "misconception": "Targets [issuance model confusion]: Incorrectly limits expiration to CA-issued certificates."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Self-signed certificates lack a trusted third-party issuer, making them untrustworthy from the start. An expired self-signed certificate is doubly problematic, failing both the trust anchor check and the validity period check.",
        "distractor_analysis": "The distractors wrongly claim self-signed certificates don't expire or are immune to expiration checks, fundamentally misunderstanding certificate validation principles.",
        "analogy": "It's like having a homemade ID card that says you're 21, but it also has a 'valid until' date that has passed. The ID was never trustworthy to begin with, and now it's also outdated."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "analyze",
      "prerequisites": [
        "SELF_SIGNED_CERTIFICATES",
        "CERTIFICATE_VALIDATION"
      ]
    },
    {
      "question_text": "Which NIST Special Publication provides guidance relevant to certificate management and validation practices?",
      "correct_answer": "NIST SP 800-53 (Security and Privacy Controls for Information Systems and Organizations)",
      "distractors": [
        {
          "text": "NIST SP 800-171 (Protecting Controlled Unclassified Information in Nonfederal Information Systems)",
          "misconception": "Targets [publication scope confusion]: Focuses on CUI protection, not directly on PKI/certificate management controls."
        },
        {
          "text": "NIST SP 1800-16 (Securing IoT Devices)",
          "misconception": "Targets [publication scope confusion]: Specific to IoT security, not general certificate lifecycle management."
        },
        {
          "text": "NIST SP 500-292 (Cloud Computing Reference Architecture)",
          "misconception": "Targets [publication scope confusion]: Focuses on cloud architecture, not specific certificate validation processes."
        }
      ],
      "detailed_explanation": {
        "core_logic": "NIST SP 800-53 includes control families like 'Identification and Authentication' (IA) and 'System and Communications Protection' (SC) that encompass requirements for Public Key Infrastructure (PKI) and certificate management, including validation.",
        "distractor_analysis": "The distractors point to NIST publications with different primary focuses (CUI, IoT, Cloud Architecture), none of which are the central resource for broad PKI and certificate management controls like SP 800-53.",
        "analogy": "If you're looking for general rules on how to manage keys and locks in a building, SP 800-53 is the master manual, while the others are specific guides for particular rooms or types of locks."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "NIST_FRAMEWORK",
        "PKI_BASICS"
      ]
    },
    {
      "question_text": "What is the difference between certificate expiration and certificate revocation from a penetration tester's perspective?",
      "correct_answer": "Expiration is a planned end-of-life, while revocation is an unplanned termination due to compromise or policy violation.",
      "distractors": [
        {
          "text": "Expiration means the certificate is compromised, while revocation means it's simply old.",
          "misconception": "Targets [cause/effect reversal]: Incorrectly assigns compromise to expiration and obsolescence to revocation."
        },
        {
          "text": "Expiration affects only client certificates, while revocation affects server certificates.",
          "misconception": "Targets [scope confusion]: Incorrectly limits the applicability of expiration and revocation based on certificate type."
        },
        {
          "text": "Expiration is checked by OCSP, while revocation is checked by CRLs.",
          "misconception": "Targets [protocol mapping error]: Incorrectly assigns specific protocols to distinct concepts."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Expiration is a predetermined lifecycle event, whereas revocation is an immediate action taken when a certificate's security is compromised or its use violates policy, requiring different detection and response considerations.",
        "distractor_analysis": "The distractors confuse the causes of expiration/revocation, misapply them to specific certificate types, and incorrectly map them to specific checking protocols (OCSP/CRL).",
        "analogy": "Expiration is like a milk carton's 'best by' date; revocation is like someone pouring the milk out because it smells bad (compromised)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "CERTIFICATE_LIFECYCLE",
        "CERTIFICATE_REVOCATION"
      ]
    },
    {
      "question_text": "How might an attacker leverage a client's failure to properly validate certificate expiration dates during a penetration test?",
      "correct_answer": "By using a MitM attack to intercept traffic, potentially presenting an expired or even a fraudulent certificate, and exploiting the client's lax validation.",
      "distractors": [
        {
          "text": "By performing a denial-of-service attack against the client's browser.",
          "misconception": "Targets [attack vector confusion]: Links lax validation to DoS, which is unrelated."
        },
        {
          "text": "By gaining administrative privileges on the client's machine through certificate manipulation.",
          "misconception": "Targets [privilege escalation confusion]: Overstates the direct impact of lax certificate validation on system compromise."
        },
        {
          "text": "By forcing the server to downgrade its encryption protocol to an insecure version.",
          "misconception": "Targets [protocol downgrade confusion]: Incorrectly assumes lax client validation directly forces server protocol changes."
        }
      ],
      "detailed_explanation": {
        "core_logic": "If a client fails to validate expiration, it may accept an invalid certificate, enabling an attacker to position themselves between the client and server (MitM) and potentially relay or manipulate traffic, exploiting the trust failure.",
        "distractor_analysis": "The distractors incorrectly link lax validation to DoS attacks, direct administrative privilege escalation, or forcing server protocol downgrades, which are not direct consequences.",
        "analogy": "If a security guard doesn't check the expiry date on visitor badges, an imposter with an expired badge could potentially walk into restricted areas, exploiting the guard's oversight."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "MITM_ATTACKS",
        "CERTIFICATE_VALIDATION",
        "CLIENT_SIDE_ATTACKS"
      ]
    },
    {
      "question_text": "What is the primary defense mechanism against issues arising from expired certificates on a web server?",
      "correct_answer": "Implementing a robust certificate lifecycle management process, including timely renewal and automated monitoring.",
      "distractors": [
        {
          "text": "Disabling all client-side certificate validation checks.",
          "misconception": "Targets [insecure configuration]: Proposes disabling security features as a solution."
        },
        {
          "text": "Using only self-signed certificates to avoid external dependencies.",
          "misconception": "Targets [insecure configuration]: Recommends a fundamentally insecure certificate type."
        },
        {
          "text": "Manually checking certificate expiration dates once a year.",
          "misconception": "Targets [inefficient process]: Suggests an inadequate frequency and method for monitoring."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Proactive lifecycle management ensures certificates are renewed before expiration, preventing service disruptions and trust issues. Automated monitoring provides timely alerts for any lapses in this process.",
        "distractor_analysis": "Disabling validation or using self-signed certificates introduces severe security risks. Manual, infrequent checks are insufficient for dynamic environments.",
        "analogy": "The best defense against a car's registration expiring is having a system that reminds you to renew it well in advance, rather than waiting for a ticket."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "CERTIFICATE_LIFECYCLE",
        "WEBSITE_SECURITY_BEST_PRACTICES"
      ]
    },
    {
      "question_text": "In the context of penetration testing, why is it important to check for expired certificates even on internal networks?",
      "correct_answer": "Expired internal certificates can still lead to trust issues, service disruptions, and potential vulnerabilities if not managed properly, impacting internal operations.",
      "distractors": [
        {
          "text": "Internal networks are immune to certificate expiration issues.",
          "misconception": "Targets [scope assumption]: Believes security concerns are limited to external-facing systems."
        },
        {
          "text": "Expired internal certificates automatically grant administrative access.",
          "misconception": "Targets [causation error]: Exaggerates the direct impact of expired internal certificates."
        },
        {
          "text": "Only publicly trusted certificates need to be monitored for expiration.",
          "misconception": "Targets [trust model confusion]: Ignores the need for managing internal PKI infrastructure."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Internal systems often rely on certificates for authentication, encryption, and service integrity. Expiration can break these functions, disrupt operations, and potentially be exploited by internal threats or attackers who gain a foothold.",
        "distractor_analysis": "The distractors wrongly claim immunity for internal networks, exaggerate the impact to administrative access, and incorrectly limit monitoring to public certificates.",
        "analogy": "Even within a company, if internal ID badges expire, employees might be locked out of certain areas or systems, disrupting work, even if no external threat exists."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "INTERNAL_PKI",
        "NETWORK_SECURITY"
      ]
    },
    {
      "question_text": "Which of the following tools is commonly used by penetration testers to automate the discovery of expired certificates across a range of hosts?",
      "correct_answer": "Nmap with NSE scripts (e.g., <code>ssl-cert</code> script)",
      "distractors": [
        {
          "text": "Wireshark",
          "misconception": "Targets [tool function confusion]: Wireshark is for packet analysis, not automated certificate scanning."
        },
        {
          "text": "Metasploit Framework",
          "misconception": "Targets [tool function confusion]: While Metasploit has modules, Nmap is more specialized for initial host discovery and certificate info gathering."
        },
        {
          "text": "John the Ripper",
          "misconception": "Targets [tool function confusion]: John the Ripper is a password cracking tool."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Nmap's scripting engine (NSE) allows for extensible network discovery, and scripts like <code>ssl-cert</code> can efficiently query and report on certificate details, including expiration dates, across multiple hosts.",
        "distractor_analysis": "Wireshark captures traffic but doesn't automate scanning. Metasploit is broader, but Nmap is often preferred for initial reconnaissance of this type. John the Ripper is for password cracking.",
        "analogy": "Nmap with its scripts is like a multi-tool designed to quickly check the 'health status' (like expiration dates) of many devices on a network, whereas Wireshark is like a microscope for examining individual data packets."
      },
      "code_snippets": [
        {
          "language": "text",
          "code": "&lt;pre&gt;&lt;code class=\"language-bash\"&gt;nmap --script ssl-cert -p 443 &lt;/code&gt;&lt;/pre&gt;",
          "context": "explanation"
        }
      ],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "NMAP_USAGE",
        "NETWORK_SCANNING_TOOLS"
      ],
      "_code_snippets_html": "<div class=\"code-snippet code-explanation\">\n<span class=\"code-label\">Code Example</span>\n<pre><code class=\"language-text\">&amp;lt;pre&amp;gt;&amp;lt;code class=&quot;language-bash&quot;&amp;gt;nmap --script ssl-cert -p 443 &amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;</code></pre>\n</div>"
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Expired Certificate Detection Penetration Testing And Ethical Hacking best practices",
    "latency_ms": 36355.72
  },
  "timestamp": "2026-01-18T14:58:32.430536"
}