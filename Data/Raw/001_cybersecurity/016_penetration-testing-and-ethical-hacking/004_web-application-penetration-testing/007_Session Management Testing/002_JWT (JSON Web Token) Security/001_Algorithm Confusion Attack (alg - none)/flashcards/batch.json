{
  "topic_title": "Algorithm Confusion Attack (alg: none)",
  "category": "Penetration Testing And Ethical Hacking - Web Application Penetration Testing",
  "flashcards": [
    {
      "question_text": "In the context of JWT security, what is the primary goal of an Algorithm Confusion Attack?",
      "correct_answer": "To trick the server into accepting a token signed with a weaker or invalid algorithm than expected.",
      "distractors": [
        {
          "text": "To force the server to reveal its private encryption keys.",
          "misconception": "Targets [key management confusion]: Confuses algorithm choice with direct key compromise."
        },
        {
          "text": "To inject malicious JavaScript into the JWT payload.",
          "misconception": "Targets [payload manipulation confusion]: Misunderstands that algorithm choice doesn't directly enable XSS in the payload itself."
        },
        {
          "text": "To bypass authentication by forging a valid token signature.",
          "misconception": "Targets [attack mechanism confusion]: While a consequence, the core is about algorithm weakness, not general forgery."
        }
      ],
      "detailed_explanation": {
        "core_logic": "An Algorithm Confusion Attack works by exploiting a server's trust in a specified algorithm (like HS256) by submitting a token signed with a different, often weaker or null, algorithm (like none or RS256 with a public key). This happens because the server might not properly validate the 'alg' header against the actual signature method used.",
        "distractor_analysis": "The first distractor focuses on key revelation, which isn't the direct goal. The second misattributes XSS injection to the algorithm choice itself. The third describes a general outcome of successful token manipulation, not the specific mechanism of algorithm confusion.",
        "analogy": null
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "JWT_BASICS",
        "JWT_SIGNATURES"
      ]
    },
    {
      "question_text": "Which JWT header parameter is most directly targeted and manipulated in an Algorithm Confusion Attack?",
      "correct_answer": "'alg' (algorithm)",
      "distractors": [
        {
          "text": "'typ' (type)",
          "misconception": "Targets [header field confusion]: Misidentifies the header related to token type as the target for algorithm manipulation."
        },
        {
          "text": "'kid' (key ID)",
          "misconception": "Targets [key management confusion]: Confuses the identifier for a key with the algorithm used for signing."
        },
        {
          "text": "'jku' (JWK Set URL)",
          "misconception": "Targets [key source confusion]: Mistakenly believes the URL for fetching keys is the manipulated parameter, not the algorithm itself."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'alg' header parameter specifies the cryptographic algorithm used to secure the JWT. In an Algorithm Confusion Attack, an attacker manipulates this field to trick the server into using an unintended or weaker algorithm for signature verification, thereby bypassing security checks.",
        "distractor_analysis": "The distractors incorrectly identify other JWT header fields ('typ', 'kid', 'jku') as the primary target, demonstrating a misunderstanding of which parameter controls the signing algorithm.",
        "analogy": null
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "JWT_HEADER"
      ]
    },
    {
      "question_text": "A common defense against Algorithm Confusion Attacks involves validating the JWT signature. What is a crucial aspect of this validation process?",
      "correct_answer": "Ensuring the algorithm specified in the 'alg' header matches the algorithm actually used to sign the token.",
      "distractors": [
        {
          "text": "Verifying that the token's expiration time ('exp') has not passed.",
          "misconception": "Targets [validation scope confusion]: Focuses on time-based validation, which is separate from algorithm integrity."
        },
        {
          "text": "Checking if the token's issuer ('iss') is a trusted entity.",
          "misconception": "Targets [identity validation confusion]: Confuses issuer validation with the cryptographic algorithm validation."
        },
        {
          "text": "Decrypting the JWT payload to inspect its contents for malicious data.",
          "misconception": "Targets [encryption vs. signing confusion]: Assumes JWTs are always encrypted and that decryption is part of signature validation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Proper JWT signature validation requires the server to explicitly check that the algorithm declared in the 'alg' header is indeed the one used for signing. This prevents attackers from substituting a weaker algorithm, like 'none', or an algorithm for which they can forge a signature.",
        "distractor_analysis": "The distractors propose validation steps that are important for JWT security but do not directly address the algorithm confusion vulnerability: checking expiration, verifying the issuer, or decrypting the payload.",
        "analogy": null
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "analyze",
      "prerequisites": [
        "JWT_SIGNATURE_VALIDATION",
        "JWT_HEADER"
      ]
    },
    {
      "question_text": "Consider a scenario where a JWT is signed using the HMAC SHA256 algorithm (HS256). An attacker crafts a new JWT where the 'alg' header is set to 'none' but includes a valid HS256 signature. What is the MOST LIKELY outcome if the server does not properly validate the algorithm?",
      "correct_answer": "The server accepts the token as valid because it proceeds to verify the signature without checking that the 'alg' header was 'none'.",
      "distractors": [
        {
          "text": "The server rejects the token because the 'none' algorithm is inherently insecure.",
          "misconception": "Targets [algorithm policy confusion]: Assumes the server has a strict policy against 'none' without proper validation logic."
        },
        {
          "text": "The server attempts to decrypt the token using a public key, leading to an error.",
          "misconception": "Targets [signing vs. encryption confusion]: Incorrectly assumes JWTs are always encrypted and that public key decryption is relevant for HS256."
        },
        {
          "text": "The server ignores the signature and validates the token based solely on the payload content.",
          "misconception": "Targets [validation process confusion]: Misunderstands that signature verification is a critical step, not bypassed by the 'alg' header alone."
        }
      ],
      "detailed_explanation": {
        "core_logic": "If a server improperly validates the 'alg' header, it might accept a token with 'alg: none' even if a signature is present. The vulnerability lies in the server's failure to enforce that the signature algorithm matches the declared 'alg' value, allowing the attacker to bypass signature checks.",
        "distractor_analysis": "The first distractor assumes a default rejection of 'none' without proper validation. The second incorrectly applies public key decryption to an HMAC-signed token. The third suggests the signature is ignored, which isn't the primary failure mode of this specific attack.",
        "analogy": null
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "JWT_HS256",
        "JWT_NONE_ALGORITHM",
        "JWT_SIGNATURE_VALIDATION"
      ]
    },
    {
      "question_text": "What is the significance of the 'none' algorithm in the context of JWTs and Algorithm Confusion Attacks?",
      "correct_answer": "It indicates that the JWT is not signed, and its use in an Algorithm Confusion Attack exploits servers that incorrectly process signed tokens without 'none'.",
      "distractors": [
        {
          "text": "It is a placeholder for future encryption algorithms.",
          "misconception": "Targets [algorithm purpose confusion]: Misunderstands 'none' as a reserved future state rather than a lack of signing."
        },
        {
          "text": "It signifies that the token has been encrypted using a symmetric key.",
          "misconception": "Targets [signing vs. encryption confusion]: Confuses the absence of a signature with encryption."
        },
        {
          "text": "It is a deprecated algorithm that should never be used.",
          "misconception": "Targets [deprecation status confusion]: While insecure in many contexts, its primary issue is how it's handled, not just its status."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'none' algorithm explicitly states that no signature was applied to the JWT. An Algorithm Confusion Attack leverages this by sending a token with 'alg: none' to a server that expects a signature, but fails to validate that the 'alg' header correctly reflects the absence of a signature.",
        "distractor_analysis": "The distractors misrepresent the purpose of the 'none' algorithm, suggesting it's for future use, encryption, or simply deprecated without explaining its role in the attack vector.",
        "analogy": null
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "JWT_NONE_ALGORITHM",
        "JWT_SIGNATURES"
      ]
    },
    {
      "question_text": "Which of the following is a common vulnerability that enables an Algorithm Confusion Attack?",
      "correct_answer": "The server blindly trusts the 'alg' header value without verifying it against the actual signature.",
      "distractors": [
        {
          "text": "Weaknesses in the encryption algorithm itself, such as short key lengths.",
          "misconception": "Targets [algorithm strength confusion]: Focuses on the inherent strength of a chosen algorithm, not the choice of algorithm."
        },
        {
          "text": "Insecure storage of the JWT secret key on the client-side.",
          "misconception": "Targets [key storage confusion]: Relates to key management, not the algorithm negotiation process."
        },
        {
          "text": "Cross-Site Scripting (XSS) vulnerabilities in the application.",
          "misconception": "Targets [vulnerability type confusion]: Confuses session management attacks with injection vulnerabilities."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The core vulnerability exploited is the server's failure to perform a strict validation of the 'alg' header. Instead of verifying that the declared algorithm matches the signature method, the server might accept the declared algorithm at face value, allowing an attacker to substitute a weaker or 'none' algorithm.",
        "distractor_analysis": "The distractors point to other common web vulnerabilities (weak encryption, insecure key storage, XSS) that are distinct from the specific mechanism of algorithm confusion.",
        "analogy": null
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "JWT_HEADER",
        "JWT_SIGNATURE_VALIDATION"
      ]
    },
    {
      "question_text": "When implementing JWT validation, what is the recommended approach to mitigate Algorithm Confusion Attacks?",
      "correct_answer": "Maintain a hardcoded whitelist of acceptable algorithms on the server-side.",
      "distractors": [
        {
          "text": "Allowing any algorithm specified in the 'alg' header as long as a valid signature is provided.",
          "misconception": "Targets [validation logic flaw]: This is the vulnerable approach, not the mitigation."
        },
        {
          "text": "Dynamically fetching the list of allowed algorithms from the client.",
          "misconception": "Targets [trust model flaw]: Trusting the client to dictate security parameters is insecure."
        },
        {
          "text": "Using only asymmetric encryption algorithms for signing JWTs.",
          "misconception": "Targets [algorithm type confusion]: While asymmetric algorithms can be used, the mitigation is about controlling *which* algorithms are allowed, not just the type."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The most effective mitigation is to maintain a server-side whitelist of algorithms that are explicitly permitted for signing JWTs. This ensures that even if an attacker tries to specify a different algorithm in the 'alg' header, the server will reject the token if it's not on the approved list.",
        "distractor_analysis": "The first distractor describes the vulnerable state. The second suggests an insecure trust model. The third focuses on algorithm type rather than the explicit control over allowed algorithms.",
        "analogy": null
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "create",
      "prerequisites": [
        "JWT_SIGNATURE_VALIDATION",
        "JWT_HEADER"
      ]
    },
    {
      "question_text": "How does an attacker leverage the 'none' algorithm in an Algorithm Confusion Attack?",
      "correct_answer": "By setting 'alg' to 'none' and submitting a token that the server incorrectly processes as valid without a signature.",
      "distractors": [
        {
          "text": "By using 'none' to indicate that the token should be encrypted instead of signed.",
          "misconception": "Targets [algorithm meaning confusion]: Misinterprets 'none' as a directive for encryption."
        },
        {
          "text": "By replacing a valid signature with the string 'none'.",
          "misconception": "Targets [signature format confusion]: Assumes 'none' is a type of signature."
        },
        {
          "text": "By using 'none' to request a stronger, unlisted algorithm from the server.",
          "misconception": "Targets [algorithm negotiation confusion]: Believes 'none' triggers a negotiation for a better algorithm."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The attacker crafts a JWT with 'alg: none' in the header. If the server's validation logic fails to check that the 'alg' header accurately reflects the absence of a signature (i.e., it doesn't check if a signature is actually present and valid for the declared algorithm), it may accept the token without verification.",
        "distractor_analysis": "The distractors incorrectly describe the function of the 'none' algorithm, associating it with encryption, signature replacement, or algorithm negotiation, rather than its intended meaning of 'no signature'.",
        "analogy": null
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "attack",
      "bloom_level": "apply",
      "prerequisites": [
        "JWT_NONE_ALGORITHM",
        "JWT_SIGNATURE_VALIDATION"
      ]
    },
    {
      "question_text": "What is the primary risk associated with a successful Algorithm Confusion Attack?",
      "correct_answer": "Authentication bypass, allowing unauthorized access to protected resources.",
      "distractors": [
        {
          "text": "Denial of Service (DoS) against the authentication service.",
          "misconception": "Targets [impact confusion]: Focuses on availability impact, not confidentiality/authentication bypass."
        },
        {
          "text": "Data exfiltration from the server's database.",
          "misconception": "Targets [data breach confusion]: While possible post-bypass, it's not the direct risk of the algorithm confusion itself."
        },
        {
          "text": "Elevation of privilege for the attacking user.",
          "misconception": "Targets [privilege confusion]: This is a potential consequence of bypass, but bypass is the immediate risk."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Since the attack tricks the server into accepting a forged or unsigned token as valid, the primary risk is that an attacker can bypass the authentication mechanism entirely. This allows them to impersonate a legitimate user and access resources they are not authorized to see or modify.",
        "distractor_analysis": "The distractors describe other security impacts (DoS, data exfiltration, privilege escalation) that might follow an authentication bypass, but the direct and immediate risk of the attack itself is the bypass.",
        "analogy": null
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "JWT_SECURITY",
        "AUTHENTICATION_BYPASS"
      ]
    },
    {
      "question_text": "Which type of JWT signature algorithm is MOST susceptible to confusion attacks if not validated properly, especially when the 'none' algorithm is involved?",
      "correct_answer": "HMAC (e.g., HS256) algorithms, where the same secret key is used for signing and verification.",
      "distractors": [
        {
          "text": "RSA (e.g., RS256) algorithms, which use separate public and private keys.",
          "misconception": "Targets [asymmetric vs. symmetric confusion]: Assumes asymmetric keys inherently prevent this type of confusion, overlooking header validation."
        },
        {
          "text": "Elliptic Curve Cryptography (ECC) algorithms (e.g., ES256).",
          "misconception": "Targets [ECC specific confusion]: Believes ECC algorithms have unique protections against header manipulation."
        },
        {
          "text": "Password-Based Key Derivation Functions (PBKDFs).",
          "misconception": "Targets [cryptographic primitive confusion]: Confuses key derivation functions with direct signing algorithms."
        }
      ],
      "detailed_explanation": {
        "core_logic": "HMAC algorithms like HS256 use a shared secret. If a server incorrectly accepts 'alg: none' while still having a valid HS256 signature, it bypasses the need for the secret key entirely. While RSA/ECC also rely on header validation, the simplicity of shared secrets in HMAC can sometimes lead to less rigorous checks if not implemented carefully.",
        "distractor_analysis": "The distractors incorrectly suggest that asymmetric algorithms (RSA, ECC) are inherently immune or that PBKDFs are directly involved in JWT signing in a way that prevents this attack, missing the core issue of header validation regardless of the algorithm type.",
        "analogy": null
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "JWT_HS256",
        "JWT_RS256",
        "JWT_NONE_ALGORITHM"
      ]
    },
    {
      "question_text": "What is the role of the JSON Web Key (JWK) Set URL ('jku') in relation to Algorithm Confusion Attacks?",
      "correct_answer": "Attackers might manipulate the 'jku' header to point to a malicious JWK Set containing a key that can forge signatures for unexpected algorithms.",
      "distractors": [
        {
          "text": "The 'jku' header is used to specify the algorithm used for signing.",
          "misconception": "Targets [header field confusion]: Incorrectly assigns the role of algorithm specification to the JWK Set URL."
        },
        {
          "text": "A valid 'jku' URL guarantees the security of the JWT signature.",
          "misconception": "Targets [security assumption flaw]: Assumes fetching keys from a URL automatically secures the signature."
        },
        {
          "text": "The 'jku' header is only relevant for encrypted JWTs, not signed ones.",
          "misconception": "Targets [encryption vs. signing confusion]: Incorrectly separates the relevance of JWK Sets based on signing vs. encryption."
        }
      ],
      "detailed_explanation": {
        "core_logic": "While the 'alg' header dictates the algorithm, the 'jku' header specifies a URL from which to fetch the public key (in a JWK Set) needed for verification. An attacker might manipulate 'jku' to point to a server they control, providing a JWK Set with a key that can forge signatures for algorithms the server might incorrectly accept.",
        "distractor_analysis": "The distractors misrepresent the function of 'jku', confusing it with algorithm specification, assuming it guarantees security, or incorrectly limiting its use to encrypted tokens.",
        "analogy": null
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "JWT_JKU",
        "JWT_JWK",
        "JWT_SIGNATURE_VALIDATION"
      ]
    },
    {
      "question_text": "Which NIST Special Publication provides guidance relevant to securing web applications and session management, indirectly addressing vulnerabilities like Algorithm Confusion Attacks?",
      "correct_answer": "NIST SP 800-53 (Security and Privacy Controls for Information Systems and Organizations)",
      "distractors": [
        {
          "text": "NIST SP 800-171 (Protecting Controlled Unclassified Information in Nonfederal Systems)",
          "misconception": "Targets [standard scope confusion]: Confuses general federal system security controls with specific application security guidance."
        },
        {
          "text": "NIST SP 1800-16 (Securing Stored Data)",
          "misconception": "Targets [data security confusion]: Focuses on data storage security, not session management or JWT validation."
        },
        {
          "text": "NIST SP 500-292 (Cloud Computing Reference Architecture)",
          "misconception": "Targets [architecture confusion]: Relates to cloud infrastructure, not specific web application JWT security."
        }
      ],
      "detailed_explanation": {
        "core_logic": "NIST SP 800-53 provides a comprehensive catalog of security controls, including those for access control (AC), identification and authentication (IA), and system and communications protection (SC), which are directly applicable to securing JWT handling and preventing authentication bypass vulnerabilities like Algorithm Confusion Attacks.",
        "distractor_analysis": "The distractors cite other relevant NIST publications but ones that focus on different domains (CUI protection, data storage, cloud architecture) rather than the broad security controls applicable to web application session management.",
        "analogy": null
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "NIST_SP_800_53",
        "WEB_APP_SECURITY_BASICS"
      ]
    },
    {
      "question_text": "In the context of JWTs, what is the difference between signing and encryption?",
      "correct_answer": "Signing ensures integrity and authenticity using a secret or private key, while encryption ensures confidentiality using a secret or public key.",
      "distractors": [
        {
          "text": "Signing uses public keys to encrypt data, while encryption uses private keys to sign data.",
          "misconception": "Targets [key usage confusion]: Reverses the roles of public and private keys for signing and encryption."
        },
        {
          "text": "Signing is a one-way process, while encryption is always reversible.",
          "misconception": "Targets [process reversibility confusion]: Overgeneralizes encryption and misunderstands the purpose of signing."
        },
        {
          "text": "Signing provides confidentiality, while encryption provides integrity.",
          "misconception": "Targets [security property confusion]: Swaps the primary security goals of signing and encryption."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Signing (e.g., using HS256 or RS256) uses a secret or private key to create a signature, proving the message's integrity and sender's authenticity. Encryption (e.g., using JWE) uses a secret or public key to make the message content unreadable to unauthorized parties, ensuring confidentiality.",
        "distractor_analysis": "The distractors incorrectly assign key usage, confuse reversibility, or swap the core security properties (confidentiality vs. integrity) that signing and encryption provide.",
        "analogy": null
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "CRYPTO_BASICS",
        "JWT_SIGNATURES",
        "JWT_ENCRYPTION"
      ]
    },
    {
      "question_text": "An attacker successfully performs an Algorithm Confusion Attack by setting 'alg' to 'none' and bypassing authentication. What is the MOST IMMEDIATE next step a security professional should take?",
      "correct_answer": "Immediately revoke the attacker's session and investigate the server-side JWT validation logic.",
      "distractors": [
        {
          "text": "Update the client-side application to use stronger encryption.",
          "misconception": "Targets [remediation scope confusion]: Focuses on client-side fixes when the vulnerability is server-side."
        },
        {
          "text": "Block the attacker's IP address and monitor network traffic.",
          "misconception": "Targets [incident response prioritization confusion]: While useful, investigation of the root cause is more critical."
        },
        {
          "text": "Notify users that their data may have been compromised.",
          "misconception": "Targets [communication timing confusion]: Premature notification without understanding the extent of compromise can cause panic."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The immediate priority after detecting an authentication bypass is to contain the breach by revoking the compromised session. Simultaneously, a thorough investigation into the server-side code responsible for JWT validation is crucial to identify and fix the root cause (improper 'alg' header validation) preventing recurrence.",
        "distractor_analysis": "The distractors suggest actions that are either misdirected (client-side fix for server vulnerability), secondary (IP blocking), or premature (user notification) compared to the immediate need for containment and root cause analysis.",
        "analogy": null
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "scenario",
      "bloom_level": "evaluate",
      "prerequisites": [
        "JWT_SIGNATURE_VALIDATION",
        "INCIDENT_RESPONSE"
      ]
    },
    {
      "question_text": "Which of the following best describes the relationship between JWTs and Algorithm Confusion Attacks?",
      "correct_answer": "Algorithm Confusion Attacks exploit weaknesses in how servers validate the 'alg' header of JWTs, often allowing unsigned tokens to be accepted.",
      "distractors": [
        {
          "text": "JWTs inherently use weak algorithms, making them prone to these attacks.",
          "misconception": "Targets [inherent weakness confusion]: Assumes JWTs themselves are weak, rather than their implementation."
        },
        {
          "text": "Algorithm Confusion Attacks are a type of SQL injection targeting JWT databases.",
          "misconception": "Targets [attack vector confusion]: Misidentifies the attack type and target (SQL injection vs. JWT validation). "
        },
        {
          "text": "JWTs are only vulnerable if they are not encrypted, making signing irrelevant.",
          "misconception": "Targets [signing vs. encryption confusion]: Incorrectly dismisses the importance of signing and its validation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "JWTs are a standard for securely transmitting information between parties as a JSON object. Algorithm Confusion Attacks target the implementation of JWT validation on the server-side, specifically the handling of the 'alg' header, which dictates the signing algorithm. Flaws here can allow attackers to bypass signature verification.",
        "distractor_analysis": "The distractors incorrectly attribute the vulnerability to inherent weaknesses in JWTs, misclassify the attack as SQL injection, or wrongly dismiss the role of signing in JWT security.",
        "analogy": null
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "JWT_BASICS",
        "JWT_SIGNATURE_VALIDATION"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Algorithm Confusion Attack (alg: none) Penetration Testing And Ethical Hacking best practices",
    "latency_ms": 34730.64
  },
  "timestamp": "2026-01-18T14:52:55.373899"
}