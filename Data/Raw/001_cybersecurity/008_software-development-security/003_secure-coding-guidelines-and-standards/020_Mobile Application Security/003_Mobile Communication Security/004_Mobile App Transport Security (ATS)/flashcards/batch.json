{
  "topic_title": "Mobile App Transport Security (ATS)",
  "category": "Software Development Security - Secure Coding Guidelines and Standards",
  "flashcards": [
    {
      "question_text": "What is the primary security goal of App Transport Security (ATS) introduced in iOS 9?",
      "correct_answer": "To enforce the use of HTTPS for all network connections made by an app.",
      "distractors": [
        {
          "text": "To mandate the use of specific encryption algorithms like AES-256.",
          "misconception": "Targets [scope confusion]: Confuses ATS's primary goal of secure transport with specific encryption cipher requirements."
        },
        {
          "text": "To ensure all network traffic is routed through a VPN.",
          "misconception": "Targets [misapplication of security]: Incorrectly assumes ATS enforces network routing rather than connection security."
        },
        {
          "text": "To require developers to implement their own custom TLS validation.",
          "misconception": "Targets [misunderstanding of default behavior]: Assumes ATS requires custom implementation rather than enforcing OS-level defaults."
        }
      ],
      "detailed_explanation": {
        "core_logic": "ATS enforces secure network communication by default, requiring HTTPS and strong TLS configurations because it aims to protect data confidentiality and integrity over untrusted networks.",
        "distractor_analysis": "The distractors incorrectly focus on specific algorithms, network routing, or custom implementations, missing ATS's core function of enforcing secure transport protocols like HTTPS.",
        "analogy": "Think of ATS as a security guard at the entrance of a building, ensuring everyone uses the designated secure path (HTTPS) to enter, rather than dictating what they carry inside (specific algorithms) or where they go afterwards (VPN)."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "HTTPS_BASICS",
        "TLS_BASICS"
      ]
    },
    {
      "question_text": "Which of the following is a minimum security requirement for connections enforced by iOS App Transport Security (ATS)?",
      "correct_answer": "TLS version 1.2 or greater.",
      "distractors": [
        {
          "text": "Data encryption using only AES-128.",
          "misconception": "Targets [algorithm specificity]: Incorrectly limits encryption to only AES-128, ignoring AES-256 as also acceptable."
        },
        {
          "text": "Certificate signing with RSA keys of 1024 bits or greater.",
          "misconception": "Targets [key length requirement]: Uses an outdated or insufficient RSA key length, as ATS requires 2048 bits or greater."
        },
        {
          "text": "Support for perfect forward secrecy (PFS) via Diffie-Hellman (DH) key exchange.",
          "misconception": "Targets [key exchange mechanism confusion]: Mentions DH but misses the specific requirement for ECDHE (Elliptic Curve Diffie-Hellman Ephemeral)."
        }
      ],
      "detailed_explanation": {
        "core_logic": "ATS mandates modern security standards to protect data in transit, therefore requiring TLS 1.2 or higher ensures robust encryption and secure communication protocols are used.",
        "distractor_analysis": "Distractors present incorrect or incomplete requirements, such as limiting encryption to AES-128, specifying a weaker RSA key length, or misidentifying the required PFS key exchange mechanism.",
        "analogy": "ATS sets a minimum standard for secure communication channels, like requiring a strong, modern lock (TLS 1.2+) on a door, rather than a weaker, older lock or a specific type of handle."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "ATS_MIN_REQUIREMENTS",
        "TLS_VERSIONS"
      ]
    },
    {
      "question_text": "How does App Transport Security (ATS) perform default server trust evaluation?",
      "correct_answer": "By validating the server's X.509 certificate against criteria like expiration, DNS name match, and trusted Certificate Authority (CA).",
      "distractors": [
        {
          "text": "By checking if the server's IP address is listed on a public blacklist.",
          "misconception": "Targets [validation mechanism confusion]: Assumes IP blacklisting is part of certificate trust evaluation, which is incorrect."
        },
        {
          "text": "By verifying the server's uptime and response time.",
          "misconception": "Targets [performance vs. security confusion]: Confuses operational metrics with security-related certificate validation."
        },
        {
          "text": "By requiring the server to pass a CAPTCHA challenge.",
          "misconception": "Targets [authentication method confusion]: Applies a human-verification method to a machine-to-machine trust process."
        }
      ],
      "detailed_explanation": {
        "core_logic": "ATS validates server identity through its X.509 certificate, ensuring it's not expired, matches the requested domain, and is issued by a trusted Certificate Authority (CA) because this process confirms the server's legitimacy.",
        "distractor_analysis": "The distractors propose irrelevant or incorrect validation methods, such as IP blacklisting, performance metrics, or CAPTCHA challenges, instead of the standard certificate-based trust evaluation.",
        "analogy": "It's like checking someone's ID card: ATS verifies the certificate (ID) to ensure it's valid (not expired), belongs to the right person (DNS name match), and was issued by a recognized authority (trusted CA)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "X509_CERTIFICATES",
        "CERTIFICATE_AUTHORITY"
      ]
    },
    {
      "question_text": "What is the role of the operating system's Trust Store in relation to ATS?",
      "correct_answer": "It contains a list of trusted Certificate Authorities (CAs) whose root certificates are used by ATS to validate server certificates.",
      "distractors": [
        {
          "text": "It stores the app's own private keys for secure communication.",
          "misconception": "Targets [storage location confusion]: Incorrectly assigns the function of storing private keys to the OS Trust Store."
        },
        {
          "text": "It logs all network traffic for auditing purposes.",
          "misconception": "Targets [functionality confusion]: Attributes network traffic logging to the Trust Store, which is for CA trust anchors."
        },
        {
          "text": "It dictates the minimum TLS version the app must use.",
          "misconception": "Targets [scope confusion]: Assigns the role of enforcing TLS versions to the Trust Store, rather than ATS itself."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The Trust Store acts as a repository of trusted root CA certificates, which ATS consults to verify the authenticity of server certificates because this chain of trust is fundamental to secure TLS connections.",
        "distractor_analysis": "Distractors misrepresent the Trust Store's purpose by associating it with private key storage, traffic logging, or TLS version enforcement, rather than its actual role in managing trusted CAs.",
        "analogy": "The Trust Store is like a directory of official government seals. When ATS sees a document (server certificate) with a seal, it checks the directory to see if the seal is from a recognized government (trusted CA)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CERTIFICATE_AUTHORITY",
        "TRUST_STORE_CONCEPT"
      ]
    },
    {
      "question_text": "Which of the following scenarios would typically require an app developer to configure exceptions to ATS default settings?",
      "correct_answer": "Connecting to an internal enterprise server that uses a self-signed certificate.",
      "distractors": [
        {
          "text": "Communicating with a public API that uses a standard, publicly trusted certificate.",
          "misconception": "Targets [understanding of defaults]: Assumes exceptions are needed for standard, secure connections."
        },
        {
          "text": "Using a third-party SDK that communicates over HTTPS with a valid certificate.",
          "misconception": "Targets [SDK integration misunderstanding]: Believes SDKs inherently require ATS exceptions even if they follow best practices."
        },
        {
          "text": "Implementing a basic HTTP connection for non-sensitive data.",
          "misconception": "Targets [ATS enforcement misunderstanding]: Assumes ATS can be bypassed for HTTP, when it primarily enforces HTTPS."
        }
      ],
      "detailed_explanation": {
        "core_logic": "ATS enforces secure connections by default, so exceptions are needed when connecting to servers with non-standard or untrusted certificates, such as self-signed ones, because the OS Trust Store wouldn't recognize them.",
        "distractor_analysis": "The distractors describe scenarios where ATS defaults should work fine, failing to identify situations where a custom trust anchor or configuration is genuinely necessary due to non-standard certificates.",
        "analogy": "If ATS is a bouncer at a club requiring valid IDs (trusted certificates), you'd need to make a special arrangement (exception) only if someone has an unusual but legitimate ID, like an employee badge for an internal event, not for regular patrons."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "ATS_EXCEPTIONS",
        "SELF_SIGNED_CERTIFICATES"
      ]
    },
    {
      "question_text": "What is the purpose of Perfect Forward Secrecy (PFS) in the context of ATS requirements?",
      "correct_answer": "To ensure that if a server's long-term private key is compromised, past communication sessions remain secure.",
      "distractors": [
        {
          "text": "To guarantee that the server's identity is always authenticated.",
          "misconception": "Targets [confusion with authentication]: Mixes the concept of PFS with server authentication, which is handled by certificates."
        },
        {
          "text": "To encrypt data using the strongest available symmetric cipher.",
          "misconception": "Targets [confusion with encryption strength]: Relates PFS to the choice of symmetric cipher, rather than session key security."
        },
        {
          "text": "To prevent Man-in-the-Middle (MitM) attacks during the initial TLS handshake.",
          "misconception": "Targets [scope confusion]: While related to secure handshakes, PFS specifically protects past sessions, not just the initial handshake."
        }
      ],
      "detailed_explanation": {
        "core_logic": "PFS, typically achieved via ECDHE, ensures that each session uses unique, ephemeral keys. Therefore, if a server's long-term private key is compromised, past session data remains encrypted because it cannot be decrypted with the compromised key.",
        "distractor_analysis": "Distractors incorrectly associate PFS with server authentication, symmetric cipher strength, or solely preventing initial handshake attacks, missing its core benefit of protecting past session data from future key compromises.",
        "analogy": "PFS is like using a different, temporary key for each safe deposit box you open each day. Even if someone steals your master key (long-term private key), they can't use it to open boxes you used on previous days."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "analyze",
      "prerequisites": [
        "PFS_CONCEPT",
        "ECDHE_KEY_EXCHANGE"
      ]
    },
    {
      "question_text": "According to OWASP MASTG, what is a key consideration when testing network communication security in iOS apps?",
      "correct_answer": "Verifying that the app properly handles certificate validation and does not trust all certificates.",
      "distractors": [
        {
          "text": "Ensuring the app uses the latest Swift version for network calls.",
          "misconception": "Targets [language version vs. security]: Confuses programming language version with network communication security practices."
        },
        {
          "text": "Checking if the app supports older iOS versions like iOS 7.",
          "misconception": "Targets [backward compatibility vs. security]: Prioritizes support for outdated systems over modern security standards like ATS."
        },
        {
          "text": "Confirming that the app's UI is responsive during network requests.",
          "misconception": "Targets [performance vs. security]: Focuses on user interface responsiveness rather than the security of the network connection itself."
        }
      ],
      "detailed_explanation": {
        "core_logic": "OWASP MASTG emphasizes validating certificate trust because insecurely trusting certificates can lead to Man-in-the-Middle attacks, undermining the confidentiality and integrity of app communications.",
        "distractor_analysis": "The distractors focus on irrelevant aspects like programming language versions, backward compatibility with insecure systems, or UI performance, rather than the critical security practice of certificate validation.",
        "analogy": "Testing network security is like checking if a security guard properly verifies IDs at a building entrance. The OWASP focus is on ensuring the guard doesn't let just anyone in (doesn't trust all certificates)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "OWASP_MASTG",
        "CERTIFICATE_VALIDATION"
      ]
    },
    {
      "question_text": "What is the primary risk if an iOS app disables ATS or configures overly permissive exceptions?",
      "correct_answer": "The app becomes vulnerable to Man-in-the-Middle (MitM) attacks and eavesdropping.",
      "distractors": [
        {
          "text": "The app may experience increased latency due to stricter encryption.",
          "misconception": "Targets [performance vs. security confusion]: Assumes stricter security inherently causes latency, which is not the primary risk of disabling ATS."
        },
        {
          "text": "The app might be rejected from the Apple App Store.",
          "misconception": "Targets [policy misunderstanding]: While possible for severe violations, the direct security risk is the primary concern."
        },
        {
          "text": "The app's data storage on the device becomes less secure.",
          "misconception": "Targets [scope confusion]: Confuses network transport security with local data storage security."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Disabling ATS or using weak exceptions bypasses crucial security checks, allowing attackers to intercept and potentially modify data in transit because the connection is no longer guaranteed to be confidential and integrity-protected.",
        "distractor_analysis": "The distractors focus on secondary concerns like app store policy or data storage, or misattribute performance issues, rather than the direct and severe security vulnerability of MitM attacks and eavesdropping.",
        "analogy": "Disabling ATS is like leaving your house unlocked. The main risk isn't that your mail might be slightly delayed (latency) or that the postman might judge your house (app store rejection), but that someone could easily enter and steal your belongings (MitM/eavesdropping)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "MITM_ATTACKS",
        "ATS_CONFIGURATION"
      ]
    },
    {
      "question_text": "Which RFC provides updated recommendations for the secure use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS), relevant to ATS?",
      "correct_answer": "RFC 9325",
      "distractors": [
        {
          "text": "RFC 7525",
          "misconception": "Targets [outdated standard confusion]: RFC 7525 is an earlier version that RFC 9325 obsoletes."
        },
        {
          "text": "RFC 5280",
          "misconception": "Targets [related but different standard]: RFC 5280 defines certificate formats but RFC 9325 provides current TLS usage recommendations."
        },
        {
          "text": "RFC 2119",
          "misconception": "Targets [miscellaneous RFC confusion]: RFC 2119 defines keywords like MUST, SHOULD, MAY, not TLS recommendations."
        }
      ],
      "detailed_explanation": {
        "core_logic": "RFC 9325 updates industry best practices for TLS/DTLS security, including recommendations on cipher suites and configurations, which are directly relevant to the security requirements enforced by ATS because it aims to ensure modern, secure communication.",
        "distractor_analysis": "Distractors cite other relevant RFCs but misattribute their purpose or relevance. RFC 7525 is obsolete, RFC 5280 deals with certificates, and RFC 2119 defines keyword usage.",
        "analogy": "If ATS is a set of rules for secure communication, RFC 9325 is the latest, updated rulebook, replacing older versions like RFC 7525, and providing specific guidance on how to follow those rules securely."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "TLS_STANDARDS",
        "RFC_INDEX"
      ]
    },
    {
      "question_text": "What is the significance of 'Server Trust Evaluation' within ATS?",
      "correct_answer": "It ensures the app is communicating with the legitimate server it intends to connect to, not an imposter.",
      "distractors": [
        {
          "text": "It verifies that the server is geographically located in the user's region.",
          "misconception": "Targets [geographical relevance confusion]: Incorrectly links trust evaluation to server location rather than identity."
        },
        {
          "text": "It checks if the server has passed performance benchmarks.",
          "misconception": "Targets [performance vs. identity confusion]: Confuses server performance metrics with identity verification."
        },
        {
          "text": "It confirms that the server's operating system is up-to-date.",
          "misconception": "Targets [scope confusion]: Relates trust evaluation to the server's OS patch level, not its cryptographic identity."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Server Trust Evaluation is critical because it uses cryptographic methods (certificates) to confirm the server's identity, preventing attackers from impersonating legitimate servers and intercepting communications.",
        "distractor_analysis": "The distractors propose irrelevant checks like geographical location, performance benchmarks, or OS version, failing to grasp that server trust evaluation is fundamentally about verifying the server's cryptographic identity.",
        "analogy": "Server Trust Evaluation is like a bouncer checking your ID to make sure you are who you say you are, not checking where you live or how fast you can run."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SERVER_TRUST_EVALUATION",
        "IDENTITY_VERIFICATION"
      ]
    },
    {
      "question_text": "When might an iOS app need to extend trust to custom Certificate Authorities (CAs) beyond the system default?",
      "correct_answer": "When connecting to an internal company server that uses an internally issued CA.",
      "distractors": [
        {
          "text": "When communicating with a public website that uses a standard EV certificate.",
          "misconception": "Targets [understanding of standard certificates]: Assumes custom CA trust is needed for widely recognized, trusted certificates."
        },
        {
          "text": "When the app needs to send data over plain HTTP.",
          "misconception": "Targets [protocol confusion]: Incorrectly links custom CA trust to the use of insecure HTTP."
        },
        {
          "text": "When the app is running on a jailbroken device.",
          "misconception": "Targets [device state vs. CA trust]: Confuses device security status with the need for custom CA trust anchors."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Apps may need to trust custom CAs when connecting to internal resources that use certificates issued by private CAs not present in the OS Trust Store, because the system wouldn't inherently trust them otherwise.",
        "distractor_analysis": "The distractors suggest scenarios where custom CA trust is unnecessary or irrelevant, such as using standard certificates, insecure protocols, or considering device state rather than the origin of the certificate.",
        "analogy": "Extending trust to custom CAs is like adding a specific, trusted vendor's logo to your company's approved supplier list. You do this for vendors your company specifically works with, not for every general supplier in the phone book."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "CUSTOM_CA",
        "ENTERPRISE_NETWORKING"
      ]
    },
    {
      "question_text": "What is the primary function of the 'URL Loading System' in iOS concerning ATS?",
      "correct_answer": "It is the system framework that ATS enforces its security checks upon for network connections.",
      "distractors": [
        {
          "text": "It is responsible for encrypting all data before it leaves the device.",
          "misconception": "Targets [scope confusion]: Attributes encryption responsibility solely to the URL Loading System, rather than TLS/ATS."
        },
        {
          "text": "It manages the device's network interface card (NIC) settings.",
          "misconception": "Targets [hardware vs. software confusion]: Confuses a high-level network API with low-level hardware management."
        },
        {
          "text": "It provides a secure tunnel for all background data transfers.",
          "misconception": "Targets [tunneling vs. connection security confusion]: Misinterprets ATS's role as creating VPN-like tunnels."
        }
      ],
      "detailed_explanation": {
        "core_logic": "ATS applies its security policies to connections made via the URL Loading System (like URLSession) because this is the standard framework iOS apps use for network communication, ensuring these connections meet security requirements.",
        "distractor_analysis": "The distractors misrepresent the URL Loading System's role, attributing encryption, hardware management, or secure tunneling functions to it, rather than its role as the target of ATS security enforcement.",
        "analogy": "The URL Loading System is like the postal service's sorting facility. ATS is the set of rules that dictate what kind of mail (secure connections) can go through that facility, ensuring everything is properly addressed and sealed."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "URL_LOADING_SYSTEM",
        "ATS_ENFORCEMENT"
      ]
    },
    {
      "question_text": "How does ATS ensure data integrity for network communications?",
      "correct_answer": "By enforcing the use of TLS, which includes mechanisms to detect data tampering during transmission.",
      "distractors": [
        {
          "text": "By encrypting data using symmetric keys that are changed every second.",
          "misconception": "Targets [integrity vs. confidentiality confusion]: Focuses on encryption frequency rather than integrity checks."
        },
        {
          "text": "By requiring all data packets to be digitally signed by the app.",
          "misconception": "Targets [signing mechanism confusion]: Suggests app-level signing for integrity, rather than TLS's built-in mechanisms."
        },
        {
          "text": "By using a checksum algorithm on the entire data payload before sending.",
          "misconception": "Targets [specific algorithm confusion]: Proposes a generic checksum, while TLS uses more robust integrity checks like Message Authentication Codes (MACs)."
        }
      ],
      "detailed_explanation": {
        "core_logic": "ATS ensures data integrity by mandating TLS, which employs Message Authentication Codes (MACs) or similar cryptographic techniques to detect any modifications to data during transit, because integrity is a core security property alongside confidentiality.",
        "distractor_analysis": "Distractors incorrectly focus on encryption timing, app-level signing, or generic checksums, missing the fact that TLS, enforced by ATS, provides integrity through specific cryptographic mechanisms within the protocol.",
        "analogy": "Ensuring data integrity is like using a tamper-evident seal on a package. ATS ensures TLS is used, which applies such seals (MACs) to data, so any attempt to open or alter the package (data) during delivery is immediately detectable."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "analyze",
      "prerequisites": [
        "DATA_INTEGRITY",
        "TLS_INTEGRITY_CHECKS"
      ]
    },
    {
      "question_text": "What is the role of Certificate Transparency (CT) logs in relation to ATS and certificate validation?",
      "correct_answer": "CT logs provide a public, auditable record of issued certificates, helping to detect mis-issued or fraudulent certificates.",
      "distractors": [
        {
          "text": "CT logs are used by ATS to store the app's private keys securely.",
          "misconception": "Targets [storage location confusion]: Incorrectly assigns private key storage to CT logs."
        },
        {
          "text": "CT logs encrypt the data transmitted between the app and the server.",
          "misconception": "Targets [encryption vs. logging confusion]: Confuses the purpose of logging with data encryption."
        },
        {
          "text": "CT logs are automatically checked by ATS to ensure the server's IP address is valid.",
          "misconception": "Targets [validation mechanism confusion]: Misunderstands CT logs as a tool for IP validation rather than certificate issuance auditing."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Certificate Transparency (CT) logs provide a public record of certificate issuance, allowing for auditing and detection of rogue certificates because this transparency enhances the overall trust in the Public Key Infrastructure (PKI) that ATS relies upon.",
        "distractor_analysis": "Distractors incorrectly describe CT logs as storage for private keys, encryption mechanisms, or IP validation tools, failing to recognize their function in auditing certificate issuance for security and trust.",
        "analogy": "Certificate Transparency logs are like a public registry of all official ID cards issued. ATS can consult this registry (or rely on systems that do) to help ensure the ID card presented by a server is legitimate and wasn't fraudulently issued."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "evaluate",
      "prerequisites": [
        "CERTIFICATE_TRANSPARENCY",
        "PKI_SECURITY"
      ]
    },
    {
      "question_text": "Which of the following is NOT a minimum security requirement for connections enforced by iOS App Transport Security (ATS)?",
      "correct_answer": "The certificate must be signed with an ECDSA key (256 bits or greater).",
      "distractors": [
        {
          "text": "The certificate must be signed with an RSA key (2048 bits or greater).",
          "misconception": "Targets [algorithm confusion]: This IS a requirement, making it a plausible distractor for someone unsure of the exact list."
        },
        {
          "text": "The certificate's fingerprint must use SHA-256 or greater.",
          "misconception": "Targets [algorithm confusion]: This IS a requirement."
        },
        {
          "text": "The link must support perfect forward secrecy (PFS) through ECDHE key exchange.",
          "misconception": "Targets [algorithm confusion]: This IS a requirement."
        }
      ],
      "detailed_explanation": {
        "core_logic": "ATS requires certificates signed with RSA (2048+ bits) or ECC (256+ bits), TLS 1.2+, SHA-256+, and ECDHE for PFS. While ECDSA is a type of ECC, ATS specifically mentions ECC keys generally, and the distractors listed are actual requirements.",
        "distractor_analysis": "The correct answer presents a plausible but incorrect requirement. The other options are actual minimum security requirements enforced by ATS, making them strong distractors for those who haven't memorized the full list.",
        "analogy": "If ATS requires a valid passport (RSA/ECC cert), a valid visa (TLS 1.2+), and a recent photo (SHA-256+), and a secure travel method (ECDHE), the incorrect option is like saying you need a specific type of airline ticket (ECDSA) when any valid airline ticket is acceptable."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "ATS_MIN_REQUIREMENTS",
        "CRYPTOGRAPHIC_ALGORITHMS"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Mobile App Transport Security (ATS) Software Development Security best practices",
    "latency_ms": 24576.132999999998
  },
  "timestamp": "2026-01-18T11:02:36.019710"
}