{
  "topic_title": "Server-Side Request Forgery (SSRF) Prevention",
  "category": "Software Development Security - Secure Coding Guidelines and Standards",
  "flashcards": [
    {
      "question_text": "What is the primary risk associated with Server-Side Request Forgery (SSRF) in web applications?",
      "correct_answer": "An attacker can coerce the server to make unintended requests to internal or external services, potentially bypassing security controls.",
      "distractors": [
        {
          "text": "The server's client-side code is directly manipulated by the attacker.",
          "misconception": "Targets [client-side vs server-side confusion]: Students confuse where the malicious request originates."
        },
        {
          "text": "Sensitive data is exfiltrated through direct database queries.",
          "misconception": "Targets [attack vector confusion]: Students assume direct database access is the only data exfiltration method."
        },
        {
          "text": "The application's user interface is defaced with malicious content.",
          "misconception": "Targets [impact confusion]: Students confuse SSRF with Cross-Site Scripting (XSS) or defacement attacks."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SSRF occurs because the server trusts user-supplied URLs, allowing attackers to trick it into accessing internal resources or bypassing firewalls, thus enabling unauthorized actions.",
        "distractor_analysis": "The first distractor incorrectly places the attack on the client-side. The second assumes direct database access, which isn't the primary SSRF mechanism. The third confuses SSRF with UI-based attacks like defacement.",
        "analogy": "Imagine asking a trusted assistant to fetch a document from a restricted archive using a provided address. SSRF is when the attacker tricks the assistant into fetching sensitive internal documents instead of the intended public one."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "NETWORK_SECURITY_BASICS",
        "WEB_APP_ATTACKS"
      ]
    },
    {
      "question_text": "Which of the following is a common modern development concept that increases the risk of SSRF vulnerabilities?",
      "correct_answer": "Webhooks that process external resource URLs provided by users.",
      "distractors": [
        {
          "text": "Implementing strict input validation on all user-submitted data.",
          "misconception": "Targets [prevention vs cause confusion]: Students confuse a mitigation strategy with a risk factor."
        },
        {
          "text": "Using stateless authentication mechanisms like JWT.",
          "misconception": "Targets [unrelated concept confusion]: Students associate unrelated security concepts with SSRF risk."
        },
        {
          "text": "Deploying applications within isolated containerized environments.",
          "misconception": "Targets [mitigation vs cause confusion]: Students confuse a security control with a vulnerability cause."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Modern development practices like webhooks encourage fetching external resources based on user input, making SSRF more common because the server processes potentially untrusted URLs.",
        "distractor_analysis": "The first distractor describes a prevention method, not a cause. The second discusses authentication, which is not directly related to SSRF's core mechanism. The third describes a deployment strategy that can mitigate, not cause, SSRF.",
        "analogy": "It's like a chef asking a kitchen assistant to fetch an ingredient from a supplier's address. If the chef doesn't verify the address, the assistant might be tricked into fetching something harmful or from a dangerous location."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "WEB_APP_ATTACKS",
        "DEVELOPMENT_TRENDS"
      ]
    },
    {
      "question_text": "According to OWASP, what is a key characteristic of Blind SSRF?",
      "correct_answer": "The attacker has no direct feedback on whether the crafted request was successful.",
      "distractors": [
        {
          "text": "The server responds with detailed error messages about the failed request.",
          "misconception": "Targets [feedback mechanism confusion]: Students confuse blind SSRF with standard SSRF where feedback is often available."
        },
        {
          "text": "The vulnerability is only exploitable through local file inclusion.",
          "misconception": "Targets [attack vector limitation]: Students incorrectly assume blind SSRF is limited to specific attack types."
        },
        {
          "text": "The attacker must have administrative privileges on the target server.",
          "misconception": "Targets [privilege requirement confusion]: Students overestimate the prerequisites for exploiting blind SSRF."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Blind SSRF is harder to detect because the application does not return the server's response to the attacker, requiring creative methods to infer success or failure.",
        "distractor_analysis": "The first distractor describes the opposite of blind SSRF. The second incorrectly limits the attack vector. The third imposes an unnecessary privilege requirement.",
        "analogy": "It's like sending a secret message to someone and not knowing if they received it or what they did with it, making it much harder to confirm if your plan worked."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "WEB_APP_ATTACKS",
        "SSRF_BASICS"
      ]
    },
    {
      "question_text": "Which of the following is a recommended prevention strategy for SSRF, according to OWASP?",
      "correct_answer": "Use an allow-list of permitted destination URLs or IP addresses.",
      "distractors": [
        {
          "text": "Disable all outbound network connections from the server.",
          "misconception": "Targets [overly restrictive solution]: Students propose a solution that is often impractical for legitimate application functions."
        },
        {
          "text": "Rely solely on client-side validation of user-supplied URLs.",
          "misconception": "Targets [client-side vs server-side defense confusion]: Students misunderstand that server-side vulnerabilities require server-side validation."
        },
        {
          "text": "Encrypt all user-supplied URLs before processing them.",
          "misconception": "Targets [inappropriate mitigation]: Students suggest encryption as a solution for URL validation, which doesn't prevent SSRF."
        }
      ],
      "detailed_explanation": {
        "core_logic": "An allow-list approach is effective because it explicitly permits only known-good destinations, thereby preventing the server from connecting to unexpected or malicious internal/external resources.",
        "distractor_analysis": "Disabling all outbound connections is often not feasible. Client-side validation is insufficient for server-side vulnerabilities. Encryption does not validate the destination of a URL.",
        "analogy": "Instead of telling a security guard 'don't let anyone suspicious in,' you give them a list of exactly who is allowed to enter the building. This is much more secure."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "SSRF_PREVENTION",
        "NETWORK_SECURITY_BASICS"
      ]
    },
    {
      "question_text": "Why are modern technologies like cloud providers and Kubernetes particularly susceptible to SSRF attacks?",
      "correct_answer": "They often expose management and control channels over HTTP on predictable, well-known paths accessible internally.",
      "distractors": [
        {
          "text": "Their APIs are exclusively designed for external access, making them easy targets.",
          "misconception": "Targets [access model confusion]: Students misunderstand that these systems often have internal management interfaces."
        },
        {
          "text": "They rely heavily on client-side rendering, which attackers can manipulate.",
          "misconception": "Targets [client-side vs server-side attack vector]: Students confuse client-side rendering with server-side vulnerabilities."
        },
        {
          "text": "Their security models are based on outdated encryption algorithms.",
          "misconception": "Targets [security model confusion]: Students incorrectly attribute SSRF susceptibility to outdated encryption rather than exposed interfaces."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Cloud and container orchestration systems expose internal management interfaces via HTTP, often on predictable addresses like <code>169.254.169.254</code> (AWS metadata), making them prime targets for SSRF attacks seeking sensitive configuration or credentials.",
        "distractor_analysis": "The first distractor incorrectly states these systems are exclusively for external access. The second confuses client-side rendering with server-side exploits. The third wrongly attributes the vulnerability to encryption algorithms.",
        "analogy": "Imagine a building with an internal intercom system for maintenance staff on specific floors. SSRF is like an attacker tricking someone in the building to use that intercom to access restricted areas or get sensitive information."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "CLOUD_SECURITY",
        "CONTAINER_SECURITY",
        "SSRF_BASICS"
      ]
    },
    {
      "question_text": "What is the potential impact of a successful SSRF attack on cloud environments?",
      "correct_answer": "Extraction of sensitive cloud metadata, including potential authentication keys.",
      "distractors": [
        {
          "text": "Direct denial-of-service (DoS) against the cloud provider's infrastructure.",
          "misconception": "Targets [impact scope confusion]: Students confuse SSRF's impact with direct DoS attacks on the provider."
        },
        {
          "text": "Modification of the application's source code hosted in the cloud.",
          "misconception": "Targets [attack type confusion]: Students confuse SSRF with code injection or RCE vulnerabilities."
        },
        {
          "text": "Compromise of the user's local machine through browser exploits.",
          "misconception": "Targets [attack origin confusion]: Students confuse server-side attacks with client-side browser exploits."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Cloud environments often expose metadata services (e.g., <code>http://169.254.169.254/</code>) that SSRF can access, potentially revealing credentials or configuration details, which is a significant security risk.",
        "distractor_analysis": "While SSRF can contribute to DoS, direct provider DoS is unlikely. Modifying source code is a different attack vector. Compromising the user's local machine is typically a client-side attack.",
        "analogy": "It's like an attacker tricking a cloud server into asking its own internal 'help desk' for the master keys to the entire data center, rather than just fetching a public document."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "CLOUD_SECURITY",
        "SSRF_BASICS",
        "METADATA_SERVICES"
      ]
    },
    {
      "question_text": "Which OWASP API Security Top 10 category directly addresses Server-Side Request Forgery?",
      "correct_answer": "API7:2023 Server Side Request Forgery",
      "distractors": [
        {
          "text": "API1:2023 Broken Object Level Authorization",
          "misconception": "Targets [category confusion]: Students confuse SSRF with authorization flaws."
        },
        {
          "text": "API3:2023 Broken Authentication",
          "misconception": "Targets [category confusion]: Students confuse SSRF with authentication vulnerabilities."
        },
        {
          "text": "API5:2023 Security Misconfiguration",
          "misconception": "Targets [category overlap confusion]: Students recognize SSRF as a misconfiguration but miss its specific categorization."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The OWASP API Security Top 10 explicitly lists Server-Side Request Forgery as API7:2023, highlighting its prevalence and impact specifically within API security contexts.",
        "distractor_analysis": "The distractors list other OWASP API Security Top 10 categories, testing if the student can correctly identify the specific category for SSRF.",
        "analogy": "It's like asking which chapter in a book is about 'dragons'. While other chapters might mention mythical creatures, one specific chapter is dedicated entirely to dragons."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "OWASP_API_SECURITY",
        "SSRF_BASICS"
      ]
    },
    {
      "question_text": "How can SSRF be used to bypass firewalls or VPNs?",
      "correct_answer": "By tricking the server into making requests to internal network resources that are normally inaccessible from the outside.",
      "distractors": [
        {
          "text": "By exploiting vulnerabilities in the firewall's own software.",
          "misconception": "Targets [attack vector confusion]: Students assume SSRF directly attacks the firewall, rather than using the server as a proxy."
        },
        {
          "text": "By redirecting the user's browser through a malicious proxy server.",
          "misconception": "Targets [client-side vs server-side bypass]: Students confuse server-side bypass with client-side redirection techniques."
        },
        {
          "text": "By injecting malicious code into the VPN client software.",
          "misconception": "Targets [attack vector confusion]: Students confuse SSRF with attacks targeting VPN client software."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SSRF bypasses perimeter defenses because the malicious request originates from the trusted internal server, which the firewall or VPN allows to communicate with internal services.",
        "distractor_analysis": "The first distractor suggests attacking the firewall directly. The second describes a client-side attack. The third involves compromising VPN client software, not exploiting server-side request handling.",
        "analogy": "Imagine a guard dog (firewall) protecting a building. SSRF is like tricking a resident (the server) inside the building to open a door for the attacker, bypassing the guard dog's perimeter."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "NETWORK_SECURITY_BASICS",
        "SSRF_BASICS"
      ]
    },
    {
      "question_text": "What is a crucial step in preventing SSRF when an API must fetch resources from user-supplied URLs?",
      "correct_answer": "Sanitize and validate the user-supplied URL against a strict allow-list of permitted schemes, hosts, and ports.",
      "distractors": [
        {
          "text": "Always use HTTPS for all external resource fetches.",
          "misconception": "Targets [incomplete solution]: Students focus on transport security (HTTPS) rather than destination validation."
        },
        {
          "text": "Implement rate limiting on all API requests that fetch external resources.",
          "misconception": "Targets [mitigation vs validation confusion]: Students confuse rate limiting (a defense against abuse) with validation (preventing the core SSRF flaw)."
        },
        {
          "text": "Encode all user-supplied URLs before passing them to the fetching function.",
          "misconception": "Targets [misapplied technique]: Students believe URL encoding prevents SSRF, which is incorrect; it can sometimes aid exploitation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Strict validation ensures that the server only attempts to fetch resources from explicitly approved locations, preventing it from being tricked into accessing internal services or malicious external sites.",
        "distractor_analysis": "HTTPS is important but doesn't prevent fetching from an internal IP. Rate limiting doesn't stop a single malicious request. URL encoding can sometimes be part of SSRF exploitation, not prevention.",
        "analogy": "When ordering supplies, you don't just accept any address given; you check it against your approved vendor list to ensure the delivery goes to the correct, safe warehouse."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "SSRF_PREVENTION",
        "SECURE_CODING_PRINCIPLES"
      ]
    },
    {
      "question_text": "Consider an API endpoint that accepts a URL to preview a webpage. Which type of SSRF is most likely if the attacker provides a URL pointing to an internal IP address like <code>http://127.0.0.1/admin</code>?",
      "correct_answer": "Standard SSRF, where the server fetches the resource and potentially returns information to the attacker.",
      "distractors": [
        {
          "text": "Blind SSRF, because the attacker cannot directly see the admin page content.",
          "misconception": "Targets [blind vs standard SSRF confusion]: Students incorrectly classify SSRF based on whether the attacker sees the target content directly."
        },
        {
          "text": "Server-Side Includes (SSI) injection, as it involves server-side processing.",
          "misconception": "Targets [vulnerability type confusion]: Students confuse SSRF with Server-Side Includes, which have different mechanisms and impacts."
        },
        {
          "text": "Cross-Site Request Forgery (CSRF), as it involves making requests on behalf of the user.",
          "misconception": "Targets [vulnerability type confusion]: Students confuse SSRF with CSRF, which targets user authentication/session state."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Standard SSRF occurs when the server fetches a URL provided by the client and potentially returns data or status codes related to that fetch, allowing the attacker to probe internal services.",
        "distractor_analysis": "Blind SSRF lacks direct feedback. SSI injection and CSRF are distinct vulnerabilities with different attack vectors and goals.",
        "analogy": "It's like asking a friend to look up a public website for you. If you ask them to look up an internal company website, and they tell you 'I got a response from that internal site,' that's standard SSRF. If they just say 'I tried,' that's blind SSRF."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "SSRF_BASICS",
        "WEB_APP_ATTACKS"
      ]
    },
    {
      "question_text": "What is the primary purpose of input validation in preventing SSRF?",
      "correct_answer": "To ensure that user-supplied URLs conform to expected formats and do not point to unauthorized destinations.",
      "distractors": [
        {
          "text": "To encrypt user-supplied URLs to prevent eavesdropping.",
          "misconception": "Targets [misapplied security control]: Students confuse validation with encryption, which addresses confidentiality, not destination control."
        },
        {
          "text": "To sanitize user input to prevent Cross-Site Scripting (XSS) attacks.",
          "misconception": "Targets [different vulnerability focus]: Students associate input sanitization solely with XSS, overlooking its role in SSRF prevention."
        },
        {
          "text": "To log all user-supplied URLs for auditing purposes.",
          "misconception": "Targets [logging vs prevention confusion]: Students confuse a monitoring activity with a direct prevention mechanism."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Input validation acts as a gatekeeper, verifying that the URL provided by the user is safe and intended for use, thereby preventing the server from making requests to malicious or unintended locations.",
        "distractor_analysis": "Encryption doesn't validate the URL's destination. Sanitization for XSS focuses on script execution, not network requests. Logging is reactive, not preventative.",
        "analogy": "It's like a bouncer checking IDs at a club. They ensure only authorized individuals (valid URLs) get in, preventing unauthorized access (malicious requests)."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SECURE_CODING_PRINCIPLES",
        "INPUT_VALIDATION"
      ]
    },
    {
      "question_text": "When configuring XML parsers to prevent SSRF, what specific configuration is crucial?",
      "correct_answer": "Disable external entity resolution (XXE prevention).",
      "distractors": [
        {
          "text": "Enable DTD (Document Type Definition) processing.",
          "misconception": "Targets [insecure configuration]: Students choose a setting that can actually facilitate XXE, a related vulnerability."
        },
        {
          "text": "Allow external schema validation.",
          "misconception": "Targets [insecure configuration]: External schema validation can also be a vector for XXE/SSRF if not carefully managed."
        },
        {
          "text": "Use the default parser settings without modification.",
          "misconception": "Targets [insecure default assumption]: Students assume default settings are secure, which is often not the case for XML parsers regarding external entities."
        }
      ],
      "detailed_explanation": {
        "core_logic": "External XML entities can reference external URLs, making XML External Entity (XXE) vulnerabilities a common vector for SSRF. Disabling external entity resolution prevents the parser from fetching these external resources.",
        "distractor_analysis": "Enabling DTDs and allowing external schema validation can introduce XXE/SSRF risks. Default settings are often insecure regarding external entity resolution.",
        "analogy": "When reading a book that might reference other books, you tell the librarian not to fetch any 'external references' automatically, to avoid getting potentially dangerous or irrelevant information."
      },
      "code_snippets": [
        {
          "language": "text",
          "code": "<!DOCTYPE foo [ <!ENTITY xxe SYSTEM \"http://external.example.com/resource\"> ]>\n<foo>&xxe;</foo>",
          "context": "explanation"
        }
      ],
      "difficulty": "expert",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "XXE_PREVENTION",
        "XML_SECURITY",
        "SSRF_PREVENTION"
      ],
      "_code_snippets_html": "<div class=\"code-snippet code-explanation\">\n<span class=\"code-label\">Code Example</span>\n<pre><code class=\"language-text\">&lt;!DOCTYPE foo [ &lt;!ENTITY xxe SYSTEM &quot;http://external.example.com/resource&quot;&gt; ]&gt;\n&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</code></pre>\n</div>"
    },
    {
      "question_text": "How can SSRF be used to enumerate internal network services?",
      "correct_answer": "By sending crafted requests to various internal IP addresses and ports, observing the server's responses or lack thereof.",
      "distractors": [
        {
          "text": "By injecting SQL commands to query network device configurations.",
          "misconception": "Targets [vulnerability type confusion]: Students confuse SSRF with SQL Injection, which targets databases."
        },
        {
          "text": "By analyzing client-side JavaScript for network information.",
          "misconception": "Targets [client-side vs server-side analysis]: Students misunderstand that SSRF leverages server-side capabilities for enumeration."
        },
        {
          "text": "By exploiting vulnerabilities in the DNS resolution process.",
          "misconception": "Targets [specific protocol confusion]: Students focus on DNS exploitation rather than the broader SSRF mechanism of arbitrary request generation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SSRF allows the attacker to make the server act as a proxy, sending requests to internal IPs and ports. By analyzing the server's responses (or timeouts), the attacker can infer which services are running and accessible internally.",
        "distractor_analysis": "SQL Injection targets databases. Client-side analysis is irrelevant for server-side enumeration. DNS exploitation is a different attack vector.",
        "analogy": "It's like using a phone inside a secure building to call different internal extensions (ports) and see which ones answer, to map out who is working inside without physically going there."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "NETWORK_SECURITY_BASICS",
        "SSRF_BASICS",
        "PORT_SCANNING"
      ]
    },
    {
      "question_text": "What is the role of a 'safe URL parser' in SSRF prevention?",
      "correct_answer": "It ensures that URLs are parsed in a way that prevents them from resolving to unintended or malicious destinations, often by strictly adhering to defined schemas and host restrictions.",
      "distractors": [
        {
          "text": "It automatically encrypts all URLs to protect them from interception.",
          "misconception": "Targets [misunderstanding of function]: Students confuse parsing with encryption, which addresses confidentiality, not URL validation."
        },
        {
          "text": "It provides a list of known malicious URLs to block.",
          "misconception": "Targets [blacklisting vs safe parsing confusion]: Students confuse a blacklist approach with the more robust method of strictly parsing and validating allowed components."
        },
        {
          "text": "It allows the server to follow any HTTP redirection, regardless of destination.",
          "misconception": "Targets [insecure behavior]: Students believe parsers should facilitate redirection, which is a common SSRF exploitation technique."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A safe URL parser strictly interprets URL components (scheme, host, port) according to security best practices, preventing ambiguous interpretations or manipulations that could lead the server to access unauthorized resources.",
        "distractor_analysis": "Encryption is unrelated to URL parsing logic. Blacklisting is less effective than strict parsing. Allowing all redirects bypasses security controls.",
        "analogy": "It's like a postal worker who only delivers mail to addresses that are clearly written, correctly formatted, and belong to a pre-approved list of recipients, refusing anything ambiguous or suspicious."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SSRF_PREVENTION",
        "SECURE_CODING_PRINCIPLES"
      ]
    },
    {
      "question_text": "Which of the following best describes the relationship between SSRF and security misconfigurations?",
      "correct_answer": "SSRF often arises from security misconfigurations, such as improperly validated user input or overly permissive network access rules.",
      "distractors": [
        {
          "text": "SSRF is a type of security misconfiguration, but it specifically targets authentication mechanisms.",
          "misconception": "Targets [vulnerability type confusion]: Students correctly identify SSRF as a misconfiguration but incorrectly associate it with authentication flaws."
        },
        {
          "text": "Security misconfigurations prevent SSRF by enforcing strict input validation.",
          "misconception": "Targets [cause vs effect confusion]: Students believe misconfigurations inherently prevent SSRF, rather than causing it."
        },
        {
          "text": "SSRF is a vulnerability that can only be exploited through complex code injection, not simple misconfigurations.",
          "misconception": "Targets [complexity assumption]: Students underestimate how basic misconfigurations can lead to severe vulnerabilities like SSRF."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SSRF exploits flaws where the application fails to properly validate user-supplied URLs or where network security controls are too permissive, both of which are common forms of security misconfiguration.",
        "distractor_analysis": "SSRF doesn't exclusively target authentication. Misconfigurations are often the *cause* of SSRF, not the prevention. SSRF can stem from simple input validation errors, not just complex code injection.",
        "analogy": "A door lock (security control) that is installed incorrectly or left unlocked (misconfiguration) allows unauthorized entry (SSRF attack), even though the lock itself is a security feature."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "SECURITY_MISCONFIGURATION",
        "SSRF_BASICS"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Server-Side Request Forgery (SSRF) Prevention Software Development Security best practices",
    "latency_ms": 28893.007
  },
  "timestamp": "2026-01-18T10:58:10.101465"
}