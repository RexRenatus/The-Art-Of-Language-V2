{
  "topic_title": "Stack Canaries",
  "category": "Software Development Security - Software Development Ecosystems",
  "flashcards": [
    {
      "question_text": "What is the primary purpose of a stack canary in software development security?",
      "correct_answer": "To detect buffer overflows on the stack before they can be exploited.",
      "distractors": [
        {
          "text": "To encrypt sensitive data stored on the stack.",
          "misconception": "Targets [functional confusion]: Confuses stack canaries with encryption mechanisms."
        },
        {
          "text": "To automatically patch vulnerabilities in compiled code.",
          "misconception": "Targets [mitigation vs. patching confusion]: Misunderstands canaries as a patching solution rather than a detection mechanism."
        },
        {
          "text": "To enforce access control policies for stack memory.",
          "misconception": "Targets [access control confusion]: Equates stack canaries with access control lists or permissions."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Stack canaries are special values placed on the stack to detect buffer overflows. Because they are overwritten by an overflow before the return address, their corruption signals an attack, allowing the program to terminate safely.",
        "distractor_analysis": "The distractors incorrectly attribute encryption, patching, or access control functions to stack canaries, missing their core purpose of overflow detection.",
        "analogy": "A stack canary is like a tripwire placed in a hallway. If someone steps on it (overflows the buffer), an alarm sounds (program terminates) before they reach a sensitive room (return address)."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "BUFFER_OVERFLOW_BASICS"
      ]
    },
    {
      "question_text": "How does a stack canary typically work to prevent buffer overflow exploitation?",
      "correct_answer": "A random or fixed value (the canary) is placed on the stack before the return address. If this value is altered during execution, the program detects it and terminates.",
      "distractors": [
        {
          "text": "It encrypts the return address to make it unreadable to attackers.",
          "misconception": "Targets [mechanism confusion]: Incorrectly assumes encryption is used for the canary's protection."
        },
        {
          "text": "It dynamically resizes buffers to prevent overflow.",
          "misconception": "Targets [mitigation strategy confusion]: Confuses canaries with dynamic buffer resizing techniques."
        },
        {
          "text": "It monitors all memory writes and halts execution if any write exceeds buffer bounds.",
          "misconception": "Targets [scope confusion]: Overstates the canary's function to encompass all memory writes, not just stack-based overflows."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Stack canaries work by being placed between local variables and the return address. Since buffer overflows typically overwrite data sequentially, the canary is corrupted if the buffer is overflowed, signaling an attack before the return address is compromised.",
        "distractor_analysis": "Distractors misrepresent the canary's function by suggesting encryption, dynamic resizing, or universal memory write monitoring, rather than its specific role in detecting stack corruption.",
        "analogy": "Imagine a guard (canary) standing between a treasure chest (return address) and a hallway (buffer). If an intruder tries to reach the treasure by breaking through the hallway, they must first pass the guard, who will raise an alarm."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "STACK_CANARY_BASICS",
        "BUFFER_OVERFLOW_MECHANISM"
      ]
    },
    {
      "question_text": "Which compiler flag is commonly used to enable stack canary protection in GCC and Clang?",
      "correct_answer": "-fstack-protector",
      "distractors": [
        {
          "text": "-fno-stack-protector",
          "misconception": "Targets [flag negation]: This flag disables stack protection."
        },
        {
          "text": "-fstack-overflow-detection",
          "misconception": "Targets [plausible but incorrect flag]: A descriptive name, but not the actual flag used."
        },
        {
          "text": "-fbuffer-security",
          "misconception": "Targets [generic security flag]: A plausible security-related flag, but not specific to stack canaries."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The '-fstack-protector' flag instructs compilers like GCC and Clang to insert stack canary checks into the compiled code. This enables runtime detection of buffer overflows by adding a canary value and a check before function returns.",
        "distractor_analysis": "The distractors represent a flag that disables protection, a plausible but non-existent flag, and a generic security flag, all failing to identify the correct compiler option for stack canaries.",
        "analogy": "Enabling stack canaries with '-fstack-protector' is like telling the construction crew to install security sensors (canaries) on all critical doors (stack frames) before they are used."
      },
      "code_snippets": [
        {
          "language": "text",
          "code": "<pre><code>class=\"language-bash\">gcc -fstack-protector my_program.c -o my_program</code></pre>",
          "context": "explanation"
        }
      ],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "COMPILER_SECURITY_FLAGS",
        "STACK_CANARY_BASICS"
      ],
      "_code_snippets_html": "<div class=\"code-snippet code-explanation\">\n<span class=\"code-label\">Code Example</span>\n<pre><code class=\"language-text\">&lt;pre&gt;&lt;code&gt;class=&quot;language-bash&quot;&gt;gcc -fstack-protector my_program.c -o my_program&lt;/code&gt;&lt;/pre&gt;</code></pre>\n</div>"
    },
    {
      "question_text": "What is a common characteristic of the 'canary' value used in stack protection mechanisms?",
      "correct_answer": "It is often a random value generated at program startup, making it difficult to guess.",
      "distractors": [
        {
          "text": "It is always a null byte (0x00) to ensure compatibility with string functions.",
          "misconception": "Targets [specific value confusion]: While null bytes can be part of bypasses, the canary itself is not typically just a null byte."
        },
        {
          "text": "It is a fixed, well-known value like 'AAAA' for easy verification.",
          "misconception": "Targets [predictability error]: A fixed value would be easily guessable and bypassable."
        },
        {
          "text": "It is derived from the program's source code to ensure uniqueness.",
          "misconception": "Targets [derivation confusion]: Canaries are typically random or system-generated, not derived from source code directly."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Stack canaries are often initialized with a random value at program startup (or per thread) to prevent attackers from predicting or guessing the canary's value. This randomness is crucial because if the canary is predictable, an attacker can simply overwrite it with its known value.",
        "distractor_analysis": "The distractors propose a null byte, a fixed value, or source-code derivation, all of which would compromise the canary's effectiveness by making it predictable or incompatible with its security purpose.",
        "analogy": "The canary's value is like a secret handshake that changes every time you meet. If someone tries to impersonate you, they won't know the current handshake and will be caught."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "STACK_CANARY_BASICS",
        "RANDOMIZATION_IN_SECURITY"
      ]
    },
    {
      "question_text": "In the context of stack canaries, what does 'stack smashing' refer to?",
      "correct_answer": "An attack that exploits a buffer overflow to overwrite critical data on the stack, such as the return address.",
      "distractors": [
        {
          "text": "A technique to increase the size of stack buffers dynamically.",
          "misconception": "Targets [misinterpretation of term]: Confuses 'smashing' with 'expanding' or 'resizing'."
        },
        {
          "text": "The process of compiling code with stack canary protection enabled.",
          "misconception": "Targets [process confusion]: Equates the attack name with the defensive measure."
        },
        {
          "text": "A method for recovering corrupted data from the stack after an overflow.",
          "misconception": "Targets [recovery vs. attack confusion]: Mistakenly believes 'smashing' refers to recovery efforts."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Stack smashing is a colloquial term for a stack buffer overflow attack. It describes the act of overwriting adjacent memory on the stack, including the return address, by writing more data into a buffer than it can hold, thereby 'smashing' the stack's integrity.",
        "distractor_analysis": "The distractors misinterpret 'stack smashing' as buffer resizing, compilation of defenses, or data recovery, failing to recognize it as a description of the attack itself.",
        "analogy": "Stack smashing is like violently shaking a stack of papers (the stack) so that the top paper (return address) falls off or gets mixed up with other papers."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "BUFFER_OVERFLOW_BASICS",
        "STACK_STRUCTURE"
      ]
    },
    {
      "question_text": "Which of the following is a limitation of stack canaries?",
      "correct_answer": "They do not protect against heap-based buffer overflows.",
      "distractors": [
        {
          "text": "They are ineffective against simple buffer overflows.",
          "misconception": "Targets [effectiveness overstatement]: Incorrectly claims canaries are ineffective against basic overflows."
        },
        {
          "text": "They require significant changes to the programming language syntax.",
          "misconception": "Targets [implementation complexity confusion]: Assumes complex language modifications are needed, when it's a compiler feature."
        },
        {
          "text": "They only protect against integer overflow vulnerabilities.",
          "misconception": "Targets [vulnerability type confusion]: Confuses buffer overflows with integer overflows."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Stack canaries are specifically designed to protect the call stack. They do not extend protection to other memory regions like the heap, which can also be subject to buffer overflow vulnerabilities. Therefore, heap overflows remain a threat even with stack canaries enabled.",
        "distractor_analysis": "The distractors incorrectly state canaries are ineffective, require language changes, or protect against integer overflows, missing the key limitation that they are stack-specific.",
        "analogy": "Stack canaries are like security guards for a specific building (the stack). They can't protect other buildings (the heap) in the same city."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "STACK_VS_HEAP",
        "STACK_CANARY_LIMITATIONS"
      ]
    },
    {
      "question_text": "Consider a scenario where a program uses a vulnerable C function like <code>strcpy</code> without proper bounds checking. If stack canaries are enabled, what is the most likely outcome if a buffer overflow occurs?",
      "correct_answer": "The canary value on the stack will be overwritten, detected by a check before function return, and the program will terminate.",
      "distractors": [
        {
          "text": "The overflow will be silently ignored, and the program will continue execution.",
          "misconception": "Targets [no-protection scenario]: Assumes canaries fail to detect the overflow."
        },
        {
          "text": "The program will automatically reallocate the buffer to accommodate the excess data.",
          "misconception": "Targets [misunderstanding of canary function]: Confuses detection with automatic resizing."
        },
        {
          "text": "The attacker will gain immediate control of the program's execution flow.",
          "misconception": "Targets [immediate exploitation scenario]: Assumes exploitation is always successful without detection."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When stack canaries are enabled, they act as a safeguard. A buffer overflow overwrites the canary before the return address. The program's epilogue then checks the canary; if it's changed, it indicates a potential exploit, and the program terminates to prevent further compromise.",
        "distractor_analysis": "The distractors suggest the overflow is ignored, the buffer resizes, or immediate exploitation occurs, all of which contradict the intended behavior of stack canaries detecting and halting execution.",
        "analogy": "If <code>strcpy</code> overflows a buffer, it's like pouring too much water into a cup. The canary is a sensor that detects when the water level exceeds the cup's rim, triggering a shutdown before it spills onto the table (return address)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "STACK_CANARY_MECHANISM",
        "VULNERABLE_FUNCTIONS"
      ]
    },
    {
      "question_text": "What is the purpose of the NULL byte in some stack canary implementations, particularly concerning string functions?",
      "correct_answer": "To cause string functions (like <code>strcpy</code>) to terminate early if they encounter the canary, preventing it from being fully read.",
      "distractors": [
        {
          "text": "To serve as the actual canary value, indicating a buffer overflow.",
          "misconception": "Targets [unknown]: Not specified"
        },
        {
          "text": "To encrypt the canary value, making it harder to guess.",
          "misconception": "Targets [encryption confusion]: Assumes the NULL byte is for encryption purposes."
        },
        {
          "text": "To automatically null-terminate the overflowing data, preventing further corruption.",
          "misconception": "Targets [misinterpretation of effect]: Believes the NULL byte actively stops overflow, rather than just terminating string reads."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Some stack canary implementations include a NULL byte (0x00) as the first byte. This is a deliberate design choice because many string manipulation functions in C will stop processing when they encounter a NULL byte. This prevents an attacker from easily leaking the canary value using these functions.",
        "distractor_analysis": "The distractors incorrectly identify the NULL byte as the canary value, an encryption component, or an active overflow stopper, missing its role in thwarting string-based canary leakage.",
        "analogy": "The NULL byte is like a 'stop sign' for certain data-reading tools (string functions). If these tools encounter the canary, they stop reading, preventing them from accidentally revealing the canary's full value."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "STACK_CANARY_BYPASSES",
        "C_STRING_FUNCTIONS"
      ]
    },
    {
      "question_text": "How can attackers attempt to bypass stack canaries?",
      "correct_answer": "By leaking the canary value through another vulnerability (e.g., format string vulnerability) and then overwriting the return address with the correct canary.",
      "distractors": [
        {
          "text": "By disabling the canary check within the program's code.",
          "misconception": "Targets [direct disabling confusion]: Assumes attackers can easily disable runtime checks."
        },
        {
          "text": "By overwriting the canary with a known default value.",
          "misconception": "Targets [predictability error]: Assumes canaries use predictable default values that are easily guessed."
        },
        {
          "text": "By exploiting vulnerabilities in the compiler itself.",
          "misconception": "Targets [scope confusion]: Focuses on compiler flaws rather than program-level vulnerabilities."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Attackers can bypass stack canaries by first finding a way to leak the canary's value (e.g., via format string bugs or information disclosure). Once the canary is known, they can overwrite the buffer and then the return address with the correct canary value, followed by their malicious code's address, thus passing the check.",
        "distractor_analysis": "The distractors suggest direct disabling, guessing a default value, or exploiting compiler flaws, which are less common or feasible bypass methods compared to leaking and re-injecting the canary value.",
        "analogy": "Bypassing a canary is like knowing the secret password before trying to enter a guarded area. If you can find out the password (leak the canary), you can say it to the guard (overwrite the return address) and pass through."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "STACK_CANARY_BYPASSES",
        "FORMAT_STRING_VULNERABILITIES"
      ]
    },
    {
      "question_text": "What is the difference between stack canaries and other buffer overflow protections like ASLR (Address Space Layout Randomization)?",
      "correct_answer": "Stack canaries detect overflows by checking a specific value on the stack, while ASLR randomizes memory addresses to make it harder to predict target locations.",
      "distractors": [
        {
          "text": "Stack canaries prevent overflows, while ASLR detects them.",
          "misconception": "Targets [prevention vs. detection confusion]: Reverses the primary function of each."
        },
        {
          "text": "Stack canaries protect the heap, while ASLR protects the stack.",
          "misconception": "Targets [memory region confusion]: Swaps the memory regions each protection targets."
        },
        {
          "text": "Stack canaries are compiler-based, while ASLR is an operating system feature.",
          "misconception": "Targets [implementation location confusion]: While true, this doesn't explain their functional difference in overflow mitigation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Stack canaries are a compiler-implemented defense that detects stack buffer overflows by verifying a canary value before function return. ASLR, an OS feature, randomizes memory layouts (stack, heap, libraries) to make it difficult for attackers to predict the addresses they need to target for exploitation.",
        "distractor_analysis": "The distractors incorrectly assign prevention/detection roles, swap memory regions, or focus on implementation location without explaining the core functional difference in how they address buffer overflows.",
        "analogy": "Stack canaries are like a security guard checking IDs at a specific checkpoint (stack return). ASLR is like randomly changing the location of all checkpoints throughout a city, making it hard for an intruder to know where to go."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "STACK_CANARY_BASICS",
        "ASLR_BASICS"
      ]
    },
    {
      "question_text": "What is the role of the 'return pointer' or 'return address' in relation to stack canaries?",
      "correct_answer": "The return pointer is the critical piece of data that stack canaries aim to protect from being overwritten by a buffer overflow.",
      "distractors": [
        {
          "text": "The return pointer is used to generate the canary value.",
          "misconception": "Targets [generation confusion]: Incorrectly links the return pointer to canary generation."
        },
        {
          "text": "The return pointer is always overwritten first in a buffer overflow.",
          "misconception": "Targets [overflow sequence confusion]: Assumes the return pointer is always the first overwritten element."
        },
        {
          "text": "The return pointer is a security mechanism itself.",
          "misconception": "Targets [misclassification]: Views the return pointer as a security feature rather than data to be protected."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The return pointer, stored on the stack, tells the program where to resume execution after a function completes. Stack canaries are placed between buffers and the return pointer. Because overflows typically overwrite sequentially, the canary is corrupted before the return pointer, allowing detection.",
        "distractor_analysis": "The distractors misrepresent the return pointer's relationship with canaries by suggesting it generates the canary, is always overwritten first, or is a security mechanism itself, missing its role as the protected target.",
        "analogy": "The return pointer is like the 'next page' instruction in a book. The canary is a bookmark placed just before that instruction. If someone scribbles all over the page (buffer overflow), they'll smudge the bookmark first, alerting you before they reach the instruction."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "STACK_STRUCTURE",
        "RETURN_ADDRESS_CONCEPT"
      ]
    },
    {
      "question_text": "What is a potential risk if a program uses a predictable canary value?",
      "correct_answer": "An attacker can easily guess the canary value and overwrite it with the correct value, bypassing the protection.",
      "distractors": [
        {
          "text": "The program will crash immediately upon startup.",
          "misconception": "Targets [incorrect consequence]: Predictability doesn't inherently cause crashes."
        },
        {
          "text": "The compiler will refuse to build the program.",
          "misconception": "Targets [compiler behavior confusion]: Compilers don't typically block predictable canaries."
        },
        {
          "text": "The canary will be automatically disabled by the operating system.",
          "misconception": "Targets [OS intervention confusion]: OS doesn't typically manage compiler-level canary values directly."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The effectiveness of stack canaries relies on their unpredictability. If an attacker can guess or determine the canary value (e.g., if it's a fixed default or easily derived), they can overwrite the buffer and then place the correct canary value before the return address, thus circumventing the detection mechanism.",
        "distractor_analysis": "The distractors propose incorrect consequences like immediate crashes, build failures, or OS intervention, failing to identify the primary security risk: bypass through predictability.",
        "analogy": "If the secret password to enter a club is always 'password123', anyone can just say it and get in. A predictable canary is like that weak password; it offers no real security."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "STACK_CANARY_BASICS",
        "SECURITY_PREDICTABILITY"
      ]
    },
    {
      "question_text": "Which of the following is NOT a common method for bypassing stack canaries?",
      "correct_answer": "Using a format string vulnerability to overwrite the canary with a NULL byte.",
      "distractors": [
        {
          "text": "Leaking the canary value through an information disclosure vulnerability.",
          "misconception": "Targets [common bypass method]: This is a primary method for bypassing canaries."
        },
        {
          "text": "Brute-forcing the canary byte by byte when the program forks.",
          "misconception": "Targets [common bypass method]: This is a known technique, especially on fork-and-exec servers."
        },
        {
          "text": "Finding a non-canary protected function call to exploit.",
          "misconception": "Targets [alternative exploit path]: Exploiting unprotected code paths is a valid bypass strategy."
        }
      ],
      "detailed_explanation": {
        "core_logic": "While format string vulnerabilities can be used for information disclosure, overwriting a canary specifically with a NULL byte is not a direct bypass method. The primary bypasses involve leaking the *correct* canary value and then using it, or exploiting code paths that might not have canaries enabled. Brute-forcing is also a viable, albeit slower, method.",
        "distractor_analysis": "The correct answer describes a scenario that is not a direct bypass. The distractors list common and effective bypass techniques: leaking the canary, brute-forcing, and exploiting unprotected code.",
        "analogy": "Imagine trying to get past a guard (canary). Leaking the password, guessing it slowly, or finding a back door are ways to get past. Trying to trick the guard by giving them a specific, but incorrect, piece of information (a NULL byte instead of the real canary) isn't the way to get through."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "evaluate",
      "prerequisites": [
        "STACK_CANARY_BYPASSES",
        "FORMAT_STRING_VULNERABILITIES"
      ]
    },
    {
      "question_text": "What is the relationship between stack canaries and the concept of 'return-to-libc' attacks?",
      "correct_answer": "Stack canaries can mitigate return-to-libc attacks by detecting the modification of the return address, which is a target of such attacks.",
      "distractors": [
        {
          "text": "Stack canaries are a type of return-to-libc attack.",
          "misconception": "Targets [classification confusion]: Incorrectly categorizes the defense as an attack."
        },
        {
          "text": "Return-to-libc attacks are used to generate stack canary values.",
          "misconception": "Targets [functional confusion]: Reverses the relationship between attack and defense."
        },
        {
          "text": "Stack canaries are only effective against return-oriented programming (ROP), not return-to-libc.",
          "misconception": "Targets [scope confusion]: Incorrectly limits canary effectiveness to ROP."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Return-to-libc attacks aim to hijack the control flow by overwriting the return address on the stack to point to existing library functions. Stack canaries detect such overwrites because the canary value would be corrupted before the return address is modified, thus preventing the attack.",
        "distractor_analysis": "The distractors misclassify canaries as attacks, reverse their relationship with return-to-libc, or incorrectly limit their scope, failing to grasp how canaries disrupt the core mechanism of return-to-libc.",
        "analogy": "A return-to-libc attack is like redirecting a mail carrier to the wrong house address. Stack canaries are like a security guard at the original house who notices the address has been tampered with and stops the mail carrier before they deliver to the wrong place."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "STACK_CANARY_BASICS",
        "RETURN_TO_LIBC_ATTACKS"
      ]
    },
    {
      "question_text": "How does the '/GS' compiler flag in Microsoft Visual C++ relate to stack canaries?",
      "correct_answer": "The '/GS' flag enables stack cookie protection, which is Microsoft's implementation of stack canaries.",
      "distractors": [
        {
          "text": "The '/GS' flag disables stack cookie protection.",
          "misconception": "Targets [flag negation]: Incorrectly states the flag's function."
        },
        {
          "text": "The '/GS' flag is used for heap overflow protection.",
          "misconception": "Targets [scope confusion]: Incorrectly assigns the flag to heap protection."
        },
        {
          "text": "The '/GS' flag is only effective on 32-bit systems.",
          "misconception": "Targets [platform limitation confusion]: '/GS' is effective on both 32-bit and 64-bit systems."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Microsoft Visual C++'s '/GS' compiler flag enables stack buffer overrun detection. It works by inserting a security cookie (a canary value) onto the stack before function-local variables. Before a function returns, the cookie is checked; if it has been modified, the program terminates.",
        "distractor_analysis": "The distractors incorrectly describe the '/GS' flag as disabling protection, applying to heap overflows, or being limited to 32-bit systems, missing its role in enabling Microsoft's stack canary equivalent.",
        "analogy": "The '/GS' flag in Visual C++ is like telling the compiler to install a 'tamper-evident seal' (stack cookie) on critical data structures within each function's workspace (stack) to detect unauthorized changes."
      },
      "code_snippets": [
        {
          "language": "text",
          "code": "<pre><code>class=\"language-bash\">cl /GS /EHsc my_program.c</code></pre>",
          "context": "explanation"
        }
      ],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "STACK_CANARY_BASICS",
        "VISUAL_STUDIO_SECURITY"
      ],
      "_code_snippets_html": "<div class=\"code-snippet code-explanation\">\n<span class=\"code-label\">Code Example</span>\n<pre><code class=\"language-text\">&lt;pre&gt;&lt;code&gt;class=&quot;language-bash&quot;&gt;cl /GS /EHsc my_program.c&lt;/code&gt;&lt;/pre&gt;</code></pre>\n</div>"
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Stack Canaries Software Development Security best practices",
    "latency_ms": 26015.639
  },
  "timestamp": "2026-01-18T10:47:27.898437"
}