{
  "topic_title": "IaC Policy Enforcement (Open Policy Agent)",
  "category": "Software Development Security - Software Development Ecosystems",
  "flashcards": [
    {
      "question_text": "What is the primary function of Open Policy Agent (OPA) in Infrastructure as Code (IaC) security?",
      "correct_answer": "To decouple policy decision-making from policy enforcement, allowing unified policy management across the stack.",
      "distractors": [
        {
          "text": "To automatically rewrite IaC code to comply with security policies.",
          "misconception": "Targets [automation misconception]: OPA evaluates policies but does not automatically rewrite code."
        },
        {
          "text": "To provide a centralized repository for all IaC security policies.",
          "misconception": "Targets [scope confusion]: OPA is an engine, not a repository; policies are written in Rego and managed separately."
        },
        {
          "text": "To perform runtime security monitoring of deployed infrastructure.",
          "misconception": "Targets [domain confusion]: OPA focuses on pre-deployment policy enforcement, not runtime monitoring."
        }
      ],
      "detailed_explanation": {
        "core_logic": "OPA decouples policy decision-making from enforcement by providing a declarative language (Rego) and APIs, enabling unified policy management across various systems including IaC. This separation allows policies to be managed independently of the services they govern.",
        "distractor_analysis": "The first distractor suggests automatic code rewriting, which OPA does not do. The second mischaracterizes OPA as a repository rather than an engine. The third incorrectly assigns runtime monitoring capabilities to OPA, which focuses on pre-deployment checks.",
        "analogy": "Think of OPA as a security guard at a building's entrance. The guard doesn't redesign the building (IaC code) but checks if visitors (deployments) meet the building's rules (policies) before they enter."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "IAC_BASICS",
        "OPA_INTRODUCTION"
      ]
    },
    {
      "question_text": "In the context of Open Policy Agent (OPA), what is Rego primarily used for?",
      "correct_answer": "To define policies in a high-level, declarative language that OPA evaluates.",
      "distractors": [
        {
          "text": "To write imperative scripts for automating IaC deployments.",
          "misconception": "Targets [language type confusion]: Rego is declarative, not imperative, and focuses on policy, not deployment automation."
        },
        {
          "text": "To store the actual infrastructure configuration data.",
          "misconception": "Targets [data vs. policy confusion]: Rego defines rules; data is input to OPA for evaluation."
        },
        {
          "text": "To generate security audit reports from OPA decisions.",
          "misconception": "Targets [functionality confusion]: OPA generates decisions; separate tools or processes generate reports from decision logs."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Rego is the declarative policy language used by OPA. It allows users to specify policies as code, enabling OPA to evaluate arbitrary structured data against these rules and make policy decisions. This declarative nature ensures policies are consistent and understandable.",
        "distractor_analysis": "The first distractor mistakes Rego's declarative nature for imperative scripting. The second confuses policy definition with data storage. The third incorrectly assigns report generation to Rego, which is an evaluation language.",
        "analogy": "Rego is like the rulebook for a game, defining what actions are allowed or disallowed. OPA is the referee that uses the rulebook to judge whether a player's move (IaC configuration) is valid."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "OPA_INTRODUCTION",
        "REGO_BASICS"
      ]
    },
    {
      "question_text": "Which of the following best describes how OPA integrates with CI/CD pipelines for IaC policy enforcement?",
      "correct_answer": "OPA can be invoked as a step in the pipeline to validate IaC configurations before deployment.",
      "distractors": [
        {
          "text": "OPA automatically detects and fixes security vulnerabilities in IaC code.",
          "misconception": "Targets [automation misconception]: OPA identifies violations but does not automatically fix them."
        },
        {
          "text": "OPA replaces the need for traditional IaC linters and formatters.",
          "misconception": "Targets [scope confusion]: OPA complements, rather than replaces, other IaC validation tools."
        },
        {
          "text": "OPA only enforces policies after the infrastructure has been deployed.",
          "misconception": "Targets [timing misconception]: OPA is most effective when used pre-deployment to prevent insecure configurations."
        }
      ],
      "detailed_explanation": {
        "core_logic": "OPA integrates into CI/CD pipelines by acting as a policy enforcement gate. Since OPA can query arbitrary structured data, it can evaluate IaC plan outputs or configurations, preventing insecure infrastructure from being provisioned. This aligns with best practices for shifting security left.",
        "distractor_analysis": "The first distractor overstates OPA's capabilities by claiming automatic fixing. The second suggests OPA replaces other tools, which is incorrect; it's complementary. The third misplaces OPA's enforcement point to post-deployment, contrary to its primary use case.",
        "analogy": "In a CI/CD pipeline, OPA acts like a final security checkpoint before a product leaves the factory. It verifies that the product (IaC configuration) meets all safety standards before it's shipped (deployed)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "CI_CD_BASICS",
        "IAC_SECURITY_BEST_PRACTICES"
      ]
    },
    {
      "question_text": "Consider an OPA policy written in Rego that denies the creation of public S3 buckets. If an IaC tool generates a configuration for a public S3 bucket, how would OPA typically enforce this policy?",
      "correct_answer": "OPA would evaluate the IaC plan/configuration data and return a 'deny' decision, causing the pipeline step to fail.",
      "distractors": [
        {
          "text": "OPA would automatically modify the IaC configuration to make the bucket private.",
          "misconception": "Targets [automation misconception]: OPA makes decisions, it does not modify configurations."
        },
        {
          "text": "OPA would flag the configuration as a warning but allow the deployment to proceed.",
          "misconception": "Targets [severity misconception]: OPA can enforce strict deny rules, not just warnings."
        },
        {
          "text": "OPA would only enforce this policy if the bucket was already created.",
          "misconception": "Targets [timing misconception]: OPA enforces policies pre-deployment on IaC plans or configurations."
        }
      ],
      "detailed_explanation": {
        "core_logic": "OPA functions as a policy decision point. When integrated into an IaC workflow, it receives the proposed configuration as input, evaluates it against Rego policies, and returns a decision (allow/deny). A 'deny' decision for a public S3 bucket would halt the deployment process, enforcing the security posture.",
        "distractor_analysis": "The first distractor attributes code modification to OPA. The second suggests OPA only issues warnings, ignoring its enforcement capability. The third incorrectly places OPA's enforcement after deployment, missing its pre-deployment validation role.",
        "analogy": "If an IaC tool tries to build a house with a door facing a busy highway (public S3 bucket), OPA is the building inspector who stops the construction (fails the pipeline) because it violates safety codes (policy)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "IAC_SECURITY_BEST_PRACTICES",
        "OPA_POLICY_EVALUATION"
      ]
    },
    {
      "question_text": "What is the main advantage of using OPA for IaC policy enforcement compared to embedding policy logic directly within IaC modules?",
      "correct_answer": "Centralized management and consistency of policies across multiple IaC projects and teams.",
      "distractors": [
        {
          "text": "Reduced complexity in writing IaC modules.",
          "misconception": "Targets [complexity misconception]: Embedding logic might seem simpler initially but leads to distributed complexity."
        },
        {
          "text": "Faster execution of IaC deployments.",
          "misconception": "Targets [performance misconception]: OPA adds a step, potentially slowing deployments slightly, but gains consistency."
        },
        {
          "text": "Automatic generation of compliance reports.",
          "misconception": "Targets [reporting misconception]: OPA provides decisions; reporting requires separate tooling."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Embedding policy logic within IaC modules leads to fragmentation and inconsistency. OPA provides a unified engine and language (Rego) for managing policies centrally, ensuring that the same security and compliance rules are applied consistently across all IaC projects and teams, which is a key Software Development Security best practice.",
        "distractor_analysis": "The first distractor incorrectly suggests OPA reduces IaC module complexity; it shifts complexity to policy management. The second claims faster deployments, which isn't the primary benefit. The third misattributes automatic reporting to OPA's core function.",
        "analogy": "Instead of each construction worker having their own slightly different blueprint for safety rules, OPA is like a central safety office that issues one master rulebook used by everyone, ensuring consistency."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "IAC_SECURITY_BEST_PRACTICES",
        "POLICY_MANAGEMENT_PRINCIPLES"
      ]
    },
    {
      "question_text": "Which of the following is a key benefit of OPA's context-aware policy decisions for IaC?",
      "correct_answer": "Policies can consider multiple data sources (e.g., user identity, resource tags, environment) to make granular decisions.",
      "distractors": [
        {
          "text": "Policies are limited to only checking resource names.",
          "misconception": "Targets [limitation misconception]: OPA can process arbitrary structured data, enabling rich context."
        },
        {
          "text": "Decisions are always binary (allow/deny) and cannot be nuanced.",
          "misconception": "Targets [output type misconception]: OPA can output arbitrary data, not just simple allow/deny."
        },
        {
          "text": "Policy evaluation occurs only after the infrastructure is fully provisioned.",
          "misconception": "Targets [timing misconception]: OPA is designed for pre-deployment validation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "OPA's strength lies in its ability to ingest and evaluate arbitrary structured data. This allows policies to be context-aware, considering factors beyond just the IaC code itself, such as the deployment environment, user roles, or resource metadata. This enables fine-grained control and adherence to complex security requirements.",
        "distractor_analysis": "The first distractor incorrectly limits OPA's data processing capabilities. The second wrongly assumes binary outputs, ignoring OPA's flexibility. The third misplaces the evaluation timing to post-deployment.",
        "analogy": "A security system that only checks if you have a key (resource name) is basic. A context-aware system checks your key, your ID, the time of day, and your access level (multiple data sources) for a more secure decision."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "OPA_POLICY_EVALUATION",
        "CONTEXT_AWARE_SECURITY"
      ]
    },
    {
      "question_text": "When using OPA with Kubernetes for IaC, what mechanism allows OPA to intercept and evaluate resource creation requests?",
      "correct_answer": "A Validating Admission Webhook.",
      "distractors": [
        {
          "text": "A Mutating Admission Controller.",
          "misconception": "Targets [webhook type confusion]: Mutating controllers modify requests, while validating controllers only permit or deny."
        },
        {
          "text": "A Kubernetes Network Policy.",
          "misconception": "Targets [resource type confusion]: Network Policies control network traffic, not resource creation."
        },
        {
          "text": "A Custom Resource Definition (CRD) for policies.",
          "misconception": "Targets [component confusion]: CRDs define new object types; admission webhooks intercept API requests."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Kubernetes uses Admission Controllers to intercept requests to the Kubernetes API server. A Validating Admission Webhook is configured to send resource creation/update requests to an external service like OPA. OPA evaluates the request against its policies and returns a decision, which the webhook uses to allow or deny the request, thereby enforcing IaC policies.",
        "distractor_analysis": "The first distractor confuses validating webhooks with mutating ones. The second misapplies Network Policies, which are for traffic control. The third confuses CRDs (for defining objects) with admission webhooks (for intercepting requests).",
        "analogy": "A Validating Admission Webhook is like a bouncer at a club's entrance. They check if a guest (Kubernetes resource request) meets the club's rules (OPA policy) before allowing them inside (to the API server)."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "KUBERNETES_ADMISSION_CONTROL",
        "OPA_INTEGRATION_K8S"
      ]
    },
    {
      "question_text": "What is the role of OPA Control Plane (OCP) in managing OPA deployments for IaC?",
      "correct_answer": "To simplify centralized management of policies and data bundles distributed to OPA agents.",
      "distractors": [
        {
          "text": "To directly execute IaC code and enforce policies.",
          "misconception": "Targets [role confusion]: OCP manages OPA agents; it doesn't execute IaC or enforce policies itself."
        },
        {
          "text": "To provide a graphical interface for writing Rego policies.",
          "misconception": "Targets [feature confusion]: OCP focuses on distribution and management, not policy authoring tools."
        },
        {
          "text": "To act as a runtime security monitoring tool for deployed infrastructure.",
          "misconception": "Targets [domain confusion]: OCP is for policy management, not runtime security monitoring."
        }
      ],
      "detailed_explanation": {
        "core_logic": "OCP acts as a control plane for OPA, streamlining the distribution of policies and data (as bundles) to numerous OPA agents. This centralized management approach simplifies updates, ensures consistency, and provides better visibility into policy deployment across an organization's IaC infrastructure, aligning with robust management practices.",
        "distractor_analysis": "The first distractor incorrectly assigns IaC execution and direct enforcement to OCP. The second misrepresents OCP's function as a policy authoring tool. The third confuses OCP's role with that of a runtime security solution.",
        "analogy": "OCP is like the air traffic control system for OPA agents. It directs where and when policies (flight plans) are delivered to the agents (planes) so they can make correct decisions."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "OPA_CONTROL_PLANE",
        "POLICY_DISTRIBUTION"
      ]
    },
    {
      "question_text": "Which of the following is an example of an IaC security policy that could be enforced by OPA?",
      "correct_answer": "Ensure all network security groups only allow ingress traffic from approved IP ranges.",
      "distractors": [
        {
          "text": "Automatically patch all operating systems within 24 hours of vulnerability release.",
          "misconception": "Targets [scope confusion]: This is an operational patching task, not a declarative IaC configuration policy."
        },
        {
          "text": "Monitor application logs for suspicious activity.",
          "misconception": "Targets [domain confusion]: This describes runtime security monitoring, not IaC configuration validation."
        },
        {
          "text": "Perform penetration testing on deployed applications.",
          "misconception": "Targets [process confusion]: Penetration testing is a distinct security assessment activity, not an IaC policy check."
        }
      ],
      "detailed_explanation": {
        "core_logic": "OPA excels at enforcing declarative rules on infrastructure configurations. A policy ensuring network security groups adhere to specific ingress rules is a perfect fit, as it checks the state defined in IaC against desired security posture. This aligns with NIST SP 800-53 controls for network access.",
        "distractor_analysis": "The first distractor describes an operational task (patching). The second describes runtime monitoring. The third describes a security assessment activity. None are direct checks on IaC configuration state.",
        "analogy": "OPA checking network security groups is like a building code inspector verifying that all windows are made of safety glass before the building is approved for occupancy."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "IAC_SECURITY_BEST_PRACTICES",
        "NETWORK_SECURITY_FUNDAMENTALS"
      ]
    },
    {
      "question_text": "What is the primary goal of decoupling policy from enforcement using OPA in IaC?",
      "correct_answer": "To enable consistent policy application and management across diverse environments and services.",
      "distractors": [
        {
          "text": "To eliminate the need for any human review of IaC changes.",
          "misconception": "Targets [automation misconception]: OPA automates checks but doesn't replace all human oversight."
        },
        {
          "text": "To ensure all IaC code is written in a single, standardized language.",
          "misconception": "Targets [language scope confusion]: OPA enforces policies, it doesn't dictate the IaC language used."
        },
        {
          "text": "To guarantee that all infrastructure is 100% secure by default.",
          "misconception": "Targets [security guarantee misconception]: Security is a process; OPA reduces risk but doesn't guarantee absolute security."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Decoupling policy using OPA allows organizations to define security and compliance rules once and apply them consistently across various IaC tools (Terraform, CloudFormation, Kubernetes manifests) and cloud environments. This unification simplifies management, reduces errors, and ensures a stronger, more predictable security posture.",
        "distractor_analysis": "The first distractor overpromises automation, ignoring the need for human review. The second incorrectly suggests OPA standardizes IaC languages. The third makes an unrealistic claim about guaranteeing absolute security.",
        "analogy": "Decoupling policy is like having a central HR department set company-wide conduct rules, rather than each department manager making up their own. This ensures fairness and consistency everywhere."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "evaluate",
      "prerequisites": [
        "POLICY_MANAGEMENT_PRINCIPLES",
        "DECOUPLING_PRINCIPLES"
      ]
    },
    {
      "question_text": "How does OPA contribute to auditability and compliance in IaC workflows?",
      "correct_answer": "By providing decision logs that record every policy evaluation and its outcome.",
      "distractors": [
        {
          "text": "By automatically generating compliance reports based on ISO 27001.",
          "misconception": "Targets [reporting misconception]: OPA logs decisions; report generation requires separate tooling and mapping to standards."
        },
        {
          "text": "By encrypting all IaC state files to prevent tampering.",
          "misconception": "Targets [functionality confusion]: OPA focuses on policy decisions, not encrypting IaC state files."
        },
        {
          "text": "By enforcing that all IaC code must be reviewed by a security team.",
          "misconception": "Targets [enforcement scope confusion]: OPA automates checks but doesn't mandate human review processes."
        }
      ],
      "detailed_explanation": {
        "core_logic": "OPA's ability to log every policy decision provides a clear audit trail. This detailed record shows what policies were evaluated, what input data was used, and the resulting decision (allow/deny). This is crucial for compliance, allowing organizations to demonstrate adherence to security standards like NIST or PCI-DSS by reviewing historical policy enforcement.",
        "distractor_analysis": "The first distractor incorrectly claims automatic compliance report generation. The second misattributes state file encryption to OPA. The third wrongly suggests OPA enforces mandatory human review processes.",
        "analogy": "OPA's decision logs are like security camera footage of every time someone tried to enter a restricted area. It provides evidence of who tried, when, and whether they were allowed in or not, aiding audits."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "AUDIT_TRAILS",
        "COMPLIANCE_MANAGEMENT"
      ]
    },
    {
      "question_text": "What is a common challenge when implementing OPA for IaC policy enforcement, and how can it be addressed?",
      "correct_answer": "Challenge: Writing effective and maintainable Rego policies. Address: Start with simple policies, use policy libraries, and iterate.",
      "distractors": [
        {
          "text": "Challenge: OPA requires a complete rewrite of existing IaC code. Address: OPA can be integrated without rewriting IaC.",
          "misconception": "Targets [integration misconception]: OPA integrates with IaC tools, not necessarily requiring rewrites."
        },
        {
          "text": "Challenge: OPA is too slow for real-time IaC validation. Address: Optimize Rego and data loading for performance.",
          "misconception": "Targets [performance misconception]: While performance is key, OPA is designed for low-latency decisions, and optimization is possible."
        },
        {
          "text": "Challenge: Lack of community support for OPA. Address: OPA is a CNCF graduated project with active community support.",
          "misconception": "Targets [community misconception]: OPA has strong community backing and resources."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Learning and writing effective Rego policies can be challenging. Best practices involve starting with foundational policies, leveraging reusable policy libraries, and adopting an iterative approach to development and testing. This methodical process helps manage complexity and ensures policies accurately reflect security requirements.",
        "distractor_analysis": "The first distractor incorrectly suggests OPA necessitates IaC rewrites. The second downplays OPA's performance capabilities and optimization potential. The third falsely claims a lack of community support for a mature CNCF project.",
        "analogy": "Learning to write Rego is like learning a new programming language. The challenge is the syntax and logic, but starting with simple programs and using documentation/examples makes it manageable."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "OPA_POLICY_WRITING",
        "SOFTWARE_IMPLEMENTATION_CHALLENGES"
      ]
    },
    {
      "question_text": "Which of the following is NOT a typical use case for OPA in IaC security?",
      "correct_answer": "Performing dynamic analysis of running applications for zero-day exploits.",
      "distractors": [
        {
          "text": "Enforcing tagging policies for cloud resources.",
          "misconception": "Targets [use case confusion]: Tagging is a common policy enforced by OPA on IaC resources."
        },
        {
          "text": "Validating that only approved container images are used.",
          "misconception": "Targets [use case confusion]: OPA can validate container image references in IaC configurations."
        },
        {
          "text": "Ensuring sensitive data is not hardcoded in IaC configurations.",
          "misconception": "Targets [use case confusion]: OPA can scan IaC for secrets or sensitive information patterns."
        }
      ],
      "detailed_explanation": {
        "core_logic": "OPA is primarily a policy decision engine for declarative systems, excelling at pre-deployment checks on IaC. Dynamic analysis of running applications for zero-day exploits is a runtime security function, typically handled by different tools like Intrusion Detection Systems (IDS) or Application Security Testing (AST) tools.",
        "distractor_analysis": "The distractors represent common and valid use cases for OPA in IaC: enforcing tagging, validating container images, and preventing hardcoded secrets. The correct answer describes a runtime security function outside OPA's core domain.",
        "analogy": "OPA checking IaC is like a building inspector checking blueprints before construction. Dynamic analysis of running apps is like a security guard patrolling the finished building for intruders."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "IAC_SECURITY_BEST_PRACTICES",
        "RUNTIME_SECURITY_VS_DEVOPS_SECURITY"
      ]
    },
    {
      "question_text": "How can OPA policies help ensure compliance with standards like PCI-DSS for infrastructure defined via IaC?",
      "correct_answer": "By defining and enforcing rules that map directly to specific PCI-DSS requirements for network segmentation, access control, and data protection.",
      "distractors": [
        {
          "text": "By automatically generating PCI-DSS compliance reports.",
          "misconception": "Targets [reporting misconception]: OPA logs decisions; report generation requires separate tooling."
        },
        {
          "text": "By encrypting all data stored within the PCI-DSS scope.",
          "misconception": "Targets [scope confusion]: OPA enforces policies on configuration, not directly on data encryption implementation."
        },
        {
          "text": "By replacing the need for manual security audits.",
          "misconception": "Targets [audit misconception]: OPA aids audits by providing evidence, but doesn't replace them entirely."
        }
      ],
      "detailed_explanation": {
        "core_logic": "OPA enables the translation of compliance requirements, such as those in PCI-DSS, into executable policies. For instance, policies can ensure that network configurations meet segmentation requirements (e.g., isolating cardholder data environments) or that access controls are correctly implemented, providing auditable evidence of compliance checks within the IaC workflow.",
        "distractor_analysis": "The first distractor overstates OPA's reporting capabilities. The second incorrectly suggests OPA directly encrypts data. The third wrongly implies OPA eliminates the need for manual audits.",
        "analogy": "Ensuring PCI-DSS compliance with OPA is like having a checklist for building a secure vault. OPA verifies each item on the checklist (policy) is met in the vault's design (IaC) before it's built."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "defense",
      "bloom_level": "analyze",
      "prerequisites": [
        "PCI_DSS_REQUIREMENTS",
        "OPA_COMPLIANCE_APPLICATIONS"
      ]
    },
    {
      "question_text": "What is the relationship between OPA, its policies (written in Rego), and the data it evaluates for IaC configurations?",
      "correct_answer": "OPA is the engine that evaluates Rego policies against input data representing the IaC configuration.",
      "distractors": [
        {
          "text": "Rego policies are the IaC configurations, and OPA evaluates them.",
          "misconception": "Targets [component confusion]: Rego defines rules; IaC defines the infrastructure state."
        },
        {
          "text": "OPA generates the Rego policies based on the IaC data.",
          "misconception": "Targets [generation misconception]: Policies are written by humans; OPA evaluates them."
        },
        {
          "text": "The IaC configuration data is used to write the Rego policies.",
          "misconception": "Targets [data vs. policy confusion]: IaC data is input for evaluation, not used to author policies."
        }
      ],
      "detailed_explanation": {
        "core_logic": "OPA acts as a general-purpose policy engine. Policies are written in Rego, a declarative language. When OPA needs to make a decision (e.g., about an IaC configuration), it queries itself with the relevant input data (e.g., a Terraform plan output). OPA then evaluates the Rego policies against this data to produce a decision.",
        "distractor_analysis": "The first distractor conflates policy language with infrastructure code. The second incorrectly assigns policy generation to OPA. The third confuses the role of input data in evaluation versus policy authoring.",
        "analogy": "OPA is the judge, Rego is the lawbook, and the IaC configuration is the evidence presented in court. The judge (OPA) uses the lawbook (Rego) to rule on the evidence (IaC data)."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "OPA_INTRODUCTION",
        "REGO_BASICS",
        "IAC_BASICS"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "IaC Policy Enforcement (Open Policy Agent) Software Development Security best practices",
    "latency_ms": 25008.992
  },
  "timestamp": "2026-01-18T10:43:17.787884"
}