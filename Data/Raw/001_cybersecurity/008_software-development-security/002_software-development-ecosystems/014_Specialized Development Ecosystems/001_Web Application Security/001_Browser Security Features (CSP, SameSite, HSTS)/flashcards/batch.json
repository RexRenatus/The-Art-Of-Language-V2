{
  "topic_title": "Browser Security Features (CSP, SameSite, HSTS)",
  "category": "Software Development Security - Software Development Ecosystems",
  "flashcards": [
    {
      "question_text": "What is the primary purpose of Content Security Policy (CSP)?",
      "correct_answer": "To mitigate the risk of certain security threats, primarily cross-site scripting (XSS) and clickjacking, by controlling the resources a web page is allowed to load or execute.",
      "distractors": [
        {
          "text": "To enforce secure cookie handling between a browser and a server.",
          "misconception": "Targets [feature confusion]: Confuses CSP with SameSite cookie attributes."
        },
        {
          "text": "To ensure all connections to a website are made over HTTPS.",
          "misconception": "Targets [feature confusion]: Confuses CSP with HTTP Strict Transport Security (HSTS)."
        },
        {
          "text": "To encrypt sensitive user data transmitted between the client and server.",
          "misconception": "Targets [scope confusion]: Misunderstands CSP's role, confusing it with transport layer encryption like TLS."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CSP functions by allowing web developers to define a policy that instructs the browser on which resources (like scripts, images, or stylesheets) are permitted to load, thereby preventing the execution of unauthorized or malicious code.",
        "distractor_analysis": "The distractors incorrectly associate CSP with cookie security (SameSite), mandatory HTTPS (HSTS), or data encryption (TLS), rather than its core function of resource loading control.",
        "analogy": "Think of CSP as a strict bouncer at a club, checking IDs and only allowing authorized guests (resources) to enter the premises (web page)."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "XSS_BASICS",
        "HTTP_BASICS"
      ]
    },
    {
      "question_text": "Which HTTP response header is primarily used to instruct browsers to only connect to a website over HTTPS, even if the original request was made via HTTP?",
      "correct_answer": "HTTP Strict Transport Security (HSTS)",
      "distractors": [
        {
          "text": "Content Security Policy (CSP)",
          "misconception": "Targets [feature confusion]: Confuses HSTS with CSP, which controls resource loading, not connection protocols."
        },
        {
          "text": "X-Frame-Options",
          "misconception": "Targets [feature confusion]: Confuses HSTS with X-Frame-Options, which prevents clickjacking by controlling framing."
        },
        {
          "text": "Access-Control-Allow-Origin",
          "misconception": "Targets [feature confusion]: Confuses HSTS with CORS headers, which manage cross-origin resource sharing."
        }
      ],
      "detailed_explanation": {
        "core_logic": "HSTS works by telling the browser that the site should only be accessed using HTTPS. This is crucial because it prevents man-in-the-middle attacks that could downgrade connections to HTTP, thereby protecting data in transit.",
        "distractor_analysis": "Distractors represent other security headers (CSP, X-Frame-Options) or CORS headers, which serve different security purposes than enforcing HTTPS connections.",
        "analogy": "HSTS is like a permanent 'No Entry' sign for HTTP traffic to a specific building, forcing all visitors to use the secure, guarded entrance (HTTPS)."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "HTTPS_BASICS",
        "MITM_BASICS"
      ]
    },
    {
      "question_text": "What is the main security benefit of the <code>SameSite</code> cookie attribute?",
      "correct_answer": "To mitigate cross-site request forgery (CSRF) attacks by controlling when cookies are sent with cross-site requests.",
      "distractors": [
        {
          "text": "To prevent cross-site scripting (XSS) attacks by restricting script execution.",
          "misconception": "Targets [feature confusion]: Confuses SameSite with Content Security Policy (CSP)."
        },
        {
          "text": "To ensure all website resources are loaded over HTTPS.",
          "misconception": "Targets [feature confusion]: Confuses SameSite with HTTP Strict Transport Security (HSTS)."
        },
        {
          "text": "To limit the domains from which cookies can be set.",
          "misconception": "Targets [scope confusion]: Misunderstands SameSite's function, which is about request context, not domain limitations for cookie setting."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>SameSite</code> attribute controls whether cookies are sent with cross-site requests. By setting it to <code>Lax</code> or <code>Strict</code>, it prevents the browser from sending cookies in certain cross-site contexts, thereby mitigating CSRF attacks.",
        "distractor_analysis": "Distractors incorrectly attribute CSRF prevention to CSP (XSS mitigation), HSTS (HTTPS enforcement), or a non-existent domain restriction feature.",
        "analogy": "The <code>SameSite</code> attribute is like a security guard at a company cafeteria, deciding whether to let an employee (cookie) into the cafeteria (cross-site request) based on whether they work for the company (same site)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CSRF_BASICS",
        "HTTP_COOKIES"
      ]
    },
    {
      "question_text": "Consider a web application that needs to prevent clickjacking. Which HTTP security header is most effective for this purpose?",
      "correct_answer": "X-Frame-Options",
      "distractors": [
        {
          "text": "Content-Security-Policy (CSP) with frame-ancestors directive",
          "misconception": "Targets [directive specificity]: While CSP's `frame-ancestors` can prevent framing, X-Frame-Options is a more direct and historically primary header for this specific purpose."
        },
        {
          "text": "Strict-Transport-Security (HSTS)",
          "misconception": "Targets [feature confusion]: HSTS enforces HTTPS, it does not control framing."
        },
        {
          "text": "Referrer-Policy",
          "misconception": "Targets [feature confusion]: Referrer-Policy controls the `Referer` header, not framing behavior."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>X-Frame-Options</code> header is specifically designed to tell the browser whether it should be allowed to render a page in a <code>&lt;frame&gt;</code>, <code>&lt;iframe&gt;</code>, <code>&lt;embed&gt;</code>, or <code>&lt;object&gt;</code>. This directly prevents clickjacking attacks where malicious sites embed vulnerable pages.",
        "distractor_analysis": "The first distractor is plausible as CSP's <code>frame-ancestors</code> serves a similar purpose, but X-Frame-Options is the dedicated header. HSTS and Referrer-Policy are unrelated to framing.",
        "analogy": "The <code>X-Frame-Options</code> header is like a 'Do Not Disturb' sign on a door, preventing other rooms (websites) from embedding this room (web page) within their own structure."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "CLICKJACKING_BASICS",
        "HTTP_HEADERS"
      ]
    },
    {
      "question_text": "A web developer is implementing a Content Security Policy (CSP). They want to allow images to be loaded from their own domain and from a specific CDN. Which directive should they use?",
      "correct_answer": "<code>img-src</code>",
      "distractors": [
        {
          "text": "<code>script-src</code>",
          "misconception": "Targets [directive scope]: Confuses image loading with script loading directives."
        },
        {
          "text": "<code>default-src</code>",
          "misconception": "Targets [directive specificity]: While `default-src` can act as a fallback, `img-src` is the specific directive for images, offering more granular control."
        },
        {
          "text": "<code>connect-src</code>",
          "misconception": "Targets [directive scope]: Confuses image loading with directives for establishing connections (e.g., via Fetch API or XHR)."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>img-src</code> directive in CSP specifically controls the sources from which images can be loaded. By setting it to <code>&#x27;self&#x27;</code> (for the same domain) and the CDN's domain, the policy precisely allows only those sources for images.",
        "distractor_analysis": "The distractors represent directives for scripts, general fallbacks, and network connections, none of which are specific to controlling image sources.",
        "analogy": "If CSP is a security policy for a building, <code>img-src</code> is the specific rule dictating which external vendors (CDNs) are allowed to deliver packages (images) to the building."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "CSP_DIRECTIVES",
        "HTTP_RESOURCES"
      ]
    },
    {
      "question_text": "What is the purpose of the <code>frame-ancestors</code> directive within a Content Security Policy (CSP)?",
      "correct_answer": "To specify valid sources for nested browsing contexts, such as <code>&lt;iframe&gt;</code> elements, thereby preventing clickjacking.",
      "distractors": [
        {
          "text": "To control which external scripts are allowed to execute on the page.",
          "misconception": "Targets [directive scope]: Confuses `frame-ancestors` with `script-src`."
        },
        {
          "text": "To enforce that all resources must be loaded over HTTPS.",
          "misconception": "Targets [feature confusion]: Confuses CSP directives with HSTS."
        },
        {
          "text": "To restrict the domains from which cookies can be sent in cross-site requests.",
          "misconception": "Targets [feature confusion]: Confuses CSP with `SameSite` cookie attributes."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>frame-ancestors</code> directive is a powerful CSP feature that defines which origins are permitted to embed the page using framing elements. By restricting these origins, it directly mitigates clickjacking attacks, as an attacker cannot frame the page within their malicious site.",
        "distractor_analysis": "The distractors incorrectly associate <code>frame-ancestors</code> with script execution, HTTPS enforcement, or cookie handling, which are managed by other security mechanisms.",
        "analogy": "The <code>frame-ancestors</code> directive is like a 'No Trespassing' sign on a property, specifying exactly which other properties (origins) are allowed to build a connecting walkway (frame) to it."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CSP_DIRECTIVES",
        "CLICKJACKING_BASICS"
      ]
    },
    {
      "question_text": "When configuring HSTS, what is the significance of the <code>includeSubDomains</code> directive?",
      "correct_answer": "It ensures that all subdomains of the current domain also enforce HTTPS connections.",
      "distractors": [
        {
          "text": "It specifies the maximum time in seconds that the browser should remember to enforce HSTS.",
          "misconception": "Targets [directive confusion]: Confuses `includeSubDomains` with the `max-age` directive."
        },
        {
          "text": "It allows the browser to fall back to HTTP if HTTPS is unavailable.",
          "misconception": "Targets [security bypass]: This is the opposite of HSTS's purpose; HSTS aims to prevent HTTP fallback."
        },
        {
          "text": "It enables the browser to load resources from other domains over HTTPS.",
          "misconception": "Targets [scope confusion]: Confuses HSTS with CORS or CSP directives related to resource loading."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>includeSubDomains</code> directive extends the HSTS policy to all subdomains. This is crucial for comprehensive security, as a vulnerable subdomain could otherwise be exploited to bypass the HSTS protection of the main domain.",
        "distractor_analysis": "The distractors misinterpret <code>includeSubDomains</code> as controlling the HSTS duration (<code>max-age</code>), allowing HTTP fallback, or managing cross-domain resource loading.",
        "analogy": "The <code>includeSubDomains</code> directive is like extending a 'secure zone' policy from a main building to all its attached annexes and outbuildings, ensuring consistent security across the entire property."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "HSTS_DIRECTIVES",
        "SUBDOMAINS"
      ]
    },
    {
      "question_text": "A web application uses cookies for session management. To protect against CSRF attacks, which <code>SameSite</code> attribute value is generally recommended for session cookies?",
      "correct_answer": "<code>Lax</code> or <code>Strict</code>",
      "distractors": [
        {
          "text": "<code>None</code>",
          "misconception": "Targets [security risk]: `None` disables SameSite protection, making cookies vulnerable to CSRF in cross-site contexts."
        },
        {
          "text": "<code>Default</code>",
          "misconception": "Targets [invalid value]: 'Default' is not a valid `SameSite` attribute value; browsers use their own defaults which may not be secure."
        },
        {
          "text": "<code>SameOrigin</code>",
          "misconception": "Targets [incompleteness]: While `SameOrigin` is a valid value, it only protects against same-origin requests, not cross-origin requests that are the primary CSRF vector."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Setting <code>SameSite</code> to <code>Lax</code> or <code>Strict</code> prevents cookies from being sent with cross-site requests initiated by third-party websites, which is the primary mechanism for preventing CSRF attacks. <code>Lax</code> is a good balance, while <code>Strict</code> offers stronger protection but can affect usability.",
        "distractor_analysis": "The <code>None</code> value disables the protection, <code>Default</code> is not a valid option, and <code>SameOrigin</code> is too restrictive and doesn't cover typical cross-site CSRF scenarios.",
        "analogy": "For session cookies, <code>SameSite=Lax</code> or <code>Strict</code> is like requiring an employee to show their ID at the main entrance (cross-site request) before being allowed to access their specific department (same-site context), preventing unauthorized entry."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "CSRF_MITIGATION",
        "HTTP_COOKIES"
      ]
    },
    {
      "question_text": "Which of the following is a key challenge when implementing Content Security Policy (CSP)?",
      "correct_answer": "Balancing security with usability, as overly strict policies can break legitimate site functionality.",
      "distractors": [
        {
          "text": "CSP is not supported by modern web browsers.",
          "misconception": "Targets [browser support]: CSP is widely supported by modern browsers."
        },
        {
          "text": "CSP only protects against SQL injection attacks.",
          "misconception": "Targets [attack scope]: CSP primarily targets XSS and related client-side code injection, not SQL injection."
        },
        {
          "text": "CSP directives are difficult to understand and configure correctly.",
          "misconception": "Targets [complexity perception]: While configuration requires care, the directives themselves are logical and well-documented."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Implementing CSP effectively requires careful analysis of all resources a web page legitimately needs. Overly restrictive policies can block essential scripts or assets, breaking the site. Therefore, finding the right balance is a significant challenge.",
        "distractor_analysis": "The distractors present false claims about browser support, incorrect attack scope, and an overstatement of configuration difficulty compared to the core challenge of balancing security and functionality.",
        "analogy": "Implementing CSP is like setting strict rules for a party: you want to keep unwanted guests out (security), but you don't want to prevent your actual friends (legitimate resources) from entering and enjoying themselves."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "CSP_IMPLEMENTATION",
        "WEB_SECURITY_PRINCIPLES"
      ]
    },
    {
      "question_text": "What is the primary function of the <code>report-uri</code> or <code>report-to</code> directive in CSP?",
      "correct_answer": "To specify a URL where the browser should send violation reports when the CSP is triggered.",
      "distractors": [
        {
          "text": "To define the allowed sources for inline scripts.",
          "misconception": "Targets [directive scope]: Confuses reporting with script source control (`script-src`)."
        },
        {
          "text": "To enforce HTTPS for all connections to the specified domain.",
          "misconception": "Targets [feature confusion]: Confuses CSP reporting with HSTS."
        },
        {
          "text": "To allow specific third-party domains to set cookies.",
          "misconception": "Targets [feature confusion]: Confuses CSP reporting with cookie management or CORS."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>report-uri</code> (older) or <code>report-to</code> (newer) directives are essential for CSP deployment. They enable developers to receive feedback on policy violations, which is critical for debugging and refining the policy to ensure it doesn't block legitimate content while still enforcing security.",
        "distractor_analysis": "The distractors misattribute the function of reporting directives to script control, HTTPS enforcement, or cookie management, which are handled by other CSP directives or security mechanisms.",
        "analogy": "The <code>report-uri</code> directive is like setting up a security camera system that records any unauthorized access attempts (CSP violations), allowing administrators to review the footage and adjust security measures."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "CSP_DIRECTIVES",
        "SECURITY_MONITORING"
      ]
    },
    {
      "question_text": "How does the <code>connect-src</code> directive in CSP differ from <code>default-src</code>?",
      "correct_answer": "<code>connect-src</code> specifically restricts connections made via interfaces like Fetch API, XHR, and WebSockets, while <code>default-src</code> acts as a fallback for all fetch directives not explicitly defined.",
      "distractors": [
        {
          "text": "<code>connect-src</code> controls image loading, while <code>default-src</code> controls script loading.",
          "misconception": "Targets [directive scope]: Incorrectly assigns image loading to `connect-src` and script loading to `default-src`."
        },
        {
          "text": "<code>connect-src</code> is used for HSTS enforcement, while <code>default-src</code> is for CSP.",
          "misconception": "Targets [feature confusion]: Confuses CSP directives with HSTS."
        },
        {
          "text": "<code>connect-src</code> only applies to same-origin connections, while <code>default-src</code> applies to all origins.",
          "misconception": "Targets [origin restriction]: Both directives can specify origins, and `connect-src` is not inherently limited to same-origin."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CSP uses specific directives for granular control. <code>connect-src</code> targets network connections (e.g., AJAX calls, WebSockets), whereas <code>default-src</code> provides a baseline for any fetch directive that doesn't have its own specific rule, ensuring a layered security approach.",
        "distractor_analysis": "The distractors incorrectly map directives to resource types, confuse CSP with HSTS, or misrepresent origin restrictions for <code>connect-src</code>.",
        "analogy": "If <code>default-src</code> is the general rule for entering any room in a building, <code>connect-src</code> is a specific rule for who can use the intercom system (network connections) to talk to other rooms."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "CSP_DIRECTIVES",
        "HTTP_APIS"
      ]
    },
    {
      "question_text": "What is the primary security concern addressed by the <code>X-Content-Type-Options: nosniff</code> header?",
      "correct_answer": "To prevent the browser from MIME-sniffing a response away from the declared content type, which can lead to XSS vulnerabilities.",
      "distractors": [
        {
          "text": "To prevent clickjacking by disallowing framing.",
          "misconception": "Targets [feature confusion]: Confuses with `X-Frame-Options` or CSP `frame-ancestors`."
        },
        {
          "text": "To enforce secure cookie transmission over HTTPS.",
          "misconception": "Targets [feature confusion]: Confuses with `Secure` flag on cookies or HSTS."
        },
        {
          "text": "To restrict the domains from which scripts can be loaded.",
          "misconception": "Targets [feature confusion]: Confuses with CSP's `script-src` directive."
        }
      ],
      "detailed_explanation": {
        "core_logic": "MIME-sniffing is a browser behavior where it tries to guess the content type if it's not explicitly declared. <code>X-Content-Type-Options: nosniff</code> disables this, forcing the browser to trust the <code>Content-Type</code> header, thus preventing attackers from tricking the browser into executing malicious content as if it were a different type (e.g., an image as a script).",
        "distractor_analysis": "The distractors incorrectly link this header to clickjacking prevention, secure cookie transmission, or script source restrictions, which are handled by other security headers or mechanisms.",
        "analogy": "The <code>X-Content-Type-Options: nosniff</code> header is like a strict librarian who only allows books (content) to be categorized and read according to their official title (Content-Type), preventing misfiling that could lead to reading inappropriate material (XSS)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "MIME_SNIFFING",
        "XSS_PREVENTION"
      ]
    },
    {
      "question_text": "Which of the following is a recommended best practice for deploying HSTS?",
      "correct_answer": "Start with a short <code>max-age</code> and gradually increase it after verifying no functionality is broken, and include the <code>includeSubDomains</code> directive if applicable.",
      "distractors": [
        {
          "text": "Immediately set a very long <code>max-age</code> (e.g., 2 years) to maximize protection.",
          "misconception": "Targets [deployment risk]: A long `max-age` makes it hard to revert if issues arise; gradual rollout is safer."
        },
        {
          "text": "Only deploy HSTS for the main domain and not for any subdomains.",
          "misconception": "Targets [incompleteness]: Subdomains can be attack vectors; `includeSubDomains` is a best practice for comprehensive security."
        },
        {
          "text": "Deploy HSTS only on development environments to test its impact.",
          "misconception": "Targets [environment mismatch]: HSTS is a production security feature; testing should be done carefully in staging/production."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A phased deployment of HSTS, starting with a short <code>max-age</code> and then increasing it, allows for safe testing and rollback if issues occur. Including <code>includeSubDomains</code> ensures consistent HTTPS enforcement across the entire domain structure, as recommended by security best practices.",
        "distractor_analysis": "The distractors suggest risky immediate long-term deployment, incomplete subdomain coverage, and incorrect environment targeting, all of which deviate from safe and effective HSTS implementation strategies.",
        "analogy": "Deploying HSTS is like gradually increasing the security level of a building's access control: start with temporary measures, ensure everything works, then implement permanent, stricter controls for all areas."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "HSTS_DEPLOYMENT",
        "PRODUCTION_SECURITY"
      ]
    },
    {
      "question_text": "What is the primary goal of the OWASP Secure Headers Project?",
      "correct_answer": "To raise awareness and provide guidance on implementing HTTP response headers that enhance web application security.",
      "distractors": [
        {
          "text": "To develop new browser security features like CSP and HSTS.",
          "misconception": "Targets [project scope]: OWASP provides guidance on *using* existing headers, not developing browser features."
        },
        {
          "text": "To enforce strict security policies on all web servers globally.",
          "misconception": "Targets [enforcement vs. guidance]: OWASP is a guidance and awareness organization, not an enforcement body."
        },
        {
          "text": "To provide a free, open-source web application firewall (WAF).",
          "misconception": "Targets [tool type confusion]: While OWASP has many tools, the Secure Headers Project focuses on HTTP headers, not WAFs."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The OWASP Secure Headers Project aims to educate developers about the security benefits of HTTP response headers like CSP, HSTS, and X-Frame-Options. It provides best practices, tools, and statistics to encourage their adoption and proper implementation, thereby improving overall web security.",
        "distractor_analysis": "The distractors misrepresent the project's scope by suggesting it develops browser features, enforces policies, or provides a WAF, rather than focusing on guidance and awareness for HTTP headers.",
        "analogy": "The OWASP Secure Headers Project is like a security consultant providing a checklist and best practices guide for securing a building's doors and windows (HTTP headers) to prevent unauthorized entry."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "OWASP_PROJECTS",
        "HTTP_HEADERS"
      ]
    },
    {
      "question_text": "Consider a scenario where a web application relies heavily on third-party scripts for analytics and ads. Which CSP directive is most critical to configure correctly to prevent these scripts from executing if compromised?",
      "correct_answer": "<code>script-src</code>",
      "distractors": [
        {
          "text": "<code>img-src</code>",
          "misconception": "Targets [resource type confusion]: `img-src` controls image loading, not script execution."
        },
        {
          "text": "<code>style-src</code>",
          "misconception": "Targets [resource type confusion]: `style-src` controls CSS, not script execution."
        },
        {
          "text": "<code>font-src</code>",
          "misconception": "Targets [resource type confusion]: `font-src` controls font loading, not script execution."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>script-src</code> directive is paramount for controlling which JavaScript sources are allowed to execute. By carefully specifying trusted domains for third-party scripts, developers can significantly reduce the risk of XSS attacks if those third-party sources are compromised.",
        "distractor_analysis": "The distractors incorrectly identify directives for images, styles, and fonts as critical for controlling script execution, highlighting a misunderstanding of CSP's granular control over different resource types.",
        "analogy": "In a factory assembly line (web page), <code>script-src</code> is the specific control that dictates which external suppliers (third-party scripts) are allowed to provide essential components (code) for the product."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "CSP_DIRECTIVES",
        "THIRD_PARTY_RISKS"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Browser Security Features (CSP, SameSite, HSTS) Software Development Security best practices",
    "latency_ms": 26287.863999999998
  },
  "timestamp": "2026-01-18T10:49:33.664730"
}