{
  "topic_title": "009_Public Key Infrastructure (PKI) Design",
  "category": "Software Development Security - Software Development Lifecycle (SDLC)",
  "flashcards": [
    {
      "question_text": "What is the primary function of a Certificate Authority (CA) within a Public Key Infrastructure (PKI)?",
      "correct_answer": "To issue and manage digital certificates, vouching for the identity of entities.",
      "distractors": [
        {
          "text": "To encrypt sensitive data transmitted over a network.",
          "misconception": "Targets [role confusion]: Confuses CA with encryption services or key usage."
        },
        {
          "text": "To store and retrieve private keys for users.",
          "misconception": "Targets [security principle violation]: CA should never store or manage private keys."
        },
        {
          "text": "To perform cryptographic hashing of data for integrity checks.",
          "misconception": "Targets [functional overlap]: Mixes CA role with hashing functions."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A Certificate Authority (CA) is a trusted entity that issues digital certificates, which bind a public key to an identity. This process works by verifying the identity of the requestor and then digitally signing the certificate, thereby vouching for its authenticity. This is foundational for establishing trust in PKI.",
        "distractor_analysis": "The first distractor confuses the CA's role with encryption itself. The second distractor describes a critical security failure, as private keys must remain private. The third distractor conflates the CA's issuance role with data integrity functions.",
        "analogy": "Think of a CA as a passport office; it verifies your identity and issues a passport (digital certificate) that others can trust to confirm who you are."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PKI_BASICS",
        "CRYPTO_BASICS"
      ]
    },
    {
      "question_text": "According to NIST SP 800-57 Part 1 Rev. 5, what is a critical aspect of cryptographic key management?",
      "correct_answer": "Ensuring that cryptographic keys are protected throughout their lifecycle, from generation to destruction.",
      "distractors": [
        {
          "text": "Using the longest possible key lengths for all cryptographic algorithms.",
          "misconception": "Targets [optimization error]: Assumes longer is always better without considering performance and practicality."
        },
        {
          "text": "Sharing private keys among trusted team members for redundancy.",
          "misconception": "Targets [security principle violation]: Private keys must never be shared."
        },
        {
          "text": "Implementing key rotation only when a known compromise occurs.",
          "misconception": "Targets [reactive vs. proactive approach]: Key rotation should be proactive, not just reactive."
        }
      ],
      "detailed_explanation": {
        "core_logic": "NIST SP 800-57 Part 1 Rev. 5 emphasizes that effective key management involves protecting keys throughout their entire lifecycle. This includes secure generation, storage, distribution, usage, and destruction, because compromised keys undermine all cryptographic security. This lifecycle management is crucial for maintaining confidentiality and integrity.",
        "distractor_analysis": "The first distractor oversimplifies key length selection. The second describes a severe security breach. The third promotes a reactive security posture instead of a proactive one.",
        "analogy": "Key management is like managing a safe deposit box; you need to control who has the key, how it's stored, when it's used, and ensure it's securely disposed of when no longer needed."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PKI_BASICS",
        "NIST_SP800_57"
      ]
    },
    {
      "question_text": "What is the purpose of a Certificate Revocation List (CRL) in a PKI?",
      "correct_answer": "To provide a list of digital certificates that have been invalidated before their scheduled expiration date.",
      "distractors": [
        {
          "text": "To list all currently valid digital certificates issued by a CA.",
          "misconception": "Targets [scope confusion]: Reverses the purpose of a CRL, confusing it with a certificate directory."
        },
        {
          "text": "To store the public keys associated with expired certificates.",
          "misconception": "Targets [functionality confusion]: CRLs are for revocation, not storage of expired keys."
        },
        {
          "text": "To verify the integrity of the certificate chain from root to end-entity.",
          "misconception": "Targets [process confusion]: Certificate path validation is a separate process from CRL checking."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A Certificate Revocation List (CRL) is published by a Certificate Authority (CA) to inform relying parties about certificates that are no longer trustworthy, even if they have not yet expired. This is essential because a certificate might be compromised or its associated entity's status may change. Checking the CRL is a critical step in validating a certificate's current trustworthiness.",
        "distractor_analysis": "The first distractor describes a directory, not a revocation list. The second misattributes a storage function. The third confuses CRLs with certificate path validation, which is a related but distinct process.",
        "analogy": "A CRL is like a 'do not admit' list at an event; it tells you which previously issued passes (certificates) are no longer valid, even if they look legitimate."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PKI_BASICS",
        "CERTIFICATE_LIFECYCLE"
      ]
    },
    {
      "question_text": "In PKI design, what is the significance of the 'trust anchor'?",
      "correct_answer": "It is the root of trust, typically a self-signed root CA certificate, from which all other certificates in the chain derive their trust.",
      "distractors": [
        {
          "text": "It is the private key of the end-user's certificate.",
          "misconception": "Targets [role confusion]: Confuses the root of trust with an end-user's private key."
        },
        {
          "text": "It is the algorithm used for encrypting the certificate chain.",
          "misconception": "Targets [component confusion]: Mixes trust establishment with encryption algorithms."
        },
        {
          "text": "It is the server that hosts the Certificate Revocation List (CRL).",
          "misconception": "Targets [infrastructure confusion]: Confuses the root of trust with CRL distribution points."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The trust anchor, usually a root CA certificate, is the ultimate source of trust in a PKI. All other certificates in a chain are validated by tracing them back to this anchor. This works because the root CA's public key is pre-installed and trusted by relying parties, establishing a foundation for verifying the authenticity of intermediate and end-entity certificates.",
        "distractor_analysis": "The first distractor incorrectly identifies the trust anchor as a private key. The second confuses it with an encryption algorithm. The third misattributes it as a CRL hosting server.",
        "analogy": "The trust anchor is like the foundational cornerstone of a building; all other parts of the structure are built upon it and derive their stability from it."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PKI_BASICS",
        "CERTIFICATE_CHAINS"
      ]
    },
    {
      "question_text": "Which of the following best describes the role of a Registration Authority (RA) in a PKI?",
      "correct_answer": "To verify the identity of entities requesting digital certificates before they are issued by the Certificate Authority (CA).",
      "distractors": [
        {
          "text": "To encrypt and decrypt data using public and private keys.",
          "misconception": "Targets [functional overlap]: Confuses RA with cryptographic operations."
        },
        {
          "text": "To manage the lifecycle of digital certificates, including revocation.",
          "misconception": "Targets [role confusion]: This is primarily the CA's role, though RAs may initiate revocation requests."
        },
        {
          "text": "To provide secure storage for users' private keys.",
          "misconception": "Targets [security principle violation]: Private keys should not be managed by RAs or CAs."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A Registration Authority (RA) acts as an intermediary, performing identity vetting for certificate applicants before forwarding requests to the Certificate Authority (CA). This separation of duties enhances security because the CA doesn't directly interact with every applicant, reducing its attack surface. The RA's function is crucial for ensuring the integrity of the certificate issuance process.",
        "distractor_analysis": "The first distractor assigns cryptographic operations to the RA. The second assigns the CA's core certificate lifecycle management role. The third describes a dangerous practice of storing private keys.",
        "analogy": "An RA is like the admissions office at a university; they verify student identities and credentials before the registrar (CA) officially enrolls them."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PKI_BASICS",
        "CA_RA_ROLES"
      ]
    },
    {
      "question_text": "What is the primary security concern when designing a PKI for a software development lifecycle (SDLC)?",
      "correct_answer": "Ensuring the integrity and authenticity of code signing certificates used to verify software publishers.",
      "distractors": [
        {
          "text": "Protecting the confidentiality of user passwords stored by the PKI.",
          "misconception": "Targets [scope confusion]: PKI primarily deals with keys and certificates, not direct password management."
        },
        {
          "text": "Implementing strong access controls for the development environment's database.",
          "misconception": "Targets [domain confusion]: Focuses on general database security, not PKI-specific SDLC concerns."
        },
        {
          "text": "Ensuring the availability of the PKI services during peak development hours.",
          "misconception": "Targets [priority confusion]: While availability is important, integrity/authenticity of code signing is paramount for software security."
        }
      ],
      "detailed_explanation": {
        "core_logic": "In the SDLC, code signing certificates are vital because they assure users that the software comes from a legitimate publisher and has not been tampered with. Compromised code signing certificates can lead to widespread distribution of malicious software. Therefore, protecting their integrity and authenticity is a primary PKI design concern for software security.",
        "distractor_analysis": "The first distractor misattributes password management to PKI. The second focuses on general database security, not PKI's role in code integrity. The third prioritizes availability over the critical integrity aspect of code signing.",
        "analogy": "Code signing certificates are like a notary's seal on a legal document; they guarantee the document's origin and that it hasn't been altered, which is critical for trust in software."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "PKI_SDLC_INTEGRATION",
        "CODE_SIGNING"
      ]
    },
    {
      "question_text": "What is the main advantage of using a hierarchical PKI model?",
      "correct_answer": "It allows for a clear chain of trust and simplifies the management of trust relationships through intermediate CAs.",
      "distractors": [
        {
          "text": "It eliminates the need for Certificate Revocation Lists (CRLs).",
          "misconception": "Targets [functional misunderstanding]: Hierarchical models still require revocation mechanisms."
        },
        {
          "text": "It requires only one Certificate Authority (CA) to manage all certificates.",
          "misconception": "Targets [structural misunderstanding]: Hierarchical models typically involve multiple CAs (root and intermediates)."
        },
        {
          "text": "It automatically distributes public keys to all users without explicit exchange.",
          "misconception": "Targets [distribution mechanism confusion]: Key distribution still requires defined protocols."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A hierarchical PKI model establishes a clear chain of trust, starting from a root CA down through intermediate CAs to end-entity certificates. This structure simplifies trust management because relying parties only need to trust the root CA and verify the chain. Intermediate CAs delegate authority and distribute the management load, making the system scalable.",
        "distractor_analysis": "The first distractor incorrectly claims CRLs are unnecessary. The second misunderstands the multi-CA nature of hierarchical structures. The third misrepresents key distribution mechanisms.",
        "analogy": "A hierarchical PKI is like a corporate organizational chart; there's a CEO (root CA) who delegates authority to VPs (intermediate CAs), who then manage their respective departments (end-entities)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "PKI_MODELS",
        "CERTIFICATE_CHAINS"
      ]
    },
    {
      "question_text": "RFC 5280 defines the profile for X.509 certificates. What is a key requirement for certificate extensions?",
      "correct_answer": "Extensions provide additional information and capabilities beyond the basic certificate fields, such as Key Usage or Subject Alternative Name.",
      "distractors": [
        {
          "text": "Extensions are optional and can be ignored by relying parties.",
          "misconception": "Targets [compliance misunderstanding]: Certain extensions are critical and must be processed."
        },
        {
          "text": "Extensions are used solely for encrypting the certificate's content.",
          "misconception": "Targets [functional confusion]: Extensions serve various purposes, not just encryption."
        },
        {
          "text": "Extensions must be unique to each Certificate Authority (CA).",
          "misconception": "Targets [standardization misunderstanding]: Extensions are standardized, not CA-specific."
        }
      ],
      "detailed_explanation": {
        "core_logic": "RFC 5280 standardizes X.509 certificate extensions, which allow for richer information and functionality beyond basic fields like subject and issuer. These extensions, such as 'Key Usage' or 'Subject Alternative Name,' are critical for defining how a certificate can be used and for whom it is valid. Therefore, relying parties must interpret them correctly to ensure secure operations.",
        "distractor_analysis": "The first distractor incorrectly suggests extensions are ignorable. The second misrepresents their purpose as solely encryption. The third wrongly claims they are CA-specific rather than standardized.",
        "analogy": "Certificate extensions are like the specialized compartments or features on a multi-tool; they add specific functionalities (like defining allowed uses) beyond the basic blade (core certificate info)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PKI_STANDARDS",
        "RFC5280"
      ]
    },
    {
      "question_text": "Consider a scenario where a web server needs to authenticate itself to a client. Which PKI component is essential for this?",
      "correct_answer": "A TLS/SSL server certificate issued by a trusted Certificate Authority (CA).",
      "distractors": [
        {
          "text": "A client authentication certificate issued to the server.",
          "misconception": "Targets [role reversal]: Client authentication certificates are for clients, not servers authenticating themselves."
        },
        {
          "text": "A Certificate Revocation List (CRL) for the server's private key.",
          "misconception": "Targets [misapplication of CRL]: CRLs apply to certificates, not private keys directly."
        },
        {
          "text": "A self-signed certificate generated by the web server itself.",
          "misconception": "Targets [trust establishment failure]: Self-signed certificates are not trusted by default by clients."
        }
      ],
      "detailed_explanation": {
        "core_logic": "For a web server to authenticate itself to a client (e.g., in TLS/SSL), it must present a server certificate that has been issued and signed by a Certificate Authority (CA) trusted by the client's browser or operating system. This works because the client can verify the CA's signature on the server's certificate, confirming the server's identity and the certificate's validity. This establishes a secure channel.",
        "distractor_analysis": "The first distractor confuses client and server authentication roles. The second misapplies CRLs to private keys. The third describes a certificate that clients won't inherently trust.",
        "analogy": "The TLS/SSL server certificate is like the server's official ID badge, issued by a trusted authority (the CA), which the client checks to be sure they are talking to the real server."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "PKI_BASICS",
        "TLS_SSL"
      ]
    },
    {
      "question_text": "What is the primary risk associated with a compromised Root Certificate Authority (Root CA)?",
      "correct_answer": "The entire trust hierarchy built upon that Root CA becomes untrustworthy, potentially leading to widespread impersonation and fraud.",
      "distractors": [
        {
          "text": "Only the specific certificate issued by the compromised Root CA is invalidated.",
          "misconception": "Targets [scope of compromise]: Underestimates the cascading effect of a root compromise."
        },
        {
          "text": "The performance of all cryptographic operations within the PKI will degrade.",
          "misconception": "Targets [impact confusion]: Compromise affects trust, not necessarily cryptographic performance directly."
        },
        {
          "text": "The compromised Root CA will be unable to issue new certificates.",
          "misconception": "Targets [consequence confusion]: While it should stop issuing, the main issue is the trust already placed."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A Root CA is the ultimate trust anchor. If compromised, any certificate issued directly or indirectly by it (through intermediate CAs) can be forged. This means attackers could impersonate any entity using certificates derived from that root, undermining the entire PKI's integrity. Therefore, protecting the Root CA is paramount because its compromise invalidates the trust foundation.",
        "distractor_analysis": "The first distractor drastically underestimates the impact. The second incorrectly links compromise to performance degradation. The third focuses on a symptom rather than the core trust erosion.",
        "analogy": "A compromised Root CA is like the foundation of a building being declared unstable; the entire structure built upon it becomes unsafe and must be distrusted."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "evaluate",
      "prerequisites": [
        "PKI_HIERARCHY",
        "ROOT_CA_SECURITY"
      ]
    },
    {
      "question_text": "What is the purpose of the 'Subject Alternative Name' (SAN) extension in an X.509 certificate?",
      "correct_answer": "To specify multiple identities (e.g., domain names, IP addresses) that the certificate applies to, beyond the 'Common Name'.",
      "distractors": [
        {
          "text": "To define the cryptographic algorithm used for the certificate's signature.",
          "misconception": "Targets [functional confusion]: This information is typically in other fields or extensions."
        },
        {
          "text": "To list all Certificate Authorities (CAs) that have signed the certificate chain.",
          "misconception": "Targets [scope confusion]: This relates to certificate path validation, not SAN."
        },
        {
          "text": "To indicate the intended use of the certificate, such as code signing or email encryption.",
          "misconception": "Targets [misapplication of extension]: This is the role of the 'Key Usage' or 'Extended Key Usage' extensions."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The Subject Alternative Name (SAN) extension in X.509 certificates allows a single certificate to secure multiple hostnames or identities. This is crucial for modern web servers that may host multiple domains or subdomains under one IP address. It works by listing these alternative names, enabling the certificate to be valid for all of them, thereby simplifying certificate management and ensuring secure connections.",
        "distractor_analysis": "The first distractor assigns the role of algorithm specification. The second confuses SAN with certificate path information. The third misattributes the function of 'Key Usage' extensions.",
        "analogy": "The SAN is like a business owner's business card listing multiple company names they represent; it allows them to act under any of those names."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PKI_STANDARDS",
        "RFC5280",
        "CERTIFICATE_EXTENSIONS"
      ]
    },
    {
      "question_text": "What is the main difference between a Cross-Certified PKI and a Hierarchical PKI?",
      "correct_answer": "Cross-certification establishes trust between separate PKI hierarchies, while hierarchical PKI defines a single, top-down trust structure.",
      "distractors": [
        {
          "text": "Cross-certification uses only self-signed certificates, while hierarchical uses CAs.",
          "misconception": "Targets [component confusion]: Both models utilize CAs, but establish trust differently."
        },
        {
          "text": "Hierarchical PKI is more secure because it has fewer trust points.",
          "misconception": "Targets [security assessment error]: Security depends on implementation, not just model structure."
        },
        {
          "text": "Cross-certification is used for internal networks, while hierarchical is for public trust.",
          "misconception": "Targets [application scope confusion]: Both can be used in various contexts."
        }
      ],
      "detailed_explanation": {
        "core_logic": "In a hierarchical PKI, trust flows downwards from a single root CA. In contrast, cross-certification involves two or more distinct PKI hierarchies establishing mutual trust through bilateral agreements, often represented by cross-certificates. This allows entities in different hierarchies to trust each other's certificates without a single overarching root, enabling interoperability between separate trust domains.",
        "distractor_analysis": "The first distractor incorrectly distinguishes components used. The second makes a generalization about security that isn't universally true. The third incorrectly limits the application scope of each model.",
        "analogy": "Hierarchical PKI is like a single kingdom with a king at the top. Cross-certification is like two independent kingdoms signing a treaty to recognize each other's citizens' passports."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "PKI_MODELS",
        "TRUST_ESTABLISHMENT"
      ]
    },
    {
      "question_text": "What is the role of Online Certificate Status Protocol (OCSP) in PKI?",
      "correct_answer": "To provide real-time status information about a specific digital certificate's validity.",
      "distractors": [
        {
          "text": "To issue new digital certificates to users.",
          "misconception": "Targets [functional confusion]: OCSP is for status checking, not issuance."
        },
        {
          "text": "To store all revoked certificates from a Certificate Authority (CA).",
          "misconception": "Targets [scope confusion]: OCSP checks status; CRLs store lists of revoked certs."
        },
        {
          "text": "To encrypt the communication channel between the client and server.",
          "misconception": "Targets [protocol confusion]: This is the role of TLS/SSL, not OCSP."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Online Certificate Status Protocol (OCSP) allows a client to query an OCSP responder (often run by the CA) in real-time to determine if a specific certificate is still valid or has been revoked. This provides more immediate feedback than waiting for a CRL to be updated. It works by sending a request with the certificate's serial number and receiving a signed response indicating its status, which is crucial for secure communication.",
        "distractor_analysis": "The first distractor assigns certificate issuance to OCSP. The second confuses it with CRL functionality. The third misattributes the role of TLS/SSL.",
        "analogy": "OCSP is like asking a security guard at a venue if a specific guest's ticket is still valid, rather than checking a list of all invalid tickets (CRL)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PKI_BASICS",
        "CERTIFICATE_VALIDATION"
      ]
    },
    {
      "question_text": "When designing a PKI for secure software updates, what is a critical consideration regarding the signing keys?",
      "correct_answer": "The signing keys must be generated, stored, and used in a highly secure environment, such as a Hardware Security Module (HSM).",
      "distractors": [
        {
          "text": "The signing keys should be regularly backed up to a cloud storage service.",
          "misconception": "Targets [security risk]: Cloud storage may not offer the required level of security for highly sensitive signing keys."
        },
        {
          "text": "The signing keys can be stored alongside the application code for easy access.",
          "misconception": "Targets [fundamental security failure]: Storing signing keys with code is extremely insecure."
        },
        {
          "text": "The signing keys should be generated using standard laptop hardware.",
          "misconception": "Targets [inadequate security measures]: Standard hardware is insufficient for generating high-assurance signing keys."
        }
      ],
      "detailed_explanation": {
        "core_logic": "For secure software updates, the integrity of the update package is paramount, guaranteed by digital signatures. The keys used for these signatures must be protected rigorously because their compromise allows attackers to distribute malicious updates. Using a Hardware Security Module (HSM) provides a tamper-resistant environment for key generation, storage, and cryptographic operations, ensuring the integrity of the signing process.",
        "distractor_analysis": "The first distractor suggests an insecure backup method. The second describes a critical vulnerability. The third proposes an insufficient method for key generation.",
        "analogy": "The signing keys are like the master stamp used to authenticate official documents; it must be kept in a highly secure vault, not left on a desk."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "PKI_SDLC_INTEGRATION",
        "CODE_SIGNING",
        "HSM"
      ]
    },
    {
      "question_text": "What is the primary function of a Public Key Infrastructure (PKI) in software development security?",
      "correct_answer": "To establish and manage trust by binding identities to public keys through digital certificates.",
      "distractors": [
        {
          "text": "To directly encrypt all source code to prevent unauthorized access.",
          "misconception": "Targets [scope confusion]: PKI is about trust and identity, not direct source code encryption."
        },
        {
          "text": "To manage user authentication credentials like passwords and multi-factor tokens.",
          "misconception": "Targets [functional overlap]: While related to authentication, PKI's core is identity-to-key binding, not credential management itself."
        },
        {
          "text": "To automatically patch vulnerabilities in deployed applications.",
          "misconception": "Targets [domain confusion]: PKI is not an automated patching system."
        }
      ],
      "detailed_explanation": {
        "core_logic": "PKI provides the framework for establishing trust in digital communications and transactions. It works by using Certificate Authorities (CAs) to issue digital certificates that cryptographically link an entity's identity (e.g., a developer, a server) with its public key. This foundation of trust is essential for secure software development practices like code signing, secure communication protocols (TLS/SSL), and identity verification.",
        "distractor_analysis": "The first distractor misrepresents PKI's role in source code protection. The second confuses PKI with general credential management. The third assigns a function entirely outside PKI's scope.",
        "analogy": "PKI is like a global notary system for the digital world; it provides official, verifiable 'signatures' (certificates) that confirm who owns which digital 'identity' (public key)."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PKI_BASICS",
        "CRYPTO_BASICS"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "009_Public Key Infrastructure (PKI) Design Software Development Security best practices",
    "latency_ms": 26403.697
  },
  "timestamp": "2026-01-18T10:28:52.194545"
}