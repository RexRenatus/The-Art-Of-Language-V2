{
  "topic_title": "Content Security Policy (CSP)",
  "category": "Software Development Security - Software Development Lifecycle (SDLC)",
  "flashcards": [
    {
      "question_text": "What is the primary purpose of Content Security Policy (CSP) in web development security?",
      "correct_answer": "To mitigate the risk of certain security threats, primarily Cross-Site Scripting (XSS) and data injection attacks, by controlling the resources a browser is allowed to load.",
      "distractors": [
        {
          "text": "To enforce secure coding standards across all development teams.",
          "misconception": "Targets [scope confusion]: CSP is a browser-level enforcement mechanism, not a development standard."
        },
        {
          "text": "To encrypt all sensitive data transmitted between the client and server.",
          "misconception": "Targets [mechanism confusion]: Encryption (like TLS/SSL) handles data confidentiality; CSP controls resource loading."
        },
        {
          "text": "To automatically patch vulnerabilities in third-party libraries.",
          "misconception": "Targets [functionality confusion]: CSP does not patch code; it restricts what code can be executed or loaded."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CSP works by instructing the browser to block or restrict the loading of specific types of content, such as scripts or images, from untrusted sources. This is because it functions as a defense-in-depth mechanism, preventing malicious code injection.",
        "distractor_analysis": "The distractors incorrectly associate CSP with development standards, data encryption, or automated vulnerability patching, missing its core function of resource loading control.",
        "analogy": "Think of CSP as a strict bouncer at a club (the browser) who checks the ID of every guest (resource) trying to enter the party (web page) and only lets in those on the approved list."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "XSS_BASICS",
        "WEB_SECURITY_FUNDAMENTALS"
      ]
    },
    {
      "question_text": "How is a Content Security Policy (CSP) typically delivered to a web browser?",
      "correct_answer": "Via the <code>Content-Security-Policy</code> HTTP response header sent by the server.",
      "distractors": [
        {
          "text": "Through a JavaScript file included on every page.",
          "misconception": "Targets [delivery mechanism confusion]: CSP is a server-side instruction, not a client-side script."
        },
        {
          "text": "Embedded directly within the HTML <code>&amp;lt;meta&amp;gt;</code> tag's <code>content</code> attribute.",
          "misconception": "Targets [completeness confusion]: While `meta` tags can be used, they don't support all CSP features and the header is preferred."
        },
        {
          "text": "As a separate configuration file downloaded by the browser before page load.",
          "misconception": "Targets [protocol confusion]: CSP is part of the HTTP communication, not a standalone file download."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CSP is primarily delivered via the <code>Content-Security-Policy</code> HTTP response header. This allows the server to dictate browser behavior for resource loading, functioning as a critical security control.",
        "distractor_analysis": "Distractors incorrectly suggest JavaScript, limited meta tag usage, or separate files as primary delivery methods, overlooking the standard HTTP header approach.",
        "analogy": "It's like the server sending a detailed guest list and rules (CSP header) to the venue manager (browser) before the event (page load) begins."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "HTTP_BASICS",
        "CSP_DELIVERY"
      ]
    },
    {
      "question_text": "Which CSP directive is used to control the sources from which JavaScript can be loaded and executed?",
      "correct_answer": "<code>script-src</code>",
      "distractors": [
        {
          "text": "<code>default-src</code>",
          "misconception": "Targets [fallback confusion]: `default-src` acts as a fallback but `script-src` is specific to JavaScript."
        },
        {
          "text": "<code>object-src</code>",
          "misconception": "Targets [resource type confusion]: `object-src` controls plugins like Flash, not JavaScript."
        },
        {
          "text": "<code>connect-src</code>",
          "misconception": "Targets [connection type confusion]: `connect-src` restricts connections via APIs like `fetch` or `XHR`, not script execution."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>script-src</code> directive specifically governs the allowed sources for JavaScript. It functions by defining a whitelist of origins from which scripts can be loaded, thereby preventing execution from untrusted locations.",
        "distractor_analysis": "Each distractor represents a plausible but incorrect directive, targeting confusion with fallback directives, object/plugin controls, or network connection restrictions.",
        "analogy": "If the web page is a house, <code>script-src</code> is the rule that says only approved electricians (scripts) from specific supply companies (sources) are allowed to do work inside."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CSP_DIRECTIVES",
        "JAVASCRIPT_SECURITY"
      ]
    },
    {
      "question_text": "What is the main security benefit of using the <code>script-src &#x27;none&#x27;</code> directive in a CSP?",
      "correct_answer": "It completely prevents any JavaScript from being loaded or executed on the page.",
      "distractors": [
        {
          "text": "It allows JavaScript only from the same origin as the page.",
          "misconception": "Targets [source expression confusion]: `'self'` allows same-origin, while `'none'` blocks all."
        },
        {
          "text": "It blocks inline JavaScript but allows external scripts.",
          "misconception": "Targets [inline vs. external confusion]: `'none'` blocks both inline and external scripts."
        },
        {
          "text": "It disables JavaScript execution only for specific user roles.",
          "misconception": "Targets [access control confusion]: CSP is a browser policy, not a role-based access control mechanism."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Setting <code>script-src</code> to <code>&#x27;none&#x27;</code> effectively creates a whitelist with no entries, thus blocking all JavaScript execution. This functions as a strong defense against XSS by ensuring no script can run.",
        "distractor_analysis": "The distractors confuse <code>&#x27;none&#x27;</code> with <code>&#x27;self&#x27;</code>, misinterpret its effect on inline vs. external scripts, or wrongly attribute role-based access control capabilities to it.",
        "analogy": "It's like putting up a 'No Entry' sign for all JavaScript, ensuring absolutely no code runs, which is useful if the page doesn't require any scripts at all."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "CSP_SCRIPT_SRC",
        "XSS_MITIGATION"
      ]
    },
    {
      "question_text": "Why is it generally recommended to avoid inline JavaScript and inline event handlers when using CSP?",
      "correct_answer": "Inline scripts and event handlers are harder to manage with CSP whitelisting and can be exploited if not carefully handled, often requiring <code>&#x27;unsafe-inline&#x27;</code> or <code>&#x27;unsafe-hashes&#x27;</code>, which weaken security.",
      "distractors": [
        {
          "text": "Inline scripts are inherently slower to execute than external scripts.",
          "misconception": "Targets [performance confusion]: CSP's concern is security, not direct performance impact of inline vs. external scripts."
        },
        {
          "text": "Modern browsers do not support inline JavaScript for security reasons.",
          "misconception": "Targets [browser support confusion]: Browsers support inline scripts but CSP can block them by default."
        },
        {
          "text": "Inline scripts increase the overall page size, impacting load times.",
          "misconception": "Targets [size vs. security confusion]: While true, the primary CSP concern is security, not page size optimization."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CSP aims to prevent XSS by restricting script sources. Inline scripts and event handlers are difficult to whitelist securely without resorting to less secure options like <code>&#x27;unsafe-inline&#x27;</code>. Therefore, using <code>addEventListener</code> with external scripts is the preferred, more secure approach.",
        "distractor_analysis": "Distractors focus on performance, browser support, or page size, which are secondary concerns compared to the security implications CSP addresses regarding inline code.",
        "analogy": "Trying to secure a house by listing every single item inside (inline scripts) is much harder than just securing the doors and windows (external script sources)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "CSP_INLINE_SCRIPTS",
        "JAVASCRIPT_SECURITY"
      ]
    },
    {
      "question_text": "What is the purpose of the <code>frame-ancestors</code> directive in CSP?",
      "correct_answer": "To control which origins are allowed to embed the page within a frame (e.g., <code>&lt;iframe&gt;</code>, <code>&lt;frame&gt;</code>).",
      "distractors": [
        {
          "text": "To specify allowed sources for images and favicons.",
          "misconception": "Targets [resource type confusion]: This is the function of `img-src`."
        },
        {
          "text": "To restrict connections made by JavaScript to other domains.",
          "misconception": "Targets [connection type confusion]: This is the function of `connect-src`."
        },
        {
          "text": "To define valid sources for web workers and nested browsing contexts.",
          "misconception": "Targets [nesting level confusion]: This is primarily handled by `child-src`."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>frame-ancestors</code> directive functions as a modern replacement for the <code>X-Frame-Options</code> header. It controls which external sites can embed the current page, thereby mitigating clickjacking attacks.",
        "distractor_analysis": "The distractors incorrectly assign the roles of image loading, JavaScript connections, or web worker sources to the <code>frame-ancestors</code> directive.",
        "analogy": "It's like setting rules for who can put up posters of your building (your page) on their own bulletin boards (other websites); <code>frame-ancestors</code> dictates which bulletin boards are allowed."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CSP_FRAME_ANCESTORS",
        "CLICKJACKING_MITIGATION"
      ]
    },
    {
      "question_text": "Consider a CSP policy: <code>Content-Security-Policy: default-src &#x27;self&#x27;; img-src &#x27;self&#x27; https://cdn.example.com;</code> What does this policy allow regarding images?",
      "correct_answer": "Images can be loaded from the same origin as the page and from <code>https://cdn.example.com</code>.",
      "distractors": [
        {
          "text": "Images can only be loaded from the same origin as the page.",
          "misconception": "Targets [directive specificity confusion]: Overlooks the explicit `img-src` directive and its additional source."
        },
        {
          "text": "Images can be loaded from any source, as <code>default-src</code> applies.",
          "misconception": "Targets [directive precedence confusion]: `img-src` overrides `default-src` for images."
        },
        {
          "text": "Images can be loaded from the same origin and any subdomain of <code>example.com</code>.",
          "misconception": "Targets [source expression interpretation]: `https://cdn.example.com` is a specific host, not a wildcard for subdomains."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>img-src</code> directive specifically allows images from <code>&#x27;self&#x27;</code> (the same origin) and <code>https://cdn.example.com</code>. Since <code>img-src</code> is more specific than <code>default-src</code>, it takes precedence for image loading.",
        "distractor_analysis": "Distractors incorrectly assume <code>default-src</code> applies universally, ignore the specific <code>img-src</code> directive, or misinterpret the source expression for <code>cdn.example.com</code>.",
        "analogy": "The policy says the house (page) can get its own supplies ('self') and also supplies from 'Warehouse A' (<code>https://cdn.example.com</code>), but not from anywhere else for images."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "CSP_DIRECTIVES",
        "CSP_SOURCE_EXPRESSIONS"
      ]
    },
    {
      "question_text": "What is the role of the <code>report-uri</code> or <code>report-to</code> directive in CSP?",
      "correct_answer": "To specify a URL where the browser should send violation reports when a policy is broken.",
      "distractors": [
        {
          "text": "To automatically correct policy violations before they occur.",
          "misconception": "Targets [enforcement vs. reporting confusion]: CSP reports violations; it doesn't auto-correct."
        },
        {
          "text": "To define the default policy for all resource types.",
          "misconception": "Targets [directive function confusion]: This is the role of `default-src`."
        },
        {
          "text": "To allow specific inline scripts using cryptographic hashes.",
          "misconception": "Targets [allowlisting mechanism confusion]: This relates to `'unsafe-hashes'`, not reporting."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>report-uri</code> (older) or <code>report-to</code> (newer) directives function by instructing the browser to send a JSON-formatted report to a specified endpoint whenever a CSP violation occurs. This enables developers to monitor and refine their policies.",
        "distractor_analysis": "Distractors confuse reporting with auto-correction, default policy setting, or specific allowlisting mechanisms, missing the diagnostic purpose of these directives.",
        "analogy": "It's like setting up a security camera (reporting endpoint) that records any time someone tries to enter a restricted area (policy violation) so you can review the footage later."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CSP_REPORTING",
        "SECURITY_MONITORING"
      ]
    },
    {
      "question_text": "Which of the following is a key advantage of using CSP over older security headers like <code>X-Frame-Options</code>?",
      "correct_answer": "CSP offers more granular control over various resource types and includes a reporting mechanism for violations.",
      "distractors": [
        {
          "text": "CSP is simpler to configure and requires fewer directives.",
          "misconception": "Targets [complexity confusion]: CSP is generally more complex due to its extensive directives."
        },
        {
          "text": "CSP provides stronger encryption for all transmitted data.",
          "misconception": "Targets [scope confusion]: CSP is about resource loading control, not data encryption (which is TLS/SSL's role)."
        },
        {
          "text": "CSP is universally supported by all browsers, including very old ones.",
          "misconception": "Targets [compatibility confusion]: While widely supported, older browsers may have limited or no CSP support."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CSP provides a comprehensive framework with numerous directives (<code>script-src</code>, <code>img-src</code>, <code>frame-ancestors</code>, etc.) for fine-grained control, unlike the more limited <code>X-Frame-Options</code>. The reporting feature also aids in policy refinement, functioning as a crucial diagnostic tool.",
        "distractor_analysis": "Distractors incorrectly claim CSP is simpler, provides encryption, or has universal legacy support, overlooking its granular control and reporting capabilities as key advantages.",
        "analogy": "Comparing <code>X-Frame-Options</code> to a single lock on a door, CSP is like a multi-point locking system with cameras and an alarm, offering much more sophisticated security."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "CSP_VS_XFRAMEOPTIONS",
        "WEB_SECURITY_HEADERS"
      ]
    },
    {
      "question_text": "A website developer implements a CSP that includes <code>script-src &#x27;self&#x27;</code>. What is the potential risk if the website has a vulnerability allowing an attacker to inject a script tag pointing to an external malicious domain?",
      "correct_answer": "The injected script will be blocked by the CSP because it violates the <code>&#x27;self&#x27;</code> source restriction.",
      "distractors": [
        {
          "text": "The injected script will execute because CSP only blocks inline scripts.",
          "misconception": "Targets [inline vs. external confusion]: CSP blocks external scripts if they don't match the source list."
        },
        {
          "text": "The CSP will automatically sanitize the malicious script before execution.",
          "misconception": "Targets [sanitization vs. blocking confusion]: CSP blocks, it does not sanitize or modify scripts."
        },
        {
          "text": "The CSP will report the violation but still allow the script to execute.",
          "misconception": "Targets [reporting vs. enforcement confusion]: CSP enforces the policy; reporting is a secondary function."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>script-src &#x27;self&#x27;</code> policy explicitly allows scripts only from the same origin. An attacker injecting a script from an external domain violates this rule. Therefore, the browser, enforcing the CSP, will block the malicious script's execution.",
        "distractor_analysis": "Distractors incorrectly assume CSP only blocks inline scripts, performs sanitization, or allows execution despite violations, misunderstanding the blocking enforcement mechanism.",
        "analogy": "The policy says only family members ('self') can enter the house. If a stranger (malicious script) tries to enter from outside, they are denied entry, even if they announce themselves."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "CSP_SCRIPT_SRC",
        "XSS_ATTACK_VECTORS"
      ]
    },
    {
      "question_text": "What is the primary security concern addressed by the <code>object-src</code> directive in CSP?",
      "correct_answer": "Preventing the execution of potentially malicious plugins like Flash, Java applets, or other embedded objects.",
      "distractors": [
        {
          "text": "Controlling the loading of images and media files.",
          "misconception": "Targets [resource type confusion]: This is handled by `img-src` and `media-src`."
        },
        {
          "text": "Restricting the use of WebAssembly modules.",
          "misconception": "Targets [modern technology confusion]: While related to executable content, `object-src` is primarily for legacy plugins."
        },
        {
          "text": "Limiting the number of concurrent network connections.",
          "misconception": "Targets [network control confusion]: This is not a function of `object-src`."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>object-src</code> directive functions by restricting the sources from which <code>&lt;object&gt;</code> and <code>&lt;embed&gt;</code> elements can be loaded. This is crucial because these elements historically hosted plugins (like Flash) which were frequent targets for exploits.",
        "distractor_analysis": "Distractors confuse <code>object-src</code> with directives for images, media, WebAssembly, or network connections, failing to recognize its focus on legacy plugin security.",
        "analogy": "It's like locking away old, potentially dangerous tools (plugins) in a cabinet (<code>object-src</code> policy) so they can't be misused on the workshop floor (web page)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CSP_OBJECT_SRC",
        "LEGACY_PLUGIN_SECURITY"
      ]
    },
    {
      "question_text": "When migrating to a strict CSP, why is it often recommended to start with a <code>Content-Security-Policy-Report-Only</code> header?",
      "correct_answer": "To monitor potential violations and gather data without actually blocking resources, allowing for policy refinement.",
      "distractors": [
        {
          "text": "To ensure the CSP is correctly formatted before deployment.",
          "misconception": "Targets [validation vs. reporting confusion]: While format is checked, the main benefit is observing violations."
        },
        {
          "text": "To bypass CSP restrictions temporarily during development.",
          "misconception": "Targets [intent confusion]: Report-Only mode is for monitoring, not bypassing security."
        },
        {
          "text": "To automatically generate the correct CSP based on observed traffic.",
          "misconception": "Targets [automation confusion]: It reports violations; it doesn't automatically generate the policy."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>Report-Only</code> mode functions by sending violation reports to the configured endpoint but does not enforce the policy. This allows developers to identify legitimate resources that would be blocked by a strict policy, enabling them to adjust the policy safely before full enforcement.",
        "distractor_analysis": "Distractors misinterpret the purpose of Report-Only mode as simple format checking, temporary bypass, or automatic policy generation, missing its diagnostic and refinement role.",
        "analogy": "It's like testing a new security system by having it log all attempted breaches without sounding the alarm, so you can adjust the sensitivity before fully activating it."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "CSP_REPORTING",
        "CSP_DEPLOYMENT_STRATEGIES"
      ]
    },
    {
      "question_text": "What is the security implication of using the <code>&#x27;unsafe-eval&#x27;</code> source expression within a CSP <code>script-src</code> directive?",
      "correct_answer": "It allows the execution of JavaScript code generated dynamically via functions like <code>eval()</code>, which is a significant security risk.",
      "distractors": [
        {
          "text": "It enables the use of WebAssembly modules, enhancing performance.",
          "misconception": "Targets [technology confusion]: `'unsafe-eval'` relates to JavaScript string execution, not WebAssembly."
        },
        {
          "text": "It permits scripts to be loaded from any external domain.",
          "misconception": "Targets [scope confusion]: `'unsafe-eval'` affects script execution methods, not loading sources."
        },
        {
          "text": "It allows inline event handlers like <code>onclick</code> to be used.",
          "misconception": "Targets [specific feature confusion]: While related to dynamic code, `'unsafe-eval'` is distinct from `'unsafe-inline'` or `'unsafe-hashes'`."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>&#x27;unsafe-eval&#x27;</code> directive allows the browser to execute JavaScript code represented as strings, typically through functions like <code>eval()</code>. This is dangerous because it can be exploited by attackers to run arbitrary code, undermining the security goals of CSP.",
        "distractor_analysis": "Distractors confuse <code>&#x27;unsafe-eval&#x27;</code> with WebAssembly, external script loading, or inline event handlers, failing to grasp its specific risk related to dynamic code execution.",
        "analogy": "It's like allowing someone to write and immediately perform a play based on instructions they receive mid-performance (dynamic code via <code>eval</code>), which is risky if the instructions are malicious."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "defense",
      "bloom_level": "analyze",
      "prerequisites": [
        "CSP_UNSAFE_EVAL",
        "JAVASCRIPT_SECURITY_RISKS"
      ]
    },
    {
      "question_text": "How does CSP contribute to defense-in-depth for web applications?",
      "correct_answer": "By providing an additional layer of security that restricts browser behavior, complementing other security measures like input validation and authentication.",
      "distractors": [
        {
          "text": "By replacing the need for secure coding practices and input validation.",
          "misconception": "Targets [redundancy confusion]: CSP is a layer, not a replacement for fundamental secure coding."
        },
        {
          "text": "By encrypting all client-side code to prevent reverse engineering.",
          "misconception": "Targets [encryption vs. restriction confusion]: CSP restricts execution, it doesn't encrypt code."
        },
        {
          "text": "By automatically detecting and removing all malware from the server.",
          "misconception": "Targets [server-side vs. client-side confusion]: CSP operates in the browser, not on the server for malware removal."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CSP functions as a defense-in-depth strategy because it operates at the browser level, enforcing policies on resource loading and script execution. This complements server-side security measures by providing a crucial client-side safeguard against attacks like XSS.",
        "distractor_analysis": "Distractors incorrectly suggest CSP replaces secure coding, encrypts code, or performs server-side malware removal, misunderstanding its role as a complementary browser-enforced security layer.",
        "analogy": "It's like having both strong locks on your doors (server-side security) and a security guard inside your house (CSP) who checks everyone's credentials before letting them move around freely."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "DEFENSE_IN_DEPTH",
        "CSP_ROLE_IN_SDLC"
      ]
    },
    {
      "question_text": "Which CSP directive is essential for preventing clickjacking attacks by controlling where a page can be framed?",
      "correct_answer": "<code>frame-ancestors</code>",
      "distractors": [
        {
          "text": "<code>script-src</code>",
          "misconception": "Targets [directive scope confusion]: `script-src` controls JavaScript, not framing."
        },
        {
          "text": "<code>default-src</code>",
          "misconception": "Targets [specificity confusion]: `default-src` is a fallback; `frame-ancestors` is specific to framing."
        },
        {
          "text": "<code>connect-src</code>",
          "misconception": "Targets [connection type confusion]: `connect-src` controls network requests, not framing."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>frame-ancestors</code> directive specifically dictates which origins are permitted to embed the page using framing elements. By disallowing framing from untrusted sources, it effectively mitigates clickjacking attacks, functioning as a modern replacement for <code>X-Frame-Options</code>.",
        "distractor_analysis": "The distractors incorrectly assign the function of controlling JavaScript execution, default resource loading, or network connections to the <code>frame-ancestors</code> directive.",
        "analogy": "It's like putting up a sign on your shop window saying 'You can only display our advertisement in these specific approved locations', preventing others from framing your content maliciously."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "CSP_FRAME_ANCESTORS",
        "CLICKJACKING_MITIGATION"
      ]
    },
    {
      "question_text": "What is the primary function of the <code>manifest-src</code> directive in Content Security Policy?",
      "correct_answer": "To specify valid sources for application manifest files, which define how a web application is presented to the user (e.g., for Progressive Web Apps).",
      "distractors": [
        {
          "text": "To control the loading of images and favicons.",
          "misconception": "Targets [resource type confusion]: This is the role of `img-src`."
        },
        {
          "text": "To restrict the sources of scripts that can be executed.",
          "misconception": "Targets [resource type confusion]: This is the role of `script-src`."
        },
        {
          "text": "To define allowed origins for WebSocket connections.",
          "misconception": "Targets [resource type confusion]: This is the role of `connect-src` or `ws-src`/`wss-src`."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>manifest-src</code> directive functions by whitelisting the sources from which application manifest files can be loaded. These manifests are crucial for Progressive Web Apps (PWAs) to define their offline capabilities and installation behavior.",
        "distractor_analysis": "Distractors incorrectly associate <code>manifest-src</code> with image loading, script execution, or WebSocket connections, failing to recognize its specific purpose for application manifest files.",
        "analogy": "It's like specifying which official blueprint providers (manifest sources) are allowed to supply the plans for building your house (web application)."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CSP_MANIFEST_SRC",
        "PWA_SECURITY"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 16,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Content Security Policy (CSP) Software Development Security best practices",
    "latency_ms": 27967.889
  },
  "timestamp": "2026-01-18T10:32:57.075747"
}