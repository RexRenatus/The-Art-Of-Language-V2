{
  "topic_title": "Kubernetes Network Policies",
  "category": "Software Development Security - Software Development Lifecycle (SDLC)",
  "flashcards": [
    {
      "question_text": "What is the primary function of Kubernetes Network Policies?",
      "correct_answer": "To control traffic flow at the IP address or port level (OSI layer 3 or 4) between pods and external entities.",
      "distractors": [
        {
          "text": "To manage application-level routing and load balancing.",
          "misconception": "Targets [layer confusion]: Confuses network layer control with application layer services like Ingress or Service."
        },
        {
          "text": "To enforce authentication and authorization for API server access.",
          "misconception": "Targets [security domain confusion]: Mixes network traffic control with API access control mechanisms."
        },
        {
          "text": "To define resource quotas and limits for pods and namespaces.",
          "misconception": "Targets [resource management confusion]: Equates network policy with Kubernetes resource management concepts."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Kubernetes Network Policies function by defining rules that govern network traffic at the IP and port level, thereby controlling communication between pods and external services. This is crucial because, by default, Kubernetes clusters have a flat network model where all pods can communicate freely.",
        "distractor_analysis": "The distractors incorrectly suggest Network Policies handle application-level routing, API authentication, or resource quotas, which are distinct Kubernetes functionalities.",
        "analogy": "Think of Network Policies as a sophisticated firewall for your Kubernetes pods, dictating exactly who can talk to whom and on which 'phone lines' (ports)."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "K8S_PODS",
        "K8S_NAMESPACES",
        "OSI_MODEL"
      ]
    },
    {
      "question_text": "Which OSI layer do Kubernetes Network Policies primarily operate on?",
      "correct_answer": "Layer 3 (Network) and Layer 4 (Transport).",
      "distractors": [
        {
          "text": "Layer 7 (Application).",
          "misconception": "Targets [layer confusion]: Assumes policies operate at the application data level, like HTTP headers."
        },
        {
          "text": "Layer 2 (Data Link).",
          "misconception": "Targets [layer confusion]: Confuses network policies with MAC address-based controls or switch-level operations."
        },
        {
          "text": "Layer 1 (Physical).",
          "misconception": "Targets [layer confusion]: Incorrectly associates network policies with physical network infrastructure."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Network Policies operate at OSI layers 3 and 4 because they control traffic based on IP addresses and port numbers, which are fundamental to network and transport layer operations. This allows for granular control over pod-to-pod and pod-to-external communication.",
        "distractor_analysis": "The distractors incorrectly place Network Policy functionality at higher or lower OSI layers, misunderstanding their scope of IP and port-based traffic control.",
        "analogy": "It's like setting rules for which streets (Layer 3) and which building entrances (Layer 4) people can use to get around a city, rather than dictating what they do inside the buildings (Layer 7)."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "OSI_MODEL"
      ]
    },
    {
      "question_text": "What is a prerequisite for Kubernetes Network Policies to function within a cluster?",
      "correct_answer": "The cluster must use a network plugin (CNI) that supports NetworkPolicy enforcement.",
      "distractors": [
        {
          "text": "All pods must be running the same container runtime.",
          "misconception": "Targets [irrelevant dependency]: Container runtime is not directly related to NetworkPolicy enforcement."
        },
        {
          "text": "The cluster must have a service mesh like Istio or Linkerd installed.",
          "misconception": "Targets [optional integration confusion]: Service meshes can enhance security but are not a prerequisite for NetworkPolicy."
        },
        {
          "text": "All namespaces must be explicitly configured with default deny policies.",
          "misconception": "Targets [configuration error]: Default deny is a best practice, not a functional prerequisite for the policy mechanism itself."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Network Policies are implemented by the Container Network Interface (CNI) plugin. Therefore, the cluster's CNI must support NetworkPolicy enforcement for these policies to have any effect, as the CNI is responsible for enforcing the defined rules.",
        "distractor_analysis": "The distractors suggest unrelated prerequisites like container runtime consistency, mandatory service mesh installation, or pre-configured default deny policies, none of which are fundamental requirements for NetworkPolicy functionality.",
        "analogy": "You can't use a specific type of lock (Network Policy) if the door frame (CNI plugin) isn't built to accommodate it."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "K8S_CNI"
      ]
    },
    {
      "question_text": "How does a pod's <code>podSelector</code> in a NetworkPolicy resource affect its application?",
      "correct_answer": "It selects the pods to which the NetworkPolicy rules will apply.",
      "distractors": [
        {
          "text": "It determines the egress traffic allowed from the pod.",
          "misconception": "Targets [selector vs rule confusion]: Confuses the selection mechanism with the traffic rules themselves."
        },
        {
          "text": "It specifies the namespaces that the pod can communicate with.",
          "misconception": "Targets [selector vs namespace scope]: Misunderstands that `podSelector` targets pods, not namespaces directly."
        },
        {
          "text": "It defines the IP blocks that are permitted to access the pod.",
          "misconception": "Targets [selector vs IP block scope]: Equates pod selection with IP-based access control."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>podSelector</code> within a NetworkPolicy resource uses label selectors to identify and target specific pods. Any pod matching these labels will have the NetworkPolicy's ingress and/or egress rules applied to it, thereby controlling its network interactions.",
        "distractor_analysis": "The distractors incorrectly assign the <code>podSelector</code>'s function to defining egress traffic, allowed namespaces, or permitted IP blocks, which are handled by other fields within the NetworkPolicy spec.",
        "analogy": "The <code>podSelector</code> is like an address label on an envelope; it tells you which specific recipient (pod) the message (policy) is intended for."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "K8S_LABELS",
        "K8S_NETWORKPOLICY_SPEC"
      ]
    },
    {
      "question_text": "What does an empty <code>podSelector</code> in a Kubernetes NetworkPolicy signify?",
      "correct_answer": "The policy applies to all pods within the policy's namespace.",
      "distractors": [
        {
          "text": "The policy applies to no pods and has no effect.",
          "misconception": "Targets [empty selector interpretation]: Incorrectly assumes an empty selector means no selection, rather than a wildcard."
        },
        {
          "text": "The policy applies only to pods without any labels.",
          "misconception": "Targets [label matching confusion]: Misinterprets 'empty' as 'no labels' rather than 'match all labels'."
        },
        {
          "text": "The policy applies to pods that are not selected by any other NetworkPolicy.",
          "misconception": "Targets [selector interaction confusion]: Assumes an empty selector interacts with other policies in a specific exclusion manner."
        }
      ],
      "detailed_explanation": {
        "core_logic": "An empty <code>podSelector</code> in a NetworkPolicy acts as a wildcard, matching all pods within the namespace where the policy is defined. This is because the absence of specific labels implies that no filtering should occur based on pod labels.",
        "distractor_analysis": "The distractors incorrectly interpret an empty <code>podSelector</code> as disabling the policy, targeting only unlabeled pods, or creating an exclusion based on other policies, rather than its intended function of selecting all pods in the namespace.",
        "analogy": "An empty <code>podSelector</code> is like a general announcement to everyone in a room, rather than a message directed to specific individuals."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "K8S_LABELS",
        "K8S_NAMESPACES",
        "K8S_NETWORKPOLICY_SPEC"
      ]
    },
    {
      "question_text": "Consider a pod that is isolated for ingress. What does this isolation mean?",
      "correct_answer": "No ingress traffic is allowed to the pod unless explicitly permitted by an ingress rule in a NetworkPolicy that selects the pod.",
      "distractors": [
        {
          "text": "No egress traffic is allowed from the pod.",
          "misconception": "Targets [ingress/egress confusion]: Confuses ingress isolation with egress isolation."
        },
        {
          "text": "All ingress traffic is allowed by default.",
          "misconception": "Targets [default behavior misunderstanding]: Assumes default allows all traffic, contrary to isolation."
        },
        {
          "text": "Only traffic from pods within the same namespace is allowed.",
          "misconception": "Targets [scope misunderstanding]: Incorrectly limits allowed ingress to same-namespace traffic."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When a pod is isolated for ingress, it means that any incoming network traffic to that pod is denied by default. Only traffic explicitly allowed by an ingress rule in a NetworkPolicy that selects the pod will be permitted, effectively restricting incoming connections.",
        "distractor_analysis": "The distractors incorrectly describe egress isolation, assume default allowance of ingress traffic, or wrongly restrict ingress to only same-namespace traffic, all contrary to the definition of ingress isolation.",
        "analogy": "An ingress-isolated pod is like a secure facility with no public entrance; you can only get in if you have a specific, authorized pass (ingress rule)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "K8S_NETWORKPOLICY_INGRESS",
        "K8S_POD_ISOLATION"
      ]
    },
    {
      "question_text": "What is the default state of egress traffic for a pod in Kubernetes if no NetworkPolicies apply?",
      "correct_answer": "Egress traffic is non-isolated; all outbound connections are allowed.",
      "distractors": [
        {
          "text": "Egress traffic is isolated; all outbound connections are denied.",
          "misconception": "Targets [default isolation misunderstanding]: Assumes isolation is the default state for egress."
        },
        {
          "text": "Egress traffic is restricted to pods within the same namespace.",
          "misconception": "Targets [scope limitation]: Incorrectly assumes egress is limited to the local namespace by default."
        },
        {
          "text": "Egress traffic is allowed only to services defined in the cluster.",
          "misconception": "Targets [destination restriction]: Assumes egress is limited to internal cluster services by default."
        }
      ],
      "detailed_explanation": {
        "core_logic": "By default, Kubernetes pods are not isolated for egress traffic. This means that without any NetworkPolicies explicitly restricting outbound connections, a pod can initiate connections to any IP address or port, reflecting a permissive default stance.",
        "distractor_analysis": "The distractors incorrectly describe egress traffic as isolated by default, restricted to the same namespace, or limited to cluster services, contrary to the permissive default behavior.",
        "analogy": "By default, a pod can 'talk' to anyone on the internet without needing special permission, unless a policy is put in place to restrict its outgoing calls."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "K8S_NETWORKPOLICY_EGRESS",
        "K8S_POD_ISOLATION"
      ]
    },
    {
      "question_text": "When a pod is isolated for egress, what determines which outbound connections are allowed?",
      "correct_answer": "The <code>egress</code> list within any NetworkPolicy that selects the pod and has 'Egress' in its <code>policyTypes</code>.",
      "distractors": [
        {
          "text": "The <code>ingress</code> list within any NetworkPolicy that selects the pod.",
          "misconception": "Targets [ingress/egress rule confusion]: Confuses egress control with ingress rules."
        },
        {
          "text": "The <code>podSelector</code> of any NetworkPolicy that selects the pod.",
          "misconception": "Targets [selector vs rule confusion]: Equates the selection mechanism with the allowed traffic rules."
        },
        {
          "text": "The default egress policy of the cluster, regardless of specific pod policies.",
          "misconception": "Targets [policy precedence confusion]: Assumes cluster-wide defaults override specific pod policies."
        }
      ],
      "detailed_explanation": {
        "core_logic": "If a pod is isolated for egress, its outbound connections are governed by the <code>egress</code> rules defined in NetworkPolicies that apply to it. These policies must select the pod and explicitly include 'Egress' in their <code>policyTypes</code> to affect outbound traffic.",
        "distractor_analysis": "The distractors incorrectly point to ingress rules, the <code>podSelector</code> itself, or cluster-wide defaults as determinants of egress traffic, rather than the specific <code>egress</code> rules within applicable NetworkPolicies.",
        "analogy": "When a pod is egress-isolated, its outbound communication is like a phone plan with a pre-approved list of numbers it can call; only calls on that list are permitted."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "analyze",
      "prerequisites": [
        "K8S_NETWORKPOLICY_EGRESS",
        "K8S_POD_ISOLATION",
        "K8S_NETWORKPOLICY_SPEC"
      ]
    },
    {
      "question_text": "What is the role of <code>policyTypes</code> in a Kubernetes NetworkPolicy?",
      "correct_answer": "It specifies whether the policy applies to ingress traffic, egress traffic, or both.",
      "distractors": [
        {
          "text": "It defines the priority of the NetworkPolicy relative to others.",
          "misconception": "Targets [policy attribute confusion]: Misinterprets `policyTypes` as a mechanism for ordering policies."
        },
        {
          "text": "It lists the specific ports that the policy will affect.",
          "misconception": "Targets [port specification confusion]: Confuses policy type with port-level rules."
        },
        {
          "text": "It determines which namespaces the policy is enforced within.",
          "misconception": "Targets [namespace scope confusion]: Equates policy type with the scope of namespaces it covers."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>policyTypes</code> field in a NetworkPolicy explicitly declares whether the policy's rules are intended to affect ingress traffic, egress traffic, or both. This is crucial for defining the policy's scope and ensuring it's applied as intended.",
        "distractor_analysis": "The distractors incorrectly suggest <code>policyTypes</code> controls policy priority, lists specific ports, or defines namespace enforcement scope, which are handled by other aspects of NetworkPolicy or Kubernetes.",
        "analogy": "<code>policyTypes</code> is like specifying whether a security guard's instructions are for people entering a building (ingress), leaving a building (egress), or both."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "K8S_NETWORKPOLICY_SPEC"
      ]
    },
    {
      "question_text": "If a NetworkPolicy resource has ingress rules but no <code>policyTypes</code> field specified, what traffic does it affect?",
      "correct_answer": "It affects ingress traffic only, as policies default to affecting ingress if ingress rules exist.",
      "distractors": [
        {
          "text": "It affects egress traffic only.",
          "misconception": "Targets [default egress confusion]: Assumes absence of `policyTypes` defaults to egress."
        },
        {
          "text": "It affects both ingress and egress traffic.",
          "misconception": "Targets [default dual-policy confusion]: Assumes absence of `policyTypes` implies both ingress and egress."
        },
        {
          "text": "It affects no traffic, as <code>policyTypes</code> must be explicitly set.",
          "misconception": "Targets [default behavior misunderstanding]: Believes `policyTypes` is mandatory for any policy to function."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Kubernetes NetworkPolicies have a default behavior for <code>policyTypes</code>: if ingress rules are present, the policy is assumed to affect ingress traffic. If egress rules are present, it's assumed to affect egress. If only ingress rules exist and <code>policyTypes</code> is omitted, it defaults to <code>[&#x27;Ingress&#x27;]</code>.",
        "distractor_analysis": "The distractors incorrectly assume default application to egress traffic, both ingress and egress, or no traffic at all, failing to recognize the default behavior based on the presence of ingress rules.",
        "analogy": "If you give a guard instructions on how to let people *in* but don't mention anything about people *leaving*, they'll assume their job is only about managing entry."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "K8S_NETWORKPOLICY_SPEC",
        "K8S_NETWORKPOLICY_INGRESS"
      ]
    },
    {
      "question_text": "What are the three types of entities a Pod can communicate with, as identified by NetworkPolicy rules?",
      "correct_answer": "Other allowed pods, allowed namespaces, and IP blocks.",
      "distractors": [
        {
          "text": "Other pods, services, and ingress controllers.",
          "misconception": "Targets [Kubernetes object confusion]: Mixes network entities with specific Kubernetes service abstractions."
        },
        {
          "text": "Nodes, cluster IPs, and external IPs.",
          "misconception": "Targets [IP addressing confusion]: Focuses on IP types rather than the policy-defined entities."
        },
        {
          "text": "Pods in the same namespace, pods in other namespaces, and external networks.",
          "misconception": "Targets [namespace scope confusion]: Overly simplifies allowed entities based solely on namespace."
        }
      ],
      "detailed_explanation": {
        "core_logic": "NetworkPolicies define allowed communication by specifying three types of entities: other pods (identified by labels and namespaces), entire namespaces, and specific IP address blocks (CIDR ranges). These provide a flexible way to define network access controls.",
        "distractor_analysis": "The distractors incorrectly list Kubernetes-specific abstractions (services, ingress controllers), generic IP types, or simplified namespace-based categories instead of the three core entity types defined for NetworkPolicy.",
        "analogy": "When deciding who can visit your house (pod), you might allow specific friends (other pods), people from a certain club (namespaces), or anyone living within a particular neighborhood (IP blocks)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "K8S_NETWORKPOLICY_SPEC",
        "K8S_PODS",
        "K8S_NAMESPACES"
      ]
    },
    {
      "question_text": "How are IP-based NetworkPolicies defined?",
      "correct_answer": "By specifying IP blocks (CIDR ranges) in the policy rules.",
      "distractors": [
        {
          "text": "By using pod labels to match IP addresses.",
          "misconception": "Targets [label vs IP confusion]: Confuses label-based pod selection with IP-based network control."
        },
        {
          "text": "By referencing service names within the cluster.",
          "misconception": "Targets [service vs IP confusion]: Equates service discovery with direct IP address control."
        },
        {
          "text": "By defining rules based on node names.",
          "misconception": "Targets [node vs IP confusion]: Misunderstands that policies target pod IPs, not necessarily node identities."
        }
      ],
      "detailed_explanation": {
        "core_logic": "IP-based NetworkPolicies allow administrators to define access rules based on IP address ranges, typically specified using CIDR notation. This enables control over traffic originating from or destined for specific external networks or internal subnets.",
        "distractor_analysis": "The distractors incorrectly suggest using pod labels, service names, or node names to define IP-based policies, failing to recognize that CIDR blocks are the standard method for specifying IP ranges.",
        "analogy": "Defining an IP-based Network Policy is like drawing a fence around a specific neighborhood (CIDR block) on a map, dictating who can enter or leave that area."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "K8S_NETWORKPOLICY_SPEC",
        "CIDR_NOTATION"
      ]
    },
    {
      "question_text": "What is a common security best practice for Network Policies in Kubernetes, as recommended by sources like Microsoft Azure AKS?",
      "correct_answer": "Implement default network policies within each namespace that deny all ingress and egress traffic, then explicitly allow necessary communication.",
      "distractors": [
        {
          "text": "Allow all ingress and egress traffic by default and only block known malicious sources.",
          "misconception": "Targets [default security posture confusion]: Advocates a permissive default, contrary to the principle of least privilege."
        },
        {
          "text": "Apply Network Policies only to external-facing services to protect the perimeter.",
          "misconception": "Targets [scope limitation]: Ignores the importance of internal (lateral) traffic control."
        },
        {
          "text": "Use Network Policies solely for Layer 7 traffic filtering, ignoring IP/port controls.",
          "misconception": "Targets [layer confusion]: Misunderstands that Network Policies primarily operate at Layers 3/4."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A core security best practice is to adopt a 'default deny' stance. This involves creating Network Policies that block all traffic within a namespace by default and then creating specific policies to allow only the necessary communication paths, thereby enforcing the principle of least privilege.",
        "distractor_analysis": "The distractors suggest insecure defaults, limited scope to external traffic, or incorrect layer operation, all of which deviate from the recommended secure practice of default denial and explicit allowance.",
        "analogy": "It's like locking all doors in your house by default and only giving keys to specific rooms to authorized people, rather than leaving all doors unlocked and trying to catch intruders."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "K8S_NETWORKPOLICY_BESTPRACTICES",
        "LEAST_PRIVILEGE"
      ]
    },
    {
      "question_text": "Which of the following is NOT an exception to the general rules of Network Policy enforcement?",
      "correct_answer": "Traffic to and from pods running on the control plane nodes.",
      "distractors": [
        {
          "text": "A pod cannot block access to itself.",
          "misconception": "Targets [self-access rule]: Misremembers the rule that pods cannot deny their own traffic."
        },
        {
          "text": "Traffic to and from the node where a Pod is running is always allowed.",
          "misconception": "Targets [node traffic exception]: Misremembers the exception for traffic to/from the pod's host node."
        },
        {
          "text": "Traffic to and from the pod's local node is always allowed.",
          "misconception": "Targets [node traffic exception]: Similar to the above, but phrased slightly differently, still incorrect."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Network Policies always allow traffic to and from the node where a pod is running, regardless of IP address. Additionally, a pod cannot block access to itself. Traffic to control plane nodes is subject to Network Policy rules like any other traffic.",
        "distractor_analysis": "The distractors present incorrect exceptions or rephrase valid exceptions in a misleading way. The key is that traffic to control plane nodes is NOT an exception and is subject to policy.",
        "analogy": "Imagine a building's security system (Network Policy). It can't stop you from accessing your own office (self-access), and it generally allows movement within the same floor (node traffic), but it can restrict access to sensitive areas like the server room (control plane nodes)."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "K8S_NETWORKPOLICY_EXCEPTIONS",
        "K8S_CONTROL_PLANE"
      ]
    },
    {
      "question_text": "When multiple NetworkPolicies select the same set of pods, how are their ingress rules combined?",
      "correct_answer": "The ingress rules from all applicable NetworkPolicies are combined additively, meaning traffic is allowed if it matches at least one rule across any of the policies.",
      "distractors": [
        {
          "text": "The ingress rules are combined multiplicatively, requiring a match in all policies.",
          "misconception": "Targets [combination logic confusion]: Assumes a restrictive AND logic instead of permissive OR logic."
        },
        {
          "text": "Only the ingress rules from the most recently created policy are applied.",
          "misconception": "Targets [policy precedence confusion]: Believes policy order dictates application, not additive combination."
        },
        {
          "text": "The ingress rules are merged, and only rules present in all policies are effective.",
          "misconception": "Targets [restrictive merge confusion]: Assumes a restrictive intersection rather than an additive union."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When multiple NetworkPolicies target the same pods, their ingress rules are combined additively. This means a pod will allow traffic if it matches at least one ingress rule from any of the NetworkPolicies that select it, promoting a more permissive approach when multiple policies apply.",
        "distractor_analysis": "The distractors incorrectly describe the combination as multiplicative, based on creation order, or requiring rules present in all policies, failing to recognize the additive (OR logic) nature of combining ingress rules.",
        "analogy": "If multiple teachers give you permission slips for different activities, you can participate in any of those activities as long as you have at least one valid slip."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "K8S_NETWORKPOLICY_SPEC",
        "K8S_POLICY_COMBINATION"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Kubernetes Network Policies Software Development Security best practices",
    "latency_ms": 23882.0
  },
  "timestamp": "2026-01-18T10:35:04.490248"
}