{
  "topic_title": "CDN and External Script Risks",
  "category": "Software Development Security - Common Web Application Vulnerabilities",
  "flashcards": [
    {
      "question_text": "What is the primary security risk associated with loading JavaScript libraries from a Content Delivery Network (CDN)?",
      "correct_answer": "The CDN could be compromised, leading to the injection of malicious code into the served scripts.",
      "distractors": [
        {
          "text": "The script might be incompatible with the browser's rendering engine.",
          "misconception": "Targets [technical compatibility confusion]: Students confuse security risks with functional compatibility issues."
        },
        {
          "text": "The script's performance might be slower than self-hosting.",
          "misconception": "Targets [performance vs. security confusion]: Students prioritize performance over critical security implications."
        },
        {
          "text": "The script might violate the website's terms of service.",
          "misconception": "Targets [legal vs. security confusion]: Students confuse legal compliance with direct security threats."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Loading external scripts from a CDN introduces a supply chain risk because if the CDN is compromised, attackers can inject malicious code into the scripts, which are then served to users, potentially compromising the entire site.",
        "distractor_analysis": "The distractors focus on non-security issues like compatibility, performance, and legal terms, failing to address the core risk of a compromised third-party source.",
        "analogy": "It's like relying on a public water source for your home's drinking water; if that source is contaminated, your entire household is at risk, even if your own pipes are secure."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "WEB_SECURITY_BASICS",
        "CDN_FUNDAMENTALS"
      ]
    },
    {
      "question_text": "Which security mechanism allows browsers to verify that fetched resources (like scripts or stylesheets) from external sources have not been tampered with?",
      "correct_answer": "Subresource Integrity (SRI)",
      "distractors": [
        {
          "text": "Content Security Policy (CSP)",
          "misconception": "Targets [policy vs. integrity confusion]: CSP controls resource loading but doesn't verify the integrity of individual resources."
        },
        {
          "text": "Cross-Origin Resource Sharing (CORS)",
          "misconception": "Targets [access control vs. integrity confusion]: CORS manages access permissions between origins, not resource integrity."
        },
        {
          "text": "HTTP Strict Transport Security (HSTS)",
          "misconception": "Targets [transport vs. integrity confusion]: HSTS enforces secure connections (HTTPS) but doesn't check resource content integrity."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Subresource Integrity (SRI) works by providing a cryptographic hash of the expected resource. The browser calculates the hash of the fetched resource and compares it to the provided hash; if they don't match, the resource is not loaded, thus ensuring integrity.",
        "distractor_analysis": "CSP controls what resources can be loaded, CORS manages cross-origin requests, and HSTS enforces HTTPS, but only SRI specifically verifies the integrity of the fetched resource's content.",
        "analogy": "SRI is like a tamper-evident seal on a package; if the seal is broken (hash mismatch), you know the contents might have been altered."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "WEB_SECURITY_BASICS",
        "SRI_FUNDAMENTALS"
      ]
    },
    {
      "question_text": "When implementing Subresource Integrity (SRI), what information must be provided in the <code>integrity</code> attribute of a script tag?",
      "correct_answer": "A cryptographic hash of the resource, prefixed by the hash algorithm (e.g., <code>sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC</code>).",
      "distractors": [
        {
          "text": "The URL of the resource, along with its expected file size.",
          "misconception": "Targets [attribute confusion]: Students confuse the `src` attribute with the `integrity` attribute's purpose."
        },
        {
          "text": "A digital signature from the resource provider.",
          "misconception": "Targets [mechanism confusion]: Students confuse hashing with digital signatures, which serve different security functions."
        },
        {
          "text": "The domain name of the CDN hosting the resource.",
          "misconception": "Targets [attribute confusion]: Students confuse the `integrity` attribute with specifying the source origin."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>integrity</code> attribute requires a cryptographic hash (e.g., SHA-384) of the resource, prefixed by the algorithm name. This allows the browser to verify the resource's content against the expected hash, ensuring it hasn't been altered since the hash was generated.",
        "distractor_analysis": "The distractors suggest providing the URL, file size, a digital signature, or just the domain, none of which directly enable the browser to verify the content's integrity as SRI requires.",
        "analogy": "It's like providing a unique fingerprint for a document; the browser checks if the document's fingerprint matches the one you provided."
      },
      "code_snippets": [
        {
          "language": "html",
          "code": "<script src=\"https://example.com/script.js\" integrity=\"sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC\" crossorigin=\"anonymous\"></script>",
          "context": "explanation"
        }
      ],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "SRI_IMPLEMENTATION",
        "CRYPTO_HASHING"
      ],
      "_code_snippets_html": "<div class=\"code-snippet code-explanation\">\n<span class=\"code-label\">Code Example</span>\n<pre><code class=\"language-html\">&lt;script src=&quot;https://example.com/script.js&quot; integrity=&quot;sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;</code></pre>\n</div>"
    },
    {
      "question_text": "What is the purpose of the <code>crossorigin=&quot;anonymous&quot;</code> attribute when using Subresource Integrity (SRI) with external resources?",
      "correct_answer": "It ensures that the browser fetches the resource using CORS, which is necessary for SRI verification of cross-origin resources.",
      "distractors": [
        {
          "text": "It encrypts the resource during transit.",
          "misconception": "Targets [encryption confusion]: Students confuse CORS with transport-layer encryption like HTTPS."
        },
        {
          "text": "It allows the script to access cookies from the origin domain.",
          "misconception": "Targets [cookie access confusion]: Students misunderstand CORS's role in controlling cross-origin requests, not cookie access."
        },
        {
          "text": "It prevents the browser from caching the external resource.",
          "misconception": "Targets [caching confusion]: Students confuse CORS with caching directives."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When a resource is loaded from a different origin (e.g., a CDN), the browser needs to perform a CORS preflight request. The <code>crossorigin=&quot;anonymous&quot;</code> attribute signals this intent, allowing the server to respond with appropriate headers, which is a prerequisite for SRI to function correctly on cross-origin resources.",
        "distractor_analysis": "The distractors incorrectly associate <code>crossorigin</code> with encryption, cookie access, or caching, rather than its actual function of enabling CORS for cross-origin resource integrity checks.",
        "analogy": "It's like asking for permission to receive a package from a neighbor; CORS is the permission slip, and SRI is checking the package's seal once you have it."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SRI_IMPLEMENTATION",
        "CORS_FUNDAMENTALS"
      ]
    },
    {
      "question_text": "Which of the following is a significant risk introduced by relying on third-party JavaScript libraries, even if loaded over HTTPS?",
      "correct_answer": "The third-party library itself could contain vulnerabilities or malicious code, regardless of the transport security.",
      "distractors": [
        {
          "text": "HTTPS encryption can be bypassed by sophisticated attackers.",
          "misconception": "Targets [transport security overestimation]: Students believe HTTPS alone solves all risks, ignoring the source code's integrity."
        },
        {
          "text": "The library's source code is publicly visible, aiding attackers.",
          "misconception": "Targets [transparency vs. vulnerability confusion]: Students confuse code visibility with inherent vulnerability."
        },
        {
          "text": "Browser JavaScript engines are inherently insecure.",
          "misconception": "Targets [browser vs. library confusion]: Students blame the browser's execution environment instead of the third-party code."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Even when loaded over HTTPS, the JavaScript code itself might be compromised or contain vulnerabilities. This is a supply chain risk, as the integrity of the code provided by the third party is paramount and not guaranteed by transport security alone.",
        "distractor_analysis": "The distractors misattribute the risk to HTTPS bypass, public visibility of code, or inherent browser insecurity, rather than the actual risk of vulnerable or malicious third-party code.",
        "analogy": "It's like buying a pre-assembled piece of furniture; even if it's delivered securely, the furniture itself might be poorly made or have hidden defects."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "WEB_SECURITY_BASICS",
        "SOFTWARE_SUPPLY_CHAIN"
      ]
    },
    {
      "question_text": "What is Content Security Policy (CSP) primarily used for in the context of external resources?",
      "correct_answer": "To define which external domains are allowed to serve resources (scripts, styles, images, etc.) to the web page.",
      "distractors": [
        {
          "text": "To verify the cryptographic integrity of each loaded resource.",
          "misconception": "Targets [CSP vs. SRI confusion]: Students confuse CSP's role in *allowing* resources with SRI's role in *verifying* them."
        },
        {
          "text": "To enforce the use of HTTPS for all external resource connections.",
          "misconception": "Targets [CSP vs. HSTS confusion]: Students confuse CSP with HSTS, which enforces HTTPS transport."
        },
        {
          "text": "To automatically update external resources to their latest versions.",
          "misconception": "Targets [policy vs. update mechanism confusion]: Students misunderstand CSP as an update management tool."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CSP acts as a whitelist for resource origins. By specifying <code>script-src</code> or <code>connect-src</code> directives, developers can dictate which external domains are permitted to load scripts or establish connections, thereby mitigating risks from untrusted sources.",
        "distractor_analysis": "The distractors incorrectly assign SRI's integrity checking, HSTS's transport enforcement, or a non-existent update function to CSP.",
        "analogy": "CSP is like a bouncer at a club, deciding which guests (resources from which domains) are allowed in, but not checking their IDs for authenticity once inside."
      },
      "code_snippets": [
        {
          "language": "http",
          "code": "Content-Security-Policy: script-src 'self' https://trusted.cdn.com;",
          "context": "explanation"
        }
      ],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "WEB_SECURITY_BASICS",
        "CSP_FUNDAMENTALS"
      ],
      "_code_snippets_html": "<div class=\"code-snippet code-explanation\">\n<span class=\"code-label\">Code Example</span>\n<pre><code class=\"language-http\">Content-Security-Policy: script-src &#x27;self&#x27; https://trusted.cdn.com;</code></pre>\n</div>"
    },
    {
      "question_text": "Consider a scenario where a website loads a JavaScript file from <code>https://cdn.example.com/script.js</code>. If an attacker compromises <code>cdn.example.com</code> and modifies <code>script.js</code> to include malicious code, what is the most effective defense if SRI is NOT implemented?",
      "correct_answer": "Content Security Policy (CSP) configured to only allow scripts from <code>https://self.origin.com</code>.",
      "distractors": [
        {
          "text": "Ensuring the website uses HTTPS to load the script.",
          "misconception": "Targets [transport security overestimation]: HTTPS protects the connection, not the content if the source is compromised."
        },
        {
          "text": "Implementing a Web Application Firewall (WAF) on the website's server.",
          "misconception": "Targets [defense layer confusion]: A WAF might detect some malicious output but cannot prevent the browser from loading a compromised script if allowed by policy."
        },
        {
          "text": "Using a Content Delivery Network (CDN) that offers DDoS protection.",
          "misconception": "Targets [threat type confusion]: DDoS protection is irrelevant to script content integrity."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Without SRI, the browser has no way to verify the integrity of the script from <code>cdn.example.com</code>. A strict CSP that *only* allows scripts from the website's own origin (<code>&#x27;self&#x27;</code>) or other explicitly trusted sources would prevent the browser from loading the compromised script from <code>cdn.example.com</code>.",
        "distractor_analysis": "HTTPS protects the transport, not the content. A WAF might help but isn't the primary defense against a compromised *allowed* script. DDoS protection is unrelated. CSP is the most effective *alternative* defense in this specific scenario.",
        "analogy": "If you can't trust the delivery person (CDN) to bring the right package (script), the best you can do is only allow deliveries from your own trusted address (CSP 'self')."
      },
      "code_snippets": [
        {
          "language": "http",
          "code": "Content-Security-Policy: script-src 'self';",
          "context": "explanation"
        }
      ],
      "difficulty": "expert",
      "question_type": "scenario",
      "bloom_level": "analyze",
      "prerequisites": [
        "CSP_IMPLEMENTATION",
        "SRI_LIMITATIONS",
        "WEB_APP_ATTACKS"
      ],
      "_code_snippets_html": "<div class=\"code-snippet code-explanation\">\n<span class=\"code-label\">Code Example</span>\n<pre><code class=\"language-http\">Content-Security-Policy: script-src &#x27;self&#x27;;</code></pre>\n</div>"
    },
    {
      "question_text": "What is the primary function of the <code>sha256</code>, <code>sha384</code>, and <code>sha512</code> prefixes in SRI <code>integrity</code> attributes?",
      "correct_answer": "They specify the cryptographic hashing algorithm used to generate the integrity hash.",
      "distractors": [
        {
          "text": "They indicate the encryption strength of the resource.",
          "misconception": "Targets [hashing vs. encryption confusion]: Students confuse hashing algorithms with encryption strength."
        },
        {
          "text": "They denote the version of the resource being loaded.",
          "misconception": "Targets [versioning confusion]: Students mistake algorithm identifiers for version numbers."
        },
        {
          "text": "They represent the size of the resource in kilobytes.",
          "misconception": "Targets [size confusion]: Students confuse algorithm names with file size indicators."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The prefixes (<code>sha256</code>, <code>sha384</code>, <code>sha512</code>) explicitly tell the browser which hashing algorithm was used to create the integrity hash. This is crucial because different algorithms produce different hash outputs, and the browser must use the correct algorithm to verify the resource's integrity.",
        "distractor_analysis": "The distractors incorrectly associate the prefixes with encryption strength, resource versioning, or file size, rather than their actual purpose of identifying the hashing algorithm.",
        "analogy": "It's like specifying the type of lock (e.g., 'pin tumbler', 'combination') before providing the key or code; the type must match for the verification to work."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SRI_IMPLEMENTATION",
        "CRYPTO_HASHING"
      ]
    },
    {
      "question_text": "What is a potential drawback of implementing Subresource Integrity (SRI) for frequently updated external resources?",
      "correct_answer": "Updating the external resource requires updating the <code>integrity</code> attribute on the website, which can be cumbersome.",
      "distractors": [
        {
          "text": "SRI significantly increases the page load time.",
          "misconception": "Targets [performance overestimation]: While there's a small overhead, it's not typically a significant performance bottleneck."
        },
        {
          "text": "SRI prevents the browser from caching the external resource.",
          "misconception": "Targets [caching confusion]: SRI does not inherently prevent caching; it verifies the cached resource."
        },
        {
          "text": "SRI is not supported by most modern browsers.",
          "misconception": "Targets [browser support misinformation]: SRI is widely supported by modern browsers."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When an external resource (like a library) is updated, its cryptographic hash changes. Therefore, the website's <code>integrity</code> attribute must be manually updated to match the new hash. This manual process can be error-prone and inconvenient, especially for frequently updated resources.",
        "distractor_analysis": "The distractors present false claims about SRI's impact on load time, caching, and browser support, ignoring the practical challenge of managing hash updates for dynamic resources.",
        "analogy": "It's like having to re-write a reference number on a document every time the referenced document is updated; it's extra work to keep things synchronized."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SRI_IMPLEMENTATION",
        "RESOURCE_MANAGEMENT"
      ]
    },
    {
      "question_text": "Which of the following best describes the 'supply chain' risk in the context of web development and external scripts?",
      "correct_answer": "Vulnerabilities or malicious code introduced into a dependency (like a CDN-hosted library) before it reaches the end-user's browser.",
      "distractors": [
        {
          "text": "The risk of a Denial-of-Service (DoS) attack against the website's server.",
          "misconception": "Targets [threat type confusion]: DoS attacks are network-level threats, not supply chain risks."
        },
        {
          "text": "The risk that a user's browser is outdated and cannot render scripts correctly.",
          "misconception": "Targets [client-side vs. supply chain confusion]: This is a compatibility issue, not a supply chain compromise."
        },
        {
          "text": "The risk of sensitive data being leaked over an insecure network connection.",
          "misconception": "Targets [transport security vs. supply chain confusion]: This relates to network security (e.g., lack of HTTPS), not the integrity of third-party code."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The software supply chain refers to all the components and processes involved in developing and delivering software. For web applications, this includes third-party libraries and resources. A supply chain risk occurs when a component within this chain is compromised, introducing vulnerabilities or malicious functionality.",
        "distractor_analysis": "The distractors describe unrelated security threats (DoS, client compatibility, network insecurity) instead of the specific risk of compromise within the chain of software delivery.",
        "analogy": "It's like a food supply chain: the risk isn't just about how the food is transported (HTTPS), but whether the ingredients themselves were contaminated before they were packaged."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SOFTWARE_SUPPLY_CHAIN",
        "WEB_SECURITY_BASICS"
      ]
    },
    {
      "question_text": "How can a developer mitigate the risk of a compromised CDN serving malicious JavaScript, assuming SRI is not used?",
      "correct_answer": "Implement a strict Content Security Policy (CSP) that whitelists only trusted script sources, including the CDN's domain if necessary.",
      "distractors": [
        {
          "text": "Ensure all external scripts are loaded via HTTP/2 for better performance.",
          "misconception": "Targets [performance vs. security confusion]: HTTP/2 is a transport protocol and doesn't inherently secure script content."
        },
        {
          "text": "Regularly scan the website's server for malware.",
          "misconception": "Targets [defense layer confusion]: Server scanning doesn't prevent the browser from loading a compromised *external* script if allowed."
        },
        {
          "text": "Use a JavaScript obfuscation tool on the website's own code.",
          "misconception": "Targets [internal vs. external mitigation confusion]: Obfuscation protects the site's own code, not external scripts."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Since SRI isn't used, the browser will load any script it's told to. CSP provides a crucial defense by acting as an allowlist. By configuring CSP to only permit scripts from specific, trusted origins (e.g., <code>&#x27;self&#x27;</code> and the CDN's domain), the browser will refuse to load scripts from any unauthorized or compromised source.",
        "distractor_analysis": "The distractors focus on transport protocols, server-side scanning, or client-side code obfuscation, none of which directly address the risk of loading a malicious *external* script when SRI is absent.",
        "analogy": "If you can't check each item delivered by a supplier (no SRI), you can at least tell the delivery person which specific suppliers are allowed to bring items to your door (CSP)."
      },
      "code_snippets": [
        {
          "language": "http",
          "code": "Content-Security-Policy: script-src 'self' https://trusted.cdn.com;",
          "context": "explanation"
        }
      ],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "CSP_IMPLEMENTATION",
        "SRI_LIMITATIONS",
        "WEB_APP_ATTACKS"
      ],
      "_code_snippets_html": "<div class=\"code-snippet code-explanation\">\n<span class=\"code-label\">Code Example</span>\n<pre><code class=\"language-http\">Content-Security-Policy: script-src &#x27;self&#x27; https://trusted.cdn.com;</code></pre>\n</div>"
    },
    {
      "question_text": "What is the primary security benefit of using Subresource Integrity (SRI) with external JavaScript libraries?",
      "correct_answer": "It prevents the execution of tampered or malicious JavaScript code loaded from external sources.",
      "distractors": [
        {
          "text": "It guarantees that the external library is free of bugs.",
          "misconception": "Targets [integrity vs. quality confusion]: SRI verifies content integrity, not code quality or bug-freeness."
        },
        {
          "text": "It speeds up the loading time of external scripts.",
          "misconception": "Targets [performance vs. security confusion]: SRI adds a verification step, potentially slightly increasing load time, not decreasing it."
        },
        {
          "text": "It automatically updates the external library to the latest secure version.",
          "misconception": "Targets [update mechanism confusion]: SRI does not manage or perform updates."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI works by comparing a cryptographic hash of the fetched resource against a known, trusted hash. If the hashes do not match, it indicates the resource has been altered (tampered with or maliciously modified), and the browser will refuse to load it, thereby preventing the execution of potentially harmful code.",
        "distractor_analysis": "The distractors misrepresent SRI's function as guaranteeing bug-freeness, improving performance, or automating updates, rather than its core purpose of ensuring content integrity against tampering.",
        "analogy": "SRI is like a security guard checking a visitor's ID against a pre-approved list; if the ID doesn't match, the visitor is denied entry, preventing potential threats."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "SRI_FUNDAMENTALS",
        "WEB_SECURITY_BASICS"
      ]
    },
    {
      "question_text": "Which of the following is a common attack vector that SRI helps to mitigate?",
      "correct_answer": "Cross-Site Scripting (XSS) attacks that leverage compromised third-party scripts.",
      "distractors": [
        {
          "text": "SQL Injection attacks targeting the website's database.",
          "misconception": "Targets [attack vector confusion]: SQLi targets database input, not external script integrity."
        },
        {
          "text": "Man-in-the-Middle (MitM) attacks during user login.",
          "misconception": "Targets [transport vs. content attack confusion]: MitM attacks target communication channels; SRI protects fetched content."
        },
        {
          "text": "Denial-of-Service (DoS) attacks overwhelming the server.",
          "misconception": "Targets [availability vs. integrity attack confusion]: DoS attacks aim to disrupt availability, not compromise script integrity."
        }
      ],
      "detailed_explanation": {
        "core_logic": "If a third-party script hosted on a CDN is compromised, an attacker can inject malicious JavaScript code. This injected code can then execute in the context of the user's browser on the website, leading to Cross-Site Scripting (XSS) attacks. SRI prevents this by ensuring the script loaded matches the expected, untampered version.",
        "distractor_analysis": "The distractors describe different types of attacks (SQLi, MitM, DoS) that SRI is not designed to prevent, focusing on database manipulation, network interception, or server overload, respectively.",
        "analogy": "SRI helps prevent XSS via compromised scripts like a security check at an airport prevents someone from boarding a plane with a dangerous item hidden in their luggage."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "XSS_ATTACKS",
        "SRI_BENEFITS",
        "SOFTWARE_SUPPLY_CHAIN"
      ]
    },
    {
      "question_text": "What is the role of the <code>Access-Control-Allow-Origin</code> header in relation to SRI and external resources?",
      "correct_answer": "It is required by CDNs serving resources for SRI to allow cross-origin requests from the web page.",
      "distractors": [
        {
          "text": "It encrypts the resource content before it is served.",
          "misconception": "Targets [header function confusion]: This header is for access control, not encryption."
        },
        {
          "text": "It specifies the integrity hash for the resource.",
          "misconception": "Targets [header vs. attribute confusion]: The integrity hash is in the `integrity` attribute, not this header."
        },
        {
          "text": "It prevents the browser from caching the resource.",
          "misconception": "Targets [header function confusion]: This header controls access, not caching behavior."
        }
      ],
      "detailed_explanation": {
        "core_logic": "For SRI to work on resources loaded from a different origin (like a CDN), the browser must be allowed to fetch that resource. The <code>Access-Control-Allow-Origin</code> header, set by the CDN server, explicitly permits the web page's origin to access the resource, fulfilling CORS requirements necessary for SRI verification.",
        "distractor_analysis": "The distractors incorrectly describe the header's function as encryption, hash specification, or cache control, missing its role in enabling cross-origin resource access for integrity checks.",
        "analogy": "It's like a sign on a building saying 'Visitors Welcome from Address X'; the sign (header) allows entry, enabling the security check (SRI) inside."
      },
      "code_snippets": [
        {
          "language": "http",
          "code": "Access-Control-Allow-Origin: https://your-website.com",
          "context": "explanation"
        }
      ],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "CORS_FUNDAMENTALS",
        "SRI_IMPLEMENTATION",
        "HTTP_HEADERS"
      ],
      "_code_snippets_html": "<div class=\"code-snippet code-explanation\">\n<span class=\"code-label\">Code Example</span>\n<pre><code class=\"language-http\">Access-Control-Allow-Origin: https://your-website.com</code></pre>\n</div>"
    },
    {
      "question_text": "Which of the following is NOT a direct benefit of implementing Subresource Integrity (SRI)?",
      "correct_answer": "Protection against vulnerabilities within the website's own backend code.",
      "distractors": [
        {
          "text": "Prevention of Cross-Site Scripting (XSS) via compromised external scripts.",
          "misconception": "Targets [scope confusion]: SRI protects against XSS from *external* scripts, not internal ones."
        },
        {
          "text": "Ensuring that loaded external resources have not been tampered with.",
          "misconception": "Targets [core benefit]: This is the primary purpose of SRI."
        },
        {
          "text": "Mitigation of risks associated with compromised CDNs.",
          "misconception": "Targets [risk mitigation]: This is a direct outcome of SRI's integrity checks."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI's core function is to verify the integrity of external resources fetched by the browser. It directly protects against attacks that involve modifying these external resources, such as XSS via compromised third-party scripts or CDN tampering. It does not, however, provide any protection for the website's own backend code or internal logic.",
        "distractor_analysis": "The distractors correctly identify direct benefits of SRI (XSS prevention via external scripts, integrity verification, CDN compromise mitigation), while the correct answer points to a scope limitation of SRI.",
        "analogy": "SRI is like a bodyguard for your imported goods; it ensures they haven't been tampered with during transit, but it doesn't protect your own factory from internal sabotage."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "SRI_BENEFITS",
        "WEB_APP_ATTACKS"
      ]
    },
    {
      "question_text": "When generating SRI hashes, which hashing algorithms are currently recommended and widely supported by browsers?",
      "correct_answer": "SHA-256, SHA-384, and SHA-512.",
      "distractors": [
        {
          "text": "MD5 and SHA-1.",
          "misconception": "Targets [obsolete algorithm confusion]: MD5 and SHA-1 are considered cryptographically broken and insecure."
        },
        {
          "text": "SHA-3 and BLAKE2.",
          "misconception": "Targets [emerging algorithm confusion]: While secure, these may have less universal browser support for SRI compared to SHA-2 variants."
        },
        {
          "text": "AES and RSA.",
          "misconception": "Targets [hashing vs. encryption confusion]: AES and RSA are encryption algorithms, not hashing algorithms used for integrity checks."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Modern browsers widely support SHA-256, SHA-384, and SHA-512 for Subresource Integrity. These algorithms provide a strong balance between security and performance for generating integrity hashes. Older algorithms like MD5 and SHA-1 are deprecated due to known vulnerabilities.",
        "distractor_analysis": "The distractors suggest insecure (MD5, SHA-1), less universally supported (SHA-3, BLAKE2), or entirely different types of algorithms (AES, RSA), failing to identify the currently recommended and supported set for SRI.",
        "analogy": "When choosing a lock for your door, you'd pick a standard, reliable model (SHA-256/384/512), not an old, easily picked one (MD5/SHA-1) or a brand new, untested one (SHA-3/BLAKE2)."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "SRI_IMPLEMENTATION",
        "CRYPTO_HASHING"
      ]
    },
    {
      "question_text": "What is the primary risk if a website fails to use SRI or a strict CSP when loading external scripts from a CDN?",
      "correct_answer": "The website becomes vulnerable to Cross-Site Scripting (XSS) attacks if the CDN is compromised.",
      "distractors": [
        {
          "text": "The website's SEO ranking may decrease.",
          "misconception": "Targets [SEO vs. security confusion]: Security vulnerabilities do not directly impact SEO rankings in this manner."
        },
        {
          "text": "The website may experience increased bandwidth costs.",
          "misconception": "Targets [cost vs. security confusion]: Script integrity issues do not directly cause higher bandwidth usage."
        },
        {
          "text": "The website's SSL certificate may become invalid.",
          "misconception": "Targets [certificate vs. script integrity confusion]: SSL certificate validity is unrelated to external script integrity."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Without SRI or CSP, a compromised CDN can serve malicious JavaScript. This script executes with the privileges of the website, allowing attackers to perform actions like stealing user credentials or defacing the site, which are characteristic of Cross-Site Scripting (XSS) attacks.",
        "distractor_analysis": "The distractors suggest unrelated consequences like SEO impact, increased costs, or SSL certificate issues, failing to identify the direct security threat of XSS due to unchecked external script execution.",
        "analogy": "Failing to check the integrity of external scripts is like leaving your front door unlocked and unattended; it opens the door for intruders (attackers) to cause harm (XSS)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "XSS_ATTACKS",
        "SRI_IMPORTANCE",
        "CSP_IMPORTANCE"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 17,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "CDN and External Script Risks Software Development Security best practices",
    "latency_ms": 29736.293
  },
  "timestamp": "2026-01-18T11:06:40.192764"
}