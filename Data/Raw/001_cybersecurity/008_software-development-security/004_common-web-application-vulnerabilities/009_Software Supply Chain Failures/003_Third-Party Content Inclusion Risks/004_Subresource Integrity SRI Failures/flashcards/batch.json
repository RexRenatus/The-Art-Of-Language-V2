{
  "topic_title": "Subresource Integrity SRI Failures",
  "category": "Software Development Security - Common Web Application Vulnerabilities",
  "flashcards": [
    {
      "question_text": "What is the primary security risk addressed by Subresource Integrity (SRI)?",
      "correct_answer": "Tampering or modification of externally hosted resources like scripts or stylesheets.",
      "distractors": [
        {
          "text": "Insecure direct object references in API endpoints",
          "misconception": "Targets [domain confusion]: Confuses web application vulnerabilities with resource integrity issues."
        },
        {
          "text": "Cross-Site Scripting (XSS) vulnerabilities within the main application code",
          "misconception": "Targets [related but distinct vulnerability]: XSS is a different attack vector, though SRI can mitigate some XSS risks from compromised third-party scripts."
        },
        {
          "text": "Denial-of-Service (DoS) attacks targeting the web server infrastructure",
          "misconception": "Targets [scope mismatch]: DoS attacks target availability, while SRI focuses on resource integrity and preventing malicious code execution."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI prevents attackers from injecting malicious code into third-party resources like CDNs because it ensures the fetched resource's cryptographic hash matches a pre-defined value, thus protecting the main application.",
        "distractor_analysis": "The distractors represent common web security concepts that are distinct from resource integrity, such as API vulnerabilities, XSS, and DoS attacks, which students might confuse with SRI's purpose.",
        "analogy": "SRI is like a tamper-evident seal on a package. If the seal is broken (hash doesn't match), you know the contents might have been altered and shouldn't be trusted."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "WEB_APP_SECURITY_BASICS",
        "THIRD_PARTY_RISKS"
      ]
    },
    {
      "question_text": "How does Subresource Integrity (SRI) work to protect web applications?",
      "correct_answer": "By requiring browsers to verify that fetched resources match a cryptographic hash provided in the HTML.",
      "distractors": [
        {
          "text": "By encrypting all third-party resources before they are served",
          "misconception": "Targets [mechanism confusion]: Confuses integrity checking with data encryption."
        },
        {
          "text": "By forcing all third-party resources to be self-hosted",
          "misconception": "Targets [implementation misunderstanding]: SRI is a defense mechanism, not a hosting requirement."
        },
        {
          "text": "By blocking all requests to external domains by default",
          "misconception": "Targets [overly broad security]: SRI is specific to resource integrity, not a general domain block."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI functions by embedding a cryptographic hash (e.g., SHA-384) within the HTML tag for a resource; the browser then calculates the hash of the fetched resource and only executes it if the hashes match, ensuring integrity.",
        "distractor_analysis": "The distractors misrepresent SRI's mechanism by suggesting encryption, mandatory self-hosting, or broad domain blocking, rather than its core function of hash verification.",
        "analogy": "It's like checking the serial number on a product against the one listed on the receipt. If they don't match, you know something is wrong with the product you received."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "SRI_BASICS",
        "CRYPTO_HASHING"
      ]
    },
    {
      "question_text": "Which attribute is used in HTML to specify the cryptographic hash for Subresource Integrity?",
      "correct_answer": "integrity",
      "distractors": [
        {
          "text": "src",
          "misconception": "Targets [attribute confusion]: 'src' specifies the resource URL, not its integrity hash."
        },
        {
          "text": "crossorigin",
          "misconception": "Targets [related attribute confusion]: 'crossorigin' relates to CORS headers, not SRI hashes."
        },
        {
          "text": "sha384",
          "misconception": "Targets [value vs. attribute confusion]: 'sha384' is a hash algorithm prefix, not the attribute name itself."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'integrity' attribute is specifically designed to hold the cryptographic hash value(s) for SRI, allowing the browser to perform the integrity check because it's the designated mechanism for this security feature.",
        "distractor_analysis": "Students might confuse 'integrity' with other attributes like 'src' (source URL), 'crossorigin' (CORS policy), or the hash algorithm prefix itself ('sha384'), mistaking a value for the attribute.",
        "analogy": "In a form, the 'name' attribute identifies the field, while the 'value' attribute holds the data. Similarly, 'integrity' is the field for the hash, and the hash itself is the value."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "HTML_BASICS",
        "SRI_BASICS"
      ]
    },
    {
      "question_text": "What is the consequence for a web browser if a fetched resource's integrity hash does not match the value specified in the HTML 'integrity' attribute?",
      "correct_answer": "The browser will refuse to load or execute the resource and may report an error.",
      "distractors": [
        {
          "text": "The browser will load the resource but flag it with a warning.",
          "misconception": "Targets [severity misjudgment]: Underestimates the strictness of SRI's security enforcement."
        },
        {
          "text": "The browser will attempt to fetch an alternative version of the resource.",
          "misconception": "Targets [fallback mechanism confusion]: SRI does not include automatic fallback mechanisms."
        },
        {
          "text": "The browser will proceed to load the resource, assuming it's a minor change.",
          "misconception": "Targets [trust assumption]: Contradicts SRI's purpose of preventing execution of untrusted, modified resources."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Because SRI's purpose is to prevent the execution of tampered code, a hash mismatch triggers a security failure, causing the browser to block the resource since it cannot guarantee its integrity.",
        "distractor_analysis": "The distractors suggest less strict outcomes like warnings, automatic fallbacks, or ignoring minor changes, which are contrary to SRI's strict security enforcement model.",
        "analogy": "If a security guard checks your ID and the photo doesn't match your face, they won't let you in; they don't just give you a warning or try to find another ID for you."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SRI_BASICS",
        "WEB_SECURITY_PRINCIPLES"
      ]
    },
    {
      "question_text": "When using Subresource Integrity, what is the role of the 'crossorigin' attribute?",
      "correct_answer": "It is required for CORS (Cross-Origin Resource Sharing) checks when fetching resources from a different origin, which is often necessary for CDNs.",
      "distractors": [
        {
          "text": "It specifies the cryptographic algorithm used for the integrity hash.",
          "misconception": "Targets [attribute confusion]: Confuses 'crossorigin' with hash algorithm prefixes like 'sha384'."
        },
        {
          "text": "It indicates that the resource is hosted on the same origin as the document.",
          "misconception": "Targets [opposite meaning]: 'crossorigin' is used when resources are from *different* origins."
        },
        {
          "text": "It enables the browser to cache the resource more aggressively.",
          "misconception": "Targets [unrelated functionality]: Caching behavior is not directly controlled by 'crossorigin' in the context of SRI."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'crossorigin' attribute is essential because SRI often involves resources from Content Delivery Networks (CDNs), which are different origins; CORS headers must be correctly configured for the browser to allow SRI checks on these external resources.",
        "distractor_analysis": "Distractors incorrectly associate 'crossorigin' with hash algorithms, same-origin policies, or caching, failing to recognize its role in enabling cross-origin resource fetching and verification.",
        "analogy": "Think of 'crossorigin' as a passport check. If you're traveling to another country (different origin), you need the right documentation (CORS headers) for your journey (resource fetch) to be permitted."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SRI_BASICS",
        "CORS_BASICS"
      ]
    },
    {
      "question_text": "Which of the following hash algorithms are commonly supported by Subresource Integrity?",
      "correct_answer": "SHA-256, SHA-384, and SHA-512",
      "distractors": [
        {
          "text": "MD5, SHA-1, and SHA-256",
          "misconception": "Targets [outdated algorithms]: MD5 and SHA-1 are cryptographically broken and not recommended for SRI."
        },
        {
          "text": "SHA-256, SHA-384, and AES-256",
          "misconception": "Targets [algorithm type confusion]: AES is an encryption algorithm, not a hashing algorithm suitable for SRI."
        },
        {
          "text": "SHA-512, RIPEMD-160, and BLAKE2b",
          "misconception": "Targets [unsupported algorithms]: RIPEMD-160 and BLAKE2b are not standard SRI algorithms, though SHA-512 is."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI specifically supports modern, strong cryptographic hash functions like SHA-256, SHA-384, and SHA-512 because they provide a high degree of confidence in resource integrity, unlike older or broken algorithms.",
        "distractor_analysis": "The distractors include deprecated/broken algorithms (MD5, SHA-1) or encryption algorithms (AES) instead of hashing algorithms, or unsupported hashing algorithms, confusing students about the specific requirements for SRI.",
        "analogy": "When you need to verify a signature, you use a reliable pen (strong hash algorithm) that's known to be hard to forge, not a pencil (MD5) that can be easily erased or altered."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "CRYPTO_HASHING",
        "SRI_BASICS"
      ]
    },
    {
      "question_text": "A website loads a critical JavaScript library from a CDN. If the CDN is compromised and the library file is replaced with malicious code, how does SRI help mitigate this attack?",
      "correct_answer": "The browser will detect that the hash of the compromised file does not match the integrity hash specified in the HTML and refuse to load it.",
      "distractors": [
        {
          "text": "SRI automatically reverts the file on the CDN to its original state.",
          "misconception": "Targets [misunderstanding of SRI's role]: SRI is a client-side verification, not a CDN management tool."
        },
        {
          "text": "SRI instructs the browser to ignore the malicious code within the script.",
          "misconception": "Targets [security bypass misunderstanding]: SRI's purpose is to block, not ignore, malicious code."
        },
        {
          "text": "SRI forces the browser to use a fallback script from a trusted source.",
          "misconception": "Targets [lack of fallback feature]: SRI does not inherently provide fallback mechanisms."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI acts as a last line of defense by enabling the browser to verify the integrity of the fetched resource against a known-good hash; therefore, if the CDN is compromised and the file altered, the hash mismatch prevents the malicious script from executing.",
        "distractor_analysis": "The distractors incorrectly suggest SRI has active CDN management, code ignoring capabilities, or automatic fallback features, rather than its core function of client-side integrity verification.",
        "analogy": "It's like a bouncer checking IDs at a club. If the ID is fake (hash mismatch), the bouncer (browser) denies entry (prevents execution) to protect the club (website)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "SRI_BASICS",
        "SOFTWARE_SUPPLY_CHAIN_ATTACKS"
      ]
    },
    {
      "question_text": "What is a potential drawback of implementing Subresource Integrity?",
      "correct_answer": "Updating a third-party resource requires updating the integrity hash in the HTML, which can be cumbersome.",
      "distractors": [
        {
          "text": "It significantly slows down the initial page load time.",
          "misconception": "Targets [performance exaggeration]: While there's a small overhead, it's generally not a significant performance bottleneck."
        },
        {
          "text": "It prevents the use of Content Security Policy (CSP).",
          "misconception": "Targets [compatibility misunderstanding]: SRI and CSP are complementary security measures."
        },
        {
          "text": "It requires all resources to be served over HTTP.",
          "misconception": "Targets [protocol misunderstanding]: SRI is designed to work with HTTPS for secure transport."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Because SRI relies on exact hash matches, any update to a third-party resource necessitates manually updating the corresponding integrity hash in the HTML, which can be an administrative burden since it requires code changes.",
        "distractor_analysis": "The distractors misrepresent SRI's impact on performance, its compatibility with CSP, and its protocol requirements, focusing on non-existent or exaggerated drawbacks.",
        "analogy": "Imagine you have a list of exact product codes for items in your inventory. If a supplier changes a product code, you must manually update your list; otherwise, your inventory system won't recognize the new item."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SRI_BASICS",
        "WEB_DEV_OPERATIONS"
      ]
    },
    {
      "question_text": "Consider a scenario where a website uses SRI for a JavaScript file hosted on a CDN. If the CDN provider updates the file to a new version without providing a new integrity hash, what will happen?",
      "correct_answer": "The browser will refuse to load the updated JavaScript file because its hash will not match the old integrity value.",
      "distractors": [
        {
          "text": "The browser will automatically update the integrity hash in the HTML.",
          "misconception": "Targets [automation misunderstanding]: Browsers do not modify HTML integrity attributes."
        },
        {
          "text": "The browser will load the new file but issue a security warning.",
          "misconception": "Targets [incorrect warning behavior]: SRI typically blocks, not just warns, on mismatch."
        },
        {
          "text": "The browser will attempt to fetch the JavaScript file from an alternative source.",
          "misconception": "Targets [lack of fallback]: SRI does not include automatic alternative source fetching."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI enforces strict integrity by comparing hashes; therefore, if the CDN updates the file and the website's HTML still references the old integrity hash, the browser will detect the mismatch and block the new, untrusted file from loading.",
        "distractor_analysis": "The distractors incorrectly assume browsers can auto-update hashes, issue only warnings for mismatches, or automatically find alternative sources, all of which are outside SRI's defined behavior.",
        "analogy": "It's like trying to use an old key (integrity hash) on a newly re-keyed lock (updated file). The old key won't work, and you can't get in."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "scenario",
      "bloom_level": "analyze",
      "prerequisites": [
        "SRI_BASICS",
        "WEB_RESOURCE_MANAGEMENT"
      ]
    },
    {
      "question_text": "Which of the following is a key benefit of using Subresource Integrity (SRI) as described by OWASP?",
      "correct_answer": "It detects and prevents the execution of tampered code from external resources.",
      "distractors": [
        {
          "text": "It guarantees the availability of external resources.",
          "misconception": "Targets [scope confusion]: SRI addresses integrity, not availability."
        },
        {
          "text": "It automatically updates outdated third-party libraries.",
          "misconception": "Targets [misunderstanding of SRI's function]: SRI is a verification mechanism, not an update tool."
        },
        {
          "text": "It encrypts all data transferred between the browser and the CDN.",
          "misconception": "Targets [mechanism confusion]: SRI verifies integrity, it does not encrypt data transport."
        }
      ],
      "detailed_explanation": {
        "core_logic": "OWASP highlights that SRI's primary benefit is ensuring the integrity of externally hosted resources, thereby detecting and preventing the execution of malicious code that might have been injected into those resources.",
        "distractor_analysis": "The distractors misrepresent SRI's function by attributing availability guarantees, automatic updates, or data encryption to it, rather than its core purpose of integrity verification.",
        "analogy": "SRI is like a quality control stamp on a product. It assures you that the product hasn't been tampered with since it left the factory, preventing you from receiving a faulty or dangerous item."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SRI_BASICS",
        "OWASP_PRINCIPLES"
      ]
    },
    {
      "question_text": "Why is it important for CDNs serving resources protected by SRI to support Cross-Origin Resource Sharing (CORS)?",
      "correct_answer": "CORS allows the browser to securely fetch and verify resources from a different origin (the CDN) than the document's origin.",
      "distractors": [
        {
          "text": "CORS ensures that the CDN itself is secure and free from malware.",
          "misconception": "Targets [security scope confusion]: CORS is about resource sharing permissions, not CDN security audits."
        },
        {
          "text": "CORS is required to generate the integrity hash for SRI.",
          "misconception": "Targets [process confusion]: Hash generation is separate from CORS configuration."
        },
        {
          "text": "CORS prevents the browser from caching the SRI-protected resources.",
          "misconception": "Targets [effect reversal]: CORS does not inherently prevent caching; it enables cross-origin requests."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Since SRI often involves resources hosted on CDNs (a different origin), CORS headers are necessary because they grant permission for the browser to request and receive these resources from the CDN, enabling the subsequent SRI integrity check.",
        "distractor_analysis": "The distractors incorrectly link CORS to CDN security audits, hash generation, or caching prevention, failing to recognize its fundamental role in enabling cross-origin requests required for SRI verification.",
        "analogy": "CORS is like a diplomatic agreement between countries (origins) allowing citizens (browser) to visit and exchange goods (resources) under specific terms. Without it, such exchanges might be blocked."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SRI_BASICS",
        "CORS_BASICS"
      ]
    },
    {
      "question_text": "What is the relationship between Subresource Integrity (SRI) and Content Security Policy (CSP)?",
      "correct_answer": "They are complementary security mechanisms; CSP controls *what* resources can be loaded, while SRI verifies the *integrity* of those loaded resources.",
      "distractors": [
        {
          "text": "CSP replaces the need for SRI by blocking all external scripts.",
          "misconception": "Targets [redundancy misunderstanding]: CSP is broader and doesn't always block all external scripts; SRI provides a specific integrity check."
        },
        {
          "text": "SRI is a directive within CSP that enforces integrity checks.",
          "misconception": "Targets [structural confusion]: SRI is a separate HTML attribute, not a CSP directive."
        },
        {
          "text": "They are mutually exclusive and cannot be used together.",
          "misconception": "Targets [incompatibility assumption]: They are designed to work together for layered security."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CSP defines policies for resource loading (e.g., 'script-src'), preventing unauthorized sources, while SRI provides a deeper layer of security by verifying the integrity of allowed resources because it ensures they haven't been tampered with.",
        "distractor_analysis": "The distractors incorrectly suggest CSP makes SRI redundant, that SRI is part of CSP, or that they are incompatible, missing the synergistic relationship between policy enforcement and integrity verification.",
        "analogy": "CSP is like a guest list for a party (which people are allowed in), and SRI is like checking each guest's ID at the door (ensuring the allowed people are who they claim to be and haven't been impersonated)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "SRI_BASICS",
        "CSP_BASICS"
      ]
    },
    {
      "question_text": "If a developer forgets to include the 'crossorigin=\"anonymous\"' attribute when using SRI for a resource from a different origin, what is the likely outcome?",
      "correct_answer": "The browser will likely ignore the integrity check, potentially loading a compromised resource.",
      "distractors": [
        {
          "text": "The browser will refuse to load the resource due to a CORS policy violation.",
          "misconception": "Targets [misunderstanding of SRI's fallback]: SRI might fall back to loading without integrity check rather than outright blocking if CORS is misconfigured."
        },
        {
          "text": "The browser will automatically add the 'crossorigin=\"anonymous\"' attribute.",
          "misconception": "Targets [browser automation misunderstanding]: Browsers do not modify HTML attributes."
        },
        {
          "text": "The integrity check will still be performed, but with reduced security.",
          "misconception": "Targets [level of security misunderstanding]: The integrity check is effectively bypassed, not just weakened."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When a resource is from a different origin, the 'crossorigin=\"anonymous\"' attribute is required for the browser to perform the SRI integrity check. Without it, the browser cannot securely fetch and verify the resource, often leading it to bypass the integrity check entirely.",
        "distractor_analysis": "The distractors suggest outright blocking, automatic attribute addition, or a reduced security level, rather than the common outcome of the integrity check being bypassed due to the missing CORS configuration.",
        "analogy": "It's like trying to get through airport security without showing your passport. You might be allowed to pass (load the resource), but the security check (integrity verification) was skipped."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "scenario",
      "bloom_level": "evaluate",
      "prerequisites": [
        "SRI_BASICS",
        "CORS_BASICS"
      ]
    },
    {
      "question_text": "What is the primary security concern when a website relies heavily on third-party JavaScript libraries without using SRI?",
      "correct_answer": "A compromise of the third-party library could lead to the execution of malicious code on the user's browser, impacting the website's security and users.",
      "distractors": [
        {
          "text": "Increased bandwidth consumption due to external resource loading.",
          "misconception": "Targets [performance vs. security]: Focuses on a minor performance aspect rather than the critical security risk."
        },
        {
          "text": "Potential for outdated library versions to cause compatibility issues.",
          "misconception": "Targets [functional vs. security risk]: Compatibility issues are functional, not direct security compromises."
        },
        {
          "text": "The website's SEO ranking might be negatively affected.",
          "misconception": "Targets [unrelated impact]: SEO is a marketing concern, not a direct security vulnerability from untrusted code."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Without SRI, a compromised third-party library can act as an attack vector because the browser trusts the source and executes the code; this allows attackers to potentially steal data, deface the site, or launch further attacks, directly compromising the website and its users.",
        "distractor_analysis": "The distractors focus on non-security issues like bandwidth, compatibility, or SEO, failing to identify the core risk of executing untrusted, potentially malicious code from compromised third-party sources.",
        "analogy": "It's like inviting a stranger into your house (website) to perform a service (run a script) without checking their background or ensuring they aren't carrying anything dangerous."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SOFTWARE_SUPPLY_CHAIN_ATTACKS",
        "WEB_APP_SECURITY_BASICS"
      ]
    },
    {
      "question_text": "How can a developer generate the correct integrity hash for a resource to be used with SRI?",
      "correct_answer": "By using command-line tools like OpenSSL to calculate the hash (e.g., SHA-384) of the resource file and then base64-encoding the result.",
      "distractors": [
        {
          "text": "By asking the CDN provider for the hash directly, without verification.",
          "misconception": "Targets [trust assumption]: Relying solely on the provider without independent verification is risky."
        },
        {
          "text": "By using a simple online tool that doesn't support CORS checks.",
          "misconception": "Targets [tool limitation]: Some tools might not verify CORS support, which is crucial for SRI."
        },
        {
          "text": "By manually calculating the hash using a standard text editor.",
          "misconception": "Targets [process impossibility]: Manual calculation of cryptographic hashes is impractical and error-prone."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Generating an SRI hash involves obtaining the resource file, using a cryptographic tool (like OpenSSL) to compute the specified hash algorithm (e.g., sha384), and then encoding the binary hash into base64, because these steps ensure an accurate and verifiable integrity value.",
        "distractor_analysis": "The distractors suggest trusting the CDN blindly, using potentially inadequate tools, or manual calculation, all of which bypass the secure and accurate process required for generating reliable SRI hashes.",
        "analogy": "It's like getting a unique fingerprint for a document. You use a specialized scanner (OpenSSL) to capture the exact pattern (hash) and then record it in a standard format (base64)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "SRI_BASICS",
        "CRYPTO_HASHING",
        "COMMAND_LINE_TOOLS"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Subresource Integrity SRI Failures Software Development Security best practices",
    "latency_ms": 25641.687
  },
  "timestamp": "2026-01-18T11:06:25.218352"
}