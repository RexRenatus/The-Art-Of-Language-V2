{
  "topic_title": "006_Server-Side Request Forgery SSRF",
  "category": "Software Development Security - Common Web Application Vulnerabilities",
  "flashcards": [
    {
      "question_text": "What is the primary risk associated with Server-Side Request Forgery (SSRF)?",
      "correct_answer": "Allowing an attacker to force the server to make unintended requests to internal or external resources.",
      "distractors": [
        {
          "text": "Exposing sensitive user data through SQL injection.",
          "misconception": "Targets [vulnerability type confusion]: Confuses SSRF with SQL injection, a different class of web vulnerability."
        },
        {
          "text": "Enabling Cross-Site Scripting (XSS) attacks by injecting malicious scripts.",
          "misconception": "Targets [vulnerability type confusion]: Confuses SSRF with XSS, which targets the user's browser, not the server's requests."
        },
        {
          "text": "Causing Denial-of-Service (DoS) by overwhelming the server with traffic.",
          "misconception": "Targets [impact confusion]: While SSRF can sometimes lead to DoS, its primary risk is unauthorized resource access, not just traffic volume."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SSRF occurs because the server trusts user-supplied URLs, allowing attackers to trick it into making requests to internal systems or sensitive cloud metadata endpoints, thereby bypassing network controls.",
        "distractor_analysis": "The distractors incorrectly associate SSRF with SQL injection, XSS, or solely DoS, failing to grasp the core mechanism of unauthorized server-initiated requests.",
        "analogy": "Imagine asking a trusted assistant to fetch a document from a restricted archive by giving them a fake address. The assistant, trusting you, goes to the wrong place, potentially revealing sensitive information or accessing unauthorized areas."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "WEB_APP_SECURITY_BASICS",
        "NETWORK_FUNDAMENTALS"
      ]
    },
    {
      "question_text": "According to the OWASP Web Security Testing Guide (WSTG), what is a key objective when testing for Server-Side Request Forgery (SSRF)?",
      "correct_answer": "To identify SSRF injection points and assess if they are exploitable.",
      "distractors": [
        {
          "text": "To verify the application's compliance with TLS encryption standards.",
          "misconception": "Targets [testing scope confusion]: Confuses SSRF testing with TLS/SSL security testing."
        },
        {
          "text": "To measure the application's performance under heavy load.",
          "misconception": "Targets [testing objective confusion]: Confuses SSRF testing with performance or load testing."
        },
        {
          "text": "To validate the security of user authentication mechanisms.",
          "misconception": "Targets [testing objective confusion]: Confuses SSRF testing with authentication security testing."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The OWASP WSTG emphasizes identifying potential SSRF vulnerabilities by finding input points that handle URLs and then testing if these points can be manipulated to make the server send requests to unintended destinations.",
        "distractor_analysis": "The distractors misrepresent the goals of SSRF testing, focusing on unrelated security aspects like TLS, performance, or authentication instead of identifying and exploiting SSRF flaws.",
        "analogy": "When looking for SSRF, you're like a detective searching for weak points in a building's security system that allow unauthorized access, not checking if the fire alarms are working or if the doors are locked."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "SSRF_BASICS",
        "OWASP_WSTG"
      ]
    },
    {
      "question_text": "Consider a web application that allows users to import an image from a URL. If the application directly uses the provided URL in a server-side request without proper validation, what type of vulnerability could be exploited?",
      "correct_answer": "Server-Side Request Forgery (SSRF)",
      "distractors": [
        {
          "text": "Cross-Site Request Forgery (CSRF)",
          "misconception": "Targets [vulnerability name confusion]: Confuses SSRF (server-initiated request) with CSRF (user-initiated action on behalf of another user)."
        },
        {
          "text": "SQL Injection",
          "misconception": "Targets [vulnerability type confusion]: Associates the vulnerability with database manipulation rather than network requests."
        },
        {
          "text": "Directory Traversal",
          "misconception": "Targets [vulnerability type confusion]: Associates the vulnerability with file path manipulation rather than URL handling."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When a server processes a user-supplied URL without validation, it can be tricked into making requests to internal resources (like <code>http://localhost/admin</code>) or cloud metadata endpoints, which is the definition of SSRF.",
        "distractor_analysis": "The distractors represent common web vulnerabilities but are distinct from SSRF. CSRF involves tricking a user, SQLi targets databases, and Directory Traversal targets file system paths.",
        "analogy": "It's like a restaurant taking an order for a dish that requires an ingredient from a specific supplier. If the kitchen blindly uses any supplier address you give them, they might end up ordering from a dangerous or internal-only supplier, causing problems."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "SSRF_BASICS",
        "WEB_APP_SECURITY_PRINCIPLES"
      ]
    },
    {
      "question_text": "Which of the following is a common technique used in SSRF attacks to access internal services that are not directly reachable by users?",
      "correct_answer": "Using loopback IP addresses like <code>127.0.0.1</code> or <code>localhost</code> to target services running on the server itself.",
      "distractors": [
        {
          "text": "Exploiting Cross-Site Scripting (XSS) vulnerabilities to execute code on the server.",
          "misconception": "Targets [attack vector confusion]: Associates server-side execution with client-side XSS, not server-initiated requests."
        },
        {
          "text": "Injecting malicious SQL queries to extract data from the database.",
          "misconception": "Targets [attack vector confusion]: Associates network request manipulation with database query manipulation."
        },
        {
          "text": "Leveraging insecure deserialization to execute arbitrary code.",
          "misconception": "Targets [attack vector confusion]: Associates SSRF with code execution vulnerabilities, not network request redirection."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SSRF attacks often target internal services by using loopback interfaces because these services are typically configured to only respond to requests originating from the server itself, thus bypassing external network restrictions.",
        "distractor_analysis": "The distractors describe different attack vectors (XSS, SQLi, insecure deserialization) that achieve code execution or data theft through different means, not by manipulating server-side network requests.",
        "analogy": "It's like trying to access a locked room within a building by pretending you are already inside the building and are just moving between adjacent rooms, rather than trying to break in from the outside."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "SSRF_BASICS",
        "NETWORK_ADDRESSING"
      ]
    },
    {
      "question_text": "What is the purpose of fetching cloud provider metadata, such as AWS metadata, via SSRF?",
      "correct_answer": "To extract sensitive information like access keys, instance configurations, and security credentials.",
      "distractors": [
        {
          "text": "To provision new cloud resources for the attacker.",
          "misconception": "Targets [impact confusion]: Assumes SSRF can directly provision resources, rather than just exfiltrate data."
        },
        {
          "text": "To update the application's firewall rules.",
          "misconception": "Targets [impact confusion]: Assumes SSRF can modify infrastructure configurations directly."
        },
        {
          "text": "To perform distributed denial-of-service (DDoS) attacks against the cloud provider.",
          "misconception": "Targets [impact confusion]: Confuses SSRF with DDoS attack capabilities."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Cloud providers expose metadata endpoints (e.g., <code>http://169.254.169.254/</code> for AWS) that contain sensitive configuration and credential information. SSRF allows an attacker to make the vulnerable server query these endpoints.",
        "distractor_analysis": "The distractors incorrectly suggest SSRF can directly provision resources, modify firewall rules, or launch DDoS attacks, which are outcomes beyond the typical scope of metadata exfiltration.",
        "analogy": "It's like finding a hidden internal phone directory in an office that lists employee contact details and security codes. By tricking someone inside to look up that directory for you, you can gain valuable information."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SSRF_BASICS",
        "CLOUD_SECURITY_BASICS",
        "AWS_METADATA"
      ]
    },
    {
      "question_text": "Which of the following is a crucial prevention technique against Server-Side Request Forgery (SSRF)?",
      "correct_answer": "Implementing strict allow-lists for URLs or domains that the server is permitted to request.",
      "distractors": [
        {
          "text": "Encrypting all outgoing server requests using TLS.",
          "misconception": "Targets [prevention confusion]: Encryption protects data in transit but doesn't prevent the server from making unauthorized requests."
        },
        {
          "text": "Sanitizing user input for SQL injection vulnerabilities.",
          "misconception": "Targets [prevention confusion]: Focuses on SQLi prevention, which is unrelated to SSRF."
        },
        {
          "text": "Implementing rate limiting on all API endpoints.",
          "misconception": "Targets [prevention confusion]: Rate limiting can mitigate some DoS aspects but doesn't stop the initial unauthorized request."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Allow-listing ensures that the server can only make requests to explicitly approved destinations, effectively blocking any attempts to forge requests to unauthorized internal or external resources.",
        "distractor_analysis": "The distractors suggest unrelated security measures. TLS protects data, SQLi sanitization protects databases, and rate limiting controls traffic volume, none of which directly prevent SSRF's core issue of unauthorized request initiation.",
        "analogy": "It's like having a strict guest list for a party. Only people on the list are allowed in, preventing anyone else from entering, regardless of how they try to get in or what they claim to be doing."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "SSRF_BASICS",
        "INPUT_VALIDATION"
      ]
    },
    {
      "question_text": "When testing for SSRF, what is the significance of using <code>file:///</code> URIs?",
      "correct_answer": "To attempt to read local files from the server's file system.",
      "distractors": [
        {
          "text": "To execute remote code on the server.",
          "misconception": "Targets [impact confusion]: File inclusion is for reading data, not direct code execution."
        },
        {
          "text": "To access internal network services.",
          "misconception": "Targets [protocol confusion]: `file://` is for local files, not network protocols like `http://` or `smb://`."
        },
        {
          "text": "To perform DNS lookups.",
          "misconception": "Targets [protocol confusion]: DNS lookups use different protocols (e.g., UDP/TCP port 53), not `file://`."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>file:///</code> URI scheme is designed to access local files on the server's filesystem. By manipulating an SSRF vulnerability to use this scheme, an attacker can attempt to read sensitive files like configuration files or password hashes.",
        "distractor_analysis": "The distractors misattribute the purpose of <code>file:///</code> URIs, confusing them with remote code execution, network service access, or DNS lookups, which require different protocols or mechanisms.",
        "analogy": "It's like using a library's internal catalog system to request a specific book from the library's own shelves, rather than asking for a book from another library or trying to write a new book."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "SSRF_BASICS",
        "FILE_SYSTEM_BASICS"
      ]
    },
    {
      "question_text": "What is the difference between SSRF and Server-Side Injection (SSI)?",
      "correct_answer": "SSRF involves tricking the server into making requests to unintended URLs, while SSI involves injecting commands or code that the server executes directly.",
      "distractors": [
        {
          "text": "SSRF targets client-side browsers, while SSI targets server-side applications.",
          "misconception": "Targets [client-server confusion]: Both SSRF and SSI primarily target the server, not the client browser."
        },
        {
          "text": "SSRF is used for data exfiltration, while SSI is used for denial-of-service.",
          "misconception": "Targets [impact confusion]: Both can potentially lead to various impacts, including data exfiltration or DoS, but their core mechanisms differ."
        },
        {
          "text": "SSRF requires a vulnerable web server, while SSI requires a vulnerable database.",
          "misconception": "Targets [component confusion]: Both typically exploit vulnerabilities in the application logic running on the server, not necessarily a specific database vulnerability for SSI."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SSRF exploits the server's ability to make network requests based on user input, directing those requests to unintended destinations. SSI, on the other hand, involves injecting commands or code that the server executes directly, like command injection or SQL injection.",
        "distractor_analysis": "The distractors incorrectly assign client-side targets, specific impact types, or component dependencies, failing to distinguish SSRF's request-forging nature from SSI's direct command/code execution.",
        "analogy": "SSRF is like tricking a mailroom clerk into sending mail to an unauthorized address. SSI is like tricking the clerk into opening and reading a secret message or executing a task from a note they received."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "SSRF_BASICS",
        "SERVER_SIDE_INJECTION_BASICS"
      ]
    },
    {
      "question_text": "Which of the following is an example of a URL that an attacker might use in an SSRF attempt to access internal resources?",
      "correct_answer": "http://169.254.169.254/latest/meta-data/",
      "distractors": [
        {
          "text": "https://www.google.com/search?q=ssrf",
          "misconception": "Targets [destination confusion]: This is a legitimate external URL, not an internal resource."
        },
        {
          "text": "ftp://example.com/files/document.pdf",
          "misconception": "Targets [protocol confusion]: While FTP can be used, this specific URL points to an external, likely legitimate, resource."
        },
        {
          "text": "mailto:user@example.com",
          "misconception": "Targets [protocol confusion]: The `mailto:` protocol is for sending emails, not for making HTTP-like requests to internal services."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The IP address <code>169.254.169.254</code> is a special link-local address used by cloud providers like AWS to expose instance metadata, which often contains sensitive credentials and configuration details. An SSRF vulnerability can be used to query this internal endpoint.",
        "distractor_analysis": "The distractors provide examples of legitimate external URLs, a standard file transfer protocol URL, or an email protocol URL, none of which are typically used to exploit SSRF for accessing internal cloud metadata.",
        "analogy": "It's like knowing the secret internal extension number for the CEO's office within a company, allowing you to bypass the main reception and directly reach a sensitive internal point."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "attack",
      "bloom_level": "apply",
      "prerequisites": [
        "SSRF_BASICS",
        "CLOUD_SECURITY_BASICS"
      ]
    },
    {
      "question_text": "What is the primary difference in impact between SSRF and Cross-Site Scripting (XSS)?",
      "correct_answer": "SSRF impacts the server's ability to interact with resources, while XSS impacts the user's browser session.",
      "distractors": [
        {
          "text": "SSRF targets the database, while XSS targets the web server.",
          "misconception": "Targets [target confusion]: SSRF targets server network requests, XSS targets the user's browser; neither directly targets the database in their primary function."
        },
        {
          "text": "SSRF allows attackers to steal user credentials, while XSS allows them to access internal files.",
          "misconception": "Targets [impact reversal]: XSS can steal credentials from the user's session, while SSRF can access internal files on the server."
        },
        {
          "text": "SSRF is a form of injection, while XSS is a form of broken authentication.",
          "misconception": "Targets [vulnerability classification confusion]: Both are injection flaws, and XSS is not primarily a broken authentication issue."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SSRF exploits the server's trust in handling URLs, enabling it to make requests to internal or external systems. XSS exploits the server's trust in rendering user-supplied content, allowing malicious scripts to execute in the user's browser.",
        "distractor_analysis": "The distractors incorrectly assign targets (database vs. server), reverse the primary impacts (credential theft vs. file access), and misclassify the vulnerability types.",
        "analogy": "SSRF is like a spy tricking a company's mailroom into sending sensitive internal documents to an external address. XSS is like a con artist tricking a customer into revealing their personal information at the point of sale."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "SSRF_BASICS",
        "XSS_BASICS"
      ]
    },
    {
      "question_text": "How can input validation help prevent SSRF vulnerabilities?",
      "correct_answer": "By ensuring that user-supplied URLs conform to expected formats, protocols, and destinations.",
      "distractors": [
        {
          "text": "By sanitizing user input to remove HTML tags.",
          "misconception": "Targets [validation scope confusion]: This is relevant for XSS prevention, not SSRF."
        },
        {
          "text": "By encrypting user-provided URLs before processing.",
          "misconception": "Targets [validation mechanism confusion]: Encryption does not validate the content or destination of a URL."
        },
        {
          "text": "By checking if the user is authenticated before accepting a URL.",
          "misconception": "Targets [validation mechanism confusion]: Authentication status is irrelevant to the security of processing a URL itself."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Strict input validation, such as using allow-lists for protocols (e.g., only <code>http</code>, <code>https</code>), domains, and IP address ranges, prevents attackers from submitting malicious URLs that point to internal resources or sensitive endpoints.",
        "distractor_analysis": "The distractors describe validation techniques for other vulnerabilities (XSS) or propose ineffective methods (encryption, authentication checks) that do not address the core issue of validating URL destinations.",
        "analogy": "It's like a security guard checking IDs and ensuring visitors are on the approved list before letting them enter specific areas of a building, rather than just checking if they have a badge or if they look official."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "SSRF_BASICS",
        "INPUT_VALIDATION"
      ]
    },
    {
      "question_text": "What is the role of a 'deny-list' in preventing SSRF, and what are its limitations?",
      "correct_answer": "A deny-list blocks known malicious URLs or patterns, but it is difficult to maintain and can be bypassed by attackers using variations.",
      "distractors": [
        {
          "text": "A deny-list allows only specific, pre-approved URLs, making it highly effective.",
          "misconception": "Targets [definition confusion]: This describes an allow-list, not a deny-list."
        },
        {
          "text": "A deny-list blocks all external requests, forcing the server to only use internal resources.",
          "misconception": "Targets [functionality confusion]: A deny-list aims to block specific bad inputs, not all external access."
        },
        {
          "text": "A deny-list is primarily used to prevent SQL injection by blocking specific keywords.",
          "misconception": "Targets [application confusion]: Deny-lists for SSRF focus on URL patterns, not SQL keywords."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Deny-lists attempt to block known bad inputs. For SSRF, this means blocking specific IP addresses, domains, or URL patterns. However, attackers can often find new ways to encode or construct URLs to bypass these lists.",
        "distractor_analysis": "The distractors misdefine deny-lists, confusing them with allow-lists, misrepresenting their blocking scope, or applying them to the wrong vulnerability type.",
        "analogy": "A deny-list is like having a list of known troublemakers at a club entrance. It works for those on the list, but new troublemakers can still get in if they aren't on the list yet."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "evaluate",
      "prerequisites": [
        "SSRF_BASICS",
        "INPUT_VALIDATION_STRATEGIES"
      ]
    },
    {
      "question_text": "Consider a scenario where a web application fetches an XML file from a user-provided URL. If the XML file contains external entity references that point to internal resources, what vulnerability is being exploited?",
      "correct_answer": "XML External Entity (XXE) injection, which can be a vector for SSRF.",
      "distractors": [
        {
          "text": "Cross-Site Scripting (XSS).",
          "misconception": "Targets [vulnerability type confusion]: XXE is distinct from XSS, which targets the user's browser."
        },
        {
          "text": "SQL Injection.",
          "misconception": "Targets [vulnerability type confusion]: XXE exploits XML parsing, not database queries."
        },
        {
          "text": "Buffer Overflow.",
          "misconception": "Targets [vulnerability type confusion]: XXE exploits XML parsing logic, not memory management issues."
        }
      ],
      "detailed_explanation": {
        "core_logic": "XXE allows an attacker to interfere with the processing of XML data by referencing external entities. If the server processes these external entities, it can lead to unauthorized access to local files or internal network resources, effectively becoming an SSRF vulnerability.",
        "distractor_analysis": "The distractors incorrectly identify the vulnerability as XSS, SQL Injection, or Buffer Overflow, which are unrelated to the exploitation of XML parsing vulnerabilities.",
        "analogy": "It's like a document processing system that can include content from other documents. If an attacker can trick the system into including sensitive internal files by manipulating the document references, it's an XXE/SSRF issue."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "scenario",
      "bloom_level": "analyze",
      "prerequisites": [
        "SSRF_BASICS",
        "XXE_BASICS",
        "XML_FUNDAMENTALS"
      ]
    },
    {
      "question_text": "What is the primary security concern when an application uses a URL provided by the user to fetch resources, such as images or data feeds?",
      "correct_answer": "The application might be tricked into making requests to internal network resources or sensitive cloud metadata endpoints.",
      "distractors": [
        {
          "text": "The application might be tricked into downloading malware that infects the user's computer.",
          "misconception": "Targets [impact confusion]: This describes a client-side download risk, not the server-side request risk of SSRF."
        },
        {
          "text": "The application might be tricked into sending sensitive user data to a third-party analytics service.",
          "misconception": "Targets [impact confusion]: While data leakage is possible, the primary SSRF risk is accessing internal resources, not just sending user data externally."
        },
        {
          "text": "The application might be tricked into performing Denial-of-Service attacks against the target URL.",
          "misconception": "Targets [impact confusion]: While SSRF can contribute to DoS, its core risk is unauthorized access to internal systems."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When a server processes user-supplied URLs, it can be manipulated to send requests to internal IP addresses (like <code>127.0.0.1</code> or private ranges) or cloud metadata endpoints, bypassing network security controls and potentially exposing sensitive information.",
        "distractor_analysis": "The distractors focus on client-side malware, general data leakage to third parties, or DoS impacts, failing to identify the specific risk of the server making unauthorized requests to internal or privileged endpoints.",
        "analogy": "It's like a receptionist who takes a message for a delivery and is told to send the package to a specific address. If the attacker gives an internal, restricted address, the receptionist might unknowingly send sensitive company materials to the wrong internal department or even outside the company's secure perimeter."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SSRF_BASICS",
        "NETWORK_SECURITY_PRINCIPLES"
      ]
    },
    {
      "question_text": "Which of the following is NOT a recommended defense mechanism against Server-Side Request Forgery (SSRF)?",
      "correct_answer": "Allowing all outbound requests from the server by default and only blocking known malicious IPs.",
      "distractors": [
        {
          "text": "Implementing a strict allow-list for all permitted destination URLs and protocols.",
          "misconception": "Targets [defense strategy confusion]: This is a recommended defense, not a non-recommended one."
        },
        {
          "text": "Disabling unused URL schemas (e.g., <code>file://</code>, <code>gopher://</code>) in the application's HTTP client.",
          "misconception": "Targets [defense strategy confusion]: This is a recommended defense, not a non-recommended one."
        },
        {
          "text": "Performing server-side validation to ensure URLs point to expected domains or IP ranges.",
          "misconception": "Targets [defense strategy confusion]: This is a recommended defense, not a non-recommended one."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Allowing all outbound requests by default and relying on a deny-list is a weak security posture for SSRF. A robust defense uses an allow-list approach, explicitly permitting only necessary and safe destinations.",
        "distractor_analysis": "The distractors describe effective SSRF prevention strategies (allow-listing, disabling schemas, server-side validation), contrasting with the insecure default-allow approach presented as the incorrect option.",
        "analogy": "It's like a security system that assumes everyone is allowed in unless they are on a specific 'bad guy' list. The safer approach is to assume no one is allowed in unless they are on a specific 'good guy' list."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "evaluate",
      "prerequisites": [
        "SSRF_BASICS",
        "INPUT_VALIDATION_STRATEGIES"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "006_Server-Side Request Forgery SSRF Software Development Security best practices",
    "latency_ms": 22260.864999999998
  },
  "timestamp": "2026-01-18T11:06:28.265067"
}