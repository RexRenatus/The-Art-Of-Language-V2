{
  "topic_title": "Use of Hard-coded Security-relevant Constants",
  "category": "Software Development Security - Common Web Application Vulnerabilities",
  "flashcards": [
    {
      "question_text": "According to CWE-547, what is the primary risk associated with using hard-coded, security-relevant constants instead of symbolic names in software development?",
      "correct_answer": "Increased likelihood of mistakes during code maintenance or security policy changes.",
      "distractors": [
        {
          "text": "Reduced code readability and maintainability.",
          "misconception": "Targets [readability focus]: Confuses a general coding issue with the specific security risk."
        },
        {
          "text": "Inability to perform static code analysis effectively.",
          "misconception": "Targets [analysis limitation]: Misunderstands how static analysis tools detect hard-coded values."
        },
        {
          "text": "Higher probability of buffer overflow vulnerabilities.",
          "misconception": "Targets [vulnerability type confusion]: Associates hard-coded constants with a different class of vulnerability."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Hard-coded constants make it difficult to update security policies or values across the codebase, increasing the chance of errors. Symbolic names (e.g., constants) allow for centralized updates, reducing maintenance risks.",
        "distractor_analysis": "The first distractor points to a general coding problem, not the specific security risk. The second incorrectly claims static analysis is hindered. The third wrongly links constants to buffer overflows.",
        "analogy": "Imagine using a specific date like '01/01/2023' for a recurring event instead of a variable like 'NEXT_ANNIVERSARY_DATE'. If the date needs changing, you have to find and replace every instance, risking missing one and causing an error."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CWE_547"
      ]
    },
    {
      "question_text": "Which of the following best describes a 'hard-coded credential' as defined by CWE-798?",
      "correct_answer": "A password or cryptographic key embedded directly within the source code or compiled binary.",
      "distractors": [
        {
          "text": "A password stored in an encrypted configuration file.",
          "misconception": "Targets [storage method confusion]: Assumes any embedded credential is encrypted, ignoring the 'hard-coded' aspect."
        },
        {
          "text": "A password that is automatically generated by the system.",
          "misconception": "Targets [generation vs. embedding confusion]: Confuses the origin of the credential with its implementation."
        },
        {
          "text": "A password that is transmitted over an unencrypted channel.",
          "misconception": "Targets [transmission vs. storage confusion]: Focuses on data in transit rather than data at rest in code."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CWE-798 identifies hard-coded credentials as sensitive information directly embedded in code. This is a security risk because anyone with access to the code or binary can potentially extract these credentials.",
        "distractor_analysis": "The first distractor describes a more secure practice (encrypted config). The second confuses credential generation with embedding. The third focuses on transmission security, not static code security.",
        "analogy": "It's like writing your house key's combination directly onto the front door instead of keeping it in a secure, separate place. Anyone looking at the door can see it."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CWE_798"
      ]
    },
    {
      "question_text": "According to the SEI CERT Oracle Coding Standard for Java (MSC03-J), why is hard-coding sensitive information like passwords or server IP addresses problematic?",
      "correct_answer": "It exposes the information to attackers who can decompile class files and discover it in clear text.",
      "distractors": [
        {
          "text": "It causes performance degradation due to increased file size.",
          "misconception": "Targets [performance focus]: Misattributes the risk to performance rather than security exposure."
        },
        {
          "text": "It violates network protocol standards, leading to connection failures.",
          "misconception": "Targets [protocol compliance confusion]: Links hard-coding to network communication errors, not direct exposure."
        },
        {
          "text": "It prevents the use of modern encryption algorithms.",
          "misconception": "Targets [algorithm compatibility confusion]: Incorrectly suggests hard-coding prevents using advanced crypto."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Hard-coding sensitive data makes it easily discoverable through decompilation, as shown in the SEI CERT example. This direct exposure bypasses intended security measures, making the information vulnerable.",
        "distractor_analysis": "The first distractor focuses on performance, which is not the primary security concern. The second incorrectly links it to network protocol violations. The third falsely claims it prevents modern encryption use.",
        "analogy": "It's like leaving your diary with all your secrets written inside on a public park bench. Anyone can pick it up and read it, no matter how well-written the diary entries are."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "MSC03-J",
        "CODE_DECOMPILATION"
      ]
    },
    {
      "question_text": "What is the main security implication of CWE-321, 'Use of Hard-coded Cryptographic Key'?",
      "correct_answer": "A compromised hard-coded key can allow attackers to decrypt sensitive data or forge signatures.",
      "distractors": [
        {
          "text": "It forces the use of weaker encryption algorithms.",
          "misconception": "Targets [algorithm weakness confusion]: Incorrectly assumes the key itself dictates algorithm strength."
        },
        {
          "text": "It increases the computational cost of encryption and decryption.",
          "misconception": "Targets [performance confusion]: Links key storage to processing overhead, not security compromise."
        },
        {
          "text": "It makes key management impossible without code changes.",
          "misconception": "Targets [management vs. exposure confusion]: Focuses on management difficulty rather than direct security breach."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A hard-coded cryptographic key, if discovered, is equivalent to an attacker possessing the key. This directly compromises the confidentiality and integrity of data protected by that key, as per CWE-321.",
        "distractor_analysis": "The first distractor wrongly links the key's presence to algorithm choice. The second incorrectly attributes performance issues to the key's storage. The third focuses on management complexity, not the immediate security breach.",
        "analogy": "It's like having the master key to a vault permanently attached to the vault door. If someone can access the door, they have the key and can open the vault."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "CWE_321",
        "CRYPTO_KEYS"
      ]
    },
    {
      "question_text": "Consider a scenario where a developer hard-codes an API key directly into a client-side JavaScript file. What is the most significant security risk?",
      "correct_answer": "The API key can be easily extracted by anyone viewing the page source, allowing unauthorized access to the API.",
      "distractors": [
        {
          "text": "The JavaScript file may fail to load, causing application errors.",
          "misconception": "Targets [functional error focus]: Confuses a security vulnerability with a potential functional bug."
        },
        {
          "text": "The browser's cache may store the API key insecurely.",
          "misconception": "Targets [caching mechanism confusion]: Focuses on browser caching rather than the direct exposure in the code."
        },
        {
          "text": "The API server may rate-limit requests due to the hard-coded key.",
          "misconception": "Targets [server-side control confusion]: Assumes the server's response is the primary risk, not the exposure itself."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Client-side code is inherently exposed. Hard-coding an API key there means the key is visible to anyone inspecting the code, enabling unauthorized use of the API. This is a direct security compromise.",
        "distractor_analysis": "The first distractor focuses on application errors, not security. The second shifts focus to browser caching, which is secondary to the code exposure. The third speculates on server responses, not the root cause.",
        "analogy": "It's like writing your username and password for a website directly into the HTML of the homepage. Anyone visiting the site can see your login details."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "CLIENT_SIDE_SECURITY",
        "API_KEY_MANAGEMENT"
      ]
    },
    {
      "question_text": "Which of the following is the MOST secure practice for handling sensitive configuration values like database passwords in a web application?",
      "correct_answer": "Store them in environment variables or a secure, external configuration management system.",
      "distractors": [
        {
          "text": "Embed them as constants within the application's source code.",
          "misconception": "Targets [direct code embedding]: This is the exact practice CWE-259 and MSC03-J warn against."
        },
        {
          "text": "Encrypt them using a hard-coded encryption key within the application.",
          "misconception": "Targets [nested hard-coding]: Creates a double vulnerability where both the password and its decryption key are exposed."
        },
        {
          "text": "Store them in a publicly accessible configuration file.",
          "misconception": "Targets [public accessibility]: Makes the sensitive data easily discoverable and exploitable."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Externalizing sensitive configuration data to environment variables or secure management systems prevents them from being embedded in code, thus avoiding direct exposure during code review or decompilation. This aligns with best practices like those implied by CWE-259.",
        "distractor_analysis": "The first option is the core vulnerability. The second creates a chained vulnerability. The third makes the data trivially accessible.",
        "analogy": "Instead of writing your house key's location on a sticky note attached to your front door (hard-coded), you keep it in a secure safe deposit box (environment variable/secure system)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "SECURE_CONFIG_MANAGEMENT",
        "CWE_259"
      ]
    },
    {
      "question_text": "A developer hard-codes a specific network port number (e.g., 8080) that is critical for a security service to function. This falls under which CWE category?",
      "correct_answer": "CWE-547: Use of Hard-coded, Security-relevant Constants",
      "distractors": [
        {
          "text": "CWE-798: Use of Hard-coded Credentials",
          "misconception": "Targets [credential confusion]: A port number is a constant, not a credential like a password or key."
        },
        {
          "text": "CWE-321: Use of Hard-coded Cryptographic Key",
          "misconception": "Targets [cryptographic confusion]: A port number is not used for encryption/decryption."
        },
        {
          "text": "CWE-259: Use of Hard-coded Password",
          "misconception": "Targets [password confusion]: A port number is not a password."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CWE-547 specifically addresses hard-coded constants that are security-relevant. A network port number used by a security service fits this definition because changing it might affect security configurations or communication protocols.",
        "distractor_analysis": "The distractors incorrectly map the constant to categories for credentials, cryptographic keys, or passwords, which are distinct types of hard-coded sensitive information.",
        "analogy": "It's like hard-coding the specific room number (e.g., 'Room 305') for a secret meeting in a building's blueprint, instead of using a variable like 'SECRET_MEETING_ROOM'. If the room changes, the blueprint is wrong."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "CWE_547",
        "CWE_798",
        "CWE_321",
        "CWE_259"
      ]
    },
    {
      "question_text": "Why is it considered a bad practice to hard-code values like TLS/SSL version numbers or cipher suite preferences directly in application code?",
      "correct_answer": "It prevents easy updates to support newer, more secure protocols and ciphers as older ones become deprecated or vulnerable.",
      "distractors": [
        {
          "text": "It increases the likelihood of syntax errors in the code.",
          "misconception": "Targets [syntax error focus]: Confuses a security best practice with a basic coding error."
        },
        {
          "text": "It requires the application to be recompiled for every minor network change.",
          "misconception": "Targets [recompilation focus]: Overstates the impact of changing protocol preferences."
        },
        {
          "text": "It limits the application's ability to connect to older systems.",
          "misconception": "Targets [backward compatibility focus]: Reverses the goal; the issue is often about *not* supporting *newer*, more secure protocols."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Security protocols and cipher suites evolve. Hard-coding specific versions or preferences (like TLS 1.0) prevents the application from easily adopting more secure, current standards (like TLS 1.3) when they become available or necessary, as older ones are deprecated.",
        "distractor_analysis": "The first distractor focuses on syntax errors, not security policy. The second exaggerates the recompilation need. The third incorrectly suggests it hinders connection to older systems rather than newer, more secure ones.",
        "analogy": "It's like hard-coding a specific phone number for customer support in your product manual. When they change the number, you can't easily update it, and customers can't reach support."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "TLS_PROTOCOLS",
        "CIPHER_SUITES",
        "SECURITY_EVOLUTION"
      ]
    },
    {
      "question_text": "A security audit reveals that an application uses hard-coded values for error codes that are exposed to users. What is the potential security risk?",
      "correct_answer": "Attackers can infer internal application logic or system states by observing specific error codes.",
      "distractors": [
        {
          "text": "The application may crash due to invalid error code handling.",
          "misconception": "Targets [functional failure focus]: Confuses security inference with application stability."
        },
        {
          "text": "The hard-coded error codes consume excessive memory resources.",
          "misconception": "Targets [resource consumption focus]: Attributes the risk to resource usage, not information leakage."
        },
        {
          "text": "The error codes might conflict with operating system error messages.",
          "misconception": "Targets [OS conflict focus]: Suggests an OS-level interaction problem rather than an application-level information leak."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Exposing internal error codes (e.g., 'DB_CONN_FAILED', 'USER_NOT_FOUND') can provide attackers with valuable information about the application's internal workings, vulnerabilities, or data structures, aiding in further exploitation.",
        "distractor_analysis": "The first distractor focuses on application crashes, not information leakage. The second incorrectly links the issue to memory usage. The third suggests an OS conflict, which is not the primary security concern.",
        "analogy": "It's like a vending machine displaying 'Item X Out of Stock' instead of just 'Error'. An attacker learns that 'Item X' is stocked, which might be useful information."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "analyze",
      "prerequisites": [
        "ERROR_HANDLING",
        "INFORMATION_LEAKAGE"
      ]
    },
    {
      "question_text": "What is the primary reason to avoid hard-coding file paths for sensitive configuration files?",
      "correct_answer": "It limits flexibility in deployment and makes it harder to secure the file's location independently of the application code.",
      "distractors": [
        {
          "text": "It increases the risk of file permission errors.",
          "misconception": "Targets [permission focus]: Confuses file path hard-coding with file system permission management."
        },
        {
          "text": "It prevents the application from accessing files on different operating systems.",
          "misconception": "Targets [OS compatibility focus]: Overstates the impact on cross-platform compatibility."
        },
        {
          "text": "It makes the file path susceptible to SQL injection attacks.",
          "misconception": "Targets [injection vulnerability confusion]: Links file path hard-coding to a different attack vector."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Hard-coding file paths ties the application's configuration to a specific location. This hinders deployment flexibility (e.g., moving the config file to a more secure directory) and makes it difficult to manage access controls separately from the application's code.",
        "distractor_analysis": "The first distractor focuses on permissions, which is a related but distinct issue. The second exaggerates the cross-platform impact. The third incorrectly associates file path hard-coding with SQL injection.",
        "analogy": "It's like hard-coding the exact shelf and drawer number in your house where you keep your important documents. If you later move those documents to a safe, the instruction is now wrong and useless."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "FILE_PATH_MANAGEMENT",
        "DEPLOYMENT_SECURITY"
      ]
    },
    {
      "question_text": "Consider a situation where a developer hard-codes a specific user ID or role name used for authorization checks. What is the security implication?",
      "correct_answer": "It can lead to privilege escalation if the hard-coded value is bypassed or if the authorization logic is flawed.",
      "distractors": [
        {
          "text": "It causes performance issues during authorization checks.",
          "misconception": "Targets [performance focus]: Misattributes the risk to performance rather than authorization bypass."
        },
        {
          "text": "It prevents the application from supporting multiple user roles.",
          "misconception": "Targets [role support limitation]: Suggests it breaks role support, rather than creating a specific bypass."
        },
        {
          "text": "It requires users to know the hard-coded ID to log in.",
          "misconception": "Targets [login requirement confusion]: Confuses authorization checks with authentication mechanisms."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Hard-coding authorization values (like 'admin_id = 123') can create vulnerabilities. If an attacker can manipulate the code or data to match this hard-coded value, they might gain unauthorized privileges. It bypasses more robust, dynamic authorization checks.",
        "distractor_analysis": "The first distractor focuses on performance, not security. The second incorrectly claims it prevents multiple role support. The third confuses authorization checks with login requirements.",
        "analogy": "It's like having a secret handshake that only 'Alice' knows to get into a VIP room. If someone figures out the handshake, they can impersonate Alice and get in, bypassing normal security."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "analyze",
      "prerequisites": [
        "AUTHORIZATION",
        "PRIVILEGE_ESCALATION"
      ]
    },
    {
      "question_text": "Which of the following is a recommended mitigation strategy for preventing the use of hard-coded security-relevant constants?",
      "correct_answer": "Utilize configuration files or environment variables managed securely outside the application code.",
      "distractors": [
        {
          "text": "Implement a linter rule that flags all numeric literals.",
          "misconception": "Targets [overly broad rule]: Flags all numbers, not just security-relevant constants, leading to noise."
        },
        {
          "text": "Store all constants in a separate, unencrypted code module.",
          "misconception": "Targets [unencrypted storage]: Moving constants to another module without proper security doesn't solve the exposure problem."
        },
        {
          "text": "Use code obfuscation techniques to hide the constants.",
          "misconception": "Targets [obfuscation as solution]: Obfuscation is not true security and can often be reversed."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Externalizing sensitive constants to secure, managed locations like environment variables or configuration files ensures they are not embedded within the application's source code or binaries, thus preventing direct exposure and allowing for easier updates.",
        "distractor_analysis": "The first distractor is too broad and impractical. The second fails to secure the constants. The third relies on obscurity, which is not a robust security measure.",
        "analogy": "Instead of writing your Wi-Fi password directly on your router (hard-coded), you store it securely in a password manager (external configuration)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "SECURE_CONFIG_MANAGEMENT",
        "MITIGATION_STRATEGIES"
      ]
    },
    {
      "question_text": "What is the primary difference between CWE-547 (Use of Hard-coded, Security-relevant Constants) and CWE-798 (Use of Hard-coded Credentials)?",
      "correct_answer": "CWE-547 applies to any security-related value (like ports, timeouts, or flags), while CWE-798 specifically targets authentication secrets (passwords, keys).",
      "distractors": [
        {
          "text": "CWE-547 is for software, CWE-798 is for hardware.",
          "misconception": "Targets [domain confusion]: Both CWEs apply to software; hardware is a separate concern."
        },
        {
          "text": "CWE-798 involves reversible data, CWE-547 involves irreversible data.",
          "misconception": "Targets [data reversibility confusion]: Neither CWE inherently implies reversibility; it depends on the constant/credential type."
        },
        {
          "text": "CWE-547 is about configuration errors, CWE-798 is about authentication bypass.",
          "misconception": "Targets [scope confusion]: Both can lead to authentication bypass or other security failures, but the core definition differs."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CWE-547 is broader, covering any security-critical constant (e.g., a default timeout value). CWE-798 is specific to credentials like passwords and keys used for authentication. Both are forms of hard-coding but target different types of sensitive information.",
        "distractor_analysis": "The first distractor incorrectly separates software and hardware domains. The second misapplies the concept of data reversibility. The third oversimplifies the scope and impact of each CWE.",
        "analogy": "CWE-547 is like hard-coding the 'secret handshake' needed to enter a club (a security-relevant constant). CWE-798 is like hard-coding the actual 'password' to get into the club's back office (a credential)."
      },
      "code_snippets": [],
      "difficulty": "master",
      "question_type": "comparison",
      "bloom_level": "evaluate",
      "prerequisites": [
        "CWE_547",
        "CWE_798"
      ]
    },
    {
      "question_text": "A security researcher discovers that an application hard-codes a specific encryption algorithm identifier (e.g., 'AES128-CBC') instead of using a configurable setting. What is the primary security concern?",
      "correct_answer": "It prevents the application from easily migrating to stronger, more modern encryption algorithms as standards evolve.",
      "distractors": [
        {
          "text": "It makes the application vulnerable to denial-of-service attacks.",
          "misconception": "Targets [DoS confusion]: Links algorithm identification to availability issues, not cryptographic strength."
        },
        {
          "text": "It increases the computational overhead of encryption operations.",
          "misconception": "Targets [performance confusion]: Assumes hard-coding algorithm identifiers impacts processing speed."
        },
        {
          "text": "It exposes the specific encryption implementation details to attackers.",
          "misconception": "Targets [implementation detail focus]: While true, the *primary* concern is the inability to update to *better* algorithms, not just revealing the current one."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Hard-coding an encryption algorithm identifier (like 'AES128-CBC') prevents the application from easily adopting newer, more secure algorithms (e.g., AES-GCM) when they become available or when older ones are found to be weak. This limits future security enhancements.",
        "distractor_analysis": "The first distractor incorrectly links algorithm identification to DoS. The second wrongly suggests performance impacts. The third focuses on revealing current implementation, which is less critical than the inability to upgrade.",
        "analogy": "It's like hard-coding a specific type of lock (e.g., a simple tumbler lock) for your house, preventing you from upgrading to a high-security deadbolt later if needed."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "CRYPTOGRAPHIC_ALGORITHMS",
        "SECURITY_STANDARDS_EVOLUTION"
      ]
    },
    {
      "question_text": "Which NIST Special Publication provides guidance relevant to avoiding hard-coded security-relevant constants and credentials?",
      "correct_answer": "NIST SP 800-53, Security and Privacy Controls for Information Systems and Organizations",
      "distractors": [
        {
          "text": "NIST SP 800-63, Digital Identity Guidelines",
          "misconception": "Targets [identity focus]: While related to credentials, SP 800-63 focuses more on identity proofing and authentication mechanisms, not code-level constants."
        },
        {
          "text": "NIST SP 800-171, Protecting Controlled Unclassified Information in Nonfederal Information Systems and Organizations",
          "misconception": "Targets [CUI focus]: This publication focuses on protecting specific types of data, not general secure coding practices for constants."
        },
        {
          "text": "NIST SP 1800 series, Cybersecurity Practice Guides",
          "misconception": "Targets [practical guide focus]: These are often specific implementations or solutions, not foundational secure coding principles for constants."
        }
      ],
      "detailed_explanation": {
        "core_logic": "NIST SP 800-53 includes control families like 'System and Communications Protection' (SC) and 'Identification and Access Management' (IA) which indirectly address secure coding practices, including the need to manage secrets and configurations securely, thus discouraging hard-coding.",
        "distractor_analysis": "SP 800-63 is about digital identity management. SP 800-171 is about protecting CUI. The SP 1800 series provides practical guides but doesn't typically detail low-level coding standards like avoiding hard-coded constants as directly as SP 800-53's control objectives imply.",
        "analogy": "NIST SP 800-53 is like a comprehensive building code that mandates secure locks and alarm systems (controls) for all rooms, implicitly discouraging leaving valuables in plain sight (hard-coded constants)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "NIST_SP_800_53",
        "SECURE_CODING_STANDARDS"
      ]
    },
    {
      "question_text": "A developer hard-codes a default administrative username and password for a device's management interface. Which CWE is MOST applicable?",
      "correct_answer": "CWE-798: Use of Hard-coded Credentials",
      "distractors": [
        {
          "text": "CWE-547: Use of Hard-coded, Security-relevant Constants",
          "misconception": "Targets [credential vs. constant confusion]: While a username/password are constants, CWE-798 is more specific and directly applicable to authentication secrets."
        },
        {
          "text": "CWE-321: Use of Hard-coded Cryptographic Key",
          "misconception": "Targets [key vs. credential confusion]: Usernames and passwords are not cryptographic keys."
        },
        {
          "text": "CWE-259: Use of Hard-coded Password",
          "misconception": "Targets [password specificity]: CWE-798 is broader and covers both passwords and keys, making it a more encompassing choice when both might be present or implied."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CWE-798 specifically addresses hard-coded credentials, which include usernames and passwords used for authentication. While CWE-259 also applies to passwords, CWE-798 is often preferred as it covers both passwords and cryptographic keys, providing a more comprehensive category for authentication secrets embedded in code.",
        "distractor_analysis": "CWE-547 is too general. CWE-321 is for cryptographic keys, not passwords. CWE-259 is specific to passwords but CWE-798 is often used as the umbrella term for hard-coded authentication secrets.",
        "analogy": "It's like writing the default 'admin' username and 'password123' directly on the back of a router. This is a hard-coded credential, fitting CWE-798 perfectly."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "CWE_798",
        "CWE_259",
        "AUTHENTICATION_SECRETS"
      ]
    },
    {
      "question_text": "What is the primary security benefit of using symbolic constants (e.g., <code>MAX_CONNECTIONS = 100</code>) instead of hard-coded numeric literals (e.g., <code>100</code>) for security-relevant values?",
      "correct_answer": "It centralizes the value, making it easier to update and manage consistently across the codebase, reducing the risk of errors.",
      "distractors": [
        {
          "text": "It automatically encrypts the value when the code is compiled.",
          "misconception": "Targets [encryption confusion]: Symbolic constants do not inherently provide encryption."
        },
        {
          "text": "It allows the value to be changed at runtime without recompiling.",
          "misconception": "Targets [runtime change confusion]: Symbolic constants are typically resolved at compile time; runtime changes require different mechanisms."
        },
        {
          "text": "It improves the performance of the application by reducing memory usage.",
          "misconception": "Targets [performance confusion]: The performance difference between a literal and a symbolic constant is usually negligible."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Symbolic constants, defined once, allow for centralized management. If a security-relevant value like <code>MAX_CONNECTIONS</code> needs to change (e.g., due to a security policy update), modifying the single constant definition is far less error-prone than finding and replacing every instance of the literal <code>100</code> throughout the code.",
        "distractor_analysis": "Symbolic constants do not encrypt values. They are typically compile-time resolutions, not runtime changes. Performance differences are usually insignificant compared to the maintainability and security benefits.",
        "analogy": "It's like having a single 'master switch' for all the lights in your house (symbolic constant) versus having to manually turn off each individual light bulb (hard-coded literal). If you want to turn them all off, the master switch is much easier and less error-prone."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "SYMBOLIC_CONSTANTS",
        "CODE_MAINTAINABILITY"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 17,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Use of Hard-coded Security-relevant Constants Software Development Security best practices",
    "latency_ms": 30106.872
  },
  "timestamp": "2026-01-18T11:02:26.786098"
}