{
  "topic_title": "Improper Content Security Policy CSP Configuration",
  "category": "Software Development Security - Common Web Application Vulnerabilities",
  "flashcards": [
    {
      "question_text": "What is the primary purpose of a Content Security Policy (CSP) in web development?",
      "correct_answer": "To mitigate the risk of certain security threats, primarily Cross-Site Scripting (XSS) and data injection attacks, by controlling which resources a browser is allowed to load.",
      "distractors": [
        {
          "text": "To enforce strict HTTPS connections for all website traffic.",
          "misconception": "Targets [scope confusion]: Confuses CSP's primary XSS mitigation with the function of 'upgrade-insecure-requests' directive."
        },
        {
          "text": "To automatically sanitize all user-submitted input before it is processed.",
          "misconception": "Targets [mechanism confusion]: Misunderstands CSP as an input sanitization tool rather than a resource loading control."
        },
        {
          "text": "To encrypt all sensitive data transmitted between the client and server.",
          "misconception": "Targets [domain confusion]: Equates CSP with data encryption, which is handled by protocols like TLS/SSL."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CSP functions by providing a set of instructions to the browser, thereby preventing the execution of unauthorized scripts and controlling resource loading. This is because CSP directives specify valid sources for content, directly mitigating XSS by blocking untrusted scripts.",
        "distractor_analysis": "The distractors incorrectly focus on HTTPS enforcement, input sanitization, or data encryption, which are separate security mechanisms, not the core function of CSP.",
        "analogy": "Think of CSP as a strict bouncer at a club, only allowing approved guests (resources) to enter and preventing unauthorized individuals (malicious scripts) from causing trouble."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "WEB_SECURITY_BASICS",
        "XSS_FUNDAMENTALS"
      ]
    },
    {
      "question_text": "Which HTTP header is primarily used to deliver a Content Security Policy (CSP) to the browser?",
      "correct_answer": "Content-Security-Policy",
      "distractors": [
        {
          "text": "X-Content-Security-Policy",
          "misconception": "Targets [outdated standard confusion]: This was an older, non-standard header for CSP."
        },
        {
          "text": "Strict-Transport-Security",
          "misconception": "Targets [related header confusion]: This header enforces HTTPS, not general resource loading policies."
        },
        {
          "text": "X-Frame-Options",
          "misconception": "Targets [specific directive confusion]: This header is for clickjacking protection, a subset of CSP's capabilities."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>Content-Security-Policy</code> header is the standard mechanism for delivering CSP directives to the browser. This is because it's the officially recognized HTTP header for this purpose, allowing browsers to interpret and enforce the defined security policy.",
        "distractor_analysis": "Distractors represent older or related headers that serve different security functions, leading students to confuse CSP with other security mechanisms.",
        "analogy": "The <code>Content-Security-Policy</code> header is like the official address label on a package, clearly indicating its contents and destination for the postal service (the browser)."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "HTTP_HEADERS",
        "CSP_BASICS"
      ]
    },
    {
      "question_text": "In CSP, what is the purpose of the <code>default-src</code> directive?",
      "correct_answer": "It acts as a fallback for other fetch directives, specifying the default set of allowed sources for various resource types if a more specific directive is not present.",
      "distractors": [
        {
          "text": "It exclusively controls the loading of JavaScript files.",
          "misconception": "Targets [specific directive confusion]: Confuses `default-src` with `script-src`."
        },
        {
          "text": "It enforces that all resources must be loaded over HTTPS.",
          "misconception": "Targets [scope confusion]: Misunderstands `default-src` as a general security enforcement, similar to `upgrade-insecure-requests`."
        },
        {
          "text": "It defines the allowed origins for form submissions.",
          "misconception": "Targets [directive mapping error]: Confuses `default-src` with `form-action`."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>default-src</code> directive is crucial because it provides a baseline security level for all resource types not explicitly covered by other fetch directives. This is because it simplifies policy management by allowing a single source to be applied broadly, reducing the need for repetitive directives.",
        "distractor_analysis": "The distractors incorrectly assign specific functions (JavaScript, HTTPS, form actions) to <code>default-src</code>, which are handled by more specific CSP directives.",
        "analogy": "<code>default-src</code> is like the 'catch-all' rule in a game; if no specific rule applies, this general rule is used. It sets the default behavior for most actions."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CSP_DIRECTIVES",
        "CSP_FETCH_DIRECTIVES"
      ]
    },
    {
      "question_text": "Which CSP directive is specifically used to restrict the sources from which JavaScript can be loaded and executed?",
      "correct_answer": "script-src",
      "distractors": [
        {
          "text": "connect-src",
          "misconception": "Targets [related directive confusion]: Controls connections to endpoints, not script execution directly."
        },
        {
          "text": "style-src",
          "misconception": "Targets [resource type confusion]: Controls CSS stylesheets, not JavaScript."
        },
        {
          "text": "img-src",
          "misconception": "Targets [resource type confusion]: Controls image sources, not JavaScript."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>script-src</code> directive is specifically designed to control JavaScript sources because JavaScript is a primary vector for XSS attacks. By defining trusted sources for scripts, websites can prevent the execution of malicious code injected by attackers.",
        "distractor_analysis": "The distractors represent directives for other resource types (connections, styles, images), leading students to select an incorrect directive for JavaScript control.",
        "analogy": "<code>script-src</code> is like a security guard for your website's code, only allowing approved scripts (from trusted sources) to run."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "CSP_DIRECTIVES",
        "XSS_MITIGATION"
      ]
    },
    {
      "question_text": "What is the security implication of using <code>&#x27;unsafe-inline&#x27;</code> in a CSP <code>script-src</code> directive?",
      "correct_answer": "It allows inline JavaScript (e.g., inline event handlers like <code>onclick</code>) and inline <code>&lt;script&gt;</code> blocks to execute, which can reintroduce XSS vulnerabilities if not carefully managed.",
      "distractors": [
        {
          "text": "It enables the use of <code>eval()</code> and similar JavaScript functions.",
          "misconception": "Targets [directive value confusion]: `eval()` is controlled by `'unsafe-eval'`."
        },
        {
          "text": "It permits scripts to be loaded from any external domain.",
          "misconception": "Targets [scope confusion]: `'unsafe-inline'` pertains to inline code, not external script origins."
        },
        {
          "text": "It automatically hashes all inline scripts for verification.",
          "misconception": "Targets [mechanism confusion]: Hashing is a different method for allowing specific inline scripts."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Using <code>&#x27;unsafe-inline&#x27;</code> weakens CSP's protection because it permits inline scripts and event handlers, which are common targets for XSS attacks. This is because attackers can often inject malicious code into these inline contexts, bypassing the policy's intended restrictions.",
        "distractor_analysis": "The distractors confuse <code>&#x27;unsafe-inline&#x27;</code> with <code>&#x27;unsafe-eval&#x27;</code>, external script loading, or hashing mechanisms, misrepresenting its security impact.",
        "analogy": "Allowing <code>&#x27;unsafe-inline&#x27;</code> is like leaving the back door of your house unlocked, even though the front door is secured. It creates an easy entry point for potential intruders (attackers)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "CSP_SCRIPT_SRC",
        "XSS_VULNERABILITIES"
      ]
    },
    {
      "question_text": "When implementing a strict CSP, what is the recommended approach for allowing specific inline scripts instead of using <code>&#x27;unsafe-inline&#x27;</code>?",
      "correct_answer": "Use nonces (numbers used once) or hashes to explicitly allow specific inline scripts or script blocks.",
      "distractors": [
        {
          "text": "Whitelisting all external JavaScript libraries.",
          "misconception": "Targets [strategy confusion]: Focuses on external scripts, not inline ones, and broad whitelisting is less secure."
        },
        {
          "text": "Disabling all JavaScript execution entirely.",
          "misconception": "Targets [overly restrictive approach]: While secure, it's often impractical for modern web applications."
        },
        {
          "text": "Allowing all scripts from the same origin as the page.",
          "misconception": "Targets [scope confusion]: This is a common pattern but doesn't specifically address inline scripts and can be too broad."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Nonces and hashes provide a more granular and secure way to permit specific inline scripts, as they are cryptographically tied to the script content or session. This is because they ensure that only the intended, verified inline scripts can execute, unlike the broad allowance of <code>&#x27;unsafe-inline&#x27;</code>.",
        "distractor_analysis": "The distractors suggest less secure or impractical alternatives, such as broad whitelisting, complete JavaScript disabling, or same-origin allowances, which don't address the specific need for controlled inline script execution.",
        "analogy": "Instead of leaving the whole toolbox open (<code>&#x27;unsafe-inline&#x27;</code>), using nonces or hashes is like giving a specific key to a specific tool for a specific job, ensuring only the right tool is used."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "CSP_NONCES",
        "CSP_HASHES",
        "SECURE_CODING_PRACTICES"
      ]
    },
    {
      "question_text": "What is the primary security benefit of using the <code>frame-ancestors</code> directive in CSP?",
      "correct_answer": "It prevents clickjacking attacks by controlling which domains are allowed to embed the page within an iframe or frame.",
      "distractors": [
        {
          "text": "It prevents cross-site scripting (XSS) attacks.",
          "misconception": "Targets [directive scope confusion]: XSS is primarily handled by `script-src` and `default-src`."
        },
        {
          "text": "It enforces secure communication channels (HTTPS).",
          "misconception": "Targets [related directive confusion]: This is the function of `upgrade-insecure-requests` or HSTS."
        },
        {
          "text": "It restricts the types of plugins that can be loaded.",
          "misconception": "Targets [specific directive confusion]: This is handled by `object-src` or `plugin-types`."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>frame-ancestors</code> directive is critical for preventing clickjacking because it dictates which external sites can frame the current page. This is because clickjacking relies on tricking users into clicking on something different from what they perceive, often by embedding a legitimate site within a malicious one.",
        "distractor_analysis": "The distractors incorrectly attribute XSS prevention, HTTPS enforcement, or plugin restrictions to <code>frame-ancestors</code>, which are handled by other CSP directives or security mechanisms.",
        "analogy": "<code>frame-ancestors</code> is like setting rules for who can put your picture in their photo album; it prevents others from framing your page maliciously."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "CLICKJACKING_MITIGATION",
        "CSP_FRAME_ANCESTORS"
      ]
    },
    {
      "question_text": "Consider a CSP policy: <code>Content-Security-Policy: default-src &#x27;self&#x27;; script-src &#x27;self&#x27; https://trusted.cdn.com; img-src *;</code> What is the allowed source for images?",
      "correct_answer": "Any source, as indicated by the wildcard character <code>*</code>.",
      "distractors": [
        {
          "text": "Only the same origin as the page (<code>&#x27;self&#x27;</code>).",
          "misconception": "Targets [directive inheritance confusion]: Incorrectly assumes `img-src` inherits from `default-src` or `script-src`."
        },
        {
          "text": "The same origin and <code>https://trusted.cdn.com</code>.",
          "misconception": "Targets [directive scope confusion]: Confuses the sources allowed for scripts with those for images."
        },
        {
          "text": "No external sources are allowed for images.",
          "misconception": "Targets [wildcard misinterpretation]: Fails to recognize the meaning of the `*` wildcard."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>img-src *</code> directive explicitly allows images to be loaded from any origin because the asterisk (<code>*</code>) is a wildcard character in CSP source lists. This is because CSP directives are processed individually, and <code>img-src *</code> overrides any more restrictive default or specific source for images.",
        "distractor_analysis": "The distractors incorrectly apply other directives' sources or misinterpret the wildcard, failing to understand that <code>*</code> permits any source for images.",
        "analogy": "The <code>img-src *</code> is like saying 'any artist can contribute a picture to this gallery,' meaning images can come from anywhere."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "CSP_SOURCE_LISTS",
        "CSP_IMG_SRC"
      ]
    },
    {
      "question_text": "What is the risk associated with using <code>script-src &#x27;unsafe-eval&#x27;</code> in a CSP?",
      "correct_answer": "It allows the execution of dynamically generated JavaScript code, such as code created by <code>eval()</code> or <code>new Function()</code>, which can be exploited for XSS if the generated code is untrusted.",
      "distractors": [
        {
          "text": "It permits inline JavaScript event handlers like <code>onclick</code>.",
          "misconception": "Targets [directive value confusion]: This is controlled by `'unsafe-inline'`."
        },
        {
          "text": "It allows scripts to be loaded from any domain.",
          "misconception": "Targets [scope confusion]: This is controlled by `script-src *` or `default-src *`."
        },
        {
          "text": "It enables the use of WebAssembly modules.",
          "misconception": "Targets [technology confusion]: WebAssembly execution is typically controlled by `script-src` or other directives, not directly by `'unsafe-eval'`."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>&#x27;unsafe-eval&#x27;</code> directive is risky because it permits the execution of code generated at runtime, such as through <code>eval()</code>. This is because attackers can inject malicious strings that are then evaluated as code, leading to XSS if the application doesn't properly sanitize the input used to generate the code.",
        "distractor_analysis": "The distractors confuse <code>&#x27;unsafe-eval&#x27;</code> with <code>&#x27;unsafe-inline&#x27;</code>, broad script sourcing, or WebAssembly, misrepresenting the specific risk it introduces.",
        "analogy": "<code>&#x27;unsafe-eval&#x27;</code> is like allowing a chef to create recipes on the fly using any ingredients they find; if they find poisoned ingredients, the meal (and your system) can be compromised."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "CSP_UNSAFE_EVAL",
        "JAVASCRIPT_SECURITY"
      ]
    },
    {
      "question_text": "Which CSP directive is used to control the sources for web workers and nested browsing contexts (e.g., iframes)?",
      "correct_answer": "child-src",
      "distractors": [
        {
          "text": "frame-src",
          "misconception": "Targets [directive hierarchy confusion]: `child-src` is a fallback for `frame-src`, but `child-src` is more general."
        },
        {
          "text": "worker-src",
          "misconception": "Targets [directive specificity confusion]: `worker-src` is specific to workers, but `child-src` covers both workers and frames."
        },
        {
          "text": "connect-src",
          "misconception": "Targets [resource type confusion]: Controls network connections, not the embedding of contexts."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>child-src</code> directive is designed to manage resources loaded into nested browsing contexts, including web workers and elements like <code>&lt;iframe&gt;</code>. This is because it provides a consolidated way to control these specific types of embedded content, which can be vectors for attacks like clickjacking.",
        "distractor_analysis": "The distractors represent directives that are either superseded by <code>child-src</code> (<code>frame-src</code>, <code>worker-src</code>) or control different resource types (<code>connect-src</code>), leading to confusion about <code>child-src</code>'s specific role.",
        "analogy": "<code>child-src</code> is like the security gatekeeper for secondary areas of your property (like guest houses or workshops), controlling who or what can enter those specific zones."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CSP_DIRECTIVES",
        "WEB_WORKERS",
        "IFRAME_SECURITY"
      ]
    },
    {
      "question_text": "What is the purpose of the <code>upgrade-insecure-requests</code> directive in CSP?",
      "correct_answer": "It instructs the browser to treat all of a site's insecure (HTTP) URLs as if they were secure (HTTPS) URLs, effectively upgrading connections.",
      "distractors": [
        {
          "text": "It forces all external resources to be loaded over HTTPS.",
          "misconception": "Targets [scope confusion]: While it upgrades requests, it primarily affects the site's own resources, not necessarily all external ones."
        },
        {
          "text": "It encrypts all data transmitted between the client and server.",
          "misconception": "Targets [mechanism confusion]: This is the role of TLS/SSL, not a CSP directive."
        },
        {
          "text": "It prevents the use of mixed content by blocking insecure resources.",
          "misconception": "Targets [action confusion]: It attempts to upgrade, not strictly block, insecure requests, which is a different approach."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>upgrade-insecure-requests</code> directive is crucial for mitigating mixed content issues and enhancing security by ensuring all requests are made over HTTPS. This is because it automatically rewrites HTTP URLs to HTTPS, preventing attackers from intercepting or modifying insecurely loaded resources.",
        "distractor_analysis": "The distractors misrepresent the directive's function by conflating it with general HTTPS enforcement for external resources, data encryption, or strict blocking of insecure content.",
        "analogy": "<code>upgrade-insecure-requests</code> is like a helpful assistant that automatically corrects a typo in an address, ensuring all mail (requests) goes to the secure destination (HTTPS) instead of the insecure one (HTTP)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "MIXED_CONTENT",
        "HTTPS_SECURITY",
        "CSP_UPGRADE_INSECURE_REQUESTS"
      ]
    },
    {
      "question_text": "What is the primary risk of a misconfigured CSP that uses <code>default-src *</code> without specific overrides?",
      "correct_answer": "It allows resources to be loaded from any origin, effectively disabling CSP's ability to prevent XSS and other injection attacks by allowing malicious scripts from anywhere.",
      "distractors": [
        {
          "text": "It prevents all JavaScript from executing, making the site non-functional.",
          "misconception": "Targets [overly restrictive interpretation]: `*` allows any source, it doesn't block execution."
        },
        {
          "text": "It only allows resources from the same origin, creating a security hole.",
          "misconception": "Targets [source interpretation error]: `*` means any origin, not just the same origin."
        },
        {
          "text": "It forces all connections to use HTTPS, potentially breaking HTTP-only resources.",
          "misconception": "Targets [directive confusion]: `*` is a source specifier, not an HTTPS enforcer."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Using <code>default-src *</code> is highly insecure because it permits resources from any domain to be loaded, including malicious scripts. This is because the wildcard <code>*</code> essentially negates the protective intent of CSP, allowing attackers to inject and execute arbitrary code from untrusted sources.",
        "distractor_analysis": "The distractors incorrectly suggest that <code>*</code> blocks JavaScript, restricts to the same origin, or enforces HTTPS, failing to grasp that it broadly permits any source.",
        "analogy": "Setting <code>default-src *</code> is like leaving all doors and windows of your house wide open, inviting anyone and anything to come in, completely defeating your security measures."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "CSP_WILDCARD",
        "XSS_ATTACK_VECTORS"
      ]
    },
    {
      "question_text": "When is it acceptable to use <code>&#x27;unsafe-inline&#x27;</code> or <code>&#x27;unsafe-eval&#x27;</code> in a CSP?",
      "correct_answer": "Only when absolutely necessary for legacy applications or specific functionalities that cannot be refactored, and with extreme caution, ideally combined with other security measures and reporting.",
      "distractors": [
        {
          "text": "Whenever it simplifies development or reduces initial coding effort.",
          "misconception": "Targets [risk assessment error]: Prioritizes convenience over security."
        },
        {
          "text": "For any application that uses client-side JavaScript frameworks.",
          "misconception": "Targets [overgeneralization]: Many modern frameworks can work with stricter CSPs."
        },
        {
          "text": "When the website is internal-only and not exposed to the public internet.",
          "misconception": "Targets [threat model error]: Internal systems can still be targets for insider threats or lateral movement."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The use of <code>&#x27;unsafe-inline&#x27;</code> and <code>&#x27;unsafe-eval&#x27;</code> should be a last resort because they significantly weaken CSP's effectiveness against XSS. This is because they reintroduce vulnerabilities that CSP is designed to prevent, making the application more susceptible to attacks if not managed with extreme care and compensating controls.",
        "distractor_analysis": "The distractors suggest using these unsafe options for convenience, common frameworks, or internal-only applications, all of which overlook the inherent security risks.",
        "analogy": "Using <code>&#x27;unsafe-inline&#x27;</code> or <code>&#x27;unsafe-eval&#x27;</code> is like deciding to leave a known weak point in your castle wall; it might be easier to build, but it's a clear target for attackers."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "evaluate",
      "prerequisites": [
        "CSP_BEST_PRACTICES",
        "SECURE_SOFTWARE_LIFECYCLE"
      ]
    },
    {
      "question_text": "What is the role of CSP reporting directives (e.g., <code>report-uri</code>, <code>report-to</code>)?",
      "correct_answer": "To send violation reports to a specified URI or endpoint, allowing developers to monitor and identify potential security issues or misconfigurations.",
      "distractors": [
        {
          "text": "To automatically block all reported violations in real-time.",
          "misconception": "Targets [action confusion]: Reporting directives collect data; they don't inherently block violations."
        },
        {
          "text": "To encrypt the CSP policy itself for secure transmission.",
          "misconception": "Targets [mechanism confusion]: CSP policies are transmitted as plain text headers; reporting is for violations."
        },
        {
          "text": "To provide a fallback mechanism if the primary CSP fails.",
          "misconception": "Targets [purpose confusion]: Reporting is for monitoring, not for fallback policy enforcement."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CSP reporting directives are essential for effective CSP deployment because they provide visibility into policy violations. This is because developers can analyze these reports to discover legitimate resource loading issues or malicious attempts to bypass the policy, enabling iterative refinement and security hardening.",
        "distractor_analysis": "The distractors misrepresent reporting as an active blocking mechanism, encryption method, or fallback strategy, rather than its true purpose of data collection for analysis.",
        "analogy": "CSP reporting is like installing security cameras around your property; they don't stop intruders directly, but they record suspicious activity, helping you understand and improve your defenses."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "CSP_REPORTING",
        "SECURITY_MONITORING"
      ]
    },
    {
      "question_text": "Which CSP directive is used to restrict the URLs that can be loaded using script interfaces like <code>fetch</code> or <code>XMLHttpRequest</code>?",
      "correct_answer": "connect-src",
      "distractors": [
        {
          "text": "script-src",
          "misconception": "Targets [resource type confusion]: Controls script execution, not general network connections initiated by scripts."
        },
        {
          "text": "default-src",
          "misconception": "Targets [fallback confusion]: Only applies if `connect-src` is not specified."
        },
        {
          "text": "xhr-src",
          "misconception": "Targets [non-existent directive]: This directive does not exist in CSP."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>connect-src</code> directive is specifically designed to control network connections made by scripts, such as AJAX requests via <code>fetch</code> or <code>XMLHttpRequest</code>. This is because these connections can be used to exfiltrate data or communicate with malicious servers, making it a critical control point for application security.",
        "distractor_analysis": "The distractors confuse <code>connect-src</code> with directives for script execution (<code>script-src</code>), fallback behavior (<code>default-src</code>), or invent a non-existent directive (<code>xhr-src</code>), misrepresenting its function.",
        "analogy": "<code>connect-src</code> is like a phone operator for your website's scripts, deciding which external numbers (URLs) they are allowed to call."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CSP_CONNECT_SRC",
        "AJAX_SECURITY"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Improper Content Security Policy CSP Configuration Software Development Security best practices",
    "latency_ms": 24304.420000000002
  },
  "timestamp": "2026-01-18T11:04:23.376485"
}