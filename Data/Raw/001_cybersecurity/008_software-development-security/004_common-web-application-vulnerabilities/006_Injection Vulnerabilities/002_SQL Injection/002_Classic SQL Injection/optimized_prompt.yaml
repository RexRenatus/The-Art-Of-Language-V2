version: '2.0'
metadata:
  topic_title: Classic SQL Injection
  hierarchy:
    level_1_category: Cybersecurity
    level_2_domain: Software Development Security
    level_3_subdomain: Common Web Application Vulnerabilities
    level_4_entry_domain: 001_Injection Vulnerabilities
    level_5_entry_subdomain: SQL Injection
    level_6_topic: Classic SQL Injection
  curriculum_type: cybersecurity
  source_folders:
    category: 001_cybersecurity
    domain: 008_software-development-security
    subdomain: 004_common-web-application-vulnerabilities
  exa_sources: []
  voting:
    consensus_reached: true
    approval_percentage: 0.83
    total_voters: 7
  generation_timestamp: '2026-01-18T11:05:53.816003'
learning_objectives:
  understand:
  - objective: Explain core concepts
    verbs:
    - explain
    measurable: true
  apply:
  - objective: Apply knowledge to scenarios
    verbs:
    - apply
    measurable: true
  remember:
  - objective: Define key terminology
    verbs:
    - define
    measurable: true
  analyze:
  - objective: Analyze relationships
    verbs:
    - analyze
    measurable: true
active_learning:
  discussion_prompt: In a group discussion, debate the persistence of classic SQLi in modern web applications despite known
    mitigations. How do factors like legacy code, developer oversight, and emerging tech (e.g., AI-generated code) contribute?
    Reference OWASP Top 10 A03:2021-Injection and provide examples.
  peer_teaching: Explain the key concepts to a partner without using technical jargon.
  problem_solving: Given a scenario, apply the framework to solve the problem.
  additional_activities: []
scaffolding:
- level: 1
  name: Foundation
  focus: Basic terminology and definitions
  content: ''
- level: 2
  name: Components
  focus: Framework components and structure
  content: ''
- level: 3
  name: Implementation
  focus: Practical implementation steps
  content: ''
- level: 4
  name: Integration
  focus: Advanced integration and optimization
  content: ''
flashcard_generation:
  output_schema:
    question: string
    correct_answer: string
    distractors:
    - text: string
      explanation: string
    explanation: string
    bloom_level: enum
    topic_hierarchy: object
  distractor_protocol: 'Generate 3 distractors per MCQ: (1) Plausible but incomplete (e.g., mentions validation but ignores
    prepared statements), (2) Common myth (e.g., ''SQLi only affects MySQL''), (3) Related but wrong concept (e.g., confuses
    with XSS). Ensure they test nuance from research/OWASP.'
system_prompt: 'You are an expert flashcard generator for cybersecurity education on ''Classic SQL Injection'' (Topic Hierarchy:
  Cybersecurity > Software Development Security > Common Web Application Vulnerabilities > 001_Injection Vulnerabilities >
  SQL Injection > Classic SQL Injection). Use the provided learning objectives, active learning components, scaffolding layers
  (4 progressive layers), and flashcard schema to create optimized Anki-style flashcards.


  Incorporate:

  - Prior knowledge: SQL basics, web forms, string concatenation.

  - OWASP SQLi Prevention: Primary (prepared statements, stored procedures), secondary (input validation, least privilege,
  WAFs). Reference Top 10 A03:2021-Injection.

  - Hands-on: Vulnerable PHP/Node.js examples, payloads like '' OR ''1''=''1''--, fixes with PDO/mysqli prepared statements.

  - Formative assessments: MCQs for vuln ID, reflections on impacts.

  - Sources: OWASP SQL Injection Prevention Cheat Sheet (https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html),
  OWASP Top 10 (https://owasp.org/Top10/A03_2021-Injection/).


  Output ONLY a JSON array of flashcards, each strictly following the schema: {front, back, type, explanation, bloom_level,
  scaffolding_layer, distractors: [] (empty if not MCQ)}.

  Generate 50 flashcards: Balance Bloom''s levels and layers as per schema. Ensure active learning tie-ins (e.g., prompts
  simulating problem-solving). Make explanations educational, linking to pedagogy.'
