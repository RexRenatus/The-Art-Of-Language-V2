{
  "topic_title": "API Versioning Security Testing",
  "category": "Software Development Security - 008_006_Application Security Testing",
  "flashcards": [
    {
      "question_text": "When testing API versioning for security, what is the primary risk associated with maintaining older, unpatched versions alongside newer ones?",
      "correct_answer": "Older versions may contain known vulnerabilities that attackers can exploit, even if newer versions are secure.",
      "distractors": [
        {
          "text": "Newer versions might become unstable due to compatibility issues with older clients.",
          "misconception": "Targets [operational risk]: Confuses security vulnerabilities with backward compatibility issues."
        },
        {
          "text": "Maintaining multiple versions increases the complexity of documentation, not security.",
          "misconception": "Targets [scope confusion]: Focuses on documentation complexity rather than security implications."
        },
        {
          "text": "Attackers will always target the most recent version due to its wider usage.",
          "misconception": "Targets [attacker motivation misconception]: Assumes attackers only target popular, not vulnerable, endpoints."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Older API versions often have unpatched vulnerabilities because they are no longer actively maintained. Attackers specifically scan for and exploit these known weaknesses, creating a direct security risk that newer versions do not possess.",
        "distractor_analysis": "The first distractor focuses on operational stability, not security. The second dismisses security concerns by focusing on documentation. The third incorrectly assumes attackers only target the newest versions.",
        "analogy": "It's like having a secure, modern house but leaving an old, unlocked shed with valuable tools in the backyard; the shed remains a prime target for thieves."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "analyze",
      "prerequisites": [
        "API_SECURITY_BASICS",
        "VULNERABILITY_MANAGEMENT"
      ]
    },
    {
      "question_text": "According to NIST SP 800-228, what is a key consideration for API protection in cloud-native systems regarding versioning?",
      "correct_answer": "Ensuring that versioning strategies do not inadvertently expose legacy endpoints with outdated security controls.",
      "distractors": [
        {
          "text": "Prioritizing versioning that offers the most features, regardless of security.",
          "misconception": "Targets [feature over security]: Prioritizes functionality over security implications of versioning."
        },
        {
          "text": "Implementing versioning solely for client convenience and backward compatibility.",
          "misconception": "Targets [limited scope]: Views versioning only through a lens of usability, ignoring security risks."
        },
        {
          "text": "Using versioning to segment access based on user roles, not endpoint security.",
          "misconception": "Targets [misapplication of versioning]: Confuses versioning's role with access control mechanisms."
        }
      ],
      "detailed_explanation": {
        "core_logic": "NIST SP 800-228 emphasizes that API versioning must consider security. A common pitfall is maintaining older versions that lack current security patches, thus creating exploitable attack vectors. Therefore, versioning strategies must actively manage and secure all active versions.",
        "distractor_analysis": "The distractors misinterpret NIST's guidance by focusing on features, usability, or access control instead of the security posture of different versions.",
        "analogy": "When updating a software suite, you wouldn't just add new features; you'd also ensure old versions are retired or secured, not left as open doors."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "NIST_SP_800_228",
        "API_SECURITY_PRINCIPLES"
      ]
    },
    {
      "question_text": "What is the primary security benefit of a well-defined API versioning strategy that includes clear deprecation policies?",
      "correct_answer": "It allows for the systematic retirement of vulnerable older versions, reducing the attack surface.",
      "distractors": [
        {
          "text": "It ensures all API endpoints are always available to all users.",
          "misconception": "Targets [availability vs. security]: Confuses the goal of availability with the security benefit of reducing attack surface."
        },
        {
          "text": "It simplifies the process of adding new features to the API.",
          "misconception": "Targets [feature development focus]: Prioritizes feature addition over security implications of version management."
        },
        {
          "text": "It guarantees that all clients will immediately adopt the latest version.",
          "misconception": "Targets [client adoption assumption]: Assumes clients will always migrate, ignoring the need for managed deprecation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A clear deprecation policy within an API versioning strategy is crucial because it provides a roadmap for retiring older versions. This systematic retirement is a defense mechanism that reduces the attack surface by eliminating endpoints that may no longer receive security updates.",
        "distractor_analysis": "The distractors incorrectly link versioning to universal availability, simplified feature development, or guaranteed client adoption, rather than its security benefit of attack surface reduction.",
        "analogy": "A clear deprecation policy is like a planned demolition of old, unsafe buildings in a city; it makes way for safer structures and removes potential hazards."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "API_VERSIONING_BASICS",
        "ATTACK_SURFACE_REDUCTION"
      ]
    },
    {
      "question_text": "When performing security testing on an API that uses versioning (e.g., /v1/users, /v2/users), what is a common testing approach for identifying vulnerabilities in older versions?",
      "correct_answer": "Actively probe older version endpoints with known attack patterns and payloads to check for unpatched vulnerabilities.",
      "distractors": [
        {
          "text": "Focus testing efforts exclusively on the latest version to ensure its security.",
          "misconception": "Targets [incomplete testing]: Ignores older versions, assuming they are not a security concern."
        },
        {
          "text": "Assume older versions are secure if they are not actively used by clients.",
          "misconception": "Targets [false security assumption]: Believes inactivity equates to security, ignoring potential for targeted attacks."
        },
        {
          "text": "Only test older versions if explicitly requested by the client.",
          "misconception": "Targets [reactive security]: Adopts a passive security stance, waiting for external requests rather than proactive testing."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Security testing for versioned APIs must include older versions because they often lag behind in security updates. Probing these endpoints with known attack vectors is essential to uncover vulnerabilities that attackers could exploit, thereby reducing the overall risk.",
        "distractor_analysis": "The distractors suggest neglecting older versions, assuming their security, or waiting for requests, all of which are poor security testing practices.",
        "analogy": "When checking a building's safety, you wouldn't just inspect the new wing; you'd also thoroughly check the older sections for structural weaknesses."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "API_SECURITY_TESTING",
        "VULNERABILITY_SCANNING"
      ]
    },
    {
      "question_text": "What is the primary security risk of exposing API version information directly in the URL (e.g., /v1/resource)?",
      "correct_answer": "It can inadvertently reveal the presence of older, potentially vulnerable API versions that are still accessible.",
      "distractors": [
        {
          "text": "It makes it harder for developers to understand which API version to use.",
          "misconception": "Targets [usability over security]: Focuses on developer experience rather than security implications."
        },
        {
          "text": "It can lead to performance degradation due to increased URL parsing.",
          "misconception": "Targets [performance misconception]: Attributes security-related issues to performance problems."
        },
        {
          "text": "It forces clients to update their code more frequently.",
          "misconception": "Targets [client burden misconception]: Views versioning as a client-side issue, not a security exposure."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Exposing API version in the URL, while common for clarity, can also reveal older, potentially unpatched versions. Attackers can use this information to specifically target these older endpoints, exploiting known vulnerabilities that have been fixed in newer versions.",
        "distractor_analysis": "The distractors focus on developer usability, performance, or client burden, rather than the direct security implication of exposing vulnerable legacy endpoints.",
        "analogy": "Having the version number in the URL is like having a sign on each door indicating its age; it helps users but also tells potential intruders which doors might be easier to break into."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "analysis",
      "bloom_level": "understand",
      "prerequisites": [
        "API_BASICS",
        "URL_STRUCTURE"
      ]
    },
    {
      "question_text": "Which of the following is a security best practice for managing API versioning to mitigate risks?",
      "correct_answer": "Implement a strict deprecation policy and actively monitor and decommission unsupported versions.",
      "distractors": [
        {
          "text": "Allow all versions to remain active indefinitely to ensure maximum compatibility.",
          "misconception": "Targets [insecure compatibility]: Prioritizes indefinite compatibility over security risk reduction."
        },
        {
          "text": "Hide version numbers from URLs to prevent attackers from identifying them.",
          "misconception": "Targets [obscurity as security]: Relies on hiding information rather than actively managing it."
        },
        {
          "text": "Only update the documentation for the latest version.",
          "misconception": "Targets [documentation neglect]: Fails to maintain documentation for all active or deprecated versions, hindering security awareness."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A robust API versioning strategy includes a clear deprecation policy. This ensures that older versions, which may contain security vulnerabilities, are systematically retired and decommissioned, thereby reducing the overall attack surface and improving security posture.",
        "distractor_analysis": "The distractors suggest insecure practices like indefinite support, relying on obscurity, or neglecting documentation, all of which undermine security.",
        "analogy": "It's like managing a fleet of vehicles: you don't keep old, unsafe models running forever; you retire them to ensure the fleet is safe and efficient."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "API_VERSIONING_STRATEGIES",
        "SECURITY_BEST_PRACTICES"
      ]
    },
    {
      "question_text": "How can security testing for API versioning help identify authorization bypass vulnerabilities?",
      "correct_answer": "By testing older versions that might have weaker or unpatched authorization mechanisms.",
      "distractors": [
        {
          "text": "By assuming that authorization controls are consistent across all versions.",
          "misconception": "Targets [consistency assumption]: Fails to recognize that authorization logic can differ or be flawed in older versions."
        },
        {
          "text": "By focusing only on the authentication process, not authorization.",
          "misconception": "Targets [authentication vs. authorization confusion]: Confuses the distinct security concepts of authentication and authorization."
        },
        {
          "text": "By verifying that only the latest version supports role-based access control (RBAC).",
          "misconception": "Targets [feature limitation misconception]: Assumes older versions inherently lack advanced security features like RBAC."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Authorization logic can evolve and be patched across API versions. Testing older versions specifically allows security testers to uncover authorization bypass vulnerabilities that may have existed in earlier implementations but were fixed in newer ones.",
        "distractor_analysis": "The distractors incorrectly assume consistency, confuse authentication with authorization, or make unfounded assumptions about feature availability in older versions.",
        "analogy": "It's like checking the security of different doors in a building; an older door might have a simpler lock that's easier to pick than the modern, reinforced doors."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "attack",
      "bloom_level": "analyze",
      "prerequisites": [
        "API_AUTHORIZATION",
        "AUTHENTICATION_VS_AUTHORIZATION"
      ]
    },
    {
      "question_text": "What is the OWASP API Security Top 10 recommendation regarding versioning and security?",
      "correct_answer": "Treating APIs as first-class citizens and ensuring that versioning does not create security gaps.",
      "distractors": [
        {
          "text": "Focusing solely on RESTful APIs, as other types are less common.",
          "misconception": "Targets [technology bias]: Overlooks security for other API types like SOAP or GraphQL."
        },
        {
          "text": "Using versioning primarily to manage feature rollouts, not security.",
          "misconception": "Targets [misaligned priorities]: Views versioning as a feature management tool, not a security consideration."
        },
        {
          "text": "Assuming that security is handled by the underlying infrastructure, not the API itself.",
          "misconception": "Targets [shared responsibility fallacy]: Fails to recognize the API's own security requirements."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The OWASP API Security Top 10 emphasizes treating APIs with the same security rigor as other applications. This includes ensuring that versioning strategies, whether in URLs or headers, do not create security loopholes by leaving older, vulnerable versions accessible.",
        "distractor_analysis": "The distractors misinterpret OWASP's guidance by showing bias towards specific API types, misusing versioning for features, or abdicating API security responsibility.",
        "analogy": "The OWASP Top 10 is like a 'Top 10 Most Wanted' list for API security flaws; versioning issues can land on that list if they create exploitable gaps."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "OWASP_API_SECURITY",
        "API_SECURITY_PRINCIPLES"
      ]
    },
    {
      "question_text": "Consider an API that uses URI versioning (e.g., /api/v1/data, /api/v2/data). What is a potential security testing scenario for the /api/v1/data endpoint?",
      "correct_answer": "Attempting to use deprecated or insecure parameters that were removed in v2, to see if they are still processed.",
      "distractors": [
        {
          "text": "Trying to access /api/v2/data using v1 authentication credentials.",
          "misconception": "Targets [cross-version authentication confusion]: Assumes authentication mechanisms are directly transferable and flawed across versions."
        },
        {
          "text": "Sending malformed requests to /api/v1/data to test its input validation.",
          "misconception": "Targets [general input validation]: This is a valid test, but not specific to versioning's unique risks."
        },
        {
          "text": "Checking if the v1 endpoint redirects automatically to the v2 endpoint.",
          "misconception": "Targets [redirection assumption]: Assumes all older versions should redirect, which is a mitigation, not a vulnerability test."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When testing older API versions like /api/v1/data, a key scenario is to probe for vulnerabilities that were fixed in newer versions. This includes attempting to use parameters or logic that were deprecated or deemed insecure in v2, to confirm they are no longer exploitable.",
        "distractor_analysis": "The first distractor tests cross-version authentication, which is different from testing v1's specific vulnerabilities. The second is general input validation. The third tests a mitigation strategy, not a vulnerability.",
        "analogy": "It's like checking if an old, decommissioned alarm system still has a known backdoor that was fixed in the newer model."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "API_VERSIONING_TESTING",
        "VULNERABILITY_IDENTIFICATION"
      ]
    },
    {
      "question_text": "What is the security implication of an API versioning strategy that uses header-based versioning (e.g., <code>Accept: application/vnd.myapp.v1+json</code>) if the <code>Accept</code> header is not properly validated?",
      "correct_answer": "An attacker could potentially spoof the <code>Accept</code> header to access older, less secure API versions.",
      "distractors": [
        {
          "text": "It would cause the API to return incorrect data types.",
          "misconception": "Targets [functional error]: Attributes security bypass to data type errors, not authorization flaws."
        },
        {
          "text": "It would lead to denial-of-service by overwhelming the API with invalid headers.",
          "misconception": "Targets [DoS confusion]: Confuses header spoofing for access with denial-of-service attacks."
        },
        {
          "text": "It would make it impossible for clients to specify their preferred version.",
          "misconception": "Targets [usability failure]: Focuses on the intended function of the header failing, not the security consequence."
        }
      ],
      "detailed_explanation": {
        "core_logic": "If an API uses header-based versioning and fails to validate the <code>Accept</code> header, an attacker can craft a request with a header value corresponding to an older version. This allows them to bypass security controls or exploit vulnerabilities present in that older version.",
        "distractor_analysis": "The distractors incorrectly link header spoofing to data type errors, DoS, or general usability failure, rather than the specific security risk of accessing older, vulnerable API versions.",
        "analogy": "It's like a security guard checking IDs at different club entrances; if the guard doesn't properly check the ID, someone could use an old, expired pass to get into a restricted area."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "attack",
      "bloom_level": "apply",
      "prerequisites": [
        "API_HEADER_SECURITY",
        "ACCEPT_HEADER_USAGE"
      ]
    },
    {
      "question_text": "When testing API versioning, what is the significance of the OAuth 2.1 Authorization Framework in relation to older versions?",
      "correct_answer": "OAuth 2.1 obsoletes OAuth 2.0, meaning older implementations might lack security improvements and should be tested for vulnerabilities.",
      "distractors": [
        {
          "text": "OAuth 2.1 requires all APIs to use header-based versioning.",
          "misconception": "Targets [misinterpretation of standard]: Confuses authorization framework requirements with versioning implementation details."
        },
        {
          "text": "Older OAuth 2.0 versions are inherently more secure due to their simplicity.",
          "misconception": "Targets [false security assumption]: Believes older, superseded standards are more secure than updated ones."
        },
        {
          "text": "OAuth 2.1 mandates that all API versions must be compatible with each other.",
          "misconception": "Targets [compatibility over security]: Assumes newer standards enforce backward compatibility at the expense of security improvements."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The OAuth 2.1 Authorization Framework is a newer standard that supersedes OAuth 2.0, incorporating security enhancements and deprecating less secure practices. Therefore, APIs still relying on OAuth 2.0 implementations, especially in older versions, may contain vulnerabilities that OAuth 2.1 addresses.",
        "distractor_analysis": "The distractors misrepresent OAuth 2.1's purpose, incorrectly assume older versions are more secure, or misunderstand its compatibility mandates.",
        "analogy": "OAuth 2.1 is like a new edition of a security manual; older editions (OAuth 2.0) might contain outdated advice or security flaws that the new edition corrects."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "OAUTH_2_1",
        "API_SECURITY_STANDARDS"
      ]
    },
    {
      "question_text": "What is a common security pitfall when an API uses a single endpoint for all versions, relying solely on request parameters for version differentiation?",
      "correct_answer": "It can be difficult to enforce version-specific security policies or deprecate older versions effectively.",
      "distractors": [
        {
          "text": "It leads to performance issues due to complex parameter parsing.",
          "misconception": "Targets [performance over security]: Focuses on performance impact rather than the security control challenges."
        },
        {
          "text": "It makes the API URL unnecessarily long and complex.",
          "misconception": "Targets [usability over security]: Views the issue as URL complexity rather than security management difficulty."
        },
        {
          "text": "It guarantees that all clients will use the latest version.",
          "misconception": "Targets [client adoption assumption]: Assumes clients will always adhere to versioning parameters, ignoring potential for misuse."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When versioning is managed solely through request parameters on a single endpoint, it becomes challenging to apply distinct security policies or to systematically deprecate and remove older versions. This lack of clear separation can lead to security gaps and make the API harder to manage securely.",
        "distractor_analysis": "The distractors focus on performance, URL complexity, or client adoption, rather than the core security management challenge of enforcing version-specific policies and deprecation.",
        "analogy": "It's like trying to manage different types of mail (letters, packages, registered mail) all through a single mailbox slot; it's hard to apply specific handling rules or know which mail is outdated."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "API_VERSIONING_METHODS",
        "SECURITY_POLICY_ENFORCEMENT"
      ]
    },
    {
      "question_text": "In the context of API versioning security testing, what does 'API Gateway' typically do to help manage security across different versions?",
      "correct_answer": "It can enforce consistent security policies (like authentication, rate limiting) across all API versions, including older ones.",
      "distractors": [
        {
          "text": "It automatically updates older API versions to the latest security standards.",
          "misconception": "Targets [automation over management]: Assumes the gateway performs automatic version upgrades, which is not its primary security function."
        },
        {
          "text": "It hides version numbers from URLs to prevent attackers from identifying them.",
          "misconception": "Targets [obscurity as security]: Relies on hiding information rather than enforcing policies."
        },
        {
          "text": "It only applies security policies to the latest API version.",
          "misconception": "Targets [limited scope]: Assumes gateways only protect the newest endpoints, ignoring the risk of older ones."
        }
      ],
      "detailed_explanation": {
        "core_logic": "API Gateways act as a central point for managing API traffic and security. They can enforce consistent security policies, such as authentication, authorization, and rate limiting, across all exposed API versions, thereby helping to secure older versions that might otherwise be vulnerable.",
        "distractor_analysis": "The distractors incorrectly suggest automatic updates, reliance on obscurity, or selective security application, rather than the gateway's role in consistent policy enforcement.",
        "analogy": "An API Gateway is like a security checkpoint at the entrance to a complex; it ensures everyone, regardless of which building they're going to, passes through the same security screening."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "API_GATEWAY_SECURITY",
        "SECURITY_POLICY_ENFORCEMENT"
      ]
    },
    {
      "question_text": "What is a critical security consideration when migrating from one API version to another, especially concerning data integrity?",
      "correct_answer": "Ensuring that data transformations between versions do not introduce corruption or loss of sensitive information.",
      "distractors": [
        {
          "text": "Verifying that the new version uses a different encryption algorithm.",
          "misconception": "Targets [algorithm focus]: Assumes changing encryption is the primary data integrity concern, not transformation logic."
        },
        {
          "text": "Confirming that the new version has more features than the old one.",
          "misconception": "Targets [feature focus]: Prioritizes feature count over data integrity during migration."
        },
        {
          "text": "Assuming that data integrity is maintained if the API endpoint remains the same.",
          "misconception": "Targets [endpoint assumption]: Believes the endpoint URL guarantees data integrity, ignoring underlying logic changes."
        }
      ],
      "detailed_explanation": {
        "core_logic": "API version migration often involves changes to data structures or processing logic. It is critical to test that these transformations maintain data integrity, ensuring no sensitive information is lost, corrupted, or improperly handled during the migration process.",
        "distractor_analysis": "The distractors focus on encryption algorithms, feature count, or endpoint consistency, rather than the crucial aspect of data transformation integrity during version migration.",
        "analogy": "Migrating API versions is like moving house; you need to ensure all your belongings (data) arrive safely and undamaged, not just that they get to the new address."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "API_MIGRATION",
        "DATA_INTEGRITY"
      ]
    },
    {
      "question_text": "What is the primary security benefit of using semantic versioning (e.g., MAJOR.MINOR.PATCH) for APIs?",
      "correct_answer": "It provides clear indicators of the potential impact of changes, allowing for better risk assessment of updates.",
      "distractors": [
        {
          "text": "It automatically enforces backward compatibility for all changes.",
          "misconception": "Targets [compatibility guarantee misconception]: Assumes semantic versioning inherently ensures backward compatibility, which is not always true for MAJOR versions."
        },
        {
          "text": "It simplifies the process of hiding older API versions.",
          "misconception": "Targets [obscurity over clarity]: Views versioning as a hiding mechanism rather than a communication tool."
        },
        {
          "text": "It guarantees that only security-related changes are made.",
          "misconception": "Targets [scope limitation]: Assumes versioning is exclusively for security updates, ignoring functional changes."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Semantic versioning (SemVer) communicates the nature of changes: MAJOR for breaking changes, MINOR for backward-compatible new features, and PATCH for backward-compatible bug fixes. This clarity allows developers and security teams to better assess the risk and impact of adopting new versions.",
        "distractor_analysis": "The distractors incorrectly claim SemVer guarantees backward compatibility, aids in hiding versions, or is solely for security updates, misrepresenting its purpose and function.",
        "analogy": "Semantic versioning is like a traffic light system for software updates: Red (MAJOR) means stop and be cautious, Yellow (MINOR) means proceed with awareness, Green (PATCH) means it's safe to go."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SEMANTIC_VERSIONING",
        "API_CHANGES"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "API Versioning Security Testing Software Development Security best practices",
    "latency_ms": 27317.094999999998
  },
  "timestamp": "2026-01-18T11:13:47.430598"
}