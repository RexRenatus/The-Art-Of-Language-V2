{
  "topic_title": "Subresource Integrity Testing",
  "category": "Software Development Security - 008_006_Application Security Testing",
  "flashcards": [
    {
      "question_text": "What is the primary security goal of Subresource Integrity (SRI)?",
      "correct_answer": "To ensure that fetched resources (like scripts or stylesheets) have not been tampered with or maliciously modified.",
      "distractors": [
        {
          "text": "To encrypt all client-side code to prevent reverse engineering.",
          "misconception": "Targets [encryption confusion]: Confuses integrity checking with data confidentiality."
        },
        {
          "text": "To enforce Content Security Policy (CSP) directives for resource loading.",
          "misconception": "Targets [policy confusion]: SRI is a complementary mechanism, not a direct enforcement of CSP."
        },
        {
          "text": "To optimize resource loading times from Content Delivery Networks (CDNs).",
          "misconception": "Targets [performance confusion]: SRI's primary goal is security, not performance optimization."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI works by providing a cryptographic hash of a resource, which the browser verifies before loading. This ensures integrity because any modification to the resource would change its hash, preventing the browser from loading it.",
        "distractor_analysis": "The distractors incorrectly associate SRI with encryption, CSP enforcement, or performance optimization, rather than its core function of verifying resource integrity.",
        "analogy": "SRI is like a tamper-evident seal on a package. If the seal is broken (hash doesn't match), you know the contents might have been altered and you shouldn't accept the package."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SRI_BASICS"
      ]
    },
    {
      "question_text": "How does Subresource Integrity (SRI) protect against compromised CDNs?",
      "correct_answer": "By requiring the browser to match a pre-defined cryptographic hash of the resource, preventing the loading of modified files.",
      "distractors": [
        {
          "text": "By encrypting the connection to the CDN using TLS 1.3.",
          "misconception": "Targets [protocol confusion]: TLS secures the transport layer, but SRI secures the resource content itself."
        },
        {
          "text": "By forcing the CDN to use only specific, pre-approved IP addresses.",
          "misconception": "Targets [network control confusion]: SRI is about content verification, not network access control."
        },
        {
          "text": "By implementing a Web Application Firewall (WAF) on the CDN.",
          "misconception": "Targets [tool confusion]: WAFs protect servers; SRI protects clients from compromised external resources."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When a CDN is compromised, attackers can inject malicious code into hosted files. SRI mitigates this because the browser checks the file's hash against the one specified in the HTML. If they don't match, the browser refuses to load the file, thus blocking the malicious code.",
        "distractor_analysis": "The distractors suggest unrelated security mechanisms like TLS, IP whitelisting, or WAFs, failing to grasp SRI's specific role in verifying resource content integrity.",
        "analogy": "It's like having a unique fingerprint for each library book you borrow. If the book you receive doesn't match the fingerprint on record, you know it's not the original or has been altered."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "SRI_BASICS",
        "CDN_SECURITY"
      ]
    },
    {
      "question_text": "Which attribute is used in HTML to specify the cryptographic hash for Subresource Integrity?",
      "correct_answer": "integrity",
      "distractors": [
        {
          "text": "hash",
          "misconception": "Targets [attribute naming confusion]: A plausible but incorrect attribute name."
        },
        {
          "text": "checksum",
          "misconception": "Targets [terminology confusion]: Uses a related but distinct security term."
        },
        {
          "text": "verify",
          "misconception": "Targets [action confusion]: Describes the function, not the attribute name."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>integrity</code> attribute is part of the HTML specification for <code>&lt;script&gt;</code> and <code>&lt;link&gt;</code> tags when using SRI. It holds the base64-encoded cryptographic hash(es) that the browser uses to verify the resource's authenticity.",
        "distractor_analysis": "Distractors use plausible-sounding but incorrect attribute names, testing recall of the specific HTML attribute required for SRI implementation.",
        "analogy": "The <code>integrity</code> attribute is like the label on a medicine bottle that states the exact chemical composition. If the medicine you receive doesn't match the label, it's suspect."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "SRI_BASICS",
        "HTML_TAGS"
      ]
    },
    {
      "question_text": "What are the currently allowed cryptographic hash algorithms for Subresource Integrity (SRI)?",
      "correct_answer": "sha256, sha384, and sha512",
      "distractors": [
        {
          "text": "md5, sha1, and sha256",
          "misconception": "Targets [obsolete algorithm confusion]: Includes older, cryptographically weak algorithms."
        },
        {
          "text": "sha256 and sha512 only",
          "misconception": "Targets [incomplete list confusion]: Omits a valid algorithm (sha384)."
        },
        {
          "text": "sha3, sha256, and sha512",
          "misconception": "Targets [algorithm confusion]: Includes a newer algorithm (sha3) not yet standard for SRI."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI requires strong cryptographic hash functions to ensure integrity. Currently, sha256, sha384, and sha512 are the standard algorithms supported by browsers for SRI, providing robust verification.",
        "distractor_analysis": "Distractors include outdated algorithms (MD5, SHA-1) or algorithms not yet universally supported for SRI, testing knowledge of current standards.",
        "analogy": "These are like the approved security standards for checking a package's seal. Using an old or unapproved method (like MD5) wouldn't provide the same level of trust."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SRI_BASICS",
        "CRYPTO_HASHING"
      ]
    },
    {
      "question_text": "When loading a resource from a different origin using SRI, what additional CORS requirement must be met?",
      "correct_answer": "The origin serving the resource must explicitly allow sharing with the requesting origin via the <code>Access-Control-Allow-Origin</code> header.",
      "distractors": [
        {
          "text": "The resource must be served over HTTP, not HTTPS.",
          "misconception": "Targets [protocol confusion]: SRI requires HTTPS for security; HTTP is insecure."
        },
        {
          "text": "The requesting origin must send an API key to the resource origin.",
          "misconception": "Targets [authentication confusion]: SRI is about integrity, not API authentication."
        },
        {
          "text": "The resource origin must use the same cryptographic hash algorithm as the requesting page.",
          "misconception": "Targets [algorithm matching confusion]: Hash algorithm compatibility is handled by the browser, not a direct server requirement."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI verification happens client-side, but for resources fetched cross-origin, the browser first checks if the server permits sharing via CORS. The <code>Access-Control-Allow-Origin</code> header is crucial for this, ensuring the resource origin allows the requesting origin to access it.",
        "distractor_analysis": "Distractors propose incorrect requirements like insecure protocols, API keys, or hash algorithm matching, missing the fundamental CORS requirement for cross-origin resource sharing.",
        "analogy": "Imagine asking for a book from another library. The other library needs to agree to lend it to you (CORS <code>Access-Control-Allow-Origin</code> header) before you can even check if it's the correct edition (SRI hash)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "SRI_BASICS",
        "CORS_BASICS"
      ]
    },
    {
      "question_text": "What is the <code>crossorigin</code> attribute used for in conjunction with SRI?",
      "correct_answer": "It indicates whether the resource is fetched with or without credentials, and is required for cross-origin requests to work with SRI.",
      "distractors": [
        {
          "text": "It specifies the cryptographic hash algorithm used for integrity checking.",
          "misconception": "Targets [attribute function confusion]: This is the role of the `integrity` attribute."
        },
        {
          "text": "It determines the Content Security Policy (CSP) to be applied to the resource.",
          "misconception": "Targets [policy confusion]: CSP is a separate security mechanism."
        },
        {
          "text": "It is optional and only used for non-secure (HTTP) resource loading.",
          "misconception": "Targets [security protocol confusion]: `crossorigin` is required for cross-origin SRI, and resources should always be loaded over HTTPS."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>crossorigin</code> attribute, when set to <code>anonymous</code> or <code>use-credentials</code>, is essential for CORS preflight requests. Browsers need this information to correctly handle cross-origin requests, which is a prerequisite for SRI to function on external resources.",
        "distractor_analysis": "Distractors misattribute the function of <code>crossorigin</code> to hash algorithms, CSP, or imply it's optional/for insecure loading, failing to recognize its role in CORS for cross-origin SRI.",
        "analogy": "The <code>crossorigin</code> attribute is like declaring your intention to borrow something from another household. It signals to the other household (and the authorities) that this is a cross-border transaction, which requires specific protocols."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SRI_BASICS",
        "CORS_BASICS"
      ]
    },
    {
      "question_text": "What is a potential drawback of implementing Subresource Integrity (SRI)?",
      "correct_answer": "Updates to external resources (e.g., library updates) require manual updating of the integrity hashes, which can break the site if not managed carefully.",
      "distractors": [
        {
          "text": "SRI significantly slows down page load times for all resources.",
          "misconception": "Targets [performance exaggeration]: SRI adds minimal overhead; the main impact is blocking malicious content."
        },
        {
          "text": "It prevents the use of Content Delivery Networks (CDNs) entirely.",
          "misconception": "Targets [usage restriction confusion]: SRI is designed to work *with* CDNs, not prevent their use."
        },
        {
          "text": "SRI only protects against accidental file corruption, not malicious attacks.",
          "misconception": "Targets [threat scope confusion]: SRI is effective against both accidental corruption and deliberate tampering."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Because SRI relies on exact hash matches, any update to an external resource (like a JavaScript library) will change its hash. If the <code>integrity</code> attribute isn't updated accordingly, the browser will refuse to load the new version, potentially breaking site functionality.",
        "distractor_analysis": "Distractors incorrectly claim SRI drastically impacts performance, prohibits CDNs, or only protects against accidental corruption, missing the key maintenance challenge of hash updates.",
        "analogy": "It's like having a specific serial number for a tool. If the manufacturer updates the tool and changes the serial number, your old record won't match, and you might think the new tool is faulty unless you update your records."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SRI_BASICS",
        "SRI_MAINTENANCE"
      ]
    },
    {
      "question_text": "Which of the following scenarios is BEST protected by Subresource Integrity (SRI)?",
      "correct_answer": "A malicious actor compromises a CDN hosting a popular JavaScript library, injecting a crypto-miner into the library file.",
      "distractors": [
        {
          "text": "A user's browser is infected with malware that steals cookies.",
          "misconception": "Targets [client-side malware confusion]: SRI protects external resources, not the user's local machine."
        },
        {
          "text": "A server-side SQL injection vulnerability allows an attacker to modify database records.",
          "misconception": "Targets [server-side vulnerability confusion]: SRI applies to client-side resources, not server-side code or databases."
        },
        {
          "text": "An attacker performs a Cross-Site Scripting (XSS) attack by injecting script tags into user comments.",
          "misconception": "Targets [XSS confusion]: While related to script execution, SRI protects *external* scripts, not scripts injected directly into the page content."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI directly addresses the threat of compromised third-party resources. When a CDN is compromised and a library file is altered, SRI's hash verification prevents the browser from loading the tampered script, thus protecting the website and its users from the injected malicious code.",
        "distractor_analysis": "The distractors describe threats that SRI does not directly mitigate: client-side malware, server-side vulnerabilities, and direct XSS injection into page content.",
        "analogy": "If a trusted supplier of building materials (CDN) starts shipping faulty bricks (malicious script), SRI is like having a quality inspector at your construction site (browser) who checks each brick against a blueprint (hash) and rejects any that don't match."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "SRI_BASICS",
        "MALWARE_TYPES",
        "WEB_ATTACKS"
      ]
    },
    {
      "question_text": "How can developers generate the necessary cryptographic hash for the <code>integrity</code> attribute?",
      "correct_answer": "By using command-line tools like <code>curl</code> combined with OpenSSL to fetch the resource and calculate the hash, or by using online SRI hash generator tools.",
      "distractors": [
        {
          "text": "By inspecting the network traffic in browser developer tools.",
          "misconception": "Targets [tool confusion]: Network tools show current data, not necessarily the original or correct hash."
        },
        {
          "text": "By asking the CDN provider for the hash value directly.",
          "misconception": "Targets [trust assumption]: While possible, the provider might not readily supply it, or could also be compromised."
        },
        {
          "text": "By using a simple string length calculation on the resource file.",
          "misconception": "Targets [hashing misunderstanding]: String length is not a cryptographic hash and provides no integrity."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Generating SRI hashes involves cryptographic functions. Tools like OpenSSL (<code>openssl dgst -sha384 -binary | openssl base64 -A</code>) are standard for calculating these hashes from fetched resources. Online generators simplify this process but rely on the same underlying principles.",
        "distractor_analysis": "Distractors suggest methods that are either insufficient (browser tools, asking provider) or fundamentally incorrect (string length) for generating secure cryptographic hashes.",
        "analogy": "Generating an SRI hash is like creating a unique wax seal impression for a document. You need a specific tool (OpenSSL) and process to make the correct, verifiable seal (hash)."
      },
      "code_snippets": [
        {
          "language": "text",
          "code": "curl -s https://example.com/script.js | openssl dgst -sha384 -binary | openssl base64 -A",
          "context": "explanation"
        }
      ],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "SRI_BASICS",
        "COMMAND_LINE_TOOLS"
      ],
      "_code_snippets_html": "<div class=\"code-snippet code-explanation\">\n<span class=\"code-label\">Code Example</span>\n<pre><code class=\"language-text\">curl -s https://example.com/script.js | openssl dgst -sha384 -binary | openssl base64 -A</code></pre>\n</div>"
    },
    {
      "question_text": "What is the relationship between Subresource Integrity (SRI) and Content Security Policy (CSP)?",
      "correct_answer": "SRI and CSP are complementary security mechanisms; CSP controls *what* resources can be loaded, while SRI verifies the *integrity* of those loaded resources.",
      "distractors": [
        {
          "text": "SRI is a directive within CSP that enforces hash checking.",
          "misconception": "Targets [policy integration confusion]: SRI is a separate HTML attribute, not a CSP directive."
        },
        {
          "text": "CSP is deprecated and has been replaced by SRI.",
          "misconception": "Targets [obsolescence confusion]: Both are active and serve different, complementary purposes."
        },
        {
          "text": "SRI is used for server-side resource validation, while CSP is for client-side.",
          "misconception": "Targets [scope confusion]: Both SRI and CSP primarily function in the client's browser."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CSP acts as a whitelist, defining which origins and types of resources are allowed to be loaded. SRI then provides an additional layer of defense by ensuring that *if* a resource is loaded (and allowed by CSP), it hasn't been tampered with. They work together to enhance client-side security.",
        "distractor_analysis": "Distractors incorrectly merge SRI into CSP, suggest CSP is obsolete, or misassign their client-side/server-side roles, failing to grasp their distinct yet complementary functions.",
        "analogy": "CSP is like a bouncer at a club deciding who gets in (which domains/resources are allowed). SRI is like a security check inside the club, ensuring that once someone is inside, they haven't smuggled anything dangerous in their pockets (tampered resources)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "SRI_BASICS",
        "CSP_BASICS"
      ]
    },
    {
      "question_text": "Why is it important to use SRI with resources loaded over HTTPS?",
      "correct_answer": "HTTPS encrypts the connection, preventing eavesdropping and man-in-the-middle attacks during transit, while SRI ensures the resource content itself hasn't been altered.",
      "distractors": [
        {
          "text": "HTTPS is not strictly necessary if SRI is implemented.",
          "misconception": "Targets [security layering confusion]: SRI and HTTPS address different threats; both are needed."
        },
        {
          "text": "SRI automatically upgrades HTTP connections to HTTPS.",
          "misconception": "Targets [protocol enforcement confusion]: SRI does not manage transport layer security protocols."
        },
        {
          "text": "HTTPS is only required for the main page, not for subresources.",
          "misconception": "Targets [scope confusion]: All resources, including subresources, should be loaded securely."
        }
      ],
      "detailed_explanation": {
        "core_logic": "HTTPS secures the communication channel, preventing attackers from intercepting or modifying data *in transit*. SRI, however, verifies the integrity of the resource *after* it has been fetched, protecting against scenarios where the source itself (like a CDN) might be compromised. They are distinct but essential layers of defense.",
        "distractor_analysis": "Distractors incorrectly suggest SRI negates the need for HTTPS, that SRI handles transport security, or that HTTPS is only for the main document, missing the complementary nature of these security measures.",
        "analogy": "HTTPS is like a secure, armored truck delivering a package. SRI is like a unique, tamper-proof seal on that package. The truck protects it during the journey, and the seal guarantees its contents haven't been changed upon arrival."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "understand",
      "prerequisites": [
        "SRI_BASICS",
        "HTTPS_BASICS"
      ]
    },
    {
      "question_text": "What does the <code>sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC</code> string represent in an SRI <code>integrity</code> attribute?",
      "correct_answer": "It's a base64-encoded SHA-384 cryptographic hash of the resource file.",
      "distractors": [
        {
          "text": "It's a unique identifier for the CDN hosting the resource.",
          "misconception": "Targets [identifier confusion]: It identifies the content, not the source location."
        },
        {
          "text": "It's a public key used for encrypting the resource.",
          "misconception": "Targets [cryptography confusion]: This is a hash, not a public key for encryption."
        },
        {
          "text": "It's a Content Security Policy (CSP) nonce value.",
          "misconception": "Targets [policy confusion]: Nonces are used for CSP, not SRI hashes."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The string <code>sha384-</code> indicates the hashing algorithm used (SHA-384), followed by the base64-encoded result of applying that algorithm to the resource's content. The browser uses this hash to verify the resource's integrity.",
        "distractor_analysis": "Distractors misinterpret the string as a CDN identifier, a public key, or a CSP nonce, failing to recognize the structure and purpose of an SRI hash.",
        "analogy": "This string is like a unique fingerprint for the file. The <code>sha384-</code> part tells you what method was used to get the fingerprint, and the rest is the actual fingerprint itself."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SRI_BASICS",
        "CRYPTO_HASHING"
      ]
    },
    {
      "question_text": "Consider a scenario where a website loads jQuery from a CDN using SRI. If the CDN is updated with a new version of jQuery, what must happen for the website to continue functioning correctly?",
      "correct_answer": "The <code>integrity</code> attribute in the website's HTML must be updated with the new hash corresponding to the updated jQuery version.",
      "distractors": [
        {
          "text": "The browser will automatically detect the new hash and update.",
          "misconception": "Targets [automation confusion]: SRI requires explicit hash updates; browsers do not auto-update integrity values."
        },
        {
          "text": "The website's Content Security Policy (CSP) must be reconfigured.",
          "misconception": "Targets [policy confusion]: CSP controls resource origins/types, not specific file hashes."
        },
        {
          "text": "The <code>crossorigin</code> attribute must be changed to <code>anonymous</code>.",
          "misconception": "Targets [attribute confusion]: The `crossorigin` attribute is usually static and unrelated to version updates."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI enforces integrity by matching exact hashes. When an external resource like jQuery is updated, its hash changes. Therefore, the developer must manually update the <code>integrity</code> attribute in the HTML to reflect the new hash. Failure to do so will cause the browser to block the updated resource, potentially breaking the site.",
        "distractor_analysis": "Distractors suggest incorrect automatic updates, irrelevant CSP changes, or incorrect modifications to the <code>crossorigin</code> attribute, missing the core requirement of updating the SRI hash.",
        "analogy": "It's like having a specific key (hash) for a lockbox (resource). If the lockbox is replaced with a new one (updated resource), you need a new key; the old key won't work, and the lockbox remains inaccessible."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "SRI_BASICS",
        "SRI_MAINTENANCE"
      ]
    },
    {
      "question_text": "What is the primary risk SRI aims to mitigate when using third-party scripts?",
      "correct_answer": "The risk that a compromised third-party server could serve malicious code disguised as a legitimate script.",
      "distractors": [
        {
          "text": "The risk that the third-party script violates the website's privacy policy.",
          "misconception": "Targets [privacy confusion]: SRI focuses on code integrity, not script behavior or privacy compliance."
        },
        {
          "text": "The risk that the third-party script is not optimized for performance.",
          "misconception": "Targets [performance confusion]: SRI is a security measure, not a performance optimization tool."
        },
        {
          "text": "The risk that the third-party script is incompatible with older browsers.",
          "misconception": "Targets [compatibility confusion]: SRI does not address browser compatibility issues."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Third-party scripts, often hosted on CDNs, are attractive targets for attackers. If a CDN is compromised, malicious code can be injected into widely used libraries. SRI prevents this by ensuring the browser only executes scripts whose content matches a pre-verified cryptographic hash, thus mitigating the risk of executing malicious code.",
        "distractor_analysis": "Distractors focus on unrelated risks like privacy violations, performance issues, or browser compatibility, failing to identify the core security threat SRI addresses: malicious code injection via compromised third-party resources.",
        "analogy": "Imagine ordering a specific tool from a catalog (third-party script). SRI is like having a detailed blueprint of the tool. If the delivered tool doesn't match the blueprint exactly, you know it's either faulty or a counterfeit."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SRI_BASICS",
        "THIRD_PARTY_RISKS"
      ]
    },
    {
      "question_text": "Which of the following statements accurately describes the role of Subresource Integrity (SRI) in modern web development security?",
      "correct_answer": "SRI acts as a critical defense-in-depth mechanism, verifying the integrity of external resources to prevent attacks like supply chain compromises.",
      "distractors": [
        {
          "text": "SRI is the primary defense against all client-side attacks, making other measures redundant.",
          "misconception": "Targets [overstated effectiveness confusion]: SRI is one layer; comprehensive security requires multiple defenses."
        },
        {
          "text": "SRI is primarily used to enforce licensing agreements for third-party libraries.",
          "misconception": "Targets [licensing confusion]: SRI is a security feature, not a licensing enforcement tool."
        },
        {
          "text": "SRI is a server-side technology that validates incoming requests.",
          "misconception": "Targets [client-side/server-side confusion]: SRI operates within the user's browser to validate fetched resources."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SRI is a vital component of defense-in-depth, specifically addressing the vulnerability of relying on external resources. By cryptographically verifying resource integrity, it directly counters supply chain attacks where attackers compromise third-party hosts to distribute malware. It complements other security measures like HTTPS and CSP.",
        "distractor_analysis": "Distractors incorrectly position SRI as a sole defense, confuse its purpose with licensing, or misattribute its operation to the server-side, failing to recognize its role as a client-side integrity check for external assets.",
        "analogy": "SRI is like a security guard at a building entrance checking IDs (hashes) of everyone entering, ensuring they are who they claim to be and haven't been replaced by imposters (malicious code)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "evaluate",
      "prerequisites": [
        "SRI_BASICS",
        "DEFENSE_IN_DEPTH"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Subresource Integrity Testing Software Development Security best practices",
    "latency_ms": 27595.158000000003
  },
  "timestamp": "2026-01-18T11:13:46.315503"
}