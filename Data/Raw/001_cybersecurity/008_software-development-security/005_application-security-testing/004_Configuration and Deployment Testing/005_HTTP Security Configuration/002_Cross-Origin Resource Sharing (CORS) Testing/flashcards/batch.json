{
  "topic_title": "Cross-Origin Resource Sharing (CORS) Testing",
  "category": "Software Development Security - 008_006_Application Security Testing",
  "flashcards": [
    {
      "question_text": "What is the primary security concern addressed by Cross-Origin Resource Sharing (CORS) when a browser makes a request from a different origin?",
      "correct_answer": "Preventing unauthorized access to sensitive data or resources from a different domain.",
      "distractors": [
        {
          "text": "Ensuring the server can handle a high volume of requests",
          "misconception": "Targets [performance confusion]: Confuses security policy with load balancing."
        },
        {
          "text": "Validating the integrity of the client-side JavaScript code",
          "misconception": "Targets [client-side validation confusion]: Misunderstands CORS's server-centric security role."
        },
        {
          "text": "Optimizing network latency for cross-domain API calls",
          "misconception": "Targets [performance optimization confusion]: Equates security mechanism with network efficiency."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CORS is a security mechanism because browsers enforce the same-origin policy by default. CORS allows servers to explicitly permit controlled cross-origin requests, thus preventing unauthorized data access from different origins.",
        "distractor_analysis": "The distractors focus on performance and client-side code integrity, which are not the primary security concerns CORS aims to address. CORS is fundamentally about controlling access between different origins.",
        "analogy": "CORS is like a bouncer at a club (the server) checking IDs (origins) to decide who (which domain) can enter and access certain areas (resources), rather than letting anyone in."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SAME_ORIGIN_POLICY"
      ]
    },
    {
      "question_text": "Which HTTP header is sent by the browser in a Cross-Origin Resource Sharing (CORS) request to indicate the origin initiating the request?",
      "correct_answer": "Origin",
      "distractors": [
        {
          "text": "Referer",
          "misconception": "Targets [header confusion]: Confuses the Origin header with the Referer header, which can be less reliable or absent."
        },
        {
          "text": "Host",
          "misconception": "Targets [header confusion]: Mistaking the Host header (target server) for the Origin header (requesting client)."
        },
        {
          "text": "User-Agent",
          "misconception": "Targets [header confusion]: Confusing the client's identity (User-Agent) with its origin domain."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'Origin' header is crucial because it identifies the domain, scheme, and port from which the request originates. This allows the server to make an informed decision based on CORS policies, unlike 'Referer' which can be absent or less specific.",
        "distractor_analysis": "Each distractor represents a plausible but incorrect HTTP header that might be confused with 'Origin', targeting students who don't precisely recall CORS header functions.",
        "analogy": "The 'Origin' header is like the return address on an envelope, telling the recipient (server) where the letter (request) came from."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "HTTP_HEADERS",
        "CORS_BASICS"
      ]
    },
    {
      "question_text": "In CORS, what is the purpose of the <code>Access-Control-Allow-Origin</code> response header?",
      "correct_answer": "To specify which origins are permitted to access the resource from the server.",
      "distractors": [
        {
          "text": "To indicate the HTTP method allowed for the request",
          "misconception": "Targets [header function confusion]: Confuses with `Access-Control-Allow-Methods`."
        },
        {
          "text": "To list the headers that can be sent in the actual request",
          "misconception": "Targets [header function confusion]: Confuses with `Access-Control-Allow-Headers`."
        },
        {
          "text": "To inform the browser about the server's IP address",
          "misconception": "Targets [network confusion]: Misunderstands the purpose of CORS headers versus network addressing."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>Access-Control-Allow-Origin</code> header is the server's explicit permission slip, telling the browser which specific origins (or all origins, using '*') are allowed to read the response. This directly enforces the server's cross-origin access policy.",
        "distractor_analysis": "Distractors incorrectly assign the roles of other CORS-related headers (<code>Allow-Methods</code>, <code>Allow-Headers</code>) or a network-level detail (IP address), targeting students who mix up the various CORS directives.",
        "analogy": "This header is like a sign on a private property stating 'Authorized Visitors from [Specific Address] Allowed,' controlling who can access the property."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CORS_BASICS",
        "HTTP_RESPONSE_HEADERS"
      ]
    },
    {
      "question_text": "What is a common security vulnerability related to misconfigured <code>Access-Control-Allow-Origin</code> headers?",
      "correct_answer": "Allowing all origins (<code>*</code>) when sensitive data is involved, leading to unauthorized access.",
      "distractors": [
        {
          "text": "Blocking legitimate cross-origin requests from trusted partners",
          "misconception": "Targets [overly restrictive configuration]: Focuses on denial of service rather than unauthorized access."
        },
        {
          "text": "Exposing internal server error messages to the client",
          "misconception": "Targets [information disclosure confusion]: Confuses CORS configuration with error handling."
        },
        {
          "text": "Enabling Cross-Site Scripting (XSS) attacks through response manipulation",
          "misconception": "Targets [attack vector confusion]: While related to web security, XSS is distinct from CORS misconfiguration risks."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Using <code>*</code> for <code>Access-Control-Allow-Origin</code> is a security risk because it permits any origin to access resources, potentially exposing sensitive data. Therefore, it should only be used for public, non-sensitive resources.",
        "distractor_analysis": "The distractors present other security issues but miss the core risk of overly permissive CORS settings, targeting students who understand general web security but not specific CORS vulnerabilities.",
        "analogy": "It's like leaving your front door wide open with a sign saying 'Anyone Welcome,' which is fine for a public park but dangerous for a private home."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "CORS_SECURITY",
        "HTTP_HEADERS"
      ]
    },
    {
      "question_text": "When testing CORS configurations, what is the significance of a preflight <code>OPTIONS</code> request?",
      "correct_answer": "It allows the browser to check with the server if the actual cross-origin request is safe to proceed.",
      "distractors": [
        {
          "text": "It is used to authenticate the user before making the main request",
          "misconception": "Targets [authentication confusion]: Confuses preflight checks with user authentication mechanisms."
        },
        {
          "text": "It retrieves the entire resource content before the main request",
          "misconception": "Targets [data retrieval confusion]: Misunderstands that preflight is for permission, not data."
        },
        {
          "text": "It establishes a persistent connection for subsequent requests",
          "misconception": "Targets [connection management confusion]: Confuses preflight with connection pooling or keep-alive."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The preflight <code>OPTIONS</code> request functions as a probe, enabling the browser to determine if the server permits the intended HTTP method and headers for the actual cross-origin request. This prevents potentially harmful requests from being sent without server consent.",
        "distractor_analysis": "Distractors misrepresent the preflight request's purpose, associating it with authentication, data retrieval, or connection management, targeting students who don't grasp the 'permission check' aspect of preflight.",
        "analogy": "A preflight request is like asking for permission before entering a restricted area. The <code>OPTIONS</code> request is asking 'Can I come in and do X?', and the server's response dictates whether the actual entry (the main request) is allowed."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "CORS_PREFLIGHT",
        "HTTP_METHODS"
      ]
    },
    {
      "question_text": "Which of the following scenarios would typically require CORS to be configured?",
      "correct_answer": "A JavaScript application hosted on <code>domain-a.com</code> needs to fetch data from an API at <code>api.domain-b.com</code>.",
      "distractors": [
        {
          "text": "A user logs into <code>mybank.com</code> and accesses their account details",
          "misconception": "Targets [same-origin scenario]: This is a same-origin request, not requiring CORS."
        },
        {
          "text": "A web page on <code>example.com</code> loads an image hosted on the same domain",
          "misconception": "Targets [same-origin scenario]: Image loading from the same origin does not trigger CORS."
        },
        {
          "text": "A user downloads a PDF file directly from <code>documents.com</code>",
          "misconception": "Targets [direct download scenario]: Direct downloads are typically not subject to browser script-based CORS restrictions."
        }
      ],
      "detailed_explanation": {
        "core_logic": "CORS is necessary when a script (like JavaScript) on one origin (<code>domain-a.com</code>) attempts to access resources from a different origin (<code>api.domain-b.com</code>). This cross-origin request is blocked by default by the browser's same-origin policy unless CORS headers permit it.",
        "distractor_analysis": "The distractors describe same-origin requests or direct resource loading, which do not involve cross-origin scripting and thus do not require CORS configuration, targeting students who don't differentiate between same-origin and cross-origin scenarios.",
        "analogy": "Imagine you're at a party (your website) and want to borrow a book from a neighbor's house (another domain). CORS is like asking the neighbor (server) if it's okay to come over and get the book."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "CORS_BASICS",
        "SAME_ORIGIN_POLICY"
      ]
    },
    {
      "question_text": "What is the security implication of a server reflecting the <code>Origin</code> header directly in the <code>Access-Control-Allow-Origin</code> response without validation?",
      "correct_answer": "It can lead to unauthorized origins accessing sensitive data if the server doesn't validate the origin.",
      "distractors": [
        {
          "text": "It increases the risk of Cross-Site Request Forgery (CSRF) attacks",
          "misconception": "Targets [attack vector confusion]: While related to web security, CSRF is a different vulnerability than insecure CORS origin reflection."
        },
        {
          "text": "It causes performance degradation due to excessive header processing",
          "misconception": "Targets [performance confusion]: Misunderstands that the issue is security, not performance."
        },
        {
          "text": "It prevents the browser from caching preflight responses",
          "misconception": "Targets [caching confusion]: Incorrectly links origin reflection to preflight caching behavior."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Reflecting the <code>Origin</code> header without validation is dangerous because any origin, including malicious ones, can send a request with a spoofed <code>Origin</code> header. If the server blindly trusts and echoes this origin, it grants unauthorized access, thus enabling data leakage.",
        "distractor_analysis": "The distractors present other web security issues or performance concerns, failing to identify the core security risk of uncontrolled origin reflection in CORS, targeting students who don't grasp the specific danger of this misconfiguration.",
        "analogy": "This is like a security guard blindly letting anyone who claims to be from 'Building A' into a secure facility, without actually verifying if they are indeed from Building A."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "CORS_SECURITY",
        "HTTP_HEADERS",
        "ORIGIN_SPOOFING"
      ]
    },
    {
      "question_text": "When testing CORS, what does it mean if the browser console shows 'CORS error: The Same Origin Policy disallows reading the remote resource'?",
      "correct_answer": "The server did not provide the necessary CORS headers to permit the cross-origin request.",
      "distractors": [
        {
          "text": "The client-side JavaScript code has a syntax error",
          "misconception": "Targets [error source confusion]: Misattributes a CORS error to client-side code issues."
        },
        {
          "text": "The network connection to the remote resource is unavailable",
          "misconception": "Targets [network error confusion]: Confuses a CORS policy violation with a network connectivity problem."
        },
        {
          "text": "The remote resource is protected by basic authentication",
          "misconception": "Targets [authentication confusion]: Associates the error with authentication rather than CORS policy."
        }
      ],
      "detailed_explanation": {
        "core_logic": "This error message directly indicates that the browser's same-origin policy blocked the request because the server did not respond with the correct CORS headers (like <code>Access-Control-Allow-Origin</code>) to explicitly allow the cross-origin access.",
        "distractor_analysis": "The distractors suggest other common web development issues (syntax errors, network problems, authentication) that could cause request failures, but they do not explain the specific 'Same Origin Policy disallows' CORS error.",
        "analogy": "It's like trying to enter a private club without the proper invitation or membership card; the bouncer (browser) stops you because the rules (same-origin policy) weren't met by the club's (server's) configuration."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "CORS_ERRORS",
        "SAME_ORIGIN_POLICY"
      ]
    },
    {
      "question_text": "Which CORS header is used in a preflight request to inform the server about the HTTP method intended for the actual request?",
      "correct_answer": "Access-Control-Request-Method",
      "distractors": [
        {
          "text": "Access-Control-Allow-Methods",
          "misconception": "Targets [request vs. response header confusion]: Confuses the request header with the corresponding response header."
        },
        {
          "text": "Access-Control-Request-Headers",
          "misconception": "Targets [header type confusion]: Confuses the method request with a header request."
        },
        {
          "text": "Access-Control-Allow-Origin",
          "misconception": "Targets [header purpose confusion]: Confuses the origin permission header with the method request."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>Access-Control-Request-Method</code> header is specifically designed for preflight requests to tell the server which HTTP method (e.g., GET, POST, PUT) the client intends to use in the subsequent actual request. This allows the server to check if that method is permitted.",
        "distractor_analysis": "Distractors incorrectly identify other CORS headers, either response headers (<code>Allow-Methods</code>, <code>Allow-Origin</code>) or a different request header (<code>Request-Headers</code>), targeting students who mix up the specific functions of various CORS directives.",
        "analogy": "This header is like filling out a form before entering a secure area, specifying 'I want to use the 'POST' door' so the guard knows what you plan to do."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CORS_PREFLIGHT",
        "HTTP_METHODS"
      ]
    },
    {
      "question_text": "What is the security risk if <code>Access-Control-Allow-Credentials</code> is set to <code>true</code> without proper origin restrictions?",
      "correct_answer": "It allows cross-origin requests with credentials (like cookies) to be sent, potentially enabling CSRF attacks.",
      "distractors": [
        {
          "text": "It bypasses the need for HTTPS, making data vulnerable to eavesdropping",
          "misconception": "Targets [protocol confusion]: Confuses credential handling with transport layer security (HTTPS)."
        },
        {
          "text": "It forces the browser to use less secure encryption algorithms",
          "misconception": "Targets [encryption confusion]: Misassociates credential handling with encryption strength."
        },
        {
          "text": "It disables the <code>Origin</code> header, making requests untraceable",
          "misconception": "Targets [header function confusion]: Incorrectly assumes it disables the `Origin` header."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Setting <code>Access-Control-Allow-Credentials</code> to <code>true</code> permits browsers to send credentials (cookies, HTTP authentication) with cross-origin requests. If <code>Access-Control-Allow-Origin</code> is not restricted to specific origins, this can be exploited for CSRF attacks, as malicious sites can trick users into performing authenticated actions.",
        "distractor_analysis": "The distractors suggest unrelated security issues like HTTPS bypass, weak encryption, or <code>Origin</code> header disabling, targeting students who don't understand the specific risk of authenticated cross-origin requests.",
        "analogy": "This is like allowing people to use their official ID badges to access sensitive areas from anywhere, without checking *who* is presenting the badge, potentially allowing unauthorized use of someone else's credentials."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "CORS_SECURITY",
        "CSRF",
        "AUTHENTICATION"
      ]
    },
    {
      "question_text": "When testing a web application, what is the primary goal of examining CORS configurations?",
      "correct_answer": "To identify potential vulnerabilities arising from improperly restricted cross-origin resource access.",
      "distractors": [
        {
          "text": "To ensure the application uses the latest JavaScript frameworks",
          "misconception": "Targets [scope confusion]: Confuses security testing with technology stack assessment."
        },
        {
          "text": "To verify that all API endpoints are functioning correctly",
          "misconception": "Targets [functional testing confusion]: Misunderstands that CORS testing is about security, not general API functionality."
        },
        {
          "text": "To optimize the application's loading speed",
          "misconception": "Targets [performance confusion]: Equates security configuration testing with performance tuning."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The primary goal of CORS testing is to uncover security flaws, such as overly permissive <code>Access-Control-Allow-Origin</code> settings or improper handling of credentials, which could allow unauthorized access to sensitive data or facilitate attacks like CSRF. This directly relates to the application's security posture.",
        "distractor_analysis": "The distractors focus on unrelated aspects of web development like framework versions, functional correctness, or performance optimization, targeting students who don't recognize CORS as a critical security configuration element.",
        "analogy": "It's like a building inspector checking if the security doors and access controls are properly installed and configured to prevent unauthorized entry, rather than checking if the elevators are fast."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "CORS_TESTING",
        "APPLICATION_SECURITY"
      ]
    },
    {
      "question_text": "Consider a scenario where a web application on <code>app.example.com</code> needs to fetch user data from <code>api.example.com</code>. If <code>api.example.com</code> is configured with <code>Access-Control-Allow-Origin: *</code>, what is the main security risk?",
      "correct_answer": "Any website, including malicious ones, can make requests to <code>api.example.com</code> and potentially access user data.",
      "distractors": [
        {
          "text": "The browser will refuse to make the request because the origins are different",
          "misconception": "Targets [policy misunderstanding]: Assumes CORS will always block different origins, ignoring the permissive header."
        },
        {
          "text": "<code>app.example.com</code> will be unable to send credentials to the API",
          "misconception": "Targets [credential handling confusion]: The `*` origin generally prevents credentialed requests unless explicitly allowed otherwise."
        },
        {
          "text": "The API server will experience a denial-of-service attack",
          "misconception": "Targets [attack vector confusion]: While possible, the primary risk of `*` is data leakage, not necessarily DoS."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Using <code>Access-Control-Allow-Origin: *</code> means any origin can access the API. Since <code>api.example.com</code> likely handles user data, this configuration allows any website to request and potentially exfiltrate that sensitive information, creating a significant data breach risk.",
        "distractor_analysis": "The distractors present incorrect outcomes: the browser *will* make the request due to the <code>*</code>, credential handling is often restricted with <code>*</code>, and while DoS is a risk, data leakage is the more direct consequence of permissive origin access.",
        "analogy": "It's like a public library allowing anyone to borrow any book without checking their library card; sensitive or private information could be taken by anyone."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "CORS_SECURITY",
        "DATA_PRIVACY"
      ]
    },
    {
      "question_text": "What is the role of the <code>Timing-Allow-Origin</code> header in relation to CORS?",
      "correct_answer": "It allows specific origins to access performance timing information for cross-origin resources.",
      "distractors": [
        {
          "text": "It dictates which HTTP methods are allowed for timing requests",
          "misconception": "Targets [header function confusion]: Confuses timing permissions with method permissions."
        },
        {
          "text": "It enables the browser to cache preflight responses for longer durations",
          "misconception": "Targets [caching confusion]: Misassociates timing data access with preflight caching."
        },
        {
          "text": "It specifies the maximum size of data that can be transferred",
          "misconception": "Targets [data transfer confusion]: Confuses timing information with data transfer limits."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>Timing-Allow-Origin</code> header is a CORS-related header that explicitly permits certain origins to view performance metrics (like load times) of cross-origin resources via the Resource Timing API. Without it, these metrics are zeroed out due to cross-origin restrictions.",
        "distractor_analysis": "Distractors incorrectly describe the header's function, linking it to HTTP methods, caching, or data transfer limits, targeting students who don't understand the specific purpose of performance timing in a cross-origin context.",
        "analogy": "It's like a coach allowing specific team members (origins) to see the detailed performance stats (timing data) of a player from another team (cross-origin resource)."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CORS_BASICS",
        "RESOURCE_TIMING_API"
      ]
    },
    {
      "question_text": "Which of the following is a recommended best practice when configuring CORS for an API that serves multiple client applications from different origins?",
      "correct_answer": "Specify each allowed origin explicitly in <code>Access-Control-Allow-Origin</code> rather than using <code>*</code>.",
      "distractors": [
        {
          "text": "Always use <code>Access-Control-Allow-Origin: *</code> for maximum compatibility",
          "misconception": "Targets [security vs. compatibility confusion]: Prioritizes broad compatibility over security."
        },
        {
          "text": "Disable CORS entirely to prevent any cross-origin access",
          "misconception": "Targets [overly restrictive approach]: Ignores legitimate use cases for CORS."
        },
        {
          "text": "Reflect the incoming <code>Origin</code> header directly in the <code>Access-Control-Allow-Origin</code> response",
          "misconception": "Targets [unvalidated reflection vulnerability]: Fails to implement secure origin validation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Explicitly listing allowed origins in <code>Access-Control-Allow-Origin</code> is a best practice because it adheres to the principle of least privilege, ensuring only trusted clients can access the API. Using <code>*</code> or reflecting the origin without validation opens the API to unauthorized access.",
        "distractor_analysis": "The distractors suggest insecure or impractical configurations: using <code>*</code> broadly, disabling CORS entirely, or reflecting the origin without validation, targeting students who don't understand secure CORS configuration principles.",
        "analogy": "It's like a club owner giving a master key to everyone versus having a list of authorized members who get specific access cards."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "create",
      "prerequisites": [
        "CORS_SECURITY",
        "API_SECURITY"
      ]
    },
    {
      "question_text": "What is the primary function of the <code>Access-Control-Expose-Headers</code> response header in CORS?",
      "correct_answer": "To allow client-side JavaScript to access specific response headers that are not exposed by default.",
      "distractors": [
        {
          "text": "To specify which HTTP methods the client can use for the request",
          "misconception": "Targets [header function confusion]: Confuses with `Access-Control-Allow-Methods`."
        },
        {
          "text": "To indicate the allowed origins for the cross-origin request",
          "misconception": "Targets [header function confusion]: Confuses with `Access-Control-Allow-Origin`."
        },
        {
          "text": "To set the cache duration for preflight request results",
          "misconception": "Targets [caching confusion]: Confuses with `Access-Control-Max-Age`."
        }
      ],
      "detailed_explanation": {
        "core_logic": "By default, browsers restrict JavaScript's access to response headers for security reasons. <code>Access-Control-Expose-Headers</code> explicitly lists which custom or non-standard headers the server permits the client to read, enabling richer data exchange.",
        "distractor_analysis": "Distractors incorrectly assign the roles of other CORS headers (<code>Allow-Methods</code>, <code>Allow-Origin</code>) or caching-related headers (<code>Max-Age</code>), targeting students who don't understand the specific purpose of exposing response headers to the client.",
        "analogy": "It's like a waiter telling you which specific items on the menu (response headers) you are allowed to ask the chef (client-side script) about."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "CORS_BASICS",
        "HTTP_RESPONSE_HEADERS"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Cross-Origin Resource Sharing (CORS) Testing Software Development Security best practices",
    "latency_ms": 30553.124
  },
  "timestamp": "2026-01-18T11:11:14.845290"
}