{
  "topic_title": "SSDT Hook Detection",
  "category": "002_Incident Response And Forensics - Digital Forensics",
  "flashcards": [
    {
      "question_text": "What is the primary function of the System Service Descriptor Table (SSDT) in Windows?",
      "correct_answer": "It acts as a lookup table for the kernel to find the addresses of system service functions.",
      "distractors": [
        {
          "text": "It manages user account permissions and access control lists.",
          "misconception": "Targets [domain confusion]: Confuses SSDT with security descriptor tables or access control mechanisms."
        },
        {
          "text": "It logs all system events and errors for auditing purposes.",
          "misconception": "Targets [logging confusion]: Mistaken for the Windows Event Log or Security Auditing subsystem."
        },
        {
          "text": "It defines the interrupt request (IRQ) assignments for hardware devices.",
          "misconception": "Targets [hardware confusion]: Confuses kernel system calls with hardware interrupt handling."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The SSDT is a critical kernel structure that maps system call numbers to the actual kernel functions that execute them, enabling user-mode applications to request services from the kernel.",
        "distractor_analysis": "The distractors incorrectly associate the SSDT with user permissions, event logging, or hardware IRQ management, rather than its core function as a system call dispatch table.",
        "analogy": "Think of the SSDT as a phone book for the operating system; when an application needs a service (like opening a file), the kernel looks up the 'phone number' (function address) in the SSDT to make the 'call'."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "KERNEL_BASICS",
        "WINDOWS_INTERNALS"
      ]
    },
    {
      "question_text": "What is the main security implication of SSDT hooking by malware?",
      "correct_answer": "Malware can intercept and manipulate system calls, allowing it to hide its activities or compromise system integrity.",
      "distractors": [
        {
          "text": "It can cause denial-of-service by overwhelming the system with requests.",
          "misconception": "Targets [DoS confusion]: Associates hooking with resource exhaustion rather than control."
        },
        {
          "text": "It allows attackers to bypass user-mode antivirus software.",
          "misconception": "Targets [scope confusion]: While true, this is a consequence, not the primary implication of the hook itself."
        },
        {
          "text": "It forces the operating system to reboot, leading to data loss.",
          "misconception": "Targets [BSOD confusion]: Associates hooking with system instability rather than covert control."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SSDT hooking replaces legitimate kernel function pointers with malicious ones, enabling attackers to control system behavior, hide processes/files, or intercept sensitive data because the kernel directly executes the hooked code.",
        "distractor_analysis": "The distractors focus on secondary effects like DoS or BSODs, or a consequence (bypassing AV) rather than the core mechanism of control and manipulation enabled by intercepting system calls.",
        "analogy": "SSDT hooking is like a corrupt operator at a switchboard; they can redirect your calls to the wrong number, listen in on conversations, or block calls entirely, all before they even reach the intended recipient."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SSDT_BASICS",
        "MALWARE_TECHNIQUES"
      ]
    },
    {
      "question_text": "Which Volatility 3 plugin is specifically designed to list system call table entries?",
      "correct_answer": "windows.ssdt",
      "distractors": [
        {
          "text": "windows.malware.unhooked_system_calls",
          "misconception": "Targets [plugin confusion]: This plugin detects hooked ntdll.dll stub functions, not the kernel's SSDT directly."
        },
        {
          "text": "windows.pslist",
          "misconception": "Targets [plugin confusion]: This plugin lists running processes, not system call table entries."
        },
        {
          "text": "windows.modules",
          "misconception": "Targets [plugin confusion]: This plugin lists loaded kernel modules, not the SSDT."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>windows.ssdt</code> plugin in Volatility 3 is purpose-built to enumerate and display the contents of the System Service Descriptor Table, providing details on each system call's index, address, and owner module.",
        "distractor_analysis": "The distractors are other Volatility plugins that perform related but distinct memory analysis tasks, such as detecting ntdll hooks, listing processes, or showing loaded modules, not the SSDT itself.",
        "analogy": "If you're looking for a specific phone number in a phone book, you'd use the 'phone book lookup' tool (windows.ssdt), not a tool for listing all businesses (windows.modules) or finding people who changed their number (windows.malware.unhooked_system_calls)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "VOLATILITY_BASICS",
        "SSDT_BASICS"
      ]
    },
    {
      "question_text": "In the context of SSDT analysis with Volatility, what is the significance of SSDT entries pointing to modules other than 'ntoskrnl' on a clean system?",
      "correct_answer": "It strongly suggests that the SSDT has been hooked, as legitimate entries should primarily reside within the core kernel module.",
      "distractors": [
        {
          "text": "It indicates a normal system operation, as many drivers hook system calls.",
          "misconception": "Targets [normal operation confusion]: Overstates the prevalence and legitimacy of non-ntoskrnl hooks."
        },
        {
          "text": "It signifies a hardware driver issue that needs immediate attention.",
          "misconception": "Targets [hardware confusion]: Incorrectly links SSDT entries to hardware driver problems."
        },
        {
          "text": "It means the system is infected with a rootkit that has been successfully hidden.",
          "misconception": "Targets [definitive infection confusion]: While suspicious, it's not definitive proof of a rootkit without further analysis."
        }
      ],
      "detailed_explanation": {
        "core_logic": "On a standard Windows system, most SSDT entries should point to functions within 'ntoskrnl.exe' (the core kernel). Entries pointing to other modules often indicate that a system call has been redirected, a common technique for rootkits and malware.",
        "distractor_analysis": "The distractors incorrectly normalize non-ntoskrnl hooks as normal, misattribute them to hardware issues, or jump to a conclusion of rootkit infection without acknowledging the need for further investigation.",
        "analogy": "If a company's official directory only lists employees from 'Main Office', but you find entries pointing to 'Branch A' or 'Branch B' for core functions, it suggests someone has altered the directory or is operating outside the main structure."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SSDT_BASICS",
        "KERNEL_MODULES",
        "MALWARE_TECHNIQUES"
      ]
    },
    {
      "question_text": "What is the role of PatchGuard (Kernel Patch Protection) concerning SSDT modifications?",
      "correct_answer": "PatchGuard monitors critical kernel structures like the SSDT and can trigger a system crash (Blue Screen of Death) if tampering is detected.",
      "distractors": [
        {
          "text": "It actively prevents any modifications to the SSDT by unauthorized processes.",
          "misconception": "Targets [prevention vs detection confusion]: Confuses PatchGuard's detection role with active prevention."
        },
        {
          "text": "It logs all SSDT modifications for forensic analysis after an incident.",
          "misconception": "Targets [logging confusion]: Misinterprets PatchGuard's protective action as an auditing function."
        },
        {
          "text": "It automatically reverts any unauthorized changes made to the SSDT.",
          "misconception": "Targets [remediation confusion]: Assumes PatchGuard has rollback capabilities, which it does not."
        }
      ],
      "detailed_explanation": {
        "core_logic": "PatchGuard is a security feature designed to detect and prevent unauthorized modifications to critical Windows kernel structures, including the SSDT. Upon detecting such changes, it initiates a system crash to prevent further compromise, acting as a deterrent.",
        "distractor_analysis": "The distractors incorrectly describe PatchGuard as a preventative tool, a logging mechanism, or an automated repair system, rather than a detection and crash-on-tamper mechanism.",
        "analogy": "PatchGuard is like a security guard who, instead of stopping a thief, immediately triggers a silent alarm that locks down the entire building if they see someone tampering with a critical vault door."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PATCHGUARD",
        "SSDT_BASICS",
        "KERNEL_SECURITY"
      ]
    },
    {
      "question_text": "Why might an anti-virus (AV) or Endpoint Detection and Response (EDR) product use techniques similar to malware, such as SSDT hooking?",
      "correct_answer": "To gain the necessary kernel-level visibility and control to detect, analyze, and potentially block malicious activities.",
      "distractors": [
        {
          "text": "To intentionally mimic malware behavior for easier detection by signature-based systems.",
          "misconception": "Targets [intent confusion]: Assumes AV/EDR intentionally mimic malware for detection, rather than for functional reasons."
        },
        {
          "text": "To exploit vulnerabilities in the operating system for enhanced security.",
          "misconception": "Targets [vulnerability exploitation confusion]: Confuses legitimate monitoring with exploiting system weaknesses."
        },
        {
          "text": "To reduce the system's performance overhead by centralizing kernel operations.",
          "misconception": "Targets [performance confusion]: Incorrectly assumes kernel hooks improve performance."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Effective threat detection and response often require deep system insight. AV/EDR solutions may use techniques like hooking (including SSDT) to monitor system calls, intercept suspicious actions, and enforce security policies because these methods provide necessary visibility.",
        "distractor_analysis": "The distractors misinterpret the intent behind AV/EDR kernel techniques, suggesting they mimic malware for detection, exploit vulnerabilities, or improve performance, rather than for gaining essential monitoring capabilities.",
        "analogy": "A security guard might use a two-way radio (like a hook) to monitor all communications within a building, not to eavesdrop maliciously, but to ensure safety and respond to emergencies quickly."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "AV_EDR_BASICS",
        "HOOKING_TECHNIQUES",
        "KERNEL_MONITORING"
      ]
    },
    {
      "question_text": "When analyzing SSDT output from Volatility, what does the 'Function Owner (Symbol)' column typically represent?",
      "correct_answer": "The kernel module (e.g., ntoskrnl.exe, specific driver) that owns the code for the system call function.",
      "distractors": [
        {
          "text": "The user-mode process that last called the system function.",
          "misconception": "Targets [process vs module confusion]: Confuses kernel module ownership with user-mode process activity."
        },
        {
          "text": "The security software that is monitoring the system call.",
          "misconception": "Targets [monitoring confusion]: Assumes the column identifies security tools rather than code origin."
        },
        {
          "text": "The timestamp when the system call function was last modified.",
          "misconception": "Targets [timestamp confusion]: Mistakes the owner identifier for a modification time."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The 'Function Owner (Symbol)' column in Volatility's <code>windows.ssdt</code> output identifies the kernel module responsible for the code pointed to by the SSDT entry. This helps determine if the function is part of the core OS (ntoskrnl) or a loaded driver.",
        "distractor_analysis": "The distractors incorrectly identify the 'owner' as a user-mode process, security software, or a timestamp, rather than the kernel module that contains the actual code for the system service.",
        "analogy": "In a library catalog, the 'Author' field tells you who wrote the book (the owner of the content), not who last checked it out (user process) or which security system is scanning the shelves (security software)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "VOLATILITY_BASICS",
        "KERNEL_MODULES"
      ]
    },
    {
      "question_text": "What is a key challenge when using Volatility's <code>windows.ssdt</code> plugin on modern Windows systems?",
      "correct_answer": "The sheer number of SSDT entries (potentially 1,500+) requires significant filtering and analysis to identify suspicious hooks.",
      "distractors": [
        {
          "text": "The plugin only shows suspicious entries, making it hard to find legitimate ones.",
          "misconception": "Targets [plugin functionality confusion]: Incorrectly assumes the plugin filters for suspicious entries by default."
        },
        {
          "text": "SSDT entries are heavily encrypted, making them unreadable by Volatility.",
          "misconception": "Targets [encryption confusion]: Assumes SSDT entries are encrypted, which they are not."
        },
        {
          "text": "The plugin requires specific hardware to function correctly.",
          "misconception": "Targets [hardware dependency confusion]: Incorrectly suggests a hardware requirement beyond memory access."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Modern Windows operating systems have a vast number of system services, resulting in a large SSDT. The <code>windows.ssdt</code> plugin dumps all entries, so analysts must possess the skills to sift through legitimate entries and identify potential hooks, which are often a small subset.",
        "distractor_analysis": "The distractors misrepresent the plugin's output (claiming it filters), introduce a false concept of SSDT encryption, or invent a hardware dependency, ignoring the actual challenge of data volume.",
        "analogy": "Trying to find a specific needle in a haystack; the haystack is the large number of SSDT entries, and the needle is the actual hook you're looking for."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "VOLATILITY_BASICS",
        "SSDT_BASICS",
        "FORENSIC_ANALYSIS"
      ]
    },
    {
      "question_text": "How does SSDT hooking differ from user-mode API hooking?",
      "correct_answer": "SSDT hooking targets kernel-level system calls, affecting all processes system-wide, whereas user-mode API hooking targets functions within specific user-mode DLLs.",
      "distractors": [
        {
          "text": "SSDT hooking is reversible, while user-mode API hooking is permanent.",
          "misconception": "Targets [reversibility confusion]: Both types of hooks can be reversible or permanent depending on implementation."
        },
        {
          "text": "SSDT hooking requires kernel-mode privileges, while user-mode API hooking does not.",
          "misconception": "Targets [privilege confusion]: Both often require elevated privileges or specific techniques to implement effectively."
        },
        {
          "text": "SSDT hooking only affects the process that installs the hook, while user-mode API hooking affects the entire system.",
          "misconception": "Targets [scope confusion]: Reverses the scope of impact between kernel and user mode."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SSDT hooks modify the kernel's dispatch table for system calls, meaning any process making that call is affected. User-mode API hooks modify functions within DLLs loaded by specific processes, limiting their scope unless injected into multiple processes.",
        "distractor_analysis": "The distractors incorrectly compare reversibility, privilege requirements, and scope of impact, fundamentally misunderstanding the distinction between kernel-level (SSDT) and user-level (API) hooking.",
        "analogy": "SSDT hooking is like changing the main water valve for an entire building; user-mode API hooking is like changing the faucet in a single apartment."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "HOOKING_TECHNIQUES",
        "KERNEL_VS_USER_MODE"
      ]
    },
    {
      "question_text": "Consider a scenario where Volatility's <code>windows.ssdt</code> plugin shows a system call entry pointing to a module named 'my_driver.sys' instead of 'ntoskrnl.exe'. What is the MOST likely implication?",
      "correct_answer": "The system call has likely been hooked by 'my_driver.sys', potentially for legitimate driver functionality or malicious purposes.",
      "distractors": [
        {
          "text": "The 'my_driver.sys' module is corrupted and needs to be reinstalled.",
          "misconception": "Targets [corruption confusion]: Assumes a non-standard owner implies corruption rather than redirection."
        },
        {
          "text": "This is a normal behavior for third-party drivers on this system.",
          "misconception": "Targets [normalization confusion]: Overstates the normalcy of drivers directly hooking SSDT entries."
        },
        {
          "text": "The system call has been disabled due to a security policy.",
          "misconception": "Targets [disabling confusion]: Confuses hooking with disabling or policy enforcement."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When a system call entry in the SSDT points to a module other than the core kernel ('ntoskrnl.exe'), it signifies that the default kernel function has been replaced. This redirection is characteristic of hooking, which can be performed by legitimate drivers or malicious software.",
        "distractor_analysis": "The distractors incorrectly attribute the non-standard owner to corruption, normalize it as standard behavior, or misinterpret it as a disabled function, failing to recognize the primary implication of hooking.",
        "analogy": "If your GPS navigation system, which normally uses official map data, suddenly starts directing you via routes provided by a 'local guide' app, it implies the 'local guide' app has taken over the routing instructions."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "SSDT_BASICS",
        "KERNEL_DRIVERS",
        "HOOKING_TECHNIQUES"
      ]
    },
    {
      "question_text": "What is the purpose of the <code>unhooked_system_calls</code> plugin in Volatility 3?",
      "correct_answer": "To detect hooked ntdll.dll stub functions within user-mode processes by comparing them against known good copies.",
      "distractors": [
        {
          "text": "To identify SSDT hooks by comparing kernel module pointers.",
          "misconception": "Targets [scope confusion]: Incorrectly applies the plugin's function to the kernel-level SSDT."
        },
        {
          "text": "To find processes that have been terminated abnormally.",
          "misconception": "Targets [process state confusion]: Confuses function hooking with process termination analysis."
        },
        {
          "text": "To list all system calls made by a specific process.",
          "misconception": "Targets [syscall logging confusion]: Mistaken for a syscall auditing or tracing tool."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>unhooked_system_calls</code> plugin focuses on user-mode memory, specifically examining the <code>ntdll.dll</code> stubs that act as intermediaries for system calls. It compares these stubs against a known good version to identify if they have been modified (hooked).",
        "distractor_analysis": "The distractors incorrectly assign the plugin's functionality to kernel-level SSDT analysis, process termination detection, or syscall logging, rather than its actual purpose of finding user-mode ntdll hooks.",
        "analogy": "This plugin is like a quality control inspector checking if the 'start buttons' on individual machines (user-mode ntdll stubs) are original or have been replaced with faulty copies, distinct from checking the main factory power switch (kernel SSDT)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "VOLATILITY_BASICS",
        "NTDLL_HOOKING",
        "USER_MODE_ANALYSIS"
      ]
    },
    {
      "question_text": "Why is analyzing SSDT hooks crucial in incident response, even if PatchGuard exists?",
      "correct_answer": "Attackers may find ways to bypass PatchGuard, or use techniques that don't trigger it, making direct SSDT analysis essential for detecting sophisticated threats.",
      "distractors": [
        {
          "text": "PatchGuard is unreliable and frequently fails to detect hooks.",
          "misconception": "Targets [PatchGuard reliability confusion]: Overstates PatchGuard's failure rate."
        },
        {
          "text": "SSDT analysis is required by NIST guidelines for all incident responses.",
          "misconception": "Targets [standard compliance confusion]: Assumes a specific, mandatory requirement without evidence."
        },
        {
          "text": "Only SSDT hooks, not other kernel modifications, are relevant to incident response.",
          "misconception": "Targets [scope limitation confusion]: Incorrectly limits incident response focus solely to SSDT hooks."
        }
      ],
      "detailed_explanation": {
        "core_logic": "While PatchGuard provides a layer of protection, advanced adversaries continuously develop methods to evade or disable it. Therefore, direct memory analysis of the SSDT remains a vital technique for incident responders to uncover sophisticated kernel-level compromises that might bypass automated defenses.",
        "distractor_analysis": "The distractors incorrectly claim PatchGuard is unreliable, mandate SSDT analysis by NIST without specific citation, or wrongly limit incident response scope, failing to acknowledge the cat-and-mouse game between attackers and defenses.",
        "analogy": "Even with a strong alarm system (PatchGuard), a determined burglar might still find ways in (evade detection). Therefore, a detective (incident responder) still needs to examine the scene directly (analyze SSDT) for signs of entry."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "defense",
      "bloom_level": "evaluate",
      "prerequisites": [
        "PATCHGUARD",
        "SSDT_BASICS",
        "INCIDENT_RESPONSE"
      ]
    },
    {
      "question_text": "What is the TTP (Tactics, Techniques, and Procedures) category that SSDT hooking most closely aligns with?",
      "correct_answer": "Defense Evasion",
      "distractors": [
        {
          "text": "Credential Access",
          "misconception": "Targets [TTP category confusion]: Credential Access focuses on stealing login information, not hiding activities."
        },
        {
          "text": "Lateral Movement",
          "misconception": "Targets [TTP category confusion]: Lateral Movement is about moving between systems, not hiding on one."
        },
        {
          "text": "Collection",
          "misconception": "Targets [TTP category confusion]: Collection is about gathering data, not evading detection."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SSDT hooking is primarily used by adversaries to evade detection by hiding their processes, files, or network connections from security software and analysts. This aligns directly with the 'Defense Evasion' tactic in frameworks like MITRE ATT&CK.",
        "distractor_analysis": "The distractors assign SSDT hooking to unrelated ATT&CK tactics: Credential Access (stealing credentials), Lateral Movement (moving across networks), and Collection (gathering data), missing its core purpose of hiding.",
        "analogy": "Using SSDT hooks to hide malware is like a bank robber using a disguise and a secret tunnel to avoid security cameras and guards; the goal is to evade being seen or caught."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "MITRE_ATTACK",
        "TTP_BASICS",
        "DEFENSE_EVASION"
      ]
    },
    {
      "question_text": "When analyzing SSDT output, what does it mean if a system call's function pointer appears to be invalid or points to unallocated memory?",
      "correct_answer": "This could indicate that the module containing the original function has been unloaded, or that the pointer itself has been corrupted or maliciously altered.",
      "distractors": [
        {
          "text": "It signifies a successful rootkit installation that has hidden its code.",
          "misconception": "Targets [rootkit confusion]: While possible, invalid pointers can have other causes besides successful rootkit hiding."
        },
        {
          "text": "The system call is no longer supported by the current Windows version.",
          "misconception": "Targets [version compatibility confusion]: Unlikely for core system calls; invalid pointers suggest a different issue."
        },
        {
          "text": "It indicates that the Volatility plugin is malfunctioning.",
          "misconception": "Targets [tool error confusion]: Assumes the tool is at fault rather than analyzing the data it presents."
        }
      ],
      "detailed_explanation": {
        "core_logic": "An invalid or unallocated memory pointer in the SSDT suggests that the expected code is missing. This can happen if a kernel module is unloaded after its SSDT entry was established, or more critically, if a hook has replaced the valid pointer with an invalid one to crash the system or hide code.",
        "distractor_analysis": "The distractors incorrectly attribute invalid pointers solely to successful rootkits, unsupported system calls, or tool errors, failing to consider the possibilities of module unloading or deliberate pointer manipulation.",
        "analogy": "If a map's directions lead you to a road that no longer exists, it could be because the road was closed (module unloaded) or the map was deliberately altered to send you off-course (malicious hook)."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "evaluate",
      "prerequisites": [
        "SSDT_BASICS",
        "MEMORY_ANALYSIS",
        "KERNEL_MODULES"
      ]
    },
    {
      "question_text": "What is the primary difference in detection focus between Volatility's <code>windows.ssdt</code> and <code>windows.malware.unhooked_system_calls</code> plugins?",
      "correct_answer": "<code>windows.ssdt</code> focuses on kernel-level system call table hooks, while <code>unhooked_system_calls</code> focuses on user-mode ntdll.dll stub function hooks.",
      "distractors": [
        {
          "text": "<code>windows.ssdt</code> detects rootkits, while <code>unhooked_system_calls</code> detects viruses.",
          "misconception": "Targets [malware type confusion]: Overly broad categorization of malware types and plugin capabilities."
        },
        {
          "text": "<code>windows.ssdt</code> analyzes network connections, while <code>unhooked_system_calls</code> analyzes file system activity.",
          "misconception": "Targets [functionality confusion]: Assigns entirely incorrect analysis domains to both plugins."
        },
        {
          "text": "<code>windows.ssdt</code> requires a clean system image, while <code>unhooked_system_calls</code> works on infected images.",
          "misconception": "Targets [image requirement confusion]: Both plugins operate on memory dumps, regardless of infection status."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>windows.ssdt</code> plugin examines the kernel's System Service Descriptor Table, which manages direct system call transitions. In contrast, <code>unhooked_system_calls</code> operates in user-mode memory, specifically targeting the stub functions in <code>ntdll.dll</code> that initiate system calls, looking for modifications there.",
        "distractor_analysis": "The distractors incorrectly differentiate the plugins based on malware types, unrelated analysis functions (network/file system), or false requirements about image cleanliness, missing the core distinction between kernel and user-mode hooking detection.",
        "analogy": "Imagine investigating a factory: <code>windows.ssdt</code> is like checking the main power distribution panel (kernel level) for tampering, while <code>unhooked_system_calls</code> is like checking the individual power buttons on each machine on the factory floor (user level)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "VOLATILITY_BASICS",
        "SSDT_BASICS",
        "NTDLL_HOOKING"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "SSDT Hook Detection 002_Incident Response And Forensics best practices",
    "latency_ms": 23707.454999999998
  },
  "timestamp": "2026-01-18T13:40:53.068126",
  "_av_safe_encoded": true,
  "_encoding_note": "Educational content encoded with HTML entities to prevent antivirus false positives. Content renders normally in Anki."
}