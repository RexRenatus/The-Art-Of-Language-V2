{
  "topic_title": "Mutex and Named Object Creation",
  "category": "002_Incident Response And Forensics - 007_Malware Analysis",
  "flashcards": [
    {
      "question_text": "What is the primary function of a mutex object in the context of malware execution?",
      "correct_answer": "To prevent multiple instances of the same malware from running simultaneously on a system.",
      "distractors": [
        {
          "text": "To encrypt communication channels between malware components.",
          "misconception": "Targets [functional confusion]: Confuses mutexes with encryption protocols like TLS."
        },
        {
          "text": "To log all system activities performed by the malware.",
          "misconception": "Targets [logging confusion]: Mixes mutex functionality with system logging mechanisms."
        },
        {
          "text": "To establish a secure communication tunnel for command and control.",
          "misconception": "Targets [communication confusion]: Equates mutexes with C2 communication channels."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Mutexes function as locking mechanisms, ensuring only one process can acquire ownership at a time. Malware uses this to avoid duplicate execution, preventing multiple instances from running concurrently on the same system.",
        "distractor_analysis": "Distractors incorrectly associate mutexes with encryption, logging, or C2 communication, demonstrating a misunderstanding of their synchronization purpose.",
        "analogy": "A mutex is like a single-occupancy restroom key; only one person can have the key and use the restroom at a time, preventing a queue from forming inside."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "MALWARE_EXECUTION_BASICS"
      ]
    },
    {
      "question_text": "According to Microsoft documentation, what is the main purpose of a mutex object?",
      "correct_answer": "To coordinate mutually exclusive access to a shared resource, preventing simultaneous access by multiple threads.",
      "distractors": [
        {
          "text": "To signal the completion of a specific task between processes.",
          "misconception": "Targets [signaling confusion]: Confuses mutexes with event objects used for signaling."
        },
        {
          "text": "To manage memory allocation and deallocation for applications.",
          "misconception": "Targets [resource management confusion]: Equates mutexes with memory management units."
        },
        {
          "text": "To enforce access control lists (ACLs) on files and directories.",
          "misconception": "Targets [access control confusion]: Mixes mutexes with file system permission mechanisms."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Mutex objects are synchronization primitives that ensure only one thread can own the mutex at any given time. This 'mutual exclusion' is crucial for protecting shared resources from concurrent modification, as explained by Microsoft's Win32 API documentation.",
        "distractor_analysis": "The distractors misrepresent mutex functionality by associating it with task signaling, memory management, or file access control, rather than its core purpose of exclusive resource access.",
        "analogy": "Imagine a single microphone at a podium; a mutex ensures only one speaker can use it at a time, preventing chaos and ensuring clear communication."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "MUTEX_BASICS",
        "SYNCHRONIZATION_PRIMITIVES"
      ]
    },
    {
      "question_text": "How can malware leverage mutexes to evade detection or prevent duplication?",
      "correct_answer": "By creating a unique mutex name and checking for its existence; if it exists, the malware exits to avoid running a second instance.",
      "distractors": [
        {
          "text": "By creating a mutex with a random name that changes with each execution.",
          "misconception": "Targets [naming convention confusion]: Assumes random naming is the primary evasion technique, ignoring the existence check."
        },
        {
          "text": "By using a mutex to encrypt its own code, making it unreadable.",
          "misconception": "Targets [encryption confusion]: Incorrectly attributes encryption capabilities to mutex objects."
        },
        {
          "text": "By embedding the mutex name within a system process's memory space.",
          "misconception": "Targets [scope confusion]: Misunderstands how system-wide mutexes are created and accessed."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Malware creates a mutex with a specific name. Before executing its main functions, it checks if a mutex with that name already exists. If it does, it implies another instance is running, so the new instance exits, thus preventing duplication and potential detection.",
        "distractor_analysis": "The distractors propose incorrect methods like random naming, encryption, or embedding within processes, failing to grasp the core 'check-and-exit' logic for preventing duplicate execution.",
        "analogy": "It's like a club with a bouncer checking a guest list. If your name is already on the list (mutex exists), you can't enter again (malware exits)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "MALWARE_EXECUTION_BASICS",
        "MUTEX_BASICS"
      ]
    },
    {
      "question_text": "What is the significance of a 'named mutex' in inter-process communication and malware analysis?",
      "correct_answer": "Named mutexes allow different processes to synchronize access to a shared resource by referencing a common, persistent name.",
      "distractors": [
        {
          "text": "Named mutexes are only used for intra-process thread synchronization.",
          "misconception": "Targets [scope confusion]: Incorrectly limits named mutexes to within a single process."
        },
        {
          "text": "Named mutexes are automatically deleted when the creating process terminates.",
          "misconception": "Targets [persistence confusion]: Assumes named mutexes lack persistence beyond the creator process."
        },
        {
          "text": "Named mutexes are primarily used for encrypting data passed between processes.",
          "misconception": "Targets [functional confusion]: Confuses named mutexes with data encryption mechanisms."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Named mutexes provide a persistent identifier across process boundaries. This allows unrelated processes to find and synchronize using the same mutex object, which is fundamental for inter-process coordination and a key indicator for malware analysis.",
        "distractor_analysis": "The distractors err by limiting named mutex scope to intra-process, assuming they lack persistence, or confusing their synchronization role with encryption.",
        "analogy": "A named mutex is like a public bulletin board where different departments can post messages to coordinate their actions, ensuring only one department posts at a time."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "INTERPROCESS_COMMUNICATION",
        "MUTEX_BASICS"
      ]
    },
    {
      "question_text": "In Linux environments, what is an alternative mechanism to system mutexes that malware might use for execution control?",
      "correct_answer": "Acquiring a lock on a mutex file.",
      "distractors": [
        {
          "text": "Creating a symbolic link to a critical system file.",
          "misconception": "Targets [file system confusion]: Confuses mutex files with symbolic links."
        },
        {
          "text": "Modifying the kernel's process scheduler.",
          "misconception": "Targets [kernel manipulation confusion]: Attributes direct kernel modification to malware for simple execution control."
        },
        {
          "text": "Utilizing inter-process signals (e.g., SIGUSR1).",
          "misconception": "Targets [signaling confusion]: Confuses mutex file locking with inter-process signal mechanisms."
        }
      ],
      "detailed_explanation": {
        "core_logic": "While system mutexes are common in Windows, Linux malware may achieve similar mutual exclusion by attempting to acquire an exclusive lock on a designated file. If the lock is successful, execution proceeds; if not, the malware exits, preventing duplicate instances.",
        "distractor_analysis": "The distractors propose unrelated Linux mechanisms like symbolic links, kernel manipulation, or inter-process signals, failing to identify the file-locking alternative to mutexes.",
        "analogy": "Instead of a digital lock (mutex), malware uses a physical lock on a door (mutex file) to ensure only one person enters a room at a time."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "LINUX_FILE_SYSTEM",
        "MUTEX_BASICS",
        "MALWARE_EXECUTION_TECHNIQUES"
      ]
    },
    {
      "question_text": "When analyzing malware, what is the significance of identifying mutex names used by the specimen?",
      "correct_answer": "Mutex names can serve as Indicators of Compromise (IOCs) to detect the presence of specific malware on a system.",
      "distractors": [
        {
          "text": "Mutex names are always hard-coded and easily predictable.",
          "misconception": "Targets [predictability confusion]: Assumes all mutex names are static and simple, ignoring dynamic generation."
        },
        {
          "text": "Mutex names are used to decrypt the malware's configuration files.",
          "misconception": "Targets [decryption confusion]: Confuses mutex names with decryption keys or algorithms."
        },
        {
          "text": "Mutex names are irrelevant as they are frequently changed by the OS.",
          "misconception": "Targets [OS interaction confusion]: Incorrectly believes the operating system actively modifies malware-created mutex names."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Malware often creates mutexes with specific, sometimes hard-coded or predictably generated, names. Discovering these names during analysis allows incident responders to search for their presence on other systems, thereby identifying infections and serving as valuable IOCs.",
        "distractor_analysis": "The distractors incorrectly claim mutex names are always predictable, used for decryption, or frequently changed by the OS, missing their utility as static or semi-static IOCs.",
        "analogy": "Finding a specific brand of cigarette butt at a crime scene (mutex name) can help identify a particular suspect (malware) who was present."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "INDICATORS_OF_COMPROMISE",
        "MALWARE_ANALYSIS_TECHNIQUES",
        "MUTEX_BASICS"
      ]
    },
    {
      "question_text": "What is a potential risk if a thread terminates unexpectedly without releasing ownership of a mutex object?",
      "correct_answer": "The mutex object becomes abandoned, potentially causing deadlocks for other threads waiting for it.",
      "distractors": [
        {
          "text": "The operating system automatically assigns ownership to another process.",
          "misconception": "Targets [ownership transfer confusion]: Assumes automatic reassignment of abandoned mutexes."
        },
        {
          "text": "The mutex object is immediately deleted, freeing up system resources.",
          "misconception": "Targets [resource management confusion]: Believes abandonment leads to automatic deletion."
        },
        {
          "text": "The terminated thread's memory is corrupted.",
          "misconception": "Targets [memory corruption confusion]: Links mutex abandonment to unrelated memory corruption issues."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When a thread holding a mutex terminates without releasing it, the mutex enters an 'abandoned' state. Other threads attempting to acquire this mutex will block indefinitely, leading to deadlocks because the resource remains locked and un-releasable by the original owner.",
        "distractor_analysis": "The distractors propose incorrect outcomes like automatic ownership transfer, immediate deletion, or memory corruption, failing to recognize the deadlock potential of an abandoned mutex.",
        "analogy": "If a person leaves a meeting room but locks the door from the inside and disappears, no one else can enter, and the room remains unusable."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "MUTEX_BASICS",
        "DEADLOCKS",
        "THREAD_SYNCHRONIZATION"
      ]
    },
    {
      "question_text": "Which NIST Special Publication provides guidance on integrating forensic techniques into incident response?",
      "correct_answer": "NIST SP 800-86",
      "distractors": [
        {
          "text": "NIST SP 800-53",
          "misconception": "Targets [standard confusion]: Confuses incident response forensics guidance with security control cataloging."
        },
        {
          "text": "NIST SP 800-61",
          "misconception": "Targets [standard confusion]: Mixes forensics integration with general incident handling procedures."
        },
        {
          "text": "NIST SP 800-171",
          "misconception": "Targets [standard confusion]: Confuses forensics integration with protecting CUI in non-federal systems."
        }
      ],
      "detailed_explanation": {
        "core_logic": "NIST SP 800-86, 'Guide to Integrating Forensic Techniques into Incident Response,' specifically addresses how to incorporate forensic activities into the broader incident response process, offering practical guidance for IT professionals.",
        "distractor_analysis": "The distractors incorrectly identify other NIST publications that focus on security controls (800-53), incident handling (800-61), or CUI protection (800-171), rather than the specific forensic integration guidance of 800-86.",
        "analogy": "NIST SP 800-86 is like a cookbook specifically for forensic chefs within the larger restaurant of incident response."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "NIST_STANDARDS",
        "INCIDENT_RESPONSE_FRAMEWORKS"
      ]
    },
    {
      "question_text": "What is the primary difference between a local mutex and a system mutex?",
      "correct_answer": "Local mutexes synchronize threads within a single process, while system mutexes synchronize activities across multiple processes.",
      "distractors": [
        {
          "text": "Local mutexes are used for network communication, while system mutexes are for local resources.",
          "misconception": "Targets [scope confusion]: Incorrectly associates local mutexes with networking and system mutexes with local resources."
        },
        {
          "text": "System mutexes are always named, while local mutexes are always unnamed.",
          "misconception": "Targets [naming convention confusion]: Assumes a strict naming difference that isn't universally true."
        },
        {
          "text": "Local mutexes are faster because they don't require OS intervention.",
          "misconception": "Targets [performance confusion]: Makes an assumption about performance without understanding the underlying mechanisms."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Local mutexes operate within the scope of a single process, synchronizing its internal threads. System mutexes, however, are kernel objects accessible by name, allowing synchronization between entirely separate processes, which is critical for inter-process coordination.",
        "distractor_analysis": "The distractors incorrectly differentiate based on network vs. local resources, naming conventions, or performance assumptions, missing the fundamental distinction in process scope.",
        "analogy": "A local mutex is like a 'Do Not Disturb' sign on your personal office door (within one process), while a system mutex is like a shared conference room booking system (across multiple processes)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "PROCESS_VS_THREAD",
        "MUTEX_BASICS"
      ]
    },
    {
      "question_text": "Consider a scenario where malware attempts to create a mutex named 'MyAppMutex_v1.0'. If the <code>CreateMutex</code> function returns a handle and <code>GetLastError()</code> returns <code>ERROR_ALREADY_EXISTS</code>, what does this indicate?",
      "correct_answer": "A mutex with that name already exists, likely created by a previously running instance of the same malware.",
      "distractors": [
        {
          "text": "The operating system is preventing the creation of duplicate mutex names.",
          "misconception": "Targets [OS policy confusion]: Assumes the OS actively prevents duplicate mutex names as a security feature."
        },
        {
          "text": "The mutex was successfully created, but an error occurred during handle retrieval.",
          "misconception": "Targets [error code confusion]: Misinterprets `ERROR_ALREADY_EXISTS` as a handle retrieval issue."
        },
        {
          "text": "The mutex name is invalid and cannot be used.",
          "misconception": "Targets [validation confusion]: Assumes the error indicates an invalid name rather than pre-existence."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>ERROR_ALREADY_EXISTS</code> code from <code>GetLastError()</code> after calling <code>CreateMutex</code> specifically signifies that the named object already exists. For malware, this is a direct indicator that another instance is likely running, prompting it to exit.",
        "distractor_analysis": "The distractors misinterpret the error code, attributing it to OS policy, handle retrieval errors, or invalid names, rather than the intended meaning of pre-existing object.",
        "analogy": "You try to reserve a specific table number at a restaurant, and the host tells you 'Table 5 is already taken' (<code>ERROR_ALREADY_EXISTS</code>). It doesn't mean table numbers are forbidden, just that it's occupied."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "MUTEX_CREATION_API",
        "WINDOWS_ERROR_CODES"
      ]
    },
    {
      "question_text": "How might an adversary dynamically generate a mutex name to evade detection, as mentioned in MITRE ATT&CK T1480.002?",
      "correct_answer": "Using a predictable algorithm based on system information or a hardcoded seed.",
      "distractors": [
        {
          "text": "By randomly selecting characters from a predefined list for each execution.",
          "misconception": "Targets [randomness confusion]: Assumes pure randomness is used, rather than predictable algorithms."
        },
        {
          "text": "By hashing the current date and time with a known salt.",
          "misconception": "Targets [hashing confusion]: Suggests a specific, potentially insecure, hashing method."
        },
        {
          "text": "By embedding the name directly within the malware's configuration file.",
          "misconception": "Targets [embedding confusion]: Confuses dynamic generation with static embedding."
        }
      ],
      "detailed_explanation": {
        "core_logic": "While some malware uses hard-coded mutex names, others employ algorithms to generate them dynamically. This often involves predictable methods, like hashing system identifiers or using a seed, allowing the malware to create a unique mutex per infection while still being reproducible if the algorithm is known.",
        "distractor_analysis": "The distractors propose pure randomness, a specific insecure hashing method, or static embedding, failing to grasp the concept of algorithm-based dynamic generation for mutex names.",
        "analogy": "Instead of using a fixed password, you use a formula (algorithm) based on today's date to generate a unique, but predictable, password each day."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "MALWARE_OBFUSCATION",
        "MUTEX_BASICS",
        "MITRE_ATTACK_T1480"
      ]
    },
    {
      "question_text": "What is the purpose of the <code>ReleaseMutex</code> function in Windows synchronization?",
      "correct_answer": "To relinquish ownership of a mutex object, allowing other waiting threads to acquire it.",
      "distractors": [
        {
          "text": "To create a new mutex object with a specified name.",
          "misconception": "Targets [creation confusion]: Confuses releasing a mutex with creating one."
        },
        {
          "text": "To check if a mutex object is currently owned by another thread.",
          "misconception": "Targets [checking confusion]: Equates releasing with checking ownership status."
        },
        {
          "text": "To terminate a thread that is currently holding a mutex.",
          "misconception": "Targets [termination confusion]: Misunderstands `ReleaseMutex` as a thread termination function."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>ReleaseMutex</code> function is essential for proper mutex management. After a thread has finished accessing the shared resource protected by the mutex, it must call <code>ReleaseMutex</code> to signal that it no longer owns the mutex, thereby allowing other waiting threads to proceed.",
        "distractor_analysis": "The distractors incorrectly describe <code>ReleaseMutex</code> as a function for creation, checking ownership, or terminating threads, missing its core purpose of relinquishing mutex ownership.",
        "analogy": "After using a shared tool, you put it back on the shelf (<code>ReleaseMutex</code>) so the next person can use it."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "MUTEX_BASICS",
        "WINDOWS_API_SYNCHRONIZATION"
      ]
    },
    {
      "question_text": "Why might an incident responder examine mutex objects on a compromised host?",
      "correct_answer": "To identify specific malware families or instances by their unique mutex names, which act as IOCs.",
      "distractors": [
        {
          "text": "To determine the malware's encryption algorithm.",
          "misconception": "Targets [decryption confusion]: Incorrectly links mutexes to cryptographic keys or algorithms."
        },
        {
          "text": "To assess the system's overall network bandwidth usage.",
          "misconception": "Targets [performance monitoring confusion]: Confuses mutex analysis with network performance metrics."
        },
        {
          "text": "To verify the integrity of the operating system kernel files.",
          "misconception": "Targets [system integrity confusion]: Equates mutex analysis with OS file integrity checks."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Mutex objects, especially named ones, often have characteristic names associated with specific malware. By examining running processes or system objects for these mutexes, responders can quickly identify the presence of known threats and use these names as Indicators of Compromise (IOCs).",
        "distractor_analysis": "The distractors propose unrelated tasks like determining encryption, assessing network bandwidth, or verifying kernel integrity, failing to recognize the value of mutexes as malware identifiers.",
        "analogy": "Finding a specific, rare type of footprint (mutex name) at a crime scene helps investigators identify which animal (malware) was present."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "INDICATORS_OF_COMPROMISE",
        "MALWARE_ANALYSIS_TECHNIQUES",
        "MUTEX_BASICS"
      ]
    },
    {
      "question_text": "What is the relationship between mutex objects and the 'Defense Evasion' tactic in the MITRE ATT&CK framework?",
      "correct_answer": "Malware uses mutexes for defense evasion by preventing duplicate execution, which can help avoid detection by security software monitoring for multiple instances.",
      "distractors": [
        {
          "text": "Mutexes are primarily used for the 'Persistence' tactic by ensuring malware restarts.",
          "misconception": "Targets [tactic confusion]: Incorrectly assigns mutexes to persistence rather than defense evasion."
        },
        {
          "text": "Mutexes are used in 'Collection' to group exfiltrated data.",
          "misconception": "Targets [tactic confusion]: Confuses mutexes with data aggregation for collection."
        },
        {
          "text": "Mutexes are a form of 'Discovery' technique to map network topology.",
          "misconception": "Targets [tactic confusion]: Equates mutexes with network reconnaissance techniques."
        }
      ],
      "detailed_explanation": {
        "core_logic": "By ensuring only one instance of itself runs, malware using mutexes avoids behaviors that might trigger alerts from security tools monitoring for multiple processes or redundant activity. This directly supports the 'Defense Evasion' tactic by making the malware less conspicuous.",
        "distractor_analysis": "The distractors misattribute the use of mutexes to other ATT&CK tactics like Persistence, Collection, or Discovery, demonstrating a lack of understanding of how mutexes contribute to evading defenses.",
        "analogy": "Hiding in a crowd by blending in (preventing multiple instances from standing out) is a form of evasion, similar to how mutexes help malware hide."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "MITRE_ATTACK_FRAMEWORK",
        "DEFENSE_EVASION",
        "MUTEX_BASICS"
      ]
    },
    {
      "question_text": "In the context of incident response, what is a key challenge when dealing with malware that dynamically generates mutex names?",
      "correct_answer": "It makes it difficult to use static mutex names as reliable Indicators of Compromise (IOCs) across different infections.",
      "distractors": [
        {
          "text": "Dynamically generated mutexes consume excessive system memory.",
          "misconception": "Targets [resource consumption confusion]: Assumes dynamic generation inherently leads to high memory usage."
        },
        {
          "text": "The operating system prevents the creation of dynamically generated mutexes.",
          "misconception": "Targets [OS restriction confusion]: Incorrectly believes the OS blocks dynamic mutex naming."
        },
        {
          "text": "Mutexes generated dynamically are automatically deleted upon process termination.",
          "misconception": "Targets [persistence confusion]: Assumes dynamic names imply lack of persistence, contrary to malware intent."
        }
      ],
      "detailed_explanation": {
        "core_logic": "When malware generates mutex names using algorithms or system-specific data, each instance might create a unique name. This variability hinders the use of simple, static mutex names as IOCs because a signature for one infection might not match another, requiring more sophisticated detection methods.",
        "distractor_analysis": "The distractors propose issues related to memory consumption, OS restrictions, or automatic deletion, which are not the primary challenges posed by dynamically generated mutex names for IOC purposes.",
        "analogy": "Trying to track a suspect who constantly changes their disguise (dynamic mutex name) is harder than tracking someone who always wears the same hat (static mutex name)."
      },
      "code_snippets": [],
      "difficulty": "master",
      "question_type": "analysis",
      "bloom_level": "evaluate",
      "prerequisites": [
        "INDICATORS_OF_COMPROMISE",
        "MALWARE_OBFUSCATION",
        "MUTEX_BASICS"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Mutex and Named Object Creation 002_Incident Response And Forensics best practices",
    "latency_ms": 24038.39
  },
  "timestamp": "2026-01-18T14:07:05.240390",
  "_av_safe_encoded": true,
  "_encoding_note": "Educational content encoded with HTML entities to prevent antivirus false positives. Content renders normally in Anki."
}