{
  "topic_title": "SSDT (System Service Descriptor Table) Hooking",
  "category": "002_Incident Response And Forensics - 007_Malware Analysis",
  "flashcards": [
    {
      "question_text": "What is the primary function of the System Service Descriptor Table (SSDT) in Windows?",
      "correct_answer": "It maps system service numbers (SSNs) to their corresponding kernel functions.",
      "distractors": [
        {
          "text": "It manages user-mode application permissions.",
          "misconception": "Targets [scope confusion]: Confuses kernel-level system calls with user-mode permissions."
        },
        {
          "text": "It encrypts data transmitted between kernel and user mode.",
          "misconception": "Targets [function confusion]: Attributes cryptographic functions to a system call table."
        },
        {
          "text": "It logs all network traffic originating from the system.",
          "misconception": "Targets [domain confusion]: Attributes network logging functions to the SSDT."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The SSDT acts as a lookup table, translating system service numbers (SSNs) requested by user-mode applications into the actual kernel function addresses that execute the requested operations.",
        "distractor_analysis": "The distractors incorrectly assign roles related to user-mode permissions, encryption, and network logging, which are outside the SSDT's core function of mapping system calls.",
        "analogy": "Think of the SSDT as a phone book for the operating system: you look up a service name (SSN) and it tells you the exact phone number (kernel function address) to dial."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "WINDOWS_KERNEL_BASICS",
        "SYSTEM_CALLS"
      ]
    },
    {
      "question_text": "How does SSDT hooking allow malware to intercept system calls?",
      "correct_answer": "By modifying the SSDT entries to point to malicious code instead of the original kernel functions.",
      "distractors": [
        {
          "text": "By altering the user-mode application's memory space.",
          "misconception": "Targets [location confusion]: Assumes hooking occurs solely in user-mode, not kernel."
        },
        {
          "text": "By disabling the system's firewall before execution.",
          "misconception": "Targets [defense mechanism confusion]: Attributes interception to disabling security controls."
        },
        {
          "text": "By injecting code into legitimate system processes.",
          "misconception": "Targets [mechanism confusion]: While related, this is a broader technique, not specific to SSDT modification."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SSDT hooking redirects system calls by overwriting the function pointers within the SSDT. When a user-mode application makes a system call, it's directed to the attacker's code first, allowing interception.",
        "distractor_analysis": "The distractors suggest user-mode manipulation, disabling defenses, or general code injection, which are distinct from the specific kernel-level modification of the SSDT.",
        "analogy": "It's like changing the destination address on a package's shipping label just before it leaves the sorting facility, rerouting it to an unintended recipient."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "attack",
      "bloom_level": "apply",
      "prerequisites": [
        "SSDT_BASICS",
        "KERNEL_MODE_EXECUTION"
      ]
    },
    {
      "question_text": "What is the typical calculation used to find a kernel function's address from the SSDT?",
      "correct_answer": "RoutineAddress = SSDTAddress + (Offset >>> 4), where Offset is derived from SSDTAddress + 4 * SSN.",
      "distractors": [
        {
          "text": "RoutineAddress = SSDTAddress - (Offset << 4)",
          "misconception": "Targets [arithmetic error]: Uses incorrect bitwise operations and subtraction."
        },
        {
          "text": "RoutineAddress = SSDTAddress + Offset, where Offset is directly the SSN.",
          "misconception": "Targets [offset calculation error]: Simplifies the offset derivation and ignores bit shifting."
        },
        {
          "text": "RoutineAddress = UserModeAddress + 4 * SSN",
          "misconception": "Targets [address space confusion]: Incorrectly uses a user-mode address as the base."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The SSDT stores offsets. The kernel calculates the routine address by first finding the offset using <code>SSDTAddress + 4 * SSN</code> and then applying a bit shift: <code>SSDTAddress + (Offset &gt;&gt;&gt; 4)</code> to get the final function pointer.",
        "distractor_analysis": "Distractors present incorrect arithmetic operations, incorrect offset calculations, or use the wrong base address, failing to replicate the precise SSDT address resolution mechanism.",
        "analogy": "It's like finding a specific book on a library shelf: you first find the shelf number (offset calculation), then you find the exact book position on that shelf (bit shift)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "SSDT_BASICS",
        "MEMORY_ADDRESSING"
      ]
    },
    {
      "question_text": "Why is SSDT hooking considered a technique for defense evasion?",
      "correct_answer": "It allows malicious code to execute under the guise of legitimate system operations, making it harder for security software to detect.",
      "distractors": [
        {
          "text": "It directly disables antivirus software signatures.",
          "misconception": "Targets [mechanism confusion]: Assumes direct disabling rather than stealthy execution."
        },
        {
          "text": "It encrypts the malware payload to hide its presence.",
          "misconception": "Targets [function confusion]: Attributes encryption, not execution flow hijacking, to evasion."
        },
        {
          "text": "It creates new, undetectable processes on the system.",
          "misconception": "Targets [process management confusion]: Focuses on process creation, not function interception."
        }
      ],
      "detailed_explanation": {
        "core_logic": "By intercepting system calls, malware can perform malicious actions while appearing to execute legitimate kernel functions. This masks its true behavior, evading signature-based detection and behavioral analysis.",
        "distractor_analysis": "The distractors suggest direct disabling of security tools, payload encryption, or process creation, which are different evasion tactics than the stealthy execution provided by SSDT hooking.",
        "analogy": "It's like a spy wearing a uniform of the organization they are infiltrating; their presence is legitimate-looking, masking their true hostile intent."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "analyze",
      "prerequisites": [
        "SSDT_HOOKING",
        "MALWARE_EVASION"
      ]
    },
    {
      "question_text": "What is the 'Shadow SSDT' (KeServiceDescriptorTableShadow)?",
      "correct_answer": "A secondary SSDT used primarily by the Win32k.sys driver, often targeted for hooking by user-mode malware.",
      "distractors": [
        {
          "text": "A backup copy of the main SSDT for recovery purposes.",
          "misconception": "Targets [purpose confusion]: Assumes a backup/recovery role instead of a functional one."
        },
        {
          "text": "An older, deprecated version of the SSDT.",
          "misconception": "Targets [version confusion]: Incorrectly labels it as obsolete."
        },
        {
          "text": "A table used exclusively for network-related system calls.",
          "misconception": "Targets [scope confusion]: Attributes a specific network function to the Shadow SSDT."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The Shadow SSDT, <code>KeServiceDescriptorTableShadow</code>, is a distinct table that manages system calls for the Win32k.sys component, which handles graphical user interface elements. It's often targeted because it's accessible from user-mode.",
        "distractor_analysis": "The distractors misrepresent the Shadow SSDT's purpose as a backup, an outdated version, or a network-specific table, failing to identify its role with Win32k.sys.",
        "analogy": "If the main SSDT is the 'public services' directory, the Shadow SSDT is like a specialized 'graphics department' directory within the same organization."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SSDT_BASICS",
        "WINDOWS_KERNEL_COMPONENTS"
      ]
    },
    {
      "question_text": "Which of the following is a common forensic challenge when analyzing a system compromised by SSDT hooking?",
      "correct_answer": "The original system call behavior is altered, making it difficult to distinguish legitimate activity from malicious actions.",
      "distractors": [
        {
          "text": "The malware always leaves easily identifiable registry keys.",
          "misconception": "Targets [persistence mechanism confusion]: Assumes malware relies solely on registry keys for persistence."
        },
        {
          "text": "All compromised files are automatically quarantined by the OS.",
          "misconception": "Targets [OS security feature confusion]: Overestimates built-in OS protection against advanced techniques."
        },
        {
          "text": "The malware's code is always stored in a predictable memory location.",
          "misconception": "Targets [memory management confusion]: Assumes static memory allocation for malware payloads."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SSDT hooking fundamentally alters the system's call flow. Forensic analysts must carefully examine execution paths and system behavior to differentiate between normal operations and malware-driven actions, which is challenging.",
        "distractor_analysis": "The distractors suggest simplistic malware behaviors like predictable registry keys, automatic OS quarantining, or static memory locations, which do not reflect the complexities introduced by SSDT hooking.",
        "analogy": "It's like trying to reconstruct a conversation where someone has secretly replaced key words with their own; the flow seems normal, but the meaning is distorted."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "FORENSIC_ANALYSIS",
        "SSDT_HOOKING"
      ]
    },
    {
      "question_text": "What is the role of the <code>NtLoadDriver</code> system call in the context of SSDT hooking?",
      "correct_answer": "It is a common target for hooking because it allows the malware to load its own kernel-mode driver.",
      "distractors": [
        {
          "text": "It is used to terminate malicious processes.",
          "misconception": "Targets [functionality confusion]: Attributes a defensive function to a potentially exploitable call."
        },
        {
          "text": "It is responsible for encrypting user data.",
          "misconception": "Targets [domain confusion]: Assigns cryptographic functions to driver loading."
        },
        {
          "text": "It establishes network connections for the system.",
          "misconception": "Targets [scope confusion]: Attributes network communication functions to driver loading."
        }
      ],
      "detailed_explanation": {
        "core_logic": "<code>NtLoadDriver</code> is a critical system call that allows the loading of kernel-mode drivers. Malware hooks this call to load its own malicious driver, gaining elevated privileges and deeper system access.",
        "distractor_analysis": "The distractors incorrectly describe <code>NtLoadDriver</code> as a process termination, data encryption, or network establishment function, failing to recognize its role in kernel driver loading.",
        "analogy": "Hooking <code>NtLoadDriver</code> is like tricking the security guard at the gate into letting you bring in a large, unauthorized package (your malicious driver) into the facility."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SSDT_HOOKING",
        "KERNEL_DRIVERS"
      ]
    },
    {
      "question_text": "How can security tools like Volatility detect SSDT hooks?",
      "correct_answer": "By comparing the addresses in the active SSDT with known-good addresses derived from the kernel image or symbols.",
      "distractors": [
        {
          "text": "By scanning the system for suspicious file names.",
          "misconception": "Targets [detection method confusion]: Relies on file-based detection, not memory analysis."
        },
        {
          "text": "By monitoring network traffic for unusual patterns.",
          "misconception": "Targets [traffic analysis confusion]: Focuses on network, not kernel memory, anomalies."
        },
        {
          "text": "By checking the integrity of user-mode processes only.",
          "misconception": "Targets [scope confusion]: Ignores kernel-level hooks by focusing only on user-mode."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Memory forensics tools like Volatility can analyze the kernel's memory space. They identify SSDT hooks by comparing the function pointers listed in the SSDT against a baseline of legitimate addresses, flagging discrepancies.",
        "distractor_analysis": "The distractors propose detection methods like file scanning, network monitoring, or user-mode checks, which are insufficient for detecting kernel-level SSDT hooks.",
        "analogy": "It's like a librarian checking the catalog against the actual books on the shelves; if a book's location in the catalog doesn't match its physical location, something is amiss."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "analyze",
      "prerequisites": [
        "MEMORY_FORENSICS",
        "SSDT_HOOKING"
      ]
    },
    {
      "question_text": "What is the significance of <code>nt&#33;KiServiceTable</code> in relation to the SSDT?",
      "correct_answer": "<code>nt&#33;KiServiceTable</code> is often used as a pointer to the base address of the main SSDT within the Windows kernel.",
      "distractors": [
        {
          "text": "It represents the user-mode entry point for all system calls.",
          "misconception": "Targets [address space confusion]: Incorrectly places it in user-mode."
        },
        {
          "text": "It is a table used for managing hardware interrupts.",
          "misconception": "Targets [function confusion]: Attributes interrupt handling functions to it."
        },
        {
          "text": "It is a deprecated function for loading drivers.",
          "misconception": "Targets [obsolescence confusion]: Incorrectly labels it as outdated."
        }
      ],
      "detailed_explanation": {
        "core_logic": "<code>nt&#33;KiServiceTable</code> is a kernel symbol that typically points to the <code>ServiceTableBase</code> member of the main <code>KSERVICE_TABLE_DESCRIPTOR</code>, effectively serving as the starting address for the primary SSDT.",
        "distractor_analysis": "The distractors incorrectly identify <code>nt&#33;KiServiceTable</code> as a user-mode entry point, an interrupt management table, or a deprecated driver loading function.",
        "analogy": "If the SSDT is the entire phone book, <code>nt&#33;KiServiceTable</code> is like the first page number that tells you where the 'A' section begins."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SSDT_BASICS",
        "WINDOWS_KERNEL_SYMBOLS"
      ]
    },
    {
      "question_text": "Why might an attacker choose to hook <code>NtCreateFile</code> via SSDT?",
      "correct_answer": "To intercept and potentially modify file operations, such as creating, reading, or writing files, to exfiltrate data or plant malicious files.",
      "distractors": [
        {
          "text": "To prevent the operating system from booting up.",
          "misconception": "Targets [impact confusion]: Overstates the impact of hooking a single file operation call."
        },
        {
          "text": "To disable all network communication on the system.",
          "misconception": "Targets [scope confusion]: Attributes network-wide impact to a file operation hook."
        },
        {
          "text": "To increase the system's overall processing speed.",
          "misconception": "Targets [performance confusion]: Assumes a performance enhancement role for a file operation hook."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Hooking <code>NtCreateFile</code> allows an attacker to monitor, block, or alter any file access operations. This is crucial for activities like data exfiltration, planting backdoors, or preventing legitimate file access.",
        "distractor_analysis": "The distractors suggest extreme system disruption (preventing boot), network-wide impact, or performance enhancement, which are not the direct or typical outcomes of hooking <code>NtCreateFile</code>.",
        "analogy": "Hooking <code>NtCreateFile</code> is like intercepting every request to open, save, or delete a document in an office, allowing you to read, alter, or block any document action."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "attack",
      "bloom_level": "apply",
      "prerequisites": [
        "SSDT_HOOKING",
        "FILE_SYSTEM_OPERATIONS"
      ]
    },
    {
      "question_text": "What is a key difference between SSDT hooking and user-mode hooking techniques?",
      "correct_answer": "SSDT hooking operates in the kernel mode, providing deeper system access and stealth, while user-mode hooking is confined to the application's process space.",
      "distractors": [
        {
          "text": "User-mode hooking is always faster than SSDT hooking.",
          "misconception": "Targets [performance confusion]: Assumes user-mode is inherently faster for all hooking scenarios."
        },
        {
          "text": "SSDT hooking requires administrator privileges, while user-mode hooking does not.",
          "misconception": "Targets [privilege confusion]: Overlooks that kernel modification often requires elevated privileges regardless of hooking method."
        },
        {
          "text": "User-mode hooks are easier to detect by antivirus software.",
          "misconception": "Targets [detection confusion]: While often true, it's not the fundamental difference in operation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "SSDT hooking modifies kernel structures, granting it pervasive control and making it harder to detect. User-mode hooking is limited to the process it targets, offering less system-wide impact and often being more visible.",
        "distractor_analysis": "The distractors focus on speed, privilege requirements, or detection ease, which are secondary characteristics, rather than the fundamental difference in operating context (kernel vs. user mode).",
        "analogy": "SSDT hooking is like altering the main power grid controls (kernel), while user-mode hooking is like changing the wiring within a single room (process)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "SSDT_HOOKING",
        "USER_MODE_HOOKING",
        "KERNEL_VS_USER_MODE"
      ]
    },
    {
      "question_text": "What is the purpose of the <code>ArgumentTable</code> within the <code>KSYSTEM_SERVICE_TABLE</code> structure?",
      "correct_answer": "It provides information about the number and types of arguments expected by each system service.",
      "distractors": [
        {
          "text": "It stores the actual code for each system service.",
          "misconception": "Targets [content confusion]: Confuses argument information with function code."
        },
        {
          "text": "It defines the security permissions for accessing system services.",
          "misconception": "Targets [security confusion]: Attributes permission management to argument handling."
        },
        {
          "text": "It logs the execution history of each system service.",
          "misconception": "Targets [logging confusion]: Attributes logging functions to argument definition."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>ArgumentTable</code> is essential for the kernel to correctly pass parameters to system service routines. It specifies how many arguments a service expects and their data types, ensuring proper function invocation.",
        "distractor_analysis": "The distractors incorrectly describe the <code>ArgumentTable</code> as containing function code, security permissions, or execution logs, rather than information about service arguments.",
        "analogy": "It's like a user manual for each function, detailing exactly what information (arguments) you need to provide for it to work correctly."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "SSDT_BASICS",
        "SYSTEM_CALL_PARAMETERS"
      ]
    },
    {
      "question_text": "In the context of incident response, what is a critical first step after detecting potential SSDT hooking?",
      "correct_answer": "Preserve the system's memory for forensic analysis before making any changes.",
      "distractors": [
        {
          "text": "Immediately reboot the system to clear the hooks.",
          "misconception": "Targets [containment/eradication confusion]: Recommends an action that destroys evidence."
        },
        {
          "text": "Wipe the affected hard drive to remove the malware.",
          "misconception": "Targets [evidence preservation error]: Recommends data destruction instead of preservation."
        },
        {
          "text": "Isolate the system from the network to prevent spread.",
          "misconception": "Targets [containment vs. analysis confusion]: While important, evidence preservation should precede or be concurrent with isolation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Memory contains the live state of the kernel, including active hooks. Capturing memory first is crucial because rebooting or modifying the system can erase this volatile evidence, hindering analysis.",
        "distractor_analysis": "The distractors suggest actions that destroy evidence (reboot, wipe) or prioritize network isolation over immediate memory acquisition, which are detrimental to forensic investigation.",
        "analogy": "Detecting a crime scene: you wouldn't immediately clean up or move evidence; you'd first document and collect it before taking further action."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "INCIDENT_RESPONSE_PHASES",
        "MEMORY_FORENSICS",
        "SSDT_HOOKING"
      ]
    },
    {
      "question_text": "How does SSDT hooking relate to the MITRE ATT&CK technique T1574.013 (KernelCallbackTable)?",
      "correct_answer": "Both techniques involve hijacking execution flow within the Windows kernel, though SSDT hooking targets system call dispatching, while KernelCallbackTable targets specific callback function pointers.",
      "distractors": [
        {
          "text": "They are unrelated techniques targeting different parts of the OS.",
          "misconception": "Targets [relationship confusion]: Denies any connection between kernel-level hijacking techniques."
        },
        {
          "text": "SSDT hooking is a specific implementation of KernelCallbackTable hijacking.",
          "misconception": "Targets [hierarchy confusion]: Incorrectly positions SSDT hooking as a sub-technique of KernelCallbackTable."
        },
        {
          "text": "KernelCallbackTable hijacking is used to bypass SSDT hooks.",
          "misconception": "Targets [dependency confusion]: Assumes one technique is solely for bypassing the other."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Both SSDT hooking and KernelCallbackTable manipulation are kernel-mode execution hijacking techniques. SSDT focuses on redirecting system calls, while KernelCallbackTable involves altering pointers within the PEB's callback tables, often for GUI functions.",
        "distractor_analysis": "The distractors incorrectly state the techniques are unrelated, misdefine their hierarchical relationship, or wrongly suggest one is solely for bypassing the other.",
        "analogy": "Both are ways to divert traffic on a highway system. SSDT hooking reroutes the main highway exits, while KernelCallbackTable hijacking redirects specific service roads branching off."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "SSDT_HOOKING",
        "MITRE_ATTACK_T1574",
        "KERNEL_CALLBACK_TABLE"
      ]
    },
    {
      "question_text": "What is a potential indicator of SSDT hooking during a live system analysis?",
      "correct_answer": "Discrepancies between the expected kernel function addresses and the addresses resolved via system service numbers (SSNs).",
      "distractors": [
        {
          "text": "Unusually high CPU usage by legitimate system processes.",
          "misconception": "Targets [symptom confusion]: Attributes a general symptom to a specific cause without direct link."
        },
        {
          "text": "The presence of unsigned drivers loaded into the kernel.",
          "misconception": "Targets [indicator confusion]: While suspicious, not all unsigned drivers indicate SSDT hooking."
        },
        {
          "text": "An excessive number of open network connections.",
          "misconception": "Targets [symptom confusion]: Focuses on network activity, not kernel function integrity."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The core of SSDT hooking involves redirecting kernel function pointers. Therefore, a primary indicator is finding that a system service number (SSN) resolves to an unexpected or malicious address, deviating from the expected kernel image.",
        "distractor_analysis": "The distractors point to general system anomalies (high CPU, unsigned drivers, network connections) that could indicate various issues, but not specifically SSDT hooking as directly as address discrepancies.",
        "analogy": "It's like checking a map: if following a road on the map leads you to a completely different landmark than expected, you know the map (or the road) has been altered."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "LIVE_ANALYSIS",
        "SSDT_HOOKING",
        "KERNEL_DEBUGGING"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "SSDT (System Service Descriptor Table) Hooking 002_Incident Response And Forensics best practices",
    "latency_ms": 26480.062
  },
  "timestamp": "2026-01-18T14:11:10.499175",
  "_av_safe_encoded": true,
  "_encoding_note": "Educational content encoded with HTML entities to prevent antivirus false positives. Content renders normally in Anki."
}