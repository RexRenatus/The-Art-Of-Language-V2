{
  "topic_title": "Inline Hooking",
  "category": "002_Incident Response And Forensics - 007_Malware Analysis",
  "flashcards": [
    {
      "question_text": "What is the primary mechanism by which inline hooking allows an attacker to redirect API calls within a process?",
      "correct_answer": "Modifying the Import Address Table (IAT) to point to malicious code.",
      "distractors": [
        {
          "text": "Overwriting the Global Descriptor Table (GDT) to intercept system calls.",
          "misconception": "Targets [component confusion]: Confuses IAT with GDT, a lower-level system structure."
        },
        {
          "text": "Injecting shellcode directly into the process's executable memory.",
          "misconception": "Targets [technique confusion]: Shellcode injection is a method of execution, not specifically API redirection via hooking."
        },
        {
          "text": "Altering the process's page table entries to redirect memory access.",
          "misconception": "Targets [abstraction level confusion]: Page table manipulation is a lower-level memory management technique, not direct API call redirection."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Inline hooking works by modifying the IAT, which stores pointers to imported API functions. By overwriting these pointers with the address of malicious code, the attacker redirects API calls for execution and privilege escalation.",
        "distractor_analysis": "The distractors confuse IAT with other system components (GDT, page tables) or related but distinct techniques like shellcode injection.",
        "analogy": "Imagine a phone book where someone has secretly changed the numbers for important contacts to their own number. When you try to call a contact, you reach the imposter instead of the intended person."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PROCESS_INJECTION",
        "API_HOOKING_BASICS"
      ]
    },
    {
      "question_text": "According to MITRE ATT&CK, which tactic is most commonly associated with the 'Hooking' technique (T0874)?",
      "correct_answer": "Execution and Privilege Escalation",
      "distractors": [
        {
          "text": "Reconnaissance and Initial Access",
          "misconception": "Targets [tactic confusion]: Associates hooking with pre-exploitation phases instead of post-exploitation actions."
        },
        {
          "text": "Defense Evasion and Persistence",
          "misconception": "Targets [tactic overlap confusion]: While hooking can aid evasion/persistence, its primary function is execution/escalation."
        },
        {
          "text": "Collection and Command and Control",
          "misconception": "Targets [tactic misapplication]: Hooking is not directly used for data exfiltration or C2 communication."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Hooking is primarily used to redirect API calls, which enables adversaries to execute malicious code and gain elevated privileges within a compromised system, aligning with the Execution and Privilege Escalation tactics.",
        "distractor_analysis": "Distractors incorrectly map hooking to unrelated ATT&CK tactics like Reconnaissance, Initial Access, Collection, or Command and Control.",
        "analogy": "Think of hooking as a detour sign on a highway. It redirects traffic (API calls) to a different destination (malicious code) to achieve a specific goal (execution or gaining more power)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "MITRE_ATTACK_FRAMEWORK",
        "TACTICS_TECHNIQUES"
      ]
    },
    {
      "question_text": "In the context of ICS (Industrial Control Systems), how might an adversary use hooking, as described by MITRE ATT&CK T0874?",
      "correct_answer": "By modifying Import Address Tables (IATs) to hook specific APIs used to open project files.",
      "distractors": [
        {
          "text": "By directly altering the PLC's firmware to change operational logic.",
          "misconception": "Targets [technique mismatch]: Direct PLC firmware alteration is a different attack vector than API hooking."
        },
        {
          "text": "By intercepting network traffic between HMIs and RTUs using packet sniffing.",
          "misconception": "Targets [method confusion]: Packet sniffing is network-level interception, not process-level API hooking."
        },
        {
          "text": "By exploiting vulnerabilities in the SCADA system's web interface.",
          "misconception": "Targets [attack vector confusion]: Web interface exploits are distinct from in-process API hooking."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Adversaries use hooking in ICS by modifying Import Address Tables (IATs) to redirect API calls, such as those used for opening project files, as seen in the Stuxnet example, enabling malicious code execution.",
        "distractor_analysis": "Distractors propose alternative ICS attack methods (PLC firmware modification, network sniffing, web exploits) that are not related to API hooking.",
        "analogy": "In an ICS environment, hooking is like a malicious actor intercepting the instructions given to a machine operator (API calls) and subtly changing them to make the operator perform unintended actions, like opening a dangerous file."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "ICS_SECURITY",
        "MITRE_ATTACK_T0874"
      ]
    },
    {
      "question_text": "Which of the following is a common mitigation strategy against inline hooking techniques?",
      "correct_answer": "Restricting the use of untrusted or unknown libraries (DLLs).",
      "distractors": [
        {
          "text": "Implementing full disk encryption on all endpoints.",
          "misconception": "Targets [mitigation scope confusion]: FDE protects data at rest, not process behavior or API calls."
        },
        {
          "text": "Regularly updating antivirus signatures to detect known malware.",
          "misconception": "Targets [detection limitation]: Signature-based AV may miss novel or fileless hooking techniques."
        },
        {
          "text": "Enforcing strong password policies for user accounts.",
          "misconception": "Targets [vulnerability mismatch]: Password policies do not directly prevent in-process hooking."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Restricting untrusted libraries is a key mitigation because hooking often involves injecting or modifying DLLs. By controlling which libraries can be loaded, organizations reduce the attack surface for such techniques.",
        "distractor_analysis": "The distractors suggest unrelated security controls: FDE, signature-based AV, and password policies, which do not directly address the mechanism of inline hooking.",
        "analogy": "It's like securing your house by only allowing trusted contractors to bring in new tools and materials, preventing unknown or potentially dangerous items from being introduced."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "MALWARE_MITIGATION",
        "DLL_SECURITY"
      ]
    },
    {
      "question_text": "How does IAT hooking differ from inline hooking in terms of code modification?",
      "correct_answer": "IAT hooking modifies the Import Address Table, while inline hooking modifies the actual function prologue in the target code.",
      "distractors": [
        {
          "text": "IAT hooking modifies the function prologue, while inline hooking modifies the IAT.",
          "misconception": "Targets [technique reversal]: Incorrectly swaps the primary modification points of the two techniques."
        },
        {
          "text": "Both IAT hooking and inline hooking modify the Global Descriptor Table (GDT).",
          "misconception": "Targets [component confusion]: Incorrectly identifies GDT as the target for both hooking methods."
        },
        {
          "text": "IAT hooking intercepts system calls, while inline hooking intercepts API calls.",
          "misconception": "Targets [scope confusion]: Both techniques primarily deal with API calls; system calls are a different layer."
        }
      ],
      "detailed_explanation": {
        "core_logic": "IAT hooking redirects calls by altering the Import Address Table, whereas inline hooking directly overwrites the beginning of the target function's code (the prologue) with a jump instruction to malicious code.",
        "distractor_analysis": "Distractors incorrectly swap the modification targets, confuse the techniques with GDT modification, or misrepresent the scope of intercepted calls.",
        "analogy": "IAT hooking is like changing the address in a directory listing for a service. Inline hooking is like physically altering the entrance to the service building itself to redirect visitors."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "API_HOOKING_BASICS",
        "IAT_HOOKING"
      ]
    },
    {
      "question_text": "What is a potential challenge during malware analysis when dealing with inline hooking?",
      "correct_answer": "The analysis environment might not accurately reflect the hooking behavior due to differences in system configurations or loaded modules.",
      "distractors": [
        {
          "text": "Hooking techniques always leave easily detectable digital signatures.",
          "misconception": "Targets [detection assumption]: Assumes all hooking is easily signatured, ignoring advanced or fileless methods."
        },
        {
          "text": "Hooked functions always crash the process, simplifying analysis.",
          "misconception": "Targets [behavioral assumption]: Hooking is designed to be stealthy; crashes indicate failure or specific types of errors, not typical behavior."
        },
        {
          "text": "Inline hooking only affects the operating system kernel, not user-mode applications.",
          "misconception": "Targets [scope confusion]: Inline hooking primarily targets user-mode API calls."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Malware analysis faces challenges because hooking behavior is highly dependent on the target environment. Analysis tools might not load the same modules or have the same configurations, leading to missed or misinterpreted hooking actions.",
        "distractor_analysis": "Distractors make incorrect assumptions about signatured detection, process stability, and the scope (kernel vs. user-mode) of inline hooking.",
        "analogy": "Trying to understand a magic trick by watching it in a different theater with different lighting and props â€“ the trick might not work the same way, or you might miss crucial details."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "MALWARE_ANALYSIS",
        "DYNAMIC_ANALYSIS"
      ]
    },
    {
      "question_text": "Why might an attacker use inline hooking for privilege escalation?",
      "correct_answer": "By intercepting and modifying calls to security-related APIs (e.g., those handling user privileges), the attacker can trick the system into granting higher permissions.",
      "distractors": [
        {
          "text": "To bypass network firewalls by redirecting traffic through a compromised proxy.",
          "misconception": "Targets [technique misapplication]: Network traffic redirection is not the primary goal of privilege escalation via hooking."
        },
        {
          "text": "To encrypt sensitive data before it can be exfiltrated by legitimate processes.",
          "misconception": "Targets [purpose confusion]: Encryption is for confidentiality, not directly for gaining privileges."
        },
        {
          "text": "To disable logging mechanisms and hide their presence.",
          "misconception": "Targets [defense evasion confusion]: While related, disabling logs is defense evasion, not the direct mechanism for privilege escalation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Attackers use inline hooking for privilege escalation because it allows them to intercept and manipulate calls to critical system APIs that manage permissions. By altering the parameters or return values of these calls, they can trick the OS into granting elevated privileges.",
        "distractor_analysis": "Distractors suggest unrelated goals like network traffic manipulation, data encryption, or log disabling, which are distinct from the core mechanism of privilege escalation through API manipulation.",
        "analogy": "It's like an employee intercepting a request for a manager's signature on an expense report and altering it to approve a much larger, unauthorized amount."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "PRIVILEGE_ESCALATION",
        "API_HOOKING_BASICS"
      ]
    },
    {
      "question_text": "What is the fundamental difference between inline hooking and detouring API calls?",
      "correct_answer": "Inline hooking directly overwrites the function's prologue, while detouring typically involves patching the IAT or using trampolines.",
      "distractors": [
        {
          "text": "Inline hooking modifies the IAT, while detouring overwrites the function prologue.",
          "misconception": "Targets [technique reversal]: Incorrectly assigns the primary modification method to the wrong technique."
        },
        {
          "text": "Inline hooking is used for defense, while detouring is used for attacks.",
          "misconception": "Targets [intent confusion]: Both techniques can be used for both offensive and defensive purposes."
        },
        {
          "text": "Detouring involves code injection, while inline hooking does not.",
          "misconception": "Targets [process confusion]: Both techniques often rely on some form of code injection or modification."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Inline hooking fundamentally alters the beginning of the target function's code (prologue) to redirect execution. Detouring is a broader term that often involves modifying the Import Address Table (IAT) or using trampoline functions to redirect calls.",
        "distractor_analysis": "Distractors incorrectly swap the core mechanisms, assign specific intents (attack/defense), or misrepresent the role of code injection in these techniques.",
        "analogy": "Inline hooking is like physically blocking the main entrance to a building and forcing everyone through a side door. Detouring is a broader concept that could involve changing the address in a directory (IAT) or setting up a temporary redirection point (trampoline)."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "API_HOOKING_BASICS",
        "IAT_HOOKING"
      ]
    },
    {
      "question_text": "Consider a scenario where a piece of malware attempts to hook the <code>CreateProcess</code> API. What is a likely objective of this action?",
      "correct_answer": "To monitor or modify newly created processes, potentially to inject further malicious code or prevent detection.",
      "distractors": [
        {
          "text": "To increase the system's overall processing speed by optimizing API calls.",
          "misconception": "Targets [malicious intent confusion]: Assumes a performance enhancement goal, ignoring the malicious context."
        },
        {
          "text": "To ensure that all network connections are properly logged by the system.",
          "misconception": "Targets [functionality confusion]: `CreateProcess` is for process creation, not network logging."
        },
        {
          "text": "To prevent the operating system from loading any further dynamic-link libraries (DLLs).",
          "misconception": "Targets [API scope confusion]: `CreateProcess` does not control DLL loading directly; other mechanisms are involved."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Hooking the <code>CreateProcess</code> API allows malware to intercept the creation of new processes. This enables the malware to monitor, modify, or inject code into these new processes, thereby furthering its objectives like evasion or lateral movement.",
        "distractor_analysis": "Distractors propose unrelated or counter-intuitive goals: performance enhancement, network logging, or blocking DLL loading, none of which align with the typical malicious use of hooking <code>CreateProcess</code>.",
        "analogy": "It's like a security guard at a building's entrance who checks everyone coming in. The malware wants to be that guard to inspect, modify, or even replace anyone trying to enter the system."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "WINDOWS_APIS",
        "MALWARE_BEHAVIORS"
      ]
    },
    {
      "question_text": "What is the primary risk associated with inline hooking from a system integrity perspective?",
      "correct_answer": "It undermines the integrity of system calls and application behavior by allowing unauthorized code execution.",
      "distractors": [
        {
          "text": "It increases the likelihood of buffer overflow vulnerabilities.",
          "misconception": "Targets [vulnerability confusion]: Hooking is a technique, not a direct cause of buffer overflows, though it can exploit them."
        },
        {
          "text": "It requires excessive system memory, leading to performance degradation.",
          "misconception": "Targets [resource confusion]: While some hooking methods might use memory, the primary risk is integrity, not necessarily performance."
        },
        {
          "text": "It makes it impossible to perform regular software updates.",
          "misconception": "Targets [operational impact confusion]: Hooking doesn't inherently block software updates, though it can interfere with their execution or integrity checks."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Inline hooking fundamentally compromises system integrity because it allows arbitrary code to execute in place of legitimate API functions. This bypasses normal security checks and can lead to unpredictable system behavior or malicious actions.",
        "distractor_analysis": "Distractors focus on secondary or unrelated risks like buffer overflows, memory usage, or update interference, rather than the core integrity violation.",
        "analogy": "It's like allowing someone to tamper with the fundamental rules of a game while it's being played, making the outcome unreliable and potentially unfair."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "SYSTEM_INTEGRITY",
        "API_HOOKING_BASICS"
      ]
    },
    {
      "question_text": "Which of the following detection strategies would be MOST effective against unknown or zero-day inline hooking techniques?",
      "correct_answer": "Behavioral analysis and anomaly detection focusing on unexpected API call sequences or modifications.",
      "distractors": [
        {
          "text": "Scanning for known malware signatures associated with hooking tools.",
          "misconception": "Targets [detection limitation]: Ineffective against unknown or custom hooking implementations."
        },
        {
          "text": "Monitoring network traffic for suspicious data exfiltration patterns.",
          "misconception": "Targets [scope confusion]: Inline hooking is a host-based technique; network monitoring may miss it unless it leads to C2 traffic."
        },
        {
          "text": "Analyzing system logs for specific error messages related to API failures.",
          "misconception": "Targets [indicator confusion]: Hooking aims to be stealthy; it may not always generate obvious API failure errors."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Behavioral analysis and anomaly detection are most effective because they focus on deviations from normal system behavior, such as unexpected API call redirections or modifications, rather than relying on known signatures.",
        "distractor_analysis": "Distractors propose methods that are less effective against novel hooking: signature scanning (misses new threats), network monitoring (host-based issue), and log analysis (may not show clear indicators).",
        "analogy": "Instead of looking for a specific known burglar's face (signature), you're watching for anyone acting suspiciously around your house, like trying to jimmy open a window or alter the locks (behavioral analysis)."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "defense",
      "bloom_level": "evaluate",
      "prerequisites": [
        "THREAT_DETECTION",
        "BEHAVIORAL_ANALYSIS"
      ]
    },
    {
      "question_text": "What is a key characteristic of inline hooking that makes it stealthy?",
      "correct_answer": "It often modifies existing code in memory rather than writing new files, making it harder for file-based detection.",
      "distractors": [
        {
          "text": "It always operates at the kernel level, bypassing user-mode security tools.",
          "misconception": "Targets [scope confusion]: Inline hooking primarily targets user-mode APIs, not exclusively kernel-level operations."
        },
        {
          "text": "It encrypts all its malicious payloads, rendering them unreadable.",
          "misconception": "Targets [technique confusion]: Encryption is a payload protection method, not the core mechanism of hooking's stealth."
        },
        {
          "text": "It relies solely on social engineering to trick users into running it.",
          "misconception": "Targets [delivery confusion]: Social engineering is a delivery method, not the technique's inherent stealth characteristic."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Inline hooking achieves stealth by modifying code directly in a process's memory (in-memory hooking). This avoids writing malicious files to disk, which are more easily scanned by traditional antivirus software.",
        "distractor_analysis": "Distractors incorrectly claim it's always kernel-level, that encryption is the primary stealth factor, or that it relies solely on social engineering for its stealth.",
        "analogy": "It's like a pickpocket who subtly alters the contents of your wallet without you noticing, rather than breaking into your house and leaving obvious signs of entry."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "MALWARE_STEALTH",
        "FILELESS_MALWARE"
      ]
    },
    {
      "question_text": "How can an incident responder use knowledge of inline hooking during forensic analysis?",
      "correct_answer": "By examining process memory for unexpected code modifications or hooks in API function prologues.",
      "distractors": [
        {
          "text": "By checking the system's event logs for records of API calls.",
          "misconception": "Targets [log limitation]: Standard event logs typically don't capture detailed in-memory API modifications."
        },
        {
          "text": "By analyzing network traffic captured during the incident for suspicious destinations.",
          "misconception": "Targets [scope confusion]: Inline hooking is a host-based technique; network analysis might miss the direct evidence."
        },
        {
          "text": "By verifying the integrity of installed software applications.",
          "misconception": "Targets [analysis focus confusion]: While software integrity is important, it doesn't directly reveal in-memory hooks."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Forensic analysis involves examining process memory dumps to find evidence of inline hooks. This includes looking for overwritten function prologues or unexpected code segments that redirect API calls, as per NIST SP 800-61 Rev. 2 guidelines for data analysis.",
        "distractor_analysis": "Distractors suggest less direct or ineffective methods: relying solely on event logs, network traffic, or software integrity checks, which don't pinpoint in-memory hooking.",
        "analogy": "It's like a detective searching a crime scene not just for footprints (logs) or getaway vehicles (network traffic), but meticulously examining the victim's belongings for hidden messages or altered items (process memory)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "FORENSIC_ANALYSIS",
        "MEMORY_FORENSICS"
      ]
    },
    {
      "question_text": "What is the role of a 'trampoline' in some hooking implementations, particularly when avoiding direct inline modification?",
      "correct_answer": "It's a small piece of code that restores the original function prologue and then jumps to the original function after the hooked code executes.",
      "distractors": [
        {
          "text": "It's the malicious code that replaces the original API function entirely.",
          "misconception": "Targets [component confusion]: Confuses the trampoline's role (restoration/bridging) with the malicious payload."
        },
        {
          "text": "It's a technique to modify the Import Address Table (IAT) without detection.",
          "misconception": "Targets [technique confusion]: Trampolines are often used *with* inline hooking, not as a method for IAT modification itself."
        },
        {
          "text": "It's a method used to inject the hooking code into the target process.",
          "misconception": "Targets [process confusion]: Code injection is a prerequisite, not the function of the trampoline itself."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A trampoline is essential in certain hooking scenarios (like inline hooking) to ensure that after the malicious code executes, control is safely returned to the original function. It restores the overwritten prologue and then jumps to the remainder of the original function.",
        "distractor_analysis": "Distractors misrepresent the trampoline as the malicious payload, an IAT modification technique, or the code injection mechanism, rather than its role in bridging execution.",
        "analogy": "Imagine a detour around a roadblock. The trampoline is like the temporary road that guides you past the roadblock and then seamlessly rejoins the original highway, allowing traffic to continue."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "API_HOOKING_BASICS",
        "INLINE_HOOKING_DETAILS"
      ]
    },
    {
      "question_text": "How does inline hooking relate to the concept of 'API spoofing'?",
      "correct_answer": "Inline hooking can be used to implement API spoofing by redirecting calls to legitimate APIs to malicious functions that mimic legitimate behavior.",
      "distractors": [
        {
          "text": "API spoofing is a type of inline hooking that only affects network APIs.",
          "misconception": "Targets [scope confusion]: API spoofing is broader than just network APIs and inline hooking is one method to achieve it."
        },
        {
          "text": "Inline hooking is a defense mechanism against API spoofing attacks.",
          "misconception": "Targets [intent confusion]: Inline hooking is typically an offensive technique, not a defense against spoofing."
        },
        {
          "text": "API spoofing involves altering system registry keys, not function calls.",
          "misconception": "Targets [mechanism confusion]: API spoofing primarily involves intercepting or redirecting function calls, not just registry manipulation."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Inline hooking provides a powerful mechanism for API spoofing because it allows an attacker to intercept calls to legitimate APIs and redirect them to malicious functions. These malicious functions can then mimic the expected behavior, deceiving the user or system.",
        "distractor_analysis": "Distractors incorrectly limit API spoofing's scope, mischaracterize inline hooking as defensive, or confuse the mechanism with registry manipulation.",
        "analogy": "API spoofing via inline hooking is like a con artist pretending to be a trusted official. They intercept your request for help from the official and provide you with fake assistance that serves their own hidden agenda."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "API_SPOOFING",
        "API_HOOKING_BASICS"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Inline Hooking 002_Incident Response And Forensics best practices",
    "latency_ms": 24712.643
  },
  "timestamp": "2026-01-18T14:10:59.123064",
  "_av_safe_encoded": true,
  "_encoding_note": "Educational content encoded with HTML entities to prevent antivirus false positives. Content renders normally in Anki."
}