{
  "topic_title": "Export Address Table (EAT)",
  "category": "002_Incident Response And Forensics - 007_Malware Analysis",
  "flashcards": [
    {
      "question_text": "In the context of Windows Portable Executable (PE) file format, what is the primary function of the Export Address Table (EAT)?",
      "correct_answer": "It maps exported function names or ordinals to their memory addresses within a DLL.",
      "distractors": [
        {
          "text": "It lists functions imported by a DLL from other modules.",
          "misconception": "Targets [Import vs. Export confusion]: Confuses the EAT with the Import Address Table (IAT)."
        },
        {
          "text": "It stores the resources embedded within a DLL, such as icons and strings.",
          "misconception": "Targets [Data structure confusion]: Misidentifies EAT as a resource directory."
        },
        {
          "text": "It contains checksums and digital signatures for verifying DLL integrity.",
          "misconception": "Targets [Security feature confusion]: Attributes integrity checks to the EAT instead of digital signatures or checksum fields."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The EAT is crucial because it allows other executables or DLLs to find and call functions exported by a specific DLL, enabling dynamic linking and modularity in Windows applications.",
        "distractor_analysis": "The first distractor incorrectly describes the IAT. The second confuses EAT with the resource directory. The third misattributes integrity verification functions to the EAT.",
        "analogy": "Think of the EAT as a DLL's public phone book, listing the names of services (functions) and their direct phone numbers (memory addresses) so others can reach them."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PE_FILE_FORMAT",
        "DLL_BASICS"
      ]
    },
    {
      "question_text": "How does malware commonly leverage Export Address Table (EAT) hooking for malicious purposes?",
      "correct_answer": "By modifying the EAT to redirect calls to legitimate DLL functions to malicious code, enabling stealthy API monitoring or manipulation.",
      "distractors": [
        {
          "text": "By overwriting the EAT with null pointers to disable critical system functions.",
          "misconception": "Targets [Attack vector misunderstanding]: Assumes disabling functions is the primary EAT hooking goal, rather than redirection."
        },
        {
          "text": "By injecting new entries into the EAT to create backdoor access points.",
          "misconception": "Targets [Mechanism confusion]: Believes malware adds new entries rather than modifying existing ones."
        },
        {
          "text": "By encrypting the EAT to prevent legitimate applications from loading DLLs.",
          "misconception": "Targets [Technique mismatch]: Confuses EAT hooking with encryption-based evasion or denial-of-service."
        }
      ],
      "detailed_explanation": {
        "core_logic": "EAT hooking is a stealthy technique because malware modifies the EAT in memory, redirecting API calls to its own code before the original function is executed, thus avoiding disk-based traces.",
        "distractor_analysis": "The first distractor suggests disabling functions, not redirection. The second incorrectly states malware adds entries. The third confuses EAT hooking with encryption.",
        "analogy": "It's like a malicious postal worker rerouting your mail: instead of delivering a letter to your address, they intercept it and send it to a P.O. box they control, reading or altering its contents."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "EAT_HOOKING",
        "MALWARE_TECHNIQUES"
      ]
    },
    {
      "question_text": "Which of the following is a key characteristic of EAT hooking that makes it a preferred technique for some malware?",
      "correct_answer": "It operates in memory, leaving minimal to no disk-based forensic artifacts.",
      "distractors": [
        {
          "text": "It requires modifying the application's source code before compilation.",
          "misconception": "Targets [Development vs. Runtime confusion]: Confuses runtime hooking with compile-time code modification."
        },
        {
          "text": "It is easily detectable by standard antivirus signature scanning.",
          "misconception": "Targets [Detection method misunderstanding]: Overestimates the effectiveness of signature-based detection against in-memory modifications."
        },
        {
          "text": "It can only be used to hook functions exported by the main executable, not DLLs.",
          "misconception": "Targets [Scope limitation error]: Incorrectly limits EAT hooking to executables and not DLLs."
        }
      ],
      "detailed_explanation": {
        "core_logic": "EAT hooking is favored for its stealth because it manipulates the Export Address Table in the target DLL's memory space, bypassing the need to alter files on disk, which are more easily scanned.",
        "distractor_analysis": "The first distractor wrongly suggests source code modification. The second overstates the ease of signature-based detection. The third incorrectly limits the scope to executables.",
        "analogy": "It's like changing the destination address on a package while it's in transit, rather than repackaging it before it's shipped."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "EAT_HOOKING",
        "FORENSIC_ARTIFACTS"
      ]
    },
    {
      "question_text": "When analyzing a suspicious DLL, what would indicate potential EAT hooking activity?",
      "correct_answer": "Discrepancies between the expected function addresses in the EAT and the actual addresses resolved by the system loader.",
      "distractors": [
        {
          "text": "The DLL's import table contains an unusually high number of entries.",
          "misconception": "Targets [Import vs. Export confusion]: Associates high import counts with EAT hooking, which affects exports."
        },
        {
          "text": "The DLL's file size has been significantly increased.",
          "misconception": "Targets [Disk vs. Memory artifact confusion]: Assumes EAT hooking involves file size changes, when it's primarily in-memory."
        },
        {
          "text": "The DLL fails to load due to missing dependencies.",
          "misconception": "Targets [Loading error confusion]: Associates EAT hooking with load failures, which are typically due to missing imports or corruption."
        }
      ],
      "detailed_explanation": {
        "core_logic": "EAT hooking involves altering the mapping of function names to addresses within the EAT. Therefore, forensic analysis would look for inconsistencies between the expected EAT structure and the resolved function pointers.",
        "distractor_analysis": "The first distractor confuses EAT with IAT. The second incorrectly links EAT hooking to file size changes. The third misattributes load failures to EAT hooking.",
        "analogy": "It's like finding a map where the street names are correct, but the street numbers point to the wrong buildings â€“ indicating someone has tampered with the map's details."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "PE_FILE_FORMAT",
        "MALWARE_ANALYSIS_TECHNIQUES"
      ]
    },
    {
      "question_text": "What is the role of the <code>AddressOfFunctions</code> array within the PE file's Export Directory?",
      "correct_answer": "It contains the Relative Virtual Addresses (RVAs) of the exported functions, or forwarding information.",
      "distractors": [
        {
          "text": "It stores the names of the exported functions.",
          "misconception": "Targets [Array purpose confusion]: Confuses `AddressOfFunctions` with `AddressOfNames`."
        },
        {
          "text": "It holds the ordinal numbers assigned to each exported function.",
          "misconception": "Targets [Array purpose confusion]: Confuses `AddressOfFunctions` with `AddressOfNameOrdinals`."
        },
        {
          "text": "It lists the memory addresses of functions imported from other DLLs.",
          "misconception": "Targets [Export vs. Import confusion]: Describes the Import Address Table (IAT) instead of the EAT's function addresses."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>AddressOfFunctions</code> array is a critical component of the EAT, as it directly maps ordinal numbers or names (via <code>AddressOfNames</code> and <code>AddressOfNameOrdinals</code>) to the actual memory locations of exported functions within the DLL.",
        "distractor_analysis": "The first distractor describes the <code>AddressOfNames</code> array. The second describes the <code>AddressOfNameOrdinals</code> array. The third describes the IAT.",
        "analogy": "This array is like a list of page numbers in a book's index, where each page number tells you exactly where to find the corresponding topic (function)."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PE_FILE_FORMAT",
        "EAT_STRUCTURE"
      ]
    },
    {
      "question_text": "Consider a scenario where a malware analyst observes that calls to <code>MessageBoxA</code> within a target application are being intercepted and modified. Which PE structure is most likely being targeted for hooking?",
      "correct_answer": "The Export Address Table (EAT) of a DLL that exports <code>MessageBoxA</code> (e.g., <code>user32.dll</code>).",
      "distractors": [
        {
          "text": "The Import Address Table (IAT) of the target application.",
          "misconception": "Targets [Import vs. Export confusion]: Assumes hooking targets the application's imports rather than the DLL's exports."
        },
        {
          "text": "The PE Header's Optional Header section.",
          "misconception": "Targets [Structural confusion]: Incorrectly identifies the main PE header as the target for function call interception."
        },
        {
          "text": "The Global Offset Table (GOT) of the target application.",
          "misconception": "Targets [Platform confusion]: Refers to a structure common in ELF binaries (Linux) rather than Windows PE files."
        }
      ],
      "detailed_explanation": {
        "core_logic": "EAT hooking targets the DLL that exports the function. By modifying the EAT of <code>user32.dll</code>, malware can intercept calls to <code>MessageBoxA</code> before they reach the legitimate function, as this table maps exported function names to addresses.",
        "distractor_analysis": "The first distractor confuses EAT with IAT. The second points to a general header section, not the specific table for exports. The third refers to a non-Windows construct.",
        "analogy": "The analyst sees that when someone asks for 'John Smith' (MessageBoxA), they are being directed to a decoy's house (malicious code) instead of John's actual house (legitimate function), and the decoy lives in the 'Community Services Directory' (user32.dll's EAT)."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "scenario",
      "bloom_level": "apply",
      "prerequisites": [
        "EAT_HOOKING",
        "MALWARE_ANALYSIS"
      ]
    },
    {
      "question_text": "What is the significance of the <code>NumberOfNames</code> field in the PE Export Directory?",
      "correct_answer": "It indicates how many exported functions are accessible by their symbolic names, as opposed to just ordinals.",
      "distractors": [
        {
          "text": "It represents the total count of all functions exported by the DLL, by name or ordinal.",
          "misconception": "Targets [Field definition confusion]: Confuses `NumberOfNames` with `NumberOfFunctions`."
        },
        {
          "text": "It specifies the maximum ordinal number used for exported functions.",
          "misconception": "Targets [Field purpose confusion]: Misinterprets `NumberOfNames` as related to the ordinal range."
        },
        {
          "text": "It denotes the number of DLLs that import functions from this module.",
          "misconception": "Targets [Export vs. Import confusion]: Attributes import-related information to an export directory field."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>NumberOfNames</code> field is crucial for efficient lookup of exported functions by name, as it dictates the size of the <code>AddressOfNames</code> array, which the loader iterates through to find a function's corresponding ordinal and then its address.",
        "distractor_analysis": "The first distractor incorrectly equates <code>NumberOfNames</code> with <code>NumberOfFunctions</code>. The second misinterprets its role regarding ordinals. The third confuses export information with import statistics.",
        "analogy": "In a company directory, <code>NumberOfNames</code> tells you how many employees have their names listed, while <code>NumberOfFunctions</code> would tell you the total number of employees, including those only known by an employee ID (ordinal)."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PE_FILE_FORMAT",
        "EAT_STRUCTURE"
      ]
    },
    {
      "question_text": "How does the <code>AddressOfNameOrdinals</code> array relate to the <code>AddressOfFunctions</code> and <code>AddressOfNames</code> arrays in the EAT?",
      "correct_answer": "It maps an index in the <code>AddressOfNames</code> array to the corresponding index (ordinal) in the <code>AddressOfFunctions</code> array.",
      "distractors": [
        {
          "text": "It directly stores the memory addresses of the exported functions.",
          "misconception": "Targets [Array purpose confusion]: Confuses `AddressOfNameOrdinals` with `AddressOfFunctions`."
        },
        {
          "text": "It contains the symbolic names of the exported functions.",
          "misconception": "Targets [Array purpose confusion]: Confuses `AddressOfNameOrdinals` with `AddressOfNames`."
        },
        {
          "text": "It provides the base ordinal number for all exported functions.",
          "misconception": "Targets [Field definition confusion]: Misinterprets the role of this array, confusing it with the `Base` field."
        }
      ],
      "detailed_explanation": {
        "core_logic": "This array acts as a bridge: for a function found by name in <code>AddressOfNames</code>, its corresponding ordinal in <code>AddressOfNameOrdinals</code> is used to look up the actual function RVA in <code>AddressOfFunctions</code>, enabling name-based resolution.",
        "distractor_analysis": "The first distractor describes <code>AddressOfFunctions</code>. The second describes <code>AddressOfNames</code>. The third confuses it with the <code>Base</code> field.",
        "analogy": "It's like a cross-reference index in a book: if you find a topic (function name) on page X, the cross-reference tells you that topic's actual chapter number (ordinal) to find its content (function address)."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PE_FILE_FORMAT",
        "EAT_STRUCTURE"
      ]
    },
    {
      "question_text": "What is a 'forwarded function' in the context of a DLL's Export Address Table (EAT)?",
      "correct_answer": "A function that is exported by the current DLL but is actually implemented and exported by another DLL.",
      "distractors": [
        {
          "text": "A function that is only accessible via its ordinal number, not its name.",
          "misconception": "Targets [Forwarding vs. Ordinal confusion]: Confuses forwarding with functions exported solely by ordinal."
        },
        {
          "text": "A function that has been deprecated and is no longer supported.",
          "misconception": "Targets [unknown]: Not specified"
        },
        {
          "text": "A function that is dynamically loaded only when explicitly requested.",
          "misconception": "Targets [Forwarding vs. Lazy Loading confusion]: Confuses forwarding with on-demand loading mechanisms."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Forwarded functions simplify DLL dependencies by allowing one DLL to expose functions implemented in another. The EAT entry for a forwarded function contains a string pointing to the target DLL and function name, rather than a direct RVA.",
        "distractor_analysis": "The first distractor describes functions exported by ordinal. The second incorrectly equates forwarding with deprecation. The third confuses it with lazy loading.",
        "analogy": "It's like a receptionist (current DLL) who, when asked for a specific service (function), tells you, 'That service is actually handled by our main office downtown (another DLL). Here's their number.'"
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "DLL_DEPENDENCIES",
        "EAT_STRUCTURE"
      ]
    },
    {
      "question_text": "Which of the following is a common defense mechanism against EAT hooking?",
      "correct_answer": "Monitoring the Export Address Table for unexpected modifications or unauthorized entries.",
      "distractors": [
        {
          "text": "Disabling dynamic linking and statically linking all required libraries.",
          "misconception": "Targets [Defense strategy mismatch]: Suggests a drastic measure (static linking) that bypasses the need for EAT but isn't a direct defense against hooking."
        },
        {
          "text": "Implementing strict file integrity checks on all DLLs before execution.",
          "misconception": "Targets [Artifact focus error]: Focuses on disk integrity, which EAT hooking often bypasses by operating in memory."
        },
        {
          "text": "Blocking all network connections to prevent DLL downloads.",
          "misconception": "Targets [Attack vector confusion]: Addresses malware delivery, not the runtime hooking technique itself."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Since EAT hooking involves modifying the EAT in memory, security solutions can detect it by periodically scanning the EAT of loaded DLLs and comparing the function addresses against known-good values or expected structures.",
        "distractor_analysis": "The first distractor avoids the problem rather than defending against it. The second focuses on disk artifacts, which are less relevant for in-memory hooking. The third addresses malware acquisition, not execution.",
        "analogy": "It's like having a security guard constantly checking the directory at the entrance of a building to ensure no one has secretly changed the room numbers or added fake office listings."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "EAT_HOOKING",
        "MALWARE_DETECTION"
      ]
    },
    {
      "question_text": "What is the primary challenge in detecting EAT hooking compared to Import Address Table (IAT) hooking?",
      "correct_answer": "EAT hooking targets functions exported by a DLL, which are used by many other processes, making it harder to isolate the impact compared to IAT hooking which affects only the calling process.",
      "distractors": [
        {
          "text": "EAT hooking is always performed on disk, making it easier to detect.",
          "misconception": "Targets [Artifact focus error]: Incorrectly assumes EAT hooking leaves disk artifacts and is thus easier to detect."
        },
        {
          "text": "IAT hooking is more common in modern malware, making EAT hooking less relevant.",
          "misconception": "Targets [Prevalence confusion]: Misjudges the relative prevalence and relevance of EAT vs. IAT hooking."
        },
        {
          "text": "EAT hooking requires kernel-level privileges, while IAT hooking does not.",
          "misconception": "Targets [Privilege level confusion]: Incorrectly assigns privilege requirements to EAT hooking."
        }
      ],
      "detailed_explanation": {
        "core_logic": "While both are hooking techniques, EAT hooking modifies a DLL's exports, potentially affecting multiple processes using that DLL. IAT hooking modifies a process's imports, typically impacting only that specific process, making EAT's broader impact a detection challenge.",
        "distractor_analysis": "The first distractor incorrectly states EAT hooking is disk-based and easier to detect. The second misjudges the relevance and prevalence. The third incorrectly assigns privilege requirements.",
        "analogy": "Detecting IAT hooking is like finding a tampered signpost on a single road leading to one house. Detecting EAT hooking is like finding a tampered signpost on a main highway interchange that affects traffic going to many different destinations."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "comparison",
      "bloom_level": "analyze",
      "prerequisites": [
        "EAT_HOOKING",
        "IAT_HOOKING",
        "MALWARE_ANALYSIS"
      ]
    },
    {
      "question_text": "In the context of malware analysis, why is understanding the Export Address Table (EAT) important when examining a DLL?",
      "correct_answer": "It reveals the functions the DLL makes available to other programs, which can indicate its intended purpose or potential malicious capabilities.",
      "distractors": [
        {
          "text": "It shows which system libraries the DLL relies on for its operation.",
          "misconception": "Targets [Import vs. Export confusion]: Describes the Import Address Table (IAT) function."
        },
        {
          "text": "It details the memory allocation strategy used by the DLL.",
          "misconception": "Targets [PE structure confusion]: Attributes memory management details to the EAT."
        },
        {
          "text": "It lists all the resources (icons, strings) embedded within the DLL.",
          "misconception": "Targets [PE structure confusion]: Confuses EAT with the resource directory."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The EAT is essentially the public interface of a DLL. By examining the exported functions, an analyst can infer the DLL's functionality, identify potentially suspicious APIs being exposed, or understand how malware might interact with it.",
        "distractor_analysis": "The first distractor describes the IAT. The second incorrectly assigns memory allocation details. The third confuses EAT with the resource directory.",
        "analogy": "Examining the EAT is like looking at the menu of a restaurant; it tells you what dishes (functions) are available to order (call)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "MALWARE_ANALYSIS",
        "PE_FILE_FORMAT"
      ]
    },
    {
      "question_text": "What is the relationship between a DLL's Export Directory and its Export Address Table (EAT)?",
      "correct_answer": "The Export Directory is a structure within the PE header that contains pointers to the various tables that constitute the EAT, including function names, ordinals, and addresses.",
      "distractors": [
        {
          "text": "The EAT is a standalone file that must be linked with the DLL.",
          "misconception": "Targets [unknown]: Not specified"
        },
        {
          "text": "The EAT is synonymous with the DLL's code section.",
          "misconception": "Targets [PE structure confusion]: Equates the EAT with the executable code segment."
        },
        {
          "text": "The Export Directory is only used for functions exported by ordinal, not by name.",
          "misconception": "Targets [Field scope confusion]: Incorrectly limits the Export Directory's scope to ordinal exports."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The Export Directory serves as the central hub, containing metadata and pointers (<code>AddressOfFunctions</code>, <code>AddressOfNames</code>, <code>AddressOfNameOrdinals</code>) that collectively define the Export Address Table, which maps exported symbols to their locations.",
        "distractor_analysis": "The first distractor wrongly separates EAT from the DLL. The second confuses EAT with the code section. The third incorrectly limits the Export Directory's function.",
        "analogy": "The Export Directory is like the table of contents for a book's index; it tells you where to find the lists of names, page numbers (ordinals), and actual page locations (addresses) for all the book's entries (exported functions)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "PE_FILE_FORMAT",
        "EAT_STRUCTURE"
      ]
    },
    {
      "question_text": "When analyzing malware that uses EAT hooking, what is a potential consequence for system stability?",
      "correct_answer": "Redirecting critical API calls can lead to unexpected application crashes or system instability if the malicious code is flawed or interferes improperly.",
      "distractors": [
        {
          "text": "EAT hooking always improves system stability by optimizing function calls.",
          "misconception": "Targets [Outcome confusion]: Assumes hooking inherently improves stability, ignoring malicious intent and potential flaws."
        },
        {
          "text": "It has no impact on system stability as it operates in memory.",
          "misconception": "Targets [Impact misunderstanding]: Underestimates the potential for in-memory operations to cause instability."
        },
        {
          "text": "It only affects the performance of the malware itself, not other applications.",
          "misconception": "Targets [Scope confusion]: Incorrectly assumes EAT hooking is isolated to the malware process."
        }
      ],
      "detailed_explanation": {
        "core_logic": "By intercepting and potentially altering legitimate API calls, EAT hooking introduces a layer of indirection. If the malware's injected code contains bugs, fails to properly call the original function, or causes resource contention, it can destabilize the application or system.",
        "distractor_analysis": "The first distractor wrongly claims stability improvement. The second dismisses any impact on stability. The third incorrectly limits the scope to the malware.",
        "analogy": "It's like having a faulty intermediary relaying messages: if the intermediary garbles the message or fails to pass it on correctly, the intended recipient (the application) might react unpredictably or shut down."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "EAT_HOOKING",
        "SYSTEM_STABILITY"
      ]
    },
    {
      "question_text": "How might a security tool detect EAT hooking without relying solely on signature-based methods?",
      "correct_answer": "By employing behavioral analysis to monitor for unexpected modifications to the Export Address Table or unusual API call patterns.",
      "distractors": [
        {
          "text": "By scanning the disk for known EAT hooking malware binaries.",
          "misconception": "Targets [Detection method mismatch]: Relies on static analysis (disk scanning) for a dynamic, in-memory technique."
        },
        {
          "text": "By checking the digital signature of all loaded DLLs.",
          "misconception": "Targets [Signature integrity focus]: Assumes a valid signature prevents EAT hooking, which is incorrect as hooking modifies memory, not the signed file itself."
        },
        {
          "text": "By blocking all DLLs that export more than 100 functions.",
          "misconception": "Targets [Arbitrary threshold error]: Uses an arbitrary, overly broad rule that would block legitimate software."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Behavioral analysis focuses on *what* a program does. Detecting EAT hooking involves observing runtime actions like unexpected EAT modifications or API call redirections, which are indicators of malicious activity, rather than just matching file hashes.",
        "distractor_analysis": "The first distractor focuses on static detection, missing in-memory changes. The second incorrectly assumes digital signatures prevent runtime hooking. The third proposes an impractical and overly restrictive rule.",
        "analogy": "Instead of looking for a known 'burglar's face' (signature), the tool watches for suspicious actions like someone trying to pick locks or tamper with the building's directory (EAT) in real-time."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "defense",
      "bloom_level": "apply",
      "prerequisites": [
        "EAT_HOOKING",
        "BEHAVIORAL_ANALYSIS"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "Export Address Table (EAT) 002_Incident Response And Forensics best practices",
    "latency_ms": 25836.125
  },
  "timestamp": "2026-01-18T14:06:54.991251",
  "_av_safe_encoded": true,
  "_encoding_note": "Educational content encoded with HTML entities to prevent antivirus false positives. Content renders normally in Anki."
}