{
  "topic_title": "YARA Rule Development",
  "category": "002_Incident Response And Forensics - 007_Malware Analysis",
  "flashcards": [
    {
      "question_text": "What is the primary purpose of the <code>strings</code> section in a YARA rule?",
      "correct_answer": "To define patterns (text, hex, or regex) that YARA will search for in the target data.",
      "distractors": [
        {
          "text": "To specify metadata about the rule's author and creation date.",
          "misconception": "Targets [section confusion]: Confuses the `strings` section with the `meta` section."
        },
        {
          "text": "To define the boolean logic that determines if a rule matches.",
          "misconception": "Targets [section confusion]: Confuses the `strings` section with the `condition` section."
        },
        {
          "text": "To import external modules or libraries for advanced functionality.",
          "misconception": "Targets [section confusion]: Confuses the `strings` section with the `import` statement."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>strings</code> section defines the specific patterns YARA searches for, acting as the foundation for rule matching. Because these patterns are identified, the <code>condition</code> section can then evaluate their presence. This mechanism allows YARA to detect specific artifacts.",
        "distractor_analysis": "The distractors incorrectly assign the functions of the <code>meta</code>, <code>condition</code>, and <code>import</code> sections to the <code>strings</code> section, demonstrating a misunderstanding of YARA rule structure.",
        "analogy": "Think of the <code>strings</code> section as the ingredients list for a recipe, and the <code>condition</code> section as the instructions on how to combine them to make the dish."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "YARA_BASICS"
      ]
    },
    {
      "question_text": "Which YARA keyword is used to define a rule's identifier and enclose its sections?",
      "correct_answer": "rule",
      "distractors": [
        {
          "text": "meta",
          "misconception": "Targets [keyword confusion]: Confuses the rule definition keyword with the metadata section keyword."
        },
        {
          "text": "strings",
          "misconception": "Targets [keyword confusion]: Confuses the rule definition keyword with the strings section keyword."
        },
        {
          "text": "condition",
          "misconception": "Targets [keyword confusion]: Confuses the rule definition keyword with the condition section keyword."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>rule</code> keyword is fundamental as it initiates the definition of a YARA rule and its identifier. Because it signals the start of a rule block, YARA knows to parse the subsequent <code>meta</code>, <code>strings</code>, and <code>condition</code> sections. This structure is essential for rule parsing.",
        "distractor_analysis": "Distractors incorrectly identify keywords associated with other parts of a YARA rule (<code>meta</code>, <code>strings</code>, <code>condition</code>) as the primary rule definition keyword.",
        "analogy": "The <code>rule</code> keyword is like the 'Chapter' heading in a book, signaling the beginning of a new section of content."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "YARA_BASICS"
      ]
    },
    {
      "question_text": "In YARA, what is the purpose of the <code>meta</code> section within a rule?",
      "correct_answer": "To store descriptive information about the rule, such as author, date, and description.",
      "distractors": [
        {
          "text": "To define the actual search patterns (strings) for the rule.",
          "misconception": "Targets [section confusion]: Confuses `meta` with the `strings` section."
        },
        {
          "text": "To specify the conditions under which the rule should trigger.",
          "misconception": "Targets [section confusion]: Confuses `meta` with the `condition` section."
        },
        {
          "text": "To declare global variables or import modules.",
          "misconception": "Targets [section confusion]: Confuses `meta` with `global` or `import` statements."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>meta</code> section provides context and documentation for a YARA rule. Because it's designed for human-readable information, it helps analysts understand the rule's intent and origin without affecting its matching logic. This aids in rule management and sharing.",
        "distractor_analysis": "Each distractor incorrectly assigns the functionality of other YARA rule components (<code>strings</code>, <code>condition</code>, <code>import</code>/<code>global</code>) to the <code>meta</code> section.",
        "analogy": "The <code>meta</code> section is like the 'About' page for a software tool, providing background information without changing how the tool functions."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "YARA_BASICS"
      ]
    },
    {
      "question_text": "Which of the following is a best practice for naming YARA rules to improve clarity and organization?",
      "correct_answer": "Use a convention that includes details like malware family, threat actor, and file type.",
      "distractors": [
        {
          "text": "Use generic names like 'MalwareRule1' or 'ScanRule2'.",
          "misconception": "Targets [naming convention error]: Promotes uninformative naming that hinders understanding."
        },
        {
          "text": "Use only the hash of the malware sample the rule is designed for.",
          "misconception": "Targets [naming convention error]: Relies solely on ephemeral identifiers, not rule intent."
        },
        {
          "text": "Use random strings to prevent attackers from easily identifying the rule's purpose.",
          "misconception": "Targets [security through obscurity]: Misapplies security principles to rule naming, hindering legitimate analysis."
        }
      ],
      "detailed_explanation": {
        "core_logic": "A structured naming convention, such as <code>THREATACTOR_MALWARE_ROLE_IMAGETYPE_DETAIL</code>, helps analysts quickly understand a rule's purpose and group similar rules. Because clear naming aids in organization and quick identification, it's a key best practice for efficient malware analysis.",
        "distractor_analysis": "The distractors suggest naming strategies that are either too generic, too ephemeral, or based on flawed security principles, all of which impede effective rule management and analysis.",
        "analogy": "Naming YARA rules is like naming files on your computer; a descriptive name like 'Q4_Sales_Report_Final.pdf' is much more useful than 'Document1.pdf'."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "YARA_BASICS",
        "YARA_RULE_NAMING"
      ]
    },
    {
      "question_text": "According to YARA best practices, when should comments be used within a rule?",
      "correct_answer": "To explain complex strings, conditions, or the rule's overall intent, especially for non-human-readable elements.",
      "distractors": [
        {
          "text": "Comments should be avoided to keep the rule concise and efficient.",
          "misconception": "Targets [performance misconception]: Believes comments negatively impact performance, ignoring their value for maintainability."
        },
        {
          "text": "Comments should only be used to document the rule's author and creation date.",
          "misconception": "Targets [documentation scope error]: Limits comments to metadata, ignoring their use for explaining logic."
        },
        {
          "text": "Comments should be used to replace the <code>condition</code> section for simpler rules.",
          "misconception": "Targets [functional error]: Misunderstands the role of comments versus the `condition` section."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Comments (using <code>//</code> or <code>/* */</code>) enhance rule readability and maintainability by explaining complex logic or non-obvious strings. Because they clarify intent and mechanics, especially for elements like hex strings or intricate conditions, they are crucial for collaborative analysis and future understanding.",
        "distractor_analysis": "The distractors suggest either omitting comments entirely, limiting their scope to metadata, or misusing them to replace core rule logic, all of which undermine effective rule development.",
        "analogy": "Comments in YARA rules are like annotations in a textbook, helping to clarify difficult passages or explain the author's reasoning."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "YARA_BASICS",
        "YARA_RULE_COMMENTS"
      ]
    },
    {
      "question_text": "What is the benefit of using file magic conditions (e.g., <code>PE: uint16(0) == 0x5A4D</code>) in YARA rules?",
      "correct_answer": "It helps focus the matching process on specific file types, improving efficiency and reducing false positives.",
      "distractors": [
        {
          "text": "It automatically encrypts the strings to protect them from reverse engineering.",
          "misconception": "Targets [functional misunderstanding]: Confuses file type identification with encryption."
        },
        {
          "text": "It ensures that the rule will always match, regardless of the file content.",
          "misconception": "Targets [logic error]: Misunderstands that file magic is a condition, not a guarantee of match."
        },
        {
          "text": "It replaces the need for a <code>condition</code> section by defining the match criteria.",
          "misconception": "Targets [structural misunderstanding]: Believes file magic can substitute the entire `condition` section."
        }
      ],
      "detailed_explanation": {
        "core_logic": "File magic conditions, like checking for the 'MZ' header for PE files, allow YARA to quickly discard irrelevant files before performing expensive string matching. Because this pre-filtering significantly narrows the search space, it enhances performance and accuracy by reducing the likelihood of false positives.",
        "distractor_analysis": "The distractors incorrectly associate file magic with encryption, guarantee of match, or replacement of the <code>condition</code> section, failing to grasp its role in efficient file type filtering.",
        "analogy": "Using file magic is like sorting mail by zip code before opening it; it quickly separates what's relevant from what isn't, saving time."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "YARA_BASICS",
        "YARA_FILE_MAGIC"
      ]
    },
    {
      "question_text": "When writing YARA rules, why is it generally recommended to place static feature evaluations (like <code>filesize</code>) before string matching conditions?",
      "correct_answer": "Static evaluations are typically faster and can eliminate many non-matching files early, reducing the workload for subsequent string searches.",
      "distractors": [
        {
          "text": "YARA processes conditions strictly from right to left, so static features must be last.",
          "misconception": "Targets [processing order error]: Incorrectly assumes YARA's evaluation order for conditions."
        },
        {
          "text": "String matching is computationally cheaper, so it should be performed first.",
          "misconception": "Targets [performance misconception]: Incorrectly believes string matching is less resource-intensive than static evaluations."
        },
        {
          "text": "Static features are only relevant if a string match is found.",
          "misconception": "Targets [dependency error]: Believes static features are dependent on string matches, not independent filters."
        }
      ],
      "detailed_explanation": {
        "core_logic": "YARA evaluates conditions from left to right. Placing faster, static checks like <code>filesize</code> or file magic first allows YARA to quickly discard non-matching files. Because this reduces the number of files subjected to potentially slower string searches, it optimizes rule performance and efficiency.",
        "distractor_analysis": "The distractors propose incorrect evaluation orders, misjudge the relative performance of static checks versus string matching, and misunderstand the independence of static features.",
        "analogy": "It's like checking if you have enough money (static evaluation) before deciding which items to pick up at the grocery store (string matching)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "YARA_BASICS",
        "YARA_RULE_PERFORMANCE"
      ]
    },
    {
      "question_text": "What is a common strategy to manage YARA rules that match too many legitimate files (high false positive rate)?",
      "correct_answer": "Add more specific strings, use file type exclusions, or incorporate checks for signed software.",
      "distractors": [
        {
          "text": "Remove all strings and rely solely on the <code>condition: true</code> statement.",
          "misconception": "Targets [over-simplification]: Suggests removing all logic, rendering the rule useless."
        },
        {
          "text": "Increase the filesize limitations to only match very large files.",
          "misconception": "Targets [granularity error]: Proposes a blunt filesize approach that might miss relevant small files."
        },
        {
          "text": "Convert all hex strings to their ASCII equivalents for better readability.",
          "misconception": "Targets [misplaced optimization]: Focuses on string representation rather than matching logic for false positive reduction."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Reducing false positives involves refining the rule's specificity. Because adding more precise strings, excluding known good file types (e.g., <code>uint16(0) &#33;= 0x5A4D or not pe.is_pe</code>), or checking for unsigned binaries (<code>pe.number_of_signatures == 0</code>) directly targets the over-matching issue, these are effective strategies.",
        "distractor_analysis": "The distractors suggest ineffective or counterproductive methods: rendering the rule useless, applying a crude filter, or focusing on string format instead of matching logic.",
        "analogy": "If your net catches too many small fish, you might use a net with smaller holes (more specific strings) or only fish in specific areas (file type exclusions)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "YARA_BASICS",
        "YARA_RULE_REFINEMENT"
      ]
    },
    {
      "question_text": "How can YARA rules be structured to improve performance when dealing with very large files?",
      "correct_answer": "Break the rule into multiple rules, each targeting different filesize bands (e.g., <1MB, 1-2MB, >2MB).",
      "distractors": [
        {
          "text": "Use only ASCII strings, as hex strings are inherently slower.",
          "misconception": "Targets [performance misconception]: Overgeneralizes the performance impact of string types."
        },
        {
          "text": "Remove all <code>meta</code> and <code>condition</code> sections to reduce overhead.",
          "misconception": "Targets [structural error]: Incorrectly assumes metadata and conditions add significant overhead."
        },
        {
          "text": "Combine all potential strings into a single, very long regex.",
          "misconception": "Targets [inefficient pattern design]: Promotes a complex regex that is often slower than multiple specific strings."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Large files increase the 'haystack' YARA must search. Because breaking a rule into multiple rules for different filesize bands allows YARA to apply targeted searches and potentially avoid scanning irrelevant portions of large files, this strategy helps manage performance. It's a form of 'divide and conquer'.",
        "distractor_analysis": "The distractors propose flawed performance optimizations: misjudging string type impact, incorrectly removing essential rule components, or creating inefficient regex patterns.",
        "analogy": "Instead of trying to read an entire encyclopedia at once, you read it chapter by chapter (filesize bands) to make the task more manageable."
      },
      "code_snippets": [],
      "difficulty": "expert",
      "question_type": "procedure",
      "bloom_level": "apply",
      "prerequisites": [
        "YARA_BASICS",
        "YARA_RULE_PERFORMANCE",
        "YARA_FILESYSTEM_INTERACTION"
      ]
    },
    {
      "question_text": "What is the role of the <code>condition</code> section in a YARA rule?",
      "correct_answer": "It defines the boolean logic that determines whether the rule matches the scanned data based on defined strings or other criteria.",
      "distractors": [
        {
          "text": "It lists all the strings that must be present for the rule to match.",
          "misconception": "Targets [section confusion]: Confuses the `condition` section with the `strings` section."
        },
        {
          "text": "It provides metadata and descriptive information about the rule.",
          "misconception": "Targets [section confusion]: Confuses the `condition` section with the `meta` section."
        },
        {
          "text": "It specifies the file types the rule should be applied to.",
          "misconception": "Targets [scope confusion]: Misunderstands that file type filtering is often done via conditions but isn't the sole purpose of the section."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>condition</code> section is the decision-making part of a YARA rule. Because it evaluates boolean expressions referencing strings, filesize, file magic, and other properties, it dictates the precise circumstances under which a match occurs. This logic is essential for accurate detection.",
        "distractor_analysis": "The distractors incorrectly attribute the functions of the <code>strings</code>, <code>meta</code>, and file type filtering mechanisms to the <code>condition</code> section, failing to recognize its role as the rule's logical core.",
        "analogy": "The <code>condition</code> section is like the 'if' statement in programming; it checks if certain criteria are met before executing an action (declaring a match)."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "YARA_BASICS"
      ]
    },
    {
      "question_text": "Which YARA string modifier is used to perform case-insensitive matching?",
      "correct_answer": "nocase",
      "distractors": [
        {
          "text": "ascii",
          "misconception": "Targets [modifier confusion]: Confuses case-insensitivity with ASCII encoding matching."
        },
        {
          "text": "wide",
          "misconception": "Targets [modifier confusion]: Confuses case-insensitivity with wide (UTF-16) character matching."
        },
        {
          "text": "fullword",
          "misconception": "Targets [modifier confusion]: Confuses case-insensitivity with whole word matching."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>nocase</code> modifier tells YARA to ignore character casing when searching for a string. Because this allows a single string definition to match variations like 'Malware', 'malware', or 'MALWARE', it increases detection flexibility without needing multiple definitions.",
        "distractor_analysis": "The distractors incorrectly identify other YARA string modifiers (<code>ascii</code>, <code>wide</code>, <code>fullword</code>) as responsible for case-insensitive matching, demonstrating confusion about their specific functions.",
        "analogy": "Using the <code>nocase</code> modifier is like searching for a word in a document without worrying if the capitalization is correct."
      },
      "code_snippets": [],
      "difficulty": "foundational",
      "question_type": "definition",
      "bloom_level": "remember",
      "prerequisites": [
        "YARA_BASICS",
        "YARA_STRING_MODIFIERS"
      ]
    },
    {
      "question_text": "What is the primary advantage of using templates when developing YARA rules?",
      "correct_answer": "Templates promote consistency in rule structure, metadata, and comments, making rules easier to manage and understand.",
      "distractors": [
        {
          "text": "Templates automatically optimize rule performance by compiling strings more efficiently.",
          "misconception": "Targets [performance misconception]: Believes templates directly impact compilation efficiency, rather than structure."
        },
        {
          "text": "Templates ensure that rules will always match the target data without false positives.",
          "misconception": "Targets [accuracy misconception]: Overstates the guarantee provided by templates, ignoring the need for precise logic."
        },
        {
          "text": "Templates are required by YARA and cannot be omitted.",
          "misconception": "Targets [requirement misunderstanding]: Incorrectly assumes templates are a mandatory syntax element."
        }
      ],
      "detailed_explanation": {
        "core_logic": "Using templates provides a standardized structure for developing YARA rules. Because this consistency in metadata, string definitions, and comments aids collaboration and maintainability, it's a key best practice for managing complex rule sets, especially in team environments.",
        "distractor_analysis": "The distractors incorrectly claim templates offer automatic performance gains, guarantee accuracy, or are a mandatory syntax requirement, missing their primary benefit of standardization.",
        "analogy": "Templates for YARA rules are like using a standardized form for job applications; they ensure all necessary information is collected in a consistent format."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "YARA_BASICS",
        "YARA_RULE_TEMPLATES"
      ]
    },
    {
      "question_text": "Consider a YARA rule with the condition <code>filesize &lt; 1MB and \\(a and \\)b</code>. What is the most efficient order for YARA to evaluate these components?",
      "correct_answer": "Evaluate <code>filesize &lt; 1MB</code> first, then <code>\\(a</code>, then <code>\\)b</code>.",
      "distractors": [
        {
          "text": "Evaluate <code>\\(a</code> first, then <code>\\)b</code>, then <code>filesize &lt; 1MB</code>.",
          "misconception": "Targets [processing order error]: Incorrectly assumes string matching should precede static file property checks."
        },
        {
          "text": "Evaluate <code>\\(b</code> first, then <code>\\)a</code>, then <code>filesize &lt; 1MB</code>.",
          "misconception": "Targets [processing order error]: Incorrectly assumes string matching should precede static file property checks."
        },
        {
          "text": "Evaluate <code>filesize &lt; 1MB</code> last, after both <code>\\(a</code> and <code>\\)b</code> have been evaluated.",
          "misconception": "Targets [processing order error]: Incorrectly assumes static file properties are evaluated after string matches."
        }
      ],
      "detailed_explanation": {
        "core_logic": "YARA evaluates conditions from left to right. Because <code>filesize &lt; 1MB</code> is a static file property check that can quickly eliminate many files, it should be evaluated first. This optimization prevents YARA from performing potentially slower string searches (<code>\\(a</code>, <code>\\)b</code>) on files that don't meet the size criteria.",
        "distractor_analysis": "The distractors propose evaluation orders that are less efficient because they prioritize string matching over the faster, preliminary check of file size.",
        "analogy": "It's more efficient to check if you have enough money (filesize) before you start picking items off the shelf (\\(a, \\)b)."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "YARA_BASICS",
        "YARA_RULE_PERFORMANCE",
        "YARA_CONDITION_EVALUATION"
      ]
    },
    {
      "question_text": "What does the YARA string modifier <code>ascii</code> primarily affect?",
      "correct_answer": "It ensures that the string is matched as a sequence of ASCII characters, ignoring potential wide (UTF-16) representations.",
      "distractors": [
        {
          "text": "It forces the match to be case-insensitive.",
          "misconception": "Targets [modifier confusion]: Confuses `ascii` with the `nocase` modifier."
        },
        {
          "text": "It requires the string to be found as a whole word.",
          "misconception": "Targets [modifier confusion]: Confuses `ascii` with the `fullword` modifier."
        },
        {
          "text": "It limits the search to only the beginning of the file.",
          "misconception": "Targets [positional confusion]: Misunderstands that `ascii` relates to character encoding, not search location."
        }
      ],
      "detailed_explanation": {
        "core_logic": "The <code>ascii</code> modifier specifies that the string should be interpreted and matched using ASCII encoding rules. Because many malware artifacts contain ASCII strings, this modifier helps ensure accurate detection by differentiating them from potential wide character encodings, which might otherwise be misinterpreted or missed.",
        "distractor_analysis": "The distractors incorrectly associate the <code>ascii</code> modifier with case-insensitivity, whole-word matching, or positional limitations, confusing it with other YARA string modifiers or concepts.",
        "analogy": "Using the <code>ascii</code> modifier is like specifying that you're reading a book in English (ASCII) and not in a language that uses a different alphabet (like wide characters)."
      },
      "code_snippets": [],
      "difficulty": "intermediate",
      "question_type": "definition",
      "bloom_level": "understand",
      "prerequisites": [
        "YARA_BASICS",
        "YARA_STRING_MODIFIERS",
        "CHARACTER_ENCODING"
      ]
    },
    {
      "question_text": "When developing YARA rules for incident response, what is a key consideration regarding the <code>condition</code> section's complexity?",
      "correct_answer": "Balance specificity for accurate detection with simplicity to ensure efficient evaluation and avoid performance bottlenecks.",
      "distractors": [
        {
          "text": "The <code>condition</code> section should be as complex as possible to catch all variations of malware.",
          "misconception": "Targets [unknown]: Not specified"
        },
        {
          "text": "The <code>condition</code> section should only contain <code>true</code> to ensure maximum coverage.",
          "misconception": "Targets [over-generalization]: Suggests a condition that matches everything, rendering the rule useless for specific detection."
        },
        {
          "text": "The <code>condition</code> section is optional and can be omitted if strings are well-defined.",
          "misconception": "Targets [structural misunderstanding]: Incorrectly believes the `condition` section is optional."
        }
      ],
      "detailed_explanation": {
        "core_logic": "While specificity is crucial for accurate malware identification, overly complex conditions can significantly slow down YARA scanning. Because a balance must be struck between detailed matching logic and efficient execution, developers should aim for conditions that are precise yet performant, avoiding unnecessary computations.",
        "distractor_analysis": "The distractors promote overly complex or simplistic conditions, or misunderstand the mandatory nature of the <code>condition</code> section, all of which are detrimental to effective YARA rule development for IR.",
        "analogy": "Crafting a YARA condition is like designing a security checkpoint: it needs to be thorough enough to catch threats but efficient enough not to cause excessive delays."
      },
      "code_snippets": [],
      "difficulty": "advanced",
      "question_type": "analysis",
      "bloom_level": "analyze",
      "prerequisites": [
        "YARA_BASICS",
        "YARA_RULE_PERFORMANCE",
        "INCIDENT_RESPONSE_PRINCIPLES"
      ]
    }
  ],
  "generation_metadata": {
    "model": "google/gemini-2.5-flash-lite",
    "num_generated": 15,
    "temperature": 0.1,
    "web_citations": [],
    "research_method": "openrouter_web_plugin",
    "search_query": "YARA Rule Development 002_Incident Response And Forensics best practices",
    "latency_ms": 26242.959
  },
  "timestamp": "2026-01-18T14:11:00.750981",
  "_av_safe_encoded": true,
  "_encoding_note": "Educational content encoded with HTML entities to prevent antivirus false positives. Content renders normally in Anki."
}