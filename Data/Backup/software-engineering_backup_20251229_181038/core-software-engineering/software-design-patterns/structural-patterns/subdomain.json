{
  "subdomain_title": "Structural Patterns",
  "domain_title": "Software Design Patterns",
  "category_title": "Core Software Engineering",
  "curriculum_type": "software-engineering",
  "processed_at": "2025-12-29T15:02:32.180318",
  "result": {
    "subdomain_title": "Structural Patterns",
    "curriculum_type": "software-engineering",
    "topic_root": "Structural Patterns",
    "topic_root_citation": "https://refactoring.guru/design-patterns/structural-patterns",
    "detailed_hierarchy": [
      {
        "level": 1,
        "domain": "Adapter Pattern",
        "subdomains": [
          {
            "level": 2,
            "subdomain": "Adapter Fundamentals",
            "topics": [
              {
                "level": 3,
                "topic": "Interface Compatibility"
              },
              {
                "level": 3,
                "topic": "Wrapper Pattern Relationship"
              },
              {
                "level": 3,
                "topic": "Two-Way Adapters"
              },
              {
                "level": 3,
                "topic": "Pluggable Adapters"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Adapter Implementation Types",
            "topics": [
              {
                "level": 3,
                "topic": "Object Adapter (Composition)"
              },
              {
                "level": 3,
                "topic": "Class Adapter (Inheritance)"
              },
              {
                "level": 3,
                "topic": "Adaptee vs Target Interfaces"
              },
              {
                "level": 3,
                "topic": "Adapter Object Lifecycle"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Adapter Use Cases",
            "topics": [
              {
                "level": 3,
                "topic": "Legacy System Integration"
              },
              {
                "level": 3,
                "topic": "Third-Party API Adaptation"
              },
              {
                "level": 3,
                "topic": "Multiple Interface Support"
              },
              {
                "level": 3,
                "topic": "Reusable Class Cooperation"
              }
            ]
          }
        ]
      },
      {
        "level": 1,
        "domain": "Bridge Pattern",
        "subdomains": [
          {
            "level": 2,
            "subdomain": "Bridge Fundamentals",
            "topics": [
              {
                "level": 3,
                "topic": "Abstraction-Implementation Separation"
              },
              {
                "level": 3,
                "topic": "Decoupling Principles"
              },
              {
                "level": 3,
                "topic": "Hierarchical Independence"
              },
              {
                "level": 3,
                "topic": "Bridge vs Adapter Distinction"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Bridge Components",
            "topics": [
              {
                "level": 3,
                "topic": "Abstraction Interface"
              },
              {
                "level": 3,
                "topic": "Refined Abstraction"
              },
              {
                "level": 3,
                "topic": "Implementation Interface"
              },
              {
                "level": 3,
                "topic": "Concrete Implementor"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Bridge Applications",
            "topics": [
              {
                "level": 3,
                "topic": "Runtime Implementation Switching"
              },
              {
                "level": 3,
                "topic": "Platform Independence"
              },
              {
                "level": 3,
                "topic": "Implementation Hiding"
              },
              {
                "level": 3,
                "topic": "Shared Implementation with Reference Counting"
              }
            ]
          }
        ]
      },
      {
        "level": 1,
        "domain": "Composite Pattern",
        "subdomains": [
          {
            "level": 2,
            "subdomain": "Composite Fundamentals",
            "topics": [
              {
                "level": 3,
                "topic": "Part-Whole Hierarchies"
              },
              {
                "level": 3,
                "topic": "Tree Structure Representation"
              },
              {
                "level": 3,
                "topic": "Uniform Object Treatment"
              },
              {
                "level": 3,
                "topic": "Recursive Composition"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Composite Components",
            "topics": [
              {
                "level": 3,
                "topic": "Component Interface"
              },
              {
                "level": 3,
                "topic": "Leaf Objects"
              },
              {
                "level": 3,
                "topic": "Composite Objects"
              },
              {
                "level": 3,
                "topic": "Client Interaction"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Composite Implementation",
            "topics": [
              {
                "level": 3,
                "topic": "Child Management Operations"
              },
              {
                "level": 3,
                "topic": "Parent References"
              },
              {
                "level": 3,
                "topic": "Component Ordering"
              },
              {
                "level": 3,
                "topic": "Transparent vs Safe Composites"
              }
            ]
          }
        ]
      },
      {
        "level": 1,
        "domain": "Decorator Pattern",
        "subdomains": [
          {
            "level": 2,
            "subdomain": "Decorator Fundamentals",
            "topics": [
              {
                "level": 3,
                "topic": "Dynamic Responsibility Addition"
              },
              {
                "level": 3,
                "topic": "Wrapper Object Design"
              },
              {
                "level": 3,
                "topic": "Decorator vs Inheritance"
              },
              {
                "level": 3,
                "topic": "Transparent Enclosure"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Decorator Components",
            "topics": [
              {
                "level": 3,
                "topic": "Component Interface"
              },
              {
                "level": 3,
                "topic": "Concrete Component"
              },
              {
                "level": 3,
                "topic": "Decorator Base Class"
              },
              {
                "level": 3,
                "topic": "Concrete Decorators"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Decorator Applications",
            "topics": [
              {
                "level": 3,
                "topic": "Behavior Extension at Runtime"
              },
              {
                "level": 3,
                "topic": "Multiple Decorator Stacking"
              },
              {
                "level": 3,
                "topic": "Subclass Explosion Prevention"
              },
              {
                "level": 3,
                "topic": "Framework Extensibility"
              }
            ]
          }
        ]
      },
      {
        "level": 1,
        "domain": "Facade Pattern",
        "subdomains": [
          {
            "level": 2,
            "subdomain": "Facade Fundamentals",
            "topics": [
              {
                "level": 3,
                "topic": "Simplified Interface Provision"
              },
              {
                "level": 3,
                "topic": "Subsystem Complexity Hiding"
              },
              {
                "level": 3,
                "topic": "Higher-Level Interface Design"
              },
              {
                "level": 3,
                "topic": "Facade vs Adapter Distinction"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Facade Structure",
            "topics": [
              {
                "level": 3,
                "topic": "Facade Class Design"
              },
              {
                "level": 3,
                "topic": "Subsystem Classes"
              },
              {
                "level": 3,
                "topic": "Client-Facade Interaction"
              },
              {
                "level": 3,
                "topic": "Multiple Facades"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Facade Applications",
            "topics": [
              {
                "level": 3,
                "topic": "Library Simplification"
              },
              {
                "level": 3,
                "topic": "Framework Interface Design"
              },
              {
                "level": 3,
                "topic": "Subsystem Layering"
              },
              {
                "level": 3,
                "topic": "API Design Patterns"
              }
            ]
          }
        ]
      },
      {
        "level": 1,
        "domain": "Flyweight Pattern",
        "subdomains": [
          {
            "level": 2,
            "subdomain": "Flyweight Fundamentals",
            "topics": [
              {
                "level": 3,
                "topic": "Memory Optimization Principles"
              },
              {
                "level": 3,
                "topic": "Object Sharing Mechanisms"
              },
              {
                "level": 3,
                "topic": "Fine-Grained Objects"
              },
              {
                "level": 3,
                "topic": "Storage Cost Reduction"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Flyweight State Management",
            "topics": [
              {
                "level": 3,
                "topic": "Intrinsic State (Shared)"
              },
              {
                "level": 3,
                "topic": "Extrinsic State (Context-Dependent)"
              },
              {
                "level": 3,
                "topic": "Flyweight Factory"
              },
              {
                "level": 3,
                "topic": "Object Pool Management"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Flyweight Applications",
            "topics": [
              {
                "level": 3,
                "topic": "Character Rendering in Text Editors"
              },
              {
                "level": 3,
                "topic": "Graphical Object Sharing"
              },
              {
                "level": 3,
                "topic": "Large-Scale Object Systems"
              },
              {
                "level": 3,
                "topic": "RAM Constraint Optimization"
              }
            ]
          }
        ]
      },
      {
        "level": 1,
        "domain": "Proxy Pattern",
        "subdomains": [
          {
            "level": 2,
            "subdomain": "Proxy Fundamentals",
            "topics": [
              {
                "level": 3,
                "topic": "Surrogate Object Design"
              },
              {
                "level": 3,
                "topic": "Access Control Mechanisms"
              },
              {
                "level": 3,
                "topic": "Placeholder Pattern"
              },
              {
                "level": 3,
                "topic": "Smart Reference Implementation"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Proxy Types",
            "topics": [
              {
                "level": 3,
                "topic": "Remote Proxy"
              },
              {
                "level": 3,
                "topic": "Virtual Proxy (Lazy Loading)"
              },
              {
                "level": 3,
                "topic": "Protection Proxy (Access Rights)"
              },
              {
                "level": 3,
                "topic": "Smart Reference Proxy"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Proxy Applications",
            "topics": [
              {
                "level": 3,
                "topic": "Distributed System Representation"
              },
              {
                "level": 3,
                "topic": "Lazy Object Initialization"
              },
              {
                "level": 3,
                "topic": "Logging and Auditing"
              },
              {
                "level": 3,
                "topic": "Dependency Injection Containers"
              }
            ]
          }
        ]
      },
      {
        "level": 1,
        "domain": "Structural Pattern Relationships",
        "subdomains": [
          {
            "level": 2,
            "subdomain": "Pattern Interactions",
            "topics": [
              {
                "level": 3,
                "topic": "Adapter vs Bridge vs Facade"
              },
              {
                "level": 3,
                "topic": "Decorator vs Proxy Comparison"
              },
              {
                "level": 3,
                "topic": "Composite and Decorator Synergy"
              },
              {
                "level": 3,
                "topic": "Flyweight with Composite"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Composition Techniques",
            "topics": [
              {
                "level": 3,
                "topic": "Object Composition Principles"
              },
              {
                "level": 3,
                "topic": "Class Composition via Inheritance"
              },
              {
                "level": 3,
                "topic": "Interface Composition"
              },
              {
                "level": 3,
                "topic": "Runtime vs Compile-Time Composition"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Selection Criteria",
            "topics": [
              {
                "level": 3,
                "topic": "Problem Domain Analysis"
              },
              {
                "level": 3,
                "topic": "Trade-off Considerations"
              },
              {
                "level": 3,
                "topic": "Pattern Combination Strategies"
              },
              {
                "level": 3,
                "topic": "Anti-Patterns and Pitfalls"
              }
            ]
          }
        ]
      },
      {
        "level": 1,
        "domain": "Implementation Considerations",
        "subdomains": [
          {
            "level": 2,
            "subdomain": "Language-Specific Implementation",
            "topics": [
              {
                "level": 3,
                "topic": "Object-Oriented Language Support"
              },
              {
                "level": 3,
                "topic": "Multiple Inheritance Handling"
              },
              {
                "level": 3,
                "topic": "Interface vs Abstract Class"
              },
              {
                "level": 3,
                "topic": "Generics and Type Safety"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Performance Implications",
            "topics": [
              {
                "level": 3,
                "topic": "Indirection Overhead"
              },
              {
                "level": 3,
                "topic": "Memory Footprint Analysis"
              },
              {
                "level": 3,
                "topic": "Runtime Performance Trade-offs"
              },
              {
                "level": 3,
                "topic": "Caching and Optimization"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Design Quality",
            "topics": [
              {
                "level": 3,
                "topic": "Flexibility and Extensibility"
              },
              {
                "level": 3,
                "topic": "Maintainability Considerations"
              },
              {
                "level": 3,
                "topic": "Code Complexity Management"
              },
              {
                "level": 3,
                "topic": "Testing and Testability"
              }
            ]
          }
        ]
      }
    ]
  },
  "metadata": {
    "duration_seconds": 786.080999,
    "timestamp": "2025-12-29T14:32:58.516872"
  }
}