{
  "subdomain_title": "SOLID Principles",
  "domain_title": "Software Design Patterns",
  "category_title": "Core Software Engineering",
  "curriculum_type": "software-engineering",
  "processed_at": "2025-12-29T15:02:31.331868",
  "result": {
    "subdomain_title": "SOLID Principles",
    "curriculum_type": "software-engineering",
    "topic_root": "SOLID Principles",
    "topic_root_citation": "http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod",
    "detailed_hierarchy": [
      {
        "level": 1,
        "domain": "Foundational Concepts",
        "subdomains": [
          {
            "level": 2,
            "subdomain": "Object-Oriented Design Fundamentals",
            "topics": [
              {
                "level": 3,
                "topic": "Abstraction"
              },
              {
                "level": 3,
                "topic": "Encapsulation"
              },
              {
                "level": 3,
                "topic": "Inheritance"
              },
              {
                "level": 3,
                "topic": "Polymorphism"
              },
              {
                "level": 3,
                "topic": "Composition"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Design Smells and Code Rot",
            "topics": [
              {
                "level": 3,
                "topic": "Rigidity"
              },
              {
                "level": 3,
                "topic": "Fragility"
              },
              {
                "level": 3,
                "topic": "Immobility"
              },
              {
                "level": 3,
                "topic": "Viscosity of Design"
              },
              {
                "level": 3,
                "topic": "Viscosity of Environment"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Dependency Management",
            "topics": [
              {
                "level": 3,
                "topic": "Coupling"
              },
              {
                "level": 3,
                "topic": "Cohesion"
              },
              {
                "level": 3,
                "topic": "Separation of Concerns"
              },
              {
                "level": 3,
                "topic": "Dependency Direction"
              },
              {
                "level": 3,
                "topic": "Transitive Dependencies"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Design Goals and Quality Attributes",
            "topics": [
              {
                "level": 3,
                "topic": "Maintainability"
              },
              {
                "level": 3,
                "topic": "Flexibility"
              },
              {
                "level": 3,
                "topic": "Extensibility"
              },
              {
                "level": 3,
                "topic": "Reusability"
              },
              {
                "level": 3,
                "topic": "Testability"
              },
              {
                "level": 3,
                "topic": "Understandability"
              }
            ]
          }
        ]
      },
      {
        "level": 1,
        "domain": "Single Responsibility Principle (SRP)",
        "subdomains": [
          {
            "level": 2,
            "subdomain": "Core Concepts",
            "topics": [
              {
                "level": 3,
                "topic": "Definition: One Reason to Change"
              },
              {
                "level": 3,
                "topic": "Responsibility as Change Driver"
              },
              {
                "level": 3,
                "topic": "Cohesion in Class Design"
              },
              {
                "level": 3,
                "topic": "Separation of Business Logic and Presentation"
              },
              {
                "level": 3,
                "topic": "Separation of Business Logic and Persistence"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Implementation Techniques",
            "topics": [
              {
                "level": 3,
                "topic": "Extracting Secondary Responsibilities"
              },
              {
                "level": 3,
                "topic": "Creating Dedicated Classes"
              },
              {
                "level": 3,
                "topic": "Localizing Changes"
              },
              {
                "level": 3,
                "topic": "Function Separation by Change Reason"
              },
              {
                "level": 3,
                "topic": "Module Decomposition"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Violations and Code Smells",
            "topics": [
              {
                "level": 3,
                "topic": "Monolithic Classes"
              },
              {
                "level": 3,
                "topic": "God Objects"
              },
              {
                "level": 3,
                "topic": "Multiple Reasons to Change"
              },
              {
                "level": 3,
                "topic": "Mixed Concerns in Single Class"
              },
              {
                "level": 3,
                "topic": "Excessive Dependencies"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Benefits and Trade-offs",
            "topics": [
              {
                "level": 3,
                "topic": "Improved Maintainability"
              },
              {
                "level": 3,
                "topic": "Enhanced Testability"
              },
              {
                "level": 3,
                "topic": "Reduced Coupling"
              },
              {
                "level": 3,
                "topic": "Better Organization"
              },
              {
                "level": 3,
                "topic": "Potential Class Proliferation"
              }
            ]
          }
        ]
      },
      {
        "level": 1,
        "domain": "Open-Closed Principle (OCP)",
        "subdomains": [
          {
            "level": 2,
            "subdomain": "Core Concepts",
            "topics": [
              {
                "level": 3,
                "topic": "Definition: Open for Extension, Closed for Modification"
              },
              {
                "level": 3,
                "topic": "Abstraction as Key Enabler"
              },
              {
                "level": 3,
                "topic": "Behavioral Extension Without Code Changes"
              },
              {
                "level": 3,
                "topic": "Preventing Cascading Changes"
              },
              {
                "level": 3,
                "topic": "Stability of Existing Code"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Implementation Techniques",
            "topics": [
              {
                "level": 3,
                "topic": "Dynamic Polymorphism with Virtual Functions"
              },
              {
                "level": 3,
                "topic": "Static Polymorphism with Templates"
              },
              {
                "level": 3,
                "topic": "Abstract Base Classes"
              },
              {
                "level": 3,
                "topic": "Interface-Based Design"
              },
              {
                "level": 3,
                "topic": "Data-Driven Approaches"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Violations and Code Smells",
            "topics": [
              {
                "level": 3,
                "topic": "Switch Statement Proliferation"
              },
              {
                "level": 3,
                "topic": "Type Checking with instanceof or typeof"
              },
              {
                "level": 3,
                "topic": "Modifying Existing Classes for New Features"
              },
              {
                "level": 3,
                "topic": "Conditional Logic Based on Types"
              },
              {
                "level": 3,
                "topic": "Runtime Type Identification (RTTI) Abuse"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Related Design Patterns",
            "topics": [
              {
                "level": 3,
                "topic": "Strategy Pattern"
              },
              {
                "level": 3,
                "topic": "Template Method Pattern"
              },
              {
                "level": 3,
                "topic": "Abstract Server Pattern"
              },
              {
                "level": 3,
                "topic": "Adapter Pattern"
              },
              {
                "level": 3,
                "topic": "Decorator Pattern"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Heuristics and Conventions",
            "topics": [
              {
                "level": 3,
                "topic": "Making Member Variables Private"
              },
              {
                "level": 3,
                "topic": "Avoiding Global Variables"
              },
              {
                "level": 3,
                "topic": "Minimizing RTTI Usage"
              },
              {
                "level": 3,
                "topic": "Programming to Interfaces"
              },
              {
                "level": 3,
                "topic": "Anticipating Variation Points"
              }
            ]
          }
        ]
      },
      {
        "level": 1,
        "domain": "Liskov Substitution Principle (LSP)",
        "subdomains": [
          {
            "level": 2,
            "subdomain": "Core Concepts",
            "topics": [
              {
                "level": 3,
                "topic": "Definition: Subtypes Must Be Substitutable"
              },
              {
                "level": 3,
                "topic": "Behavioral Subtyping"
              },
              {
                "level": 3,
                "topic": "IS-A Relationship in Behavior"
              },
              {
                "level": 3,
                "topic": "Polymorphic Substitutability"
              },
              {
                "level": 3,
                "topic": "Preservation of Program Correctness"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Design by Contract",
            "topics": [
              {
                "level": 3,
                "topic": "Preconditions"
              },
              {
                "level": 3,
                "topic": "Postconditions"
              },
              {
                "level": 3,
                "topic": "Invariants"
              },
              {
                "level": 3,
                "topic": "Contract Strengthening and Weakening"
              },
              {
                "level": 3,
                "topic": "Derived Methods: Expect No More, Provide No Less"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Violations and Anti-patterns",
            "topics": [
              {
                "level": 3,
                "topic": "Rectangle-Square Problem"
              },
              {
                "level": 3,
                "topic": "Circle-Ellipse Dilemma"
              },
              {
                "level": 3,
                "topic": "Throwing Unexpected Exceptions"
              },
              {
                "level": 3,
                "topic": "Returning Different Types in Subtypes"
              },
              {
                "level": 3,
                "topic": "Degenerative Methods in Subclasses"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Implementation Techniques",
            "topics": [
              {
                "level": 3,
                "topic": "Honoring Base Class Contracts"
              },
              {
                "level": 3,
                "topic": "Refactoring to Proper Abstractions"
              },
              {
                "level": 3,
                "topic": "Using Assertions to Document Contracts"
              },
              {
                "level": 3,
                "topic": "Interface-Based Type Hierarchies"
              },
              {
                "level": 3,
                "topic": "Favor Composition Over Problematic Inheritance"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Relationship to Other Principles",
            "topics": [
              {
                "level": 3,
                "topic": "LSP Enables OCP"
              },
              {
                "level": 3,
                "topic": "LSP Violations Lead to OCP Violations"
              },
              {
                "level": 3,
                "topic": "Foundation for Polymorphic Behavior"
              },
              {
                "level": 3,
                "topic": "Type Safety and Predictability"
              },
              {
                "level": 3,
                "topic": "Reliability Through Contract Adherence"
              }
            ]
          }
        ]
      },
      {
        "level": 1,
        "domain": "Interface Segregation Principle (ISP)",
        "subdomains": [
          {
            "level": 2,
            "subdomain": "Core Concepts",
            "topics": [
              {
                "level": 3,
                "topic": "Definition: Client-Specific Interfaces"
              },
              {
                "level": 3,
                "topic": "Fine-Grained Interface Design"
              },
              {
                "level": 3,
                "topic": "Avoiding Fat Interfaces"
              },
              {
                "level": 3,
                "topic": "Interface Pollution Prevention"
              },
              {
                "level": 3,
                "topic": "Minimizing Interface Dependencies"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Implementation Techniques",
            "topics": [
              {
                "level": 3,
                "topic": "Interface Segregation and Decomposition"
              },
              {
                "level": 3,
                "topic": "Multiple Inheritance of Interfaces"
              },
              {
                "level": 3,
                "topic": "Role-Based Interface Design"
              },
              {
                "level": 3,
                "topic": "Adapter Pattern for Interface Adaptation"
              },
              {
                "level": 3,
                "topic": "Dynamic Interface Queries"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Violations and Code Smells",
            "topics": [
              {
                "level": 3,
                "topic": "Monolithic Interfaces"
              },
              {
                "level": 3,
                "topic": "Forced Implementation of Unused Methods"
              },
              {
                "level": 3,
                "topic": "Non-Cohesive Interface Methods"
              },
              {
                "level": 3,
                "topic": "Inadvertent Coupling Between Clients"
              },
              {
                "level": 3,
                "topic": "Unnecessary Recompilation of Clients"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Benefits and Considerations",
            "topics": [
              {
                "level": 3,
                "topic": "Decoupling Clients from Unnecessary Dependencies"
              },
              {
                "level": 3,
                "topic": "Improved Modularity"
              },
              {
                "level": 3,
                "topic": "Enhanced Flexibility in Implementation"
              },
              {
                "level": 3,
                "topic": "Reduced Compilation Dependencies"
              },
              {
                "level": 3,
                "topic": "Targeted Testing of Interfaces"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Related Patterns and Techniques",
            "topics": [
              {
                "level": 3,
                "topic": "Adapter Pattern (Class Form)"
              },
              {
                "level": 3,
                "topic": "Facade Pattern"
              },
              {
                "level": 3,
                "topic": "Proxy Pattern"
              },
              {
                "level": 3,
                "topic": "Factory Pattern with Specific Interfaces"
              },
              {
                "level": 3,
                "topic": "Service Locator with Interface Queries"
              }
            ]
          }
        ]
      },
      {
        "level": 1,
        "domain": "Dependency Inversion Principle (DIP)",
        "subdomains": [
          {
            "level": 2,
            "subdomain": "Core Concepts",
            "topics": [
              {
                "level": 3,
                "topic": "Definition: Depend on Abstractions, Not Concretions"
              },
              {
                "level": 3,
                "topic": "High-Level vs Low-Level Modules"
              },
              {
                "level": 3,
                "topic": "Dependency Inversion vs Traditional Layering"
              },
              {
                "level": 3,
                "topic": "Abstractions as Hinge Points"
              },
              {
                "level": 3,
                "topic": "Policy-Detail Separation"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Implementation Techniques",
            "topics": [
              {
                "level": 3,
                "topic": "Dependency Injection (Constructor Injection)"
              },
              {
                "level": 3,
                "topic": "Dependency Injection (Setter Injection)"
              },
              {
                "level": 3,
                "topic": "Dependency Injection (Interface Injection)"
              },
              {
                "level": 3,
                "topic": "Type Hinting to Abstractions"
              },
              {
                "level": 3,
                "topic": "Abstract Factory for Object Creation"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Violations and Code Smells",
            "topics": [
              {
                "level": 3,
                "topic": "Direct Instantiation with new Keyword"
              },
              {
                "level": 3,
                "topic": "Tight Coupling to Concrete Classes"
              },
              {
                "level": 3,
                "topic": "High-Level Modules Depending on Low-Level Details"
              },
              {
                "level": 3,
                "topic": "Dependencies on Volatile Modules"
              },
              {
                "level": 3,
                "topic": "Hard-to-Test Code Due to Concrete Dependencies"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Related Design Patterns",
            "topics": [
              {
                "level": 3,
                "topic": "Abstract Factory Pattern"
              },
              {
                "level": 3,
                "topic": "Factory Method Pattern"
              },
              {
                "level": 3,
                "topic": "Abstract Server Pattern"
              },
              {
                "level": 3,
                "topic": "Service Locator Pattern"
              },
              {
                "level": 3,
                "topic": "Dependency Injection Containers"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Architectural Implications",
            "topics": [
              {
                "level": 3,
                "topic": "Hexagonal Architecture (Ports and Adapters)"
              },
              {
                "level": 3,
                "topic": "Clean Architecture"
              },
              {
                "level": 3,
                "topic": "Onion Architecture"
              },
              {
                "level": 3,
                "topic": "Plugin Architecture"
              },
              {
                "level": 3,
                "topic": "Dependency on Stable vs Volatile Modules"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Relationship to Other Principles",
            "topics": [
              {
                "level": 3,
                "topic": "DIP Enables OCP"
              },
              {
                "level": 3,
                "topic": "DIP as Outgrowth of OCP and LSP"
              },
              {
                "level": 3,
                "topic": "Foundation for Flexible Dependency Management"
              },
              {
                "level": 3,
                "topic": "Loose Coupling for Testability"
              },
              {
                "level": 3,
                "topic": "Decoupling for Maintainability"
              }
            ]
          }
        ]
      },
      {
        "level": 1,
        "domain": "SOLID Principles Integration and Application",
        "subdomains": [
          {
            "level": 2,
            "subdomain": "Interrelationships Between Principles",
            "topics": [
              {
                "level": 3,
                "topic": "SRP as Foundation for OCP"
              },
              {
                "level": 3,
                "topic": "LSP Enabling Polymorphic OCP"
              },
              {
                "level": 3,
                "topic": "DIP as Prerequisite for OCP and LSP"
              },
              {
                "level": 3,
                "topic": "ISP Supporting SRP and DIP"
              },
              {
                "level": 3,
                "topic": "Cascading Effects of Principle Violations"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Practical Application Strategies",
            "topics": [
              {
                "level": 3,
                "topic": "Identifying Responsibilities and Change Reasons"
              },
              {
                "level": 3,
                "topic": "Finding Appropriate Abstractions"
              },
              {
                "level": 3,
                "topic": "Refactoring Legacy Code to SOLID"
              },
              {
                "level": 3,
                "topic": "Test-Driven Development with SOLID"
              },
              {
                "level": 3,
                "topic": "Code Reviews for SOLID Compliance"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Testing and SOLID Principles",
            "topics": [
              {
                "level": 3,
                "topic": "Unit Testing with Mocks and Stubs"
              },
              {
                "level": 3,
                "topic": "Test Isolation Through Dependency Injection"
              },
              {
                "level": 3,
                "topic": "Testing Substitutability (LSP Verification)"
              },
              {
                "level": 3,
                "topic": "Interface-Based Test Doubles"
              },
              {
                "level": 3,
                "topic": "Test Maintainability and SRP"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Common Pitfalls and Anti-patterns",
            "topics": [
              {
                "level": 3,
                "topic": "Over-Engineering and Premature Abstraction"
              },
              {
                "level": 3,
                "topic": "Abstract Class Proliferation"
              },
              {
                "level": 3,
                "topic": "Interface Bloat"
              },
              {
                "level": 3,
                "topic": "Analysis Paralysis"
              },
              {
                "level": 3,
                "topic": "Dogmatic Application Without Context"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Language-Specific Considerations",
            "topics": [
              {
                "level": 3,
                "topic": "SOLID in Statically Typed Languages"
              },
              {
                "level": 3,
                "topic": "SOLID in Dynamically Typed Languages"
              },
              {
                "level": 3,
                "topic": "SOLID with Functional Programming Features"
              },
              {
                "level": 3,
                "topic": "SOLID in Multi-Paradigm Languages"
              },
              {
                "level": 3,
                "topic": "SOLID with Modern Language Features"
              }
            ]
          }
        ]
      },
      {
        "level": 1,
        "domain": "Advanced Topics and Extensions",
        "subdomains": [
          {
            "level": 2,
            "subdomain": "Package Cohesion Principles",
            "topics": [
              {
                "level": 3,
                "topic": "Release Reuse Equivalency Principle (REP)"
              },
              {
                "level": 3,
                "topic": "Common Closure Principle (CCP)"
              },
              {
                "level": 3,
                "topic": "Common Reuse Principle (CRP)"
              },
              {
                "level": 3,
                "topic": "Balancing Cohesion Principles"
              },
              {
                "level": 3,
                "topic": "Package Granularity"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Package Coupling Principles",
            "topics": [
              {
                "level": 3,
                "topic": "Acyclic Dependencies Principle (ADP)"
              },
              {
                "level": 3,
                "topic": "Stable Dependencies Principle (SDP)"
              },
              {
                "level": 3,
                "topic": "Stable Abstractions Principle (SAP)"
              },
              {
                "level": 3,
                "topic": "Stability Metrics (Afferent/Efferent Coupling)"
              },
              {
                "level": 3,
                "topic": "The Main Sequence"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Architectural Patterns and SOLID",
            "topics": [
              {
                "level": 3,
                "topic": "Layered Architecture"
              },
              {
                "level": 3,
                "topic": "Microservices Architecture"
              },
              {
                "level": 3,
                "topic": "Event-Driven Architecture"
              },
              {
                "level": 3,
                "topic": "Domain-Driven Design"
              },
              {
                "level": 3,
                "topic": "Modular Monolith"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Design Patterns Catalog",
            "topics": [
              {
                "level": 3,
                "topic": "Observer Pattern"
              },
              {
                "level": 3,
                "topic": "Bridge Pattern"
              },
              {
                "level": 3,
                "topic": "Composite Pattern"
              },
              {
                "level": 3,
                "topic": "Command Pattern"
              },
              {
                "level": 3,
                "topic": "Visitor Pattern"
              }
            ]
          },
          {
            "level": 2,
            "subdomain": "Metrics and Measurement",
            "topics": [
              {
                "level": 3,
                "topic": "Cyclomatic Complexity"
              },
              {
                "level": 3,
                "topic": "Coupling Metrics"
              },
              {
                "level": 3,
                "topic": "Cohesion Metrics"
              },
              {
                "level": 3,
                "topic": "Code Coverage and SOLID"
              },
              {
                "level": 3,
                "topic": "Static Analysis for SOLID Violations"
              }
            ]
          }
        ]
      }
    ]
  },
  "metadata": {
    "duration_seconds": 664.295687,
    "timestamp": "2025-12-29T14:30:56.731508"
  }
}