{
  "subdomain_title": "Advanced Programming Paradigms",
  "domain_title": "Programming Fundamentals",
  "category_title": "Foundational Computer Science",
  "curriculum_type": "software-engineering",
  "processed_at": "2025-12-29T15:02:29.624737",
  "result": {
    "subdomain_title": "Advanced Programming Paradigms",
    "curriculum_type": "software-engineering",
    "topic_root": "Advanced Programming Paradigms",
    "topic_root_citation": "https://see.stanford.edu/course/cs107",
    "detailed_hierarchy": [
      {
        "domain": "Imperative Programming Paradigm",
        "subdomains": [
          {
            "subdomain": "Procedural Programming",
            "atomic_topics": [
              "Procedure Definition and Declaration",
              "Parameter Passing Mechanisms (Call-by-Value, Call-by-Reference)",
              "Stack Frame Management and Activation Records",
              "Scope and Binding Rules",
              "Control Flow Abstractions",
              "Sequential Execution Model",
              "Statement-Oriented Computation",
              "Side Effects and State Mutation"
            ]
          },
          {
            "subdomain": "Object-Oriented Programming",
            "atomic_topics": [
              "Class-Based Inheritance",
              "Prototype-Based Inheritance",
              "Encapsulation and Information Hiding",
              "Polymorphism (Static and Dynamic)",
              "Method Dispatch and Virtual Tables",
              "Object Runtime and 'This' Pointer Mechanics",
              "Multiple Inheritance and Interface Implementation",
              "Abstract Classes and Interfaces"
            ]
          },
          {
            "subdomain": "Low-Level Systems Programming",
            "atomic_topics": [
              "Memory Layout and Address Spaces",
              "Pointer Arithmetic and Type Casting",
              "Manual Memory Management (malloc/free)",
              "Stack vs Heap Allocation",
              "Memory Alignment and Padding",
              "Endianness (Little-Endian vs Big-Endian)",
              "Generic Programming with Void Pointers",
              "Function Pointers and Callbacks"
            ]
          }
        ]
      },
      {
        "domain": "Functional Programming Paradigm",
        "subdomains": [
          {
            "subdomain": "Core Functional Concepts",
            "atomic_topics": [
              "Pure Functions and Referential Transparency",
              "Immutability and Persistent Data Structures",
              "First-Class and Higher-Order Functions",
              "Function Composition and Pipelining",
              "Currying and Partial Application",
              "Lazy Evaluation and Strictness",
              "Recursion and Tail-Call Optimization",
              "Pattern Matching and Destructuring"
            ]
          },
          {
            "subdomain": "Lambda Calculus and Foundations",
            "atomic_topics": [
              "Lambda Abstraction and Application",
              "Alpha Conversion and Beta Reduction",
              "Church Encodings",
              "Combinators (SKI Combinators)",
              "Fixed-Point Combinators (Y Combinator)",
              "Substitution Model of Evaluation",
              "Normal Order vs Applicative Order",
              "Lambda Calculus as Computation Model"
            ]
          },
          {
            "subdomain": "Advanced Functional Techniques",
            "atomic_topics": [
              "Functors and Mappable Structures",
              "Applicative Functors",
              "Monads and Monad Laws",
              "Monad Transformers",
              "Algebraic Data Types (Sum and Product Types)",
              "Type Classes and Polymorphism",
              "Lenses and Optics",
              "Free Monads and Interpreters"
            ]
          },
          {
            "subdomain": "Functional Data Processing",
            "atomic_topics": [
              "Map-Reduce Programming Model",
              "Stream Processing and Pipelines",
              "Folding and Catamorphisms",
              "List Comprehensions",
              "Parallel Map and Parallel Reduce",
              "Transducers",
              "Functional Reactive Streams",
              "Event-Driven Functional Programming"
            ]
          }
        ]
      },
      {
        "domain": "Logic Programming Paradigm",
        "subdomains": [
          {
            "subdomain": "Declarative Logic Foundations",
            "atomic_topics": [
              "First-Order Predicate Logic",
              "Horn Clauses and Resolution",
              "Unification Algorithm",
              "Facts, Rules, and Queries",
              "Backward Chaining (Goal-Directed Search)",
              "Forward Chaining (Data-Driven)",
              "Logical Inference and Theorem Proving",
              "Herbrand Universe and Models"
            ]
          },
          {
            "subdomain": "Constraint Logic Programming (CLP)",
            "atomic_topics": [
              "Constraint Satisfaction Problems (CSP)",
              "Finite Domain Constraints",
              "Constraint Propagation and Arc Consistency",
              "Backtracking with Constraint Checking",
              "CLP over Finite Domains (CLP(FD))",
              "CLP over Reals (CLP(R))",
              "Global Constraints",
              "Optimization in CLP"
            ]
          },
          {
            "subdomain": "Logic Programming Implementation",
            "atomic_topics": [
              "WAM (Warren Abstract Machine)",
              "Choice Points and Backtracking",
              "Cut Operator and Negation",
              "Tail Recursion in Logic Programming",
              "Dynamic Predicates",
              "Meta-Interpreters",
              "Definite Clause Grammars (DCG)",
              "Tabling and Memoization"
            ]
          }
        ]
      },
      {
        "domain": "Concurrent and Parallel Programming Paradigms",
        "subdomains": [
          {
            "subdomain": "Shared Memory Concurrency",
            "atomic_topics": [
              "Multithreading and Thread Management",
              "Race Conditions and Data Races",
              "Critical Sections and Mutual Exclusion",
              "Locks and Spinlocks",
              "Semaphores (Binary and Counting)",
              "Monitors and Condition Variables",
              "Deadlock Detection and Prevention",
              "Memory Consistency Models"
            ]
          },
          {
            "subdomain": "Message-Passing Concurrency",
            "atomic_topics": [
              "Actor Model and Mailboxes",
              "Communicating Sequential Processes (CSP)",
              "Channels and Synchronous Communication",
              "Asynchronous Message Passing",
              "Process Calculi (Pi-Calculus)",
              "Supervision Trees and Fault Tolerance",
              "Location Transparency",
              "Message Ordering Guarantees"
            ]
          },
          {
            "subdomain": "Parallel Computing Models",
            "atomic_topics": [
              "Data Parallelism vs Task Parallelism",
              "Fork-Join Parallelism",
              "Work-Stealing Algorithms",
              "SIMD (Single Instruction Multiple Data)",
              "GPU Programming Models (CUDA/OpenCL)",
              "Distributed Memory Systems",
              "MapReduce and Bulk Synchronous Parallel (BSP)",
              "Parallel Functional Programming"
            ]
          },
          {
            "subdomain": "Reactive Programming",
            "atomic_topics": [
              "Observable Streams and Observers",
              "Functional Reactive Programming (FRP)",
              "Event Streams and Time-Varying Values",
              "Operators (Map, Filter, Merge, FlatMap)",
              "Backpressure Management",
              "Hot vs Cold Observables",
              "Schedulers and Concurrency Control",
              "Reactive Extensions (Rx)"
            ]
          }
        ]
      },
      {
        "domain": "Type Systems and Formal Methods",
        "subdomains": [
          {
            "subdomain": "Type Theory Foundations",
            "atomic_topics": [
              "Simply Typed Lambda Calculus",
              "System F (Polymorphic Lambda Calculus)",
              "System F-omega (Higher-Kinded Types)",
              "Dependent Types",
              "Linear Types and Affine Types",
              "Gradual Typing",
              "Type Inference (Hindley-Milner)",
              "Subtyping and Type Lattices"
            ]
          },
          {
            "subdomain": "Advanced Type System Features",
            "atomic_topics": [
              "Parametric Polymorphism (Generics)",
              "Ad-hoc Polymorphism (Overloading)",
              "Variance (Covariance and Contravariance)",
              "Existential Types",
              "Phantom Types",
              "GADTs (Generalized Algebraic Data Types)",
              "Type Families and Associated Types",
              "Effect Systems and Effect Handlers"
            ]
          },
          {
            "subdomain": "Program Verification and Correctness",
            "atomic_topics": [
              "Hoare Logic and Pre/Post-conditions",
              "Weakest Precondition Calculus",
              "Separation Logic",
              "Structural Induction Proofs",
              "Equational Reasoning",
              "Proof Assistants (Coq, Agda, Lean, Isabelle)",
              "Curry-Howard Correspondence",
              "Automated Theorem Proving"
            ]
          },
          {
            "subdomain": "Ownership and Resource Management",
            "atomic_topics": [
              "Ownership Type Systems",
              "Borrowing and Lifetimes",
              "Affine and Linear Type Systems",
              "Region-Based Memory Management",
              "Capability-Based Security",
              "Uniqueness Types",
              "Session Types",
              "Resource-Aware Type Systems"
            ]
          }
        ]
      },
      {
        "domain": "Metaprogramming Paradigms",
        "subdomains": [
          {
            "subdomain": "Compile-Time Metaprogramming",
            "atomic_topics": [
              "Template Metaprogramming (C++)",
              "Macro Systems (Lisp, Scheme)",
              "Hygienic Macros",
              "Syntax Extension and DSL Embedding",
              "Code Generation at Compile Time",
              "Constexpr and Constant Evaluation",
              "Type-Level Programming",
              "Static Reflection"
            ]
          },
          {
            "subdomain": "Runtime Metaprogramming",
            "atomic_topics": [
              "Reflection and Introspection",
              "Dynamic Code Generation",
              "Eval and Dynamic Execution",
              "Monkey Patching and Open Classes",
              "Prototype Modification",
              "Method Intercession and Proxies",
              "Metaclasses and Metaobject Protocols",
              "Bytecode Manipulation"
            ]
          },
          {
            "subdomain": "Program Transformation",
            "atomic_topics": [
              "Abstract Syntax Trees (AST) Manipulation",
              "Source-to-Source Translation",
              "Partial Evaluation and Staging",
              "Program Synthesis",
              "Aspect Weaving",
              "Deforestation and Fusion",
              "Quasiquotation",
              "Multi-Stage Programming"
            ]
          }
        ]
      },
      {
        "domain": "Aspect-Oriented and Advanced Paradigms",
        "subdomains": [
          {
            "subdomain": "Aspect-Oriented Programming (AOP)",
            "atomic_topics": [
              "Cross-Cutting Concerns",
              "Join Points and Pointcuts",
              "Advice (Before, After, Around)",
              "Aspect Weaving (Compile-Time, Load-Time, Runtime)",
              "AspectJ and AOP Frameworks",
              "Concern Separation and Modularity",
              "Policy Injection",
              "Quantification and Obliviousness"
            ]
          },
          {
            "subdomain": "Dataflow Programming",
            "atomic_topics": [
              "Dataflow Graphs and Networks",
              "Static Dataflow Analysis",
              "Reactive Dataflow (Spreadsheet Model)",
              "Stream Processing Frameworks",
              "Dataflow Variables and Single Assignment",
              "Flow-Based Programming",
              "Kahn Process Networks",
              "Synchronous Dataflow"
            ]
          },
          {
            "subdomain": "Domain-Specific and Specialized Paradigms",
            "atomic_topics": [
              "Domain-Specific Languages (DSL) Design",
              "Embedded DSLs vs External DSLs",
              "Differentiable Programming",
              "Probabilistic Programming",
              "Array Programming",
              "Literate Programming",
              "Visual and Graph-Based Programming",
              "Quantum Programming Paradigms"
            ]
          }
        ]
      },
      {
        "domain": "Language Implementation and Semantics",
        "subdomains": [
          {
            "subdomain": "Formal Language Description",
            "atomic_topics": [
              "Context-Free Grammars (CFG)",
              "Backus-Naur Form (BNF) and EBNF",
              "Abstract Syntax vs Concrete Syntax",
              "Lexical Analysis and Tokenization",
              "Parsing (Recursive Descent, LR, LALR)",
              "Operator Precedence and Associativity",
              "Ambiguity Resolution",
              "Parser Generators and Combinator Libraries"
            ]
          },
          {
            "subdomain": "Semantic Models",
            "atomic_topics": [
              "Operational Semantics (Small-Step, Big-Step)",
              "Denotational Semantics",
              "Axiomatic Semantics",
              "Environment Model of Evaluation",
              "Substitution Model of Evaluation",
              "Continuation Semantics",
              "Abstract Interpretation",
              "Formal Semantics of Concurrency"
            ]
          },
          {
            "subdomain": "Runtime Systems and Virtual Machines",
            "atomic_topics": [
              "Bytecode Interpretation",
              "Just-In-Time (JIT) Compilation",
              "Garbage Collection (Mark-Sweep, Generational)",
              "Reference Counting",
              "Dynamic Type Checking",
              "Virtual Machine Design",
              "Instruction Set Architecture for VMs",
              "Stack-Based vs Register-Based VMs"
            ]
          },
          {
            "subdomain": "Compilation and Code Generation",
            "atomic_topics": [
              "Static Single Assignment (SSA) Form",
              "Control Flow Graphs (CFG)",
              "Register Allocation",
              "Instruction Selection",
              "Code Optimization (Constant Folding, Dead Code Elimination)",
              "Intermediate Representations (IR)",
              "Linking and Symbol Resolution",
              "Ahead-of-Time (AOT) Compilation"
            ]
          }
        ]
      }
    ]
  },
  "metadata": {
    "duration_seconds": 124.029517,
    "timestamp": "2025-12-29T14:21:56.464880"
  }
}